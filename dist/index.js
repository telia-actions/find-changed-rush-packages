module.exports =
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 73394:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse("{\"assert\":true,\"async_hooks\":\">= 8\",\"buffer_ieee754\":\"< 0.9.7\",\"buffer\":true,\"child_process\":true,\"cluster\":true,\"console\":true,\"constants\":true,\"crypto\":true,\"_debug_agent\":\">= 1 && < 8\",\"_debugger\":\"< 8\",\"dgram\":true,\"dns\":true,\"domain\":true,\"events\":true,\"freelist\":\"< 6\",\"fs\":true,\"fs/promises\":[\">= 10 && < 10.1\",\">= 14\"],\"_http_agent\":\">= 0.11.1\",\"_http_client\":\">= 0.11.1\",\"_http_common\":\">= 0.11.1\",\"_http_incoming\":\">= 0.11.1\",\"_http_outgoing\":\">= 0.11.1\",\"_http_server\":\">= 0.11.1\",\"http\":true,\"http2\":\">= 8.8\",\"https\":true,\"inspector\":\">= 8.0.0\",\"_linklist\":\"< 8\",\"module\":true,\"net\":true,\"node-inspect/lib/_inspect\":\">= 7.6.0 && < 12\",\"node-inspect/lib/internal/inspect_client\":\">= 7.6.0 && < 12\",\"node-inspect/lib/internal/inspect_repl\":\">= 7.6.0 && < 12\",\"os\":true,\"path\":true,\"perf_hooks\":\">= 8.5\",\"process\":\">= 1\",\"punycode\":true,\"querystring\":true,\"readline\":true,\"repl\":true,\"smalloc\":\">= 0.11.5 && < 3\",\"_stream_duplex\":\">= 0.9.4\",\"_stream_transform\":\">= 0.9.4\",\"_stream_wrap\":\">= 1.4.1\",\"_stream_passthrough\":\">= 0.9.4\",\"_stream_readable\":\">= 0.9.4\",\"_stream_writable\":\">= 0.9.4\",\"stream\":true,\"string_decoder\":true,\"sys\":true,\"timers\":true,\"_tls_common\":\">= 0.11.13\",\"_tls_legacy\":\">= 0.11.3 && < 10\",\"_tls_wrap\":\">= 0.11.3\",\"tls\":true,\"trace_events\":\">= 10\",\"tty\":true,\"url\":true,\"util\":true,\"v8/tools/arguments\":\">= 10 && < 12\",\"v8/tools/codemap\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/consarray\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/csvparser\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/logreader\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/profile_view\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/splaytree\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8\":\">= 1\",\"vm\":true,\"wasi\":\">= 13.4 && < 13.5\",\"worker_threads\":\">= 11.7\",\"zlib\":true}");

/***/ }),

/***/ 94302:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse("{\"assert\":true,\"async_hooks\":\">= 8\",\"buffer_ieee754\":\"< 0.9.7\",\"buffer\":true,\"child_process\":true,\"cluster\":true,\"console\":true,\"constants\":true,\"crypto\":true,\"_debug_agent\":\">= 1 && < 8\",\"_debugger\":\"< 8\",\"dgram\":true,\"dns\":true,\"domain\":true,\"events\":true,\"freelist\":\"< 6\",\"fs\":true,\"fs/promises\":[\">= 10 && < 10.1\",\">= 14\"],\"_http_agent\":\">= 0.11.1\",\"_http_client\":\">= 0.11.1\",\"_http_common\":\">= 0.11.1\",\"_http_incoming\":\">= 0.11.1\",\"_http_outgoing\":\">= 0.11.1\",\"_http_server\":\">= 0.11.1\",\"http\":true,\"http2\":\">= 8.8\",\"https\":true,\"inspector\":\">= 8.0.0\",\"_linklist\":\"< 8\",\"module\":true,\"net\":true,\"node-inspect/lib/_inspect\":\">= 7.6.0 && < 12\",\"node-inspect/lib/internal/inspect_client\":\">= 7.6.0 && < 12\",\"node-inspect/lib/internal/inspect_repl\":\">= 7.6.0 && < 12\",\"os\":true,\"path\":true,\"perf_hooks\":\">= 8.5\",\"process\":\">= 1\",\"punycode\":true,\"querystring\":true,\"readline\":true,\"repl\":true,\"smalloc\":\">= 0.11.5 && < 3\",\"_stream_duplex\":\">= 0.9.4\",\"_stream_transform\":\">= 0.9.4\",\"_stream_wrap\":\">= 1.4.1\",\"_stream_passthrough\":\">= 0.9.4\",\"_stream_readable\":\">= 0.9.4\",\"_stream_writable\":\">= 0.9.4\",\"stream\":true,\"string_decoder\":true,\"sys\":true,\"timers\":true,\"_tls_common\":\">= 0.11.13\",\"_tls_legacy\":\">= 0.11.3 && < 10\",\"_tls_wrap\":\">= 0.11.3\",\"tls\":true,\"trace_events\":\">= 10\",\"tty\":true,\"url\":true,\"util\":true,\"v8/tools/arguments\":\">= 10 && < 12\",\"v8/tools/codemap\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/consarray\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/csvparser\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/logreader\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/profile_view\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/splaytree\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8\":\">= 1\",\"vm\":true,\"wasi\":\">= 13.4 && < 13.5\",\"worker_threads\":\">= 11.7\",\"zlib\":true}");

/***/ }),

/***/ 9816:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse("{\"assert\":true,\"async_hooks\":\">= 8\",\"buffer_ieee754\":\"< 0.9.7\",\"buffer\":true,\"child_process\":true,\"cluster\":true,\"console\":true,\"constants\":true,\"crypto\":true,\"_debug_agent\":\">= 1 && < 8\",\"_debugger\":\"< 8\",\"dgram\":true,\"dns\":true,\"domain\":true,\"events\":true,\"freelist\":\"< 6\",\"fs\":true,\"fs/promises\":[\">= 10 && < 10.1\",\">= 14\"],\"_http_agent\":\">= 0.11.1\",\"_http_client\":\">= 0.11.1\",\"_http_common\":\">= 0.11.1\",\"_http_incoming\":\">= 0.11.1\",\"_http_outgoing\":\">= 0.11.1\",\"_http_server\":\">= 0.11.1\",\"http\":true,\"http2\":\">= 8.8\",\"https\":true,\"inspector\":\">= 8.0.0\",\"_linklist\":\"< 8\",\"module\":true,\"net\":true,\"node-inspect/lib/_inspect\":\">= 7.6.0 && < 12\",\"node-inspect/lib/internal/inspect_client\":\">= 7.6.0 && < 12\",\"node-inspect/lib/internal/inspect_repl\":\">= 7.6.0 && < 12\",\"os\":true,\"path\":true,\"perf_hooks\":\">= 8.5\",\"process\":\">= 1\",\"punycode\":true,\"querystring\":true,\"readline\":true,\"repl\":true,\"smalloc\":\">= 0.11.5 && < 3\",\"_stream_duplex\":\">= 0.9.4\",\"_stream_transform\":\">= 0.9.4\",\"_stream_wrap\":\">= 1.4.1\",\"_stream_passthrough\":\">= 0.9.4\",\"_stream_readable\":\">= 0.9.4\",\"_stream_writable\":\">= 0.9.4\",\"stream\":true,\"string_decoder\":true,\"sys\":true,\"timers\":true,\"_tls_common\":\">= 0.11.13\",\"_tls_legacy\":\">= 0.11.3 && < 10\",\"_tls_wrap\":\">= 0.11.3\",\"tls\":true,\"trace_events\":\">= 10\",\"tty\":true,\"url\":true,\"util\":true,\"v8/tools/arguments\":\">= 10 && < 12\",\"v8/tools/codemap\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/consarray\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/csvparser\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/logreader\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/profile_view\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/splaytree\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8\":\">= 1\",\"vm\":true,\"wasi\":\">= 13.4 && < 13.5\",\"worker_threads\":\">= 11.7\",\"zlib\":true}");

/***/ }),

/***/ 86255:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse("{\"assert\":true,\"async_hooks\":\">= 8\",\"buffer_ieee754\":\"< 0.9.7\",\"buffer\":true,\"child_process\":true,\"cluster\":true,\"console\":true,\"constants\":true,\"crypto\":true,\"_debug_agent\":\">= 1 && < 8\",\"_debugger\":\"< 8\",\"dgram\":true,\"dns\":true,\"domain\":true,\"events\":true,\"freelist\":\"< 6\",\"fs\":true,\"fs/promises\":[\">= 10 && < 10.1\",\">= 14\"],\"_http_agent\":\">= 0.11.1\",\"_http_client\":\">= 0.11.1\",\"_http_common\":\">= 0.11.1\",\"_http_incoming\":\">= 0.11.1\",\"_http_outgoing\":\">= 0.11.1\",\"_http_server\":\">= 0.11.1\",\"http\":true,\"http2\":\">= 8.8\",\"https\":true,\"inspector\":\">= 8.0.0\",\"_linklist\":\"< 8\",\"module\":true,\"net\":true,\"node-inspect/lib/_inspect\":\">= 7.6.0 && < 12\",\"node-inspect/lib/internal/inspect_client\":\">= 7.6.0 && < 12\",\"node-inspect/lib/internal/inspect_repl\":\">= 7.6.0 && < 12\",\"os\":true,\"path\":true,\"perf_hooks\":\">= 8.5\",\"process\":\">= 1\",\"punycode\":true,\"querystring\":true,\"readline\":true,\"repl\":true,\"smalloc\":\">= 0.11.5 && < 3\",\"_stream_duplex\":\">= 0.9.4\",\"_stream_transform\":\">= 0.9.4\",\"_stream_wrap\":\">= 1.4.1\",\"_stream_passthrough\":\">= 0.9.4\",\"_stream_readable\":\">= 0.9.4\",\"_stream_writable\":\">= 0.9.4\",\"stream\":true,\"string_decoder\":true,\"sys\":true,\"timers\":true,\"_tls_common\":\">= 0.11.13\",\"_tls_legacy\":\">= 0.11.3 && < 10\",\"_tls_wrap\":\">= 0.11.3\",\"tls\":true,\"trace_events\":\">= 10\",\"tty\":true,\"url\":true,\"util\":true,\"v8/tools/arguments\":\">= 10 && < 12\",\"v8/tools/codemap\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/consarray\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/csvparser\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/logreader\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/profile_view\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/splaytree\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8\":\">= 1\",\"vm\":true,\"wasi\":\">= 13.4 && < 13.5\",\"worker_threads\":\">= 11.7\",\"zlib\":true}");

/***/ }),

/***/ 15827:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse("{\"assert\":true,\"async_hooks\":\">= 8\",\"buffer_ieee754\":\"< 0.9.7\",\"buffer\":true,\"child_process\":true,\"cluster\":true,\"console\":true,\"constants\":true,\"crypto\":true,\"_debug_agent\":\">= 1 && < 8\",\"_debugger\":\"< 8\",\"dgram\":true,\"dns\":true,\"domain\":true,\"events\":true,\"freelist\":\"< 6\",\"fs\":true,\"fs/promises\":[\">= 10 && < 10.1\",\">= 14\"],\"_http_agent\":\">= 0.11.1\",\"_http_client\":\">= 0.11.1\",\"_http_common\":\">= 0.11.1\",\"_http_incoming\":\">= 0.11.1\",\"_http_outgoing\":\">= 0.11.1\",\"_http_server\":\">= 0.11.1\",\"http\":true,\"http2\":\">= 8.8\",\"https\":true,\"inspector\":\">= 8.0.0\",\"_linklist\":\"< 8\",\"module\":true,\"net\":true,\"node-inspect/lib/_inspect\":\">= 7.6.0 && < 12\",\"node-inspect/lib/internal/inspect_client\":\">= 7.6.0 && < 12\",\"node-inspect/lib/internal/inspect_repl\":\">= 7.6.0 && < 12\",\"os\":true,\"path\":true,\"perf_hooks\":\">= 8.5\",\"process\":\">= 1\",\"punycode\":true,\"querystring\":true,\"readline\":true,\"repl\":true,\"smalloc\":\">= 0.11.5 && < 3\",\"_stream_duplex\":\">= 0.9.4\",\"_stream_transform\":\">= 0.9.4\",\"_stream_wrap\":\">= 1.4.1\",\"_stream_passthrough\":\">= 0.9.4\",\"_stream_readable\":\">= 0.9.4\",\"_stream_writable\":\">= 0.9.4\",\"stream\":true,\"string_decoder\":true,\"sys\":true,\"timers\":true,\"_tls_common\":\">= 0.11.13\",\"_tls_legacy\":\">= 0.11.3 && < 10\",\"_tls_wrap\":\">= 0.11.3\",\"tls\":true,\"trace_events\":\">= 10\",\"tty\":true,\"url\":true,\"util\":true,\"v8/tools/arguments\":\">= 10 && < 12\",\"v8/tools/codemap\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/consarray\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/csvparser\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/logreader\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/profile_view\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/splaytree\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8\":\">= 1\",\"vm\":true,\"wasi\":\">= 13.4 && < 13.5\",\"worker_threads\":\">= 11.7\",\"zlib\":true}");

/***/ }),

/***/ 9838:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse("{\"assert\":true,\"async_hooks\":\">= 8\",\"buffer_ieee754\":\"< 0.9.7\",\"buffer\":true,\"child_process\":true,\"cluster\":true,\"console\":true,\"constants\":true,\"crypto\":true,\"_debug_agent\":\">= 1 && < 8\",\"_debugger\":\"< 8\",\"dgram\":true,\"dns\":true,\"domain\":true,\"events\":true,\"freelist\":\"< 6\",\"fs\":true,\"fs/promises\":[\">= 10 && < 10.1\",\">= 14\"],\"_http_agent\":\">= 0.11.1\",\"_http_client\":\">= 0.11.1\",\"_http_common\":\">= 0.11.1\",\"_http_incoming\":\">= 0.11.1\",\"_http_outgoing\":\">= 0.11.1\",\"_http_server\":\">= 0.11.1\",\"http\":true,\"http2\":\">= 8.8\",\"https\":true,\"inspector\":\">= 8.0.0\",\"_linklist\":\"< 8\",\"module\":true,\"net\":true,\"node-inspect/lib/_inspect\":\">= 7.6.0 && < 12\",\"node-inspect/lib/internal/inspect_client\":\">= 7.6.0 && < 12\",\"node-inspect/lib/internal/inspect_repl\":\">= 7.6.0 && < 12\",\"os\":true,\"path\":true,\"perf_hooks\":\">= 8.5\",\"process\":\">= 1\",\"punycode\":true,\"querystring\":true,\"readline\":true,\"repl\":true,\"smalloc\":\">= 0.11.5 && < 3\",\"_stream_duplex\":\">= 0.9.4\",\"_stream_transform\":\">= 0.9.4\",\"_stream_wrap\":\">= 1.4.1\",\"_stream_passthrough\":\">= 0.9.4\",\"_stream_readable\":\">= 0.9.4\",\"_stream_writable\":\">= 0.9.4\",\"stream\":true,\"string_decoder\":true,\"sys\":true,\"timers\":true,\"_tls_common\":\">= 0.11.13\",\"_tls_legacy\":\">= 0.11.3 && < 10\",\"_tls_wrap\":\">= 0.11.3\",\"tls\":true,\"trace_events\":\">= 10\",\"tty\":true,\"url\":true,\"util\":true,\"v8/tools/arguments\":\">= 10 && < 12\",\"v8/tools/codemap\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/consarray\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/csvparser\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/logreader\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/profile_view\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/splaytree\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8\":\">= 1\",\"vm\":true,\"wasi\":\">= 13.4 && < 13.5\",\"worker_threads\":\">= 11.7\",\"zlib\":true}");

/***/ }),

/***/ 67096:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse("{\"assert\":true,\"async_hooks\":\">= 8\",\"buffer_ieee754\":\"< 0.9.7\",\"buffer\":true,\"child_process\":true,\"cluster\":true,\"console\":true,\"constants\":true,\"crypto\":true,\"_debug_agent\":\">= 1 && < 8\",\"_debugger\":\"< 8\",\"dgram\":true,\"dns\":true,\"domain\":true,\"events\":true,\"freelist\":\"< 6\",\"fs\":true,\"fs/promises\":[\">= 10 && < 10.1\",\">= 14\"],\"_http_agent\":\">= 0.11.1\",\"_http_client\":\">= 0.11.1\",\"_http_common\":\">= 0.11.1\",\"_http_incoming\":\">= 0.11.1\",\"_http_outgoing\":\">= 0.11.1\",\"_http_server\":\">= 0.11.1\",\"http\":true,\"http2\":\">= 8.8\",\"https\":true,\"inspector\":\">= 8.0.0\",\"_linklist\":\"< 8\",\"module\":true,\"net\":true,\"node-inspect/lib/_inspect\":\">= 7.6.0 && < 12\",\"node-inspect/lib/internal/inspect_client\":\">= 7.6.0 && < 12\",\"node-inspect/lib/internal/inspect_repl\":\">= 7.6.0 && < 12\",\"os\":true,\"path\":true,\"perf_hooks\":\">= 8.5\",\"process\":\">= 1\",\"punycode\":true,\"querystring\":true,\"readline\":true,\"repl\":true,\"smalloc\":\">= 0.11.5 && < 3\",\"_stream_duplex\":\">= 0.9.4\",\"_stream_transform\":\">= 0.9.4\",\"_stream_wrap\":\">= 1.4.1\",\"_stream_passthrough\":\">= 0.9.4\",\"_stream_readable\":\">= 0.9.4\",\"_stream_writable\":\">= 0.9.4\",\"stream\":true,\"string_decoder\":true,\"sys\":true,\"timers\":true,\"_tls_common\":\">= 0.11.13\",\"_tls_legacy\":\">= 0.11.3 && < 10\",\"_tls_wrap\":\">= 0.11.3\",\"tls\":true,\"trace_events\":\">= 10\",\"tty\":true,\"url\":true,\"util\":true,\"v8/tools/arguments\":\">= 10 && < 12\",\"v8/tools/codemap\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/consarray\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/csvparser\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/logreader\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/profile_view\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8/tools/splaytree\":[\">= 4.4.0 && < 5\",\">= 5.2.0 && < 12\"],\"v8\":\">= 1\",\"vm\":true,\"wasi\":\">= 13.4 && < 13.5\",\"worker_threads\":\">= 11.7\",\"zlib\":true}");

/***/ }),

/***/ 87351:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issue = exports.issueCommand = void 0;
const os = __importStar(__webpack_require__(12087));
const utils_1 = __webpack_require__(5278);
/**
 * Commands
 *
 * Command Format:
 *   ::name key=value,key=value::message
 *
 * Examples:
 *   ::warning::This is the message
 *   ::set-env name=MY_VAR::some value
 */
function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
}
exports.issueCommand = issueCommand;
function issue(name, message = '') {
    issueCommand(name, {}, message);
}
exports.issue = issue;
const CMD_STRING = '::';
class Command {
    constructor(command, properties, message) {
        if (!command) {
            command = 'missing.command';
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
    }
    toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += ' ';
            let first = true;
            for (const key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    const val = this.properties[key];
                    if (val) {
                        if (first) {
                            first = false;
                        }
                        else {
                            cmdStr += ',';
                        }
                        cmdStr += `${key}=${escapeProperty(val)}`;
                    }
                }
            }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
    }
}
function escapeData(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A');
}
function escapeProperty(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A')
        .replace(/:/g, '%3A')
        .replace(/,/g, '%2C');
}
//# sourceMappingURL=command.js.map

/***/ }),

/***/ 42186:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
const command_1 = __webpack_require__(87351);
const file_command_1 = __webpack_require__(717);
const utils_1 = __webpack_require__(5278);
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
/**
 * The code to exit an action
 */
var ExitCode;
(function (ExitCode) {
    /**
     * A code indicating that the action was successful
     */
    ExitCode[ExitCode["Success"] = 0] = "Success";
    /**
     * A code indicating that the action was a failure
     */
    ExitCode[ExitCode["Failure"] = 1] = "Failure";
})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
//-----------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------
/**
 * Sets env variable for this action and future actions in the job
 * @param name the name of the variable to set
 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function exportVariable(name, val) {
    const convertedVal = utils_1.toCommandValue(val);
    process.env[name] = convertedVal;
    const filePath = process.env['GITHUB_ENV'] || '';
    if (filePath) {
        const delimiter = '_GitHubActionsFileCommandDelimeter_';
        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;
        file_command_1.issueCommand('ENV', commandValue);
    }
    else {
        command_1.issueCommand('set-env', { name }, convertedVal);
    }
}
exports.exportVariable = exportVariable;
/**
 * Registers a secret which will get masked from logs
 * @param secret value of the secret
 */
function setSecret(secret) {
    command_1.issueCommand('add-mask', {}, secret);
}
exports.setSecret = setSecret;
/**
 * Prepends inputPath to the PATH (for this action and future actions)
 * @param inputPath
 */
function addPath(inputPath) {
    const filePath = process.env['GITHUB_PATH'] || '';
    if (filePath) {
        file_command_1.issueCommand('PATH', inputPath);
    }
    else {
        command_1.issueCommand('add-path', {}, inputPath);
    }
    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
}
exports.addPath = addPath;
/**
 * Gets the value of an input.
 * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
 * Returns an empty string if the value is not defined.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string
 */
function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
    if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
    }
    if (options && options.trimWhitespace === false) {
        return val;
    }
    return val.trim();
}
exports.getInput = getInput;
/**
 * Gets the values of an multiline input.  Each value is also trimmed.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string[]
 *
 */
function getMultilineInput(name, options) {
    const inputs = getInput(name, options)
        .split('\n')
        .filter(x => x !== '');
    return inputs;
}
exports.getMultilineInput = getMultilineInput;
/**
 * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
 * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
 * The return value is also in boolean type.
 * ref: https://yaml.org/spec/1.2/spec.html#id2804923
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   boolean
 */
function getBooleanInput(name, options) {
    const trueValue = ['true', 'True', 'TRUE'];
    const falseValue = ['false', 'False', 'FALSE'];
    const val = getInput(name, options);
    if (trueValue.includes(val))
        return true;
    if (falseValue.includes(val))
        return false;
    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
        `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
}
exports.getBooleanInput = getBooleanInput;
/**
 * Sets the value of an output.
 *
 * @param     name     name of the output to set
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setOutput(name, value) {
    process.stdout.write(os.EOL);
    command_1.issueCommand('set-output', { name }, value);
}
exports.setOutput = setOutput;
/**
 * Enables or disables the echoing of commands into stdout for the rest of the step.
 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
 *
 */
function setCommandEcho(enabled) {
    command_1.issue('echo', enabled ? 'on' : 'off');
}
exports.setCommandEcho = setCommandEcho;
//-----------------------------------------------------------------------
// Results
//-----------------------------------------------------------------------
/**
 * Sets the action status to failed.
 * When the action exits it will be with an exit code of 1
 * @param message add error issue message
 */
function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
}
exports.setFailed = setFailed;
//-----------------------------------------------------------------------
// Logging Commands
//-----------------------------------------------------------------------
/**
 * Gets whether Actions Step Debug is on or not
 */
function isDebug() {
    return process.env['RUNNER_DEBUG'] === '1';
}
exports.isDebug = isDebug;
/**
 * Writes debug message to user log
 * @param message debug message
 */
function debug(message) {
    command_1.issueCommand('debug', {}, message);
}
exports.debug = debug;
/**
 * Adds an error issue
 * @param message error issue message. Errors will be converted to string via toString()
 */
function error(message) {
    command_1.issue('error', message instanceof Error ? message.toString() : message);
}
exports.error = error;
/**
 * Adds an warning issue
 * @param message warning issue message. Errors will be converted to string via toString()
 */
function warning(message) {
    command_1.issue('warning', message instanceof Error ? message.toString() : message);
}
exports.warning = warning;
/**
 * Writes info to log with console.log.
 * @param message info message
 */
function info(message) {
    process.stdout.write(message + os.EOL);
}
exports.info = info;
/**
 * Begin an output group.
 *
 * Output until the next `groupEnd` will be foldable in this group
 *
 * @param name The name of the output group
 */
function startGroup(name) {
    command_1.issue('group', name);
}
exports.startGroup = startGroup;
/**
 * End an output group.
 */
function endGroup() {
    command_1.issue('endgroup');
}
exports.endGroup = endGroup;
/**
 * Wrap an asynchronous function call in a group.
 *
 * Returns the same type as the function itself.
 *
 * @param name The name of the group
 * @param fn The function to wrap in the group
 */
function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
            result = yield fn();
        }
        finally {
            endGroup();
        }
        return result;
    });
}
exports.group = group;
//-----------------------------------------------------------------------
// Wrapper action state
//-----------------------------------------------------------------------
/**
 * Saves state for current action, the state can only be retrieved by this action's post job execution.
 *
 * @param     name     name of the state to store
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function saveState(name, value) {
    command_1.issueCommand('save-state', { name }, value);
}
exports.saveState = saveState;
/**
 * Gets the value of an state set by this action's main execution.
 *
 * @param     name     name of the state to get
 * @returns   string
 */
function getState(name) {
    return process.env[`STATE_${name}`] || '';
}
exports.getState = getState;
//# sourceMappingURL=core.js.map

/***/ }),

/***/ 717:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// For internal use, subject to change.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issueCommand = void 0;
// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
const fs = __importStar(__webpack_require__(35747));
const os = __importStar(__webpack_require__(12087));
const utils_1 = __webpack_require__(5278);
function issueCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: 'utf8'
    });
}
exports.issueCommand = issueCommand;
//# sourceMappingURL=file-command.js.map

/***/ }),

/***/ 5278:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toCommandValue = void 0;
/**
 * Sanitizes an input into a string so it can be passed into issueCommand safely
 * @param input input to sanitize into a string
 */
function toCommandValue(input) {
    if (input === null || input === undefined) {
        return '';
    }
    else if (typeof input === 'string' || input instanceof String) {
        return input;
    }
    return JSON.stringify(input);
}
exports.toCommandValue = toCommandValue;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 74087:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Context = void 0;
const fs_1 = __webpack_require__(35747);
const os_1 = __webpack_require__(12087);
class Context {
    /**
     * Hydrate the context from the environment
     */
    constructor() {
        var _a, _b, _c;
        this.payload = {};
        if (process.env.GITHUB_EVENT_PATH) {
            if (fs_1.existsSync(process.env.GITHUB_EVENT_PATH)) {
                this.payload = JSON.parse(fs_1.readFileSync(process.env.GITHUB_EVENT_PATH, { encoding: 'utf8' }));
            }
            else {
                const path = process.env.GITHUB_EVENT_PATH;
                process.stdout.write(`GITHUB_EVENT_PATH ${path} does not exist${os_1.EOL}`);
            }
        }
        this.eventName = process.env.GITHUB_EVENT_NAME;
        this.sha = process.env.GITHUB_SHA;
        this.ref = process.env.GITHUB_REF;
        this.workflow = process.env.GITHUB_WORKFLOW;
        this.action = process.env.GITHUB_ACTION;
        this.actor = process.env.GITHUB_ACTOR;
        this.job = process.env.GITHUB_JOB;
        this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
        this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
        this.apiUrl = (_a = process.env.GITHUB_API_URL) !== null && _a !== void 0 ? _a : `https://api.github.com`;
        this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== void 0 ? _b : `https://github.com`;
        this.graphqlUrl = (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== void 0 ? _c : `https://api.github.com/graphql`;
    }
    get issue() {
        const payload = this.payload;
        return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
    }
    get repo() {
        if (process.env.GITHUB_REPOSITORY) {
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
            return { owner, repo };
        }
        if (this.payload.repository) {
            return {
                owner: this.payload.repository.owner.login,
                repo: this.payload.repository.name
            };
        }
        throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
    }
}
exports.Context = Context;
//# sourceMappingURL=context.js.map

/***/ }),

/***/ 95438:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOctokit = exports.context = void 0;
const Context = __importStar(__webpack_require__(74087));
const utils_1 = __webpack_require__(73030);
exports.context = new Context.Context();
/**
 * Returns a hydrated octokit ready to use for GitHub Actions
 *
 * @param     token    the repo PAT or GITHUB_TOKEN
 * @param     options  other options to set
 */
function getOctokit(token, options) {
    return new utils_1.GitHub(utils_1.getOctokitOptions(token, options));
}
exports.getOctokit = getOctokit;
//# sourceMappingURL=github.js.map

/***/ }),

/***/ 47914:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getApiBaseUrl = exports.getProxyAgent = exports.getAuthString = void 0;
const httpClient = __importStar(__webpack_require__(39925));
function getAuthString(token, options) {
    if (!token && !options.auth) {
        throw new Error('Parameter token or opts.auth is required');
    }
    else if (token && options.auth) {
        throw new Error('Parameters token and opts.auth may not both be specified');
    }
    return typeof options.auth === 'string' ? options.auth : `token ${token}`;
}
exports.getAuthString = getAuthString;
function getProxyAgent(destinationUrl) {
    const hc = new httpClient.HttpClient();
    return hc.getAgent(destinationUrl);
}
exports.getProxyAgent = getProxyAgent;
function getApiBaseUrl() {
    return process.env['GITHUB_API_URL'] || 'https://api.github.com';
}
exports.getApiBaseUrl = getApiBaseUrl;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 73030:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOctokitOptions = exports.GitHub = exports.context = void 0;
const Context = __importStar(__webpack_require__(74087));
const Utils = __importStar(__webpack_require__(47914));
// octokit + plugins
const core_1 = __webpack_require__(76762);
const plugin_rest_endpoint_methods_1 = __webpack_require__(83044);
const plugin_paginate_rest_1 = __webpack_require__(64193);
exports.context = new Context.Context();
const baseUrl = Utils.getApiBaseUrl();
const defaults = {
    baseUrl,
    request: {
        agent: Utils.getProxyAgent(baseUrl)
    }
};
exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(defaults);
/**
 * Convience function to correctly format Octokit Options to pass into the constructor.
 *
 * @param     token    the repo PAT or GITHUB_TOKEN
 * @param     options  other options to set
 */
function getOctokitOptions(token, options) {
    const opts = Object.assign({}, options || {}); // Shallow clone - don't mutate the object provided by the caller
    // Auth
    const auth = Utils.getAuthString(token, opts);
    if (auth) {
        opts.auth = auth;
    }
    return opts;
}
exports.getOctokitOptions = getOctokitOptions;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 39925:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const http = __webpack_require__(15876);
const https = __webpack_require__(57211);
const pm = __webpack_require__(16443);
let tunnel;
var HttpCodes;
(function (HttpCodes) {
    HttpCodes[HttpCodes["OK"] = 200] = "OK";
    HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
    HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
    HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
    HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
    HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
    HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
    HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
    HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
    HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
    HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));
var Headers;
(function (Headers) {
    Headers["Accept"] = "accept";
    Headers["ContentType"] = "content-type";
})(Headers = exports.Headers || (exports.Headers = {}));
var MediaTypes;
(function (MediaTypes) {
    MediaTypes["ApplicationJson"] = "application/json";
})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));
/**
 * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
 */
function getProxyUrl(serverUrl) {
    let proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : '';
}
exports.getProxyUrl = getProxyUrl;
const HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
];
const HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
];
const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
const ExponentialBackoffCeiling = 10;
const ExponentialBackoffTimeSlice = 5;
class HttpClientError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.name = 'HttpClientError';
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, HttpClientError.prototype);
    }
}
exports.HttpClientError = HttpClientError;
class HttpClientResponse {
    constructor(message) {
        this.message = message;
    }
    readBody() {
        return new Promise(async (resolve, reject) => {
            let output = Buffer.alloc(0);
            this.message.on('data', (chunk) => {
                output = Buffer.concat([output, chunk]);
            });
            this.message.on('end', () => {
                resolve(output.toString());
            });
        });
    }
}
exports.HttpClientResponse = HttpClientResponse;
function isHttps(requestUrl) {
    let parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === 'https:';
}
exports.isHttps = isHttps;
class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
            if (requestOptions.ignoreSslError != null) {
                this._ignoreSslError = requestOptions.ignoreSslError;
            }
            this._socketTimeout = requestOptions.socketTimeout;
            if (requestOptions.allowRedirects != null) {
                this._allowRedirects = requestOptions.allowRedirects;
            }
            if (requestOptions.allowRedirectDowngrade != null) {
                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
            }
            if (requestOptions.maxRedirects != null) {
                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
            }
            if (requestOptions.keepAlive != null) {
                this._keepAlive = requestOptions.keepAlive;
            }
            if (requestOptions.allowRetries != null) {
                this._allowRetries = requestOptions.allowRetries;
            }
            if (requestOptions.maxRetries != null) {
                this._maxRetries = requestOptions.maxRetries;
            }
        }
    }
    options(requestUrl, additionalHeaders) {
        return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
    }
    get(requestUrl, additionalHeaders) {
        return this.request('GET', requestUrl, null, additionalHeaders || {});
    }
    del(requestUrl, additionalHeaders) {
        return this.request('DELETE', requestUrl, null, additionalHeaders || {});
    }
    post(requestUrl, data, additionalHeaders) {
        return this.request('POST', requestUrl, data, additionalHeaders || {});
    }
    patch(requestUrl, data, additionalHeaders) {
        return this.request('PATCH', requestUrl, data, additionalHeaders || {});
    }
    put(requestUrl, data, additionalHeaders) {
        return this.request('PUT', requestUrl, data, additionalHeaders || {});
    }
    head(requestUrl, additionalHeaders) {
        return this.request('HEAD', requestUrl, null, additionalHeaders || {});
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
        return this.request(verb, requestUrl, stream, additionalHeaders);
    }
    /**
     * Gets a typed object from an endpoint
     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
     */
    async getJson(requestUrl, additionalHeaders = {}) {
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        let res = await this.get(requestUrl, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
    }
    async postJson(requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        let res = await this.post(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
    }
    async putJson(requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        let res = await this.put(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
    }
    async patchJson(requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        let res = await this.patch(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
    }
    /**
     * Makes a raw http request.
     * All other methods such as get, post, patch, and request ultimately call this.
     * Prefer get, del, post and patch
     */
    async request(verb, requestUrl, data, headers) {
        if (this._disposed) {
            throw new Error('Client has already been disposed.');
        }
        let parsedUrl = new URL(requestUrl);
        let info = this._prepareRequest(verb, parsedUrl, headers);
        // Only perform retries on reads since writes may not be idempotent.
        let maxTries = this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1
            ? this._maxRetries + 1
            : 1;
        let numTries = 0;
        let response;
        while (numTries < maxTries) {
            response = await this.requestRaw(info, data);
            // Check if it's an authentication challenge
            if (response &&
                response.message &&
                response.message.statusCode === HttpCodes.Unauthorized) {
                let authenticationHandler;
                for (let i = 0; i < this.handlers.length; i++) {
                    if (this.handlers[i].canHandleAuthentication(response)) {
                        authenticationHandler = this.handlers[i];
                        break;
                    }
                }
                if (authenticationHandler) {
                    return authenticationHandler.handleAuthentication(this, info, data);
                }
                else {
                    // We have received an unauthorized response but have no handlers to handle it.
                    // Let the response return to the caller.
                    return response;
                }
            }
            let redirectsRemaining = this._maxRedirects;
            while (HttpRedirectCodes.indexOf(response.message.statusCode) != -1 &&
                this._allowRedirects &&
                redirectsRemaining > 0) {
                const redirectUrl = response.message.headers['location'];
                if (!redirectUrl) {
                    // if there's no location to redirect to, we won't
                    break;
                }
                let parsedRedirectUrl = new URL(redirectUrl);
                if (parsedUrl.protocol == 'https:' &&
                    parsedUrl.protocol != parsedRedirectUrl.protocol &&
                    !this._allowRedirectDowngrade) {
                    throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
                }
                // we need to finish reading the response before reassigning response
                // which will leak the open socket.
                await response.readBody();
                // strip authorization header if redirected to a different hostname
                if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                    for (let header in headers) {
                        // header names are case insensitive
                        if (header.toLowerCase() === 'authorization') {
                            delete headers[header];
                        }
                    }
                }
                // let's make the request with the new redirectUrl
                info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                response = await this.requestRaw(info, data);
                redirectsRemaining--;
            }
            if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) {
                // If not a retry code, return immediately instead of retrying
                return response;
            }
            numTries += 1;
            if (numTries < maxTries) {
                await response.readBody();
                await this._performExponentialBackoff(numTries);
            }
        }
        return response;
    }
    /**
     * Needs to be called if keepAlive is set to true in request options.
     */
    dispose() {
        if (this._agent) {
            this._agent.destroy();
        }
        this._disposed = true;
    }
    /**
     * Raw request.
     * @param info
     * @param data
     */
    requestRaw(info, data) {
        return new Promise((resolve, reject) => {
            let callbackForResult = function (err, res) {
                if (err) {
                    reject(err);
                }
                resolve(res);
            };
            this.requestRawWithCallback(info, data, callbackForResult);
        });
    }
    /**
     * Raw request with callback.
     * @param info
     * @param data
     * @param onResult
     */
    requestRawWithCallback(info, data, onResult) {
        let socket;
        if (typeof data === 'string') {
            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
        }
        let callbackCalled = false;
        let handleResult = (err, res) => {
            if (!callbackCalled) {
                callbackCalled = true;
                onResult(err, res);
            }
        };
        let req = info.httpModule.request(info.options, (msg) => {
            let res = new HttpClientResponse(msg);
            handleResult(null, res);
        });
        req.on('socket', sock => {
            socket = sock;
        });
        // If we ever get disconnected, we want the socket to timeout eventually
        req.setTimeout(this._socketTimeout || 3 * 60000, () => {
            if (socket) {
                socket.end();
            }
            handleResult(new Error('Request timeout: ' + info.options.path), null);
        });
        req.on('error', function (err) {
            // err has statusCode property
            // res should have headers
            handleResult(err, null);
        });
        if (data && typeof data === 'string') {
            req.write(data, 'utf8');
        }
        if (data && typeof data !== 'string') {
            data.on('close', function () {
                req.end();
            });
            data.pipe(req);
        }
        else {
            req.end();
        }
    }
    /**
     * Gets an http agent. This function is useful when you need an http agent that handles
     * routing through a proxy server - depending upon the url and proxy environment variables.
     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
     */
    getAgent(serverUrl) {
        let parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === 'https:';
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port
            ? parseInt(info.parsedUrl.port)
            : defaultPort;
        info.options.path =
            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
            info.options.headers['user-agent'] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        // gives handlers an opportunity to participate
        if (this.handlers) {
            this.handlers.forEach(handler => {
                handler.prepareRequest(info.options);
            });
        }
        return info;
    }
    _mergeHeaders(headers) {
        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
        if (this.requestOptions && this.requestOptions.headers) {
            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers));
        }
        return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
        let agent;
        let proxyUrl = pm.getProxyUrl(parsedUrl);
        let useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
            agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
            agent = this._agent;
        }
        // if agent is already assigned use that agent.
        if (!!agent) {
            return agent;
        }
        const usingSsl = parsedUrl.protocol === 'https:';
        let maxSockets = 100;
        if (!!this.requestOptions) {
            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        if (useProxy) {
            // If using proxy, need tunnel
            if (!tunnel) {
                tunnel = __webpack_require__(74294);
            }
            const agentOptions = {
                maxSockets: maxSockets,
                keepAlive: this._keepAlive,
                proxy: {
                    ...((proxyUrl.username || proxyUrl.password) && {
                        proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
                    }),
                    host: proxyUrl.hostname,
                    port: proxyUrl.port
                }
            };
            let tunnelAgent;
            const overHttps = proxyUrl.protocol === 'https:';
            if (usingSsl) {
                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
            }
            else {
                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
            }
            agent = tunnelAgent(agentOptions);
            this._proxyAgent = agent;
        }
        // if reusing agent across request and tunneling agent isn't assigned create a new agent
        if (this._keepAlive && !agent) {
            const options = { keepAlive: this._keepAlive, maxSockets: maxSockets };
            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
            this._agent = agent;
        }
        // if not using private agent and tunnel agent isn't setup then use global agent
        if (!agent) {
            agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
            // we have to cast it to any and change it directly
            agent.options = Object.assign(agent.options || {}, {
                rejectUnauthorized: false
            });
        }
        return agent;
    }
    _performExponentialBackoff(retryNumber) {
        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
        return new Promise(resolve => setTimeout(() => resolve(), ms));
    }
    static dateTimeDeserializer(key, value) {
        if (typeof value === 'string') {
            let a = new Date(value);
            if (!isNaN(a.valueOf())) {
                return a;
            }
        }
        return value;
    }
    async _processResponse(res, options) {
        return new Promise(async (resolve, reject) => {
            const statusCode = res.message.statusCode;
            const response = {
                statusCode: statusCode,
                result: null,
                headers: {}
            };
            // not found leads to null obj returned
            if (statusCode == HttpCodes.NotFound) {
                resolve(response);
            }
            let obj;
            let contents;
            // get the result from the body
            try {
                contents = await res.readBody();
                if (contents && contents.length > 0) {
                    if (options && options.deserializeDates) {
                        obj = JSON.parse(contents, HttpClient.dateTimeDeserializer);
                    }
                    else {
                        obj = JSON.parse(contents);
                    }
                    response.result = obj;
                }
                response.headers = res.message.headers;
            }
            catch (err) {
                // Invalid resource (contents not json);  leaving result obj null
            }
            // note that 3xx redirects are handled by the http layer.
            if (statusCode > 299) {
                let msg;
                // if exception/error in body, attempt to get better error
                if (obj && obj.message) {
                    msg = obj.message;
                }
                else if (contents && contents.length > 0) {
                    // it may be the case that the exception is in the body message as string
                    msg = contents;
                }
                else {
                    msg = 'Failed request: (' + statusCode + ')';
                }
                let err = new HttpClientError(msg, statusCode);
                err.result = response.result;
                reject(err);
            }
            else {
                resolve(response);
            }
        });
    }
}
exports.HttpClient = HttpClient;


/***/ }),

/***/ 16443:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function getProxyUrl(reqUrl) {
    let usingSsl = reqUrl.protocol === 'https:';
    let proxyUrl;
    if (checkBypass(reqUrl)) {
        return proxyUrl;
    }
    let proxyVar;
    if (usingSsl) {
        proxyVar = process.env['https_proxy'] || process.env['HTTPS_PROXY'];
    }
    else {
        proxyVar = process.env['http_proxy'] || process.env['HTTP_PROXY'];
    }
    if (proxyVar) {
        proxyUrl = new URL(proxyVar);
    }
    return proxyUrl;
}
exports.getProxyUrl = getProxyUrl;
function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
        return false;
    }
    let noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
    if (!noProxy) {
        return false;
    }
    // Determine the request port
    let reqPort;
    if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
    }
    else if (reqUrl.protocol === 'http:') {
        reqPort = 80;
    }
    else if (reqUrl.protocol === 'https:') {
        reqPort = 443;
    }
    // Format the request hostname and hostname with port
    let upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === 'number') {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    // Compare request host against noproxy
    for (let upperNoProxyItem of noProxy
        .split(',')
        .map(x => x.trim().toUpperCase())
        .filter(x => x)) {
        if (upperReqHosts.some(x => x === upperNoProxyItem)) {
            return true;
        }
    }
    return false;
}
exports.checkBypass = checkBypass;


/***/ }),

/***/ 23838:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApprovedPackagesConfiguration = exports.ApprovedPackagesItem = void 0;
const path = __importStar(__webpack_require__(85622));
const os = __importStar(__webpack_require__(12087));
const node_core_library_1 = __webpack_require__(24019);
const Utilities_1 = __webpack_require__(89521);
const JsonSchemaUrls_1 = __webpack_require__(66846);
/**
 * An item returned by ApprovedPackagesConfiguration
 * @public
 */
class ApprovedPackagesItem {
    /**
     * @internal
     */
    constructor(packageName) {
        /**
         * The project categories that are allowed to use this package.
         */
        this.allowedCategories = new Set();
        this.packageName = packageName;
    }
}
exports.ApprovedPackagesItem = ApprovedPackagesItem;
/**
 * This represents the JSON file specified via the "approvedPackagesFile" option in rush.json.
 * @public
 */
class ApprovedPackagesConfiguration {
    constructor(jsonFilename) {
        this.items = [];
        this._itemsByName = new Map();
        this._jsonFilename = jsonFilename;
        this.clear();
    }
    /**
     * Clears all the settings, returning to an empty state.
     */
    clear() {
        this._itemsByName.clear();
        this._loadedJson = {
            // Ensure this comes first in the key ordering
            $schema: '',
            packages: []
        };
    }
    getItemByName(packageName) {
        return this._itemsByName.get(packageName);
    }
    addOrUpdatePackage(packageName, reviewCategory) {
        let changed = false;
        let item = this._itemsByName.get(packageName);
        if (!item) {
            item = new ApprovedPackagesItem(packageName);
            this._addItem(item);
            changed = true;
        }
        if (reviewCategory && !item.allowedCategories.has(reviewCategory)) {
            item.allowedCategories.add(reviewCategory);
            changed = true;
        }
        return changed;
    }
    /**
     * If the file exists, calls loadFromFile().
     */
    tryLoadFromFile(approvedPackagesPolicyEnabled) {
        if (!node_core_library_1.FileSystem.exists(this._jsonFilename)) {
            return false;
        }
        this.loadFromFile();
        if (!approvedPackagesPolicyEnabled) {
            console.log(`Warning: Ignoring "${path.basename(this._jsonFilename)}" because the` +
                ` "approvedPackagesPolicy" setting was not specified in rush.json`);
        }
        return false;
    }
    /**
     * Loads the configuration data from the filename that was passed to the constructor.
     */
    loadFromFile() {
        const approvedPackagesJson = node_core_library_1.JsonFile.loadAndValidate(this._jsonFilename, ApprovedPackagesConfiguration._jsonSchema);
        this.clear();
        for (const browserPackage of approvedPackagesJson.packages) {
            this._addItemJson(browserPackage, this._jsonFilename);
        }
    }
    /**
     * Loads the configuration data to the filename that was passed to the constructor.
     */
    saveToFile() {
        // Update the JSON structure that we already loaded, preserving any existing state
        // (which passed schema validation).
        // eslint-disable-next-line dot-notation
        this._loadedJson['$schema'] = JsonSchemaUrls_1.JsonSchemaUrls.approvedPackages;
        this._loadedJson.packages = [];
        this.items.sort((a, b) => {
            return a.packageName.localeCompare(b.packageName);
        });
        for (const item of this.items) {
            // Sort the items from the set.  Too bad we can't use the new Array.from().
            const allowedCategories = Utilities_1.Utilities.getSetAsArray(item.allowedCategories);
            allowedCategories.sort();
            const itemJson = {
                name: item.packageName,
                allowedCategories: allowedCategories
            };
            this._loadedJson.packages.push(itemJson);
        }
        // Save the file
        let body = node_core_library_1.JsonFile.stringify(this._loadedJson);
        // Unindent the allowedCategories array to improve readability
        body = body.replace(/("allowedCategories": +\[)([^\]]+)/g, (substring, ...args) => {
            return args[0] + args[1].replace(/\s+/g, ' ');
        });
        // Add a header
        body = '// DO NOT ADD COMMENTS IN THIS FILE.  They will be lost when the Rush tool resaves it.\n' + body;
        node_core_library_1.FileSystem.writeFile(this._jsonFilename, body, {
            convertLineEndings: "\r\n" /* CrLf */
        });
    }
    /**
     * Helper function only used by the constructor when loading the file.
     */
    _addItemJson(itemJson, jsonFilename) {
        if (this._itemsByName.has(itemJson.name)) {
            throw new Error(`Error loading package review file ${jsonFilename}:` +
                os.EOL +
                ` the name "${itemJson.name}" appears more than once`);
        }
        const item = new ApprovedPackagesItem(itemJson.name);
        if (itemJson.allowedCategories) {
            for (const allowedCategory of itemJson.allowedCategories) {
                item.allowedCategories.add(allowedCategory);
            }
        }
        this._addItem(item);
    }
    /**
     * Helper function that adds an already created ApprovedPackagesItem to the
     * list and set.
     */
    _addItem(item) {
        if (this._itemsByName.has(item.packageName)) {
            throw new node_core_library_1.InternalError('Duplicate key');
        }
        this.items.push(item);
        this._itemsByName.set(item.packageName, item);
    }
}
exports.ApprovedPackagesConfiguration = ApprovedPackagesConfiguration;
ApprovedPackagesConfiguration._jsonSchema = node_core_library_1.JsonSchema.fromFile(path.join(__dirname, '../schemas/approved-packages.schema.json'));
//# sourceMappingURL=ApprovedPackagesConfiguration.js.map

/***/ }),

/***/ 73162:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApprovedPackagesPolicy = void 0;
const path = __importStar(__webpack_require__(85622));
const ApprovedPackagesConfiguration_1 = __webpack_require__(23838);
const RushConstants_1 = __webpack_require__(63985);
/**
 * This is a helper object for RushConfiguration.
 * It exposes the "approvedPackagesPolicy" feature from rush.json.
 * @public
 */
class ApprovedPackagesPolicy {
    /** @internal */
    constructor(rushConfiguration, rushConfigurationJson) {
        const approvedPackagesPolicy = rushConfigurationJson.approvedPackagesPolicy || {};
        this._enabled = !!rushConfigurationJson.approvedPackagesPolicy;
        this._ignoredNpmScopes = new Set(approvedPackagesPolicy.ignoredNpmScopes);
        this._reviewCategories = new Set(approvedPackagesPolicy.reviewCategories);
        if (this._enabled) {
            if (!this.reviewCategories.size) {
                throw new Error(`The "approvedPackagesPolicy" feature is enabled rush.json, but the reviewCategories` +
                    ` list is not configured.`);
            }
        }
        // Load browser-approved-packages.json
        const browserApprovedPackagesPath = path.join(rushConfiguration.commonRushConfigFolder, RushConstants_1.RushConstants.browserApprovedPackagesFilename);
        this._browserApprovedPackages = new ApprovedPackagesConfiguration_1.ApprovedPackagesConfiguration(browserApprovedPackagesPath);
        this._browserApprovedPackages.tryLoadFromFile(this._enabled);
        // Load nonbrowser-approved-packages.json
        const nonbrowserApprovedPackagesPath = path.join(rushConfiguration.commonRushConfigFolder, RushConstants_1.RushConstants.nonbrowserApprovedPackagesFilename);
        this._nonbrowserApprovedPackages = new ApprovedPackagesConfiguration_1.ApprovedPackagesConfiguration(nonbrowserApprovedPackagesPath);
        this._nonbrowserApprovedPackages.tryLoadFromFile(this._enabled);
    }
    /**
     * Whether the feature is enabled.  The feature is enabled if the "approvedPackagesPolicy"
     * field is assigned in rush.json.
     */
    get enabled() {
        return this._enabled;
    }
    /**
     * A list of NPM package scopes that will be excluded from review (e.g. `@types`)
     */
    get ignoredNpmScopes() {
        return this._ignoredNpmScopes;
    }
    /**
     * A list of category names that are valid for usage as the RushConfigurationProject.reviewCategory field.
     * This array will never be undefined.
     */
    get reviewCategories() {
        return this._reviewCategories;
    }
    /**
     * Packages approved for usage in a web browser.  This is the stricter of the two types, so by default
     * all new packages are added to this file.
     *
     * @remarks
     *
     * This is part of an optional approval workflow, whose purpose is to review any new dependencies
     * that are introduced (e.g. maybe a legal review is required, or maybe we are trying to minimize bloat).
     * When Rush discovers a new dependency has been added to package.json, it will update the file.
     * The intent is that the file will be stored in Git and tracked by a branch policy that notifies
     * reviewers when a PR attempts to modify the file.
     *
     * Example filename: `C:\MyRepo\common\config\rush\browser-approved-packages.json`
     */
    get browserApprovedPackages() {
        return this._browserApprovedPackages;
    }
    /**
     * Packages approved for usage everywhere *except* in a web browser.
     *
     * @remarks
     *
     * This is part of an optional approval workflow, whose purpose is to review any new dependencies
     * that are introduced (e.g. maybe a legal review is required, or maybe we are trying to minimize bloat).
     * The intent is that the file will be stored in Git and tracked by a branch policy that notifies
     * reviewers when a PR attempts to modify the file.
     *
     * Example filename: `C:\MyRepo\common\config\rush\browser-approved-packages.json`
     */
    get nonbrowserApprovedPackages() {
        return this._nonbrowserApprovedPackages;
    }
}
exports.ApprovedPackagesPolicy = ApprovedPackagesPolicy;
//# sourceMappingURL=ApprovedPackagesPolicy.js.map

/***/ }),

/***/ 7538:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BuildCacheConfiguration = void 0;
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const FileSystemBuildCacheProvider_1 = __webpack_require__(76964);
const RushConstants_1 = __webpack_require__(63985);
const RushUserConfiguration_1 = __webpack_require__(78221);
const EnvironmentConfiguration_1 = __webpack_require__(84018);
const CacheEntryId_1 = __webpack_require__(97939);
const AzureStorageBuildCacheProviderModule = node_core_library_1.Import.lazy('../logic/buildCache/AzureStorageBuildCacheProvider', require);
const AmazonS3BuildCacheProviderModule = node_core_library_1.Import.lazy('../logic/buildCache/AmazonS3/AmazonS3BuildCacheProvider', require);
/**
 * Use this class to load and save the "common/config/rush/build-cache.json" config file.
 * This file provides configuration options for cached project build output.
 * @public
 */
class BuildCacheConfiguration {
    constructor(options) {
        var _a;
        this.buildCacheEnabled =
            (_a = EnvironmentConfiguration_1.EnvironmentConfiguration.buildCacheEnabled) !== null && _a !== void 0 ? _a : options.buildCacheJson.buildCacheEnabled;
        this.getCacheEntryId = options.getCacheEntryId;
        this.localCacheProvider = new FileSystemBuildCacheProvider_1.FileSystemBuildCacheProvider({
            rushUserConfiguration: options.rushUserConfiguration,
            rushConfiguration: options.rushConfiguration
        });
        const { buildCacheJson } = options;
        switch (buildCacheJson.cacheProvider) {
            case 'local-only': {
                // Don't configure a cloud cache provider
                break;
            }
            case 'azure-blob-storage': {
                this.cloudCacheProvider = this._createAzureStorageBuildCacheProvider(buildCacheJson.azureBlobStorageConfiguration);
                break;
            }
            case 'amazon-s3': {
                this.cloudCacheProvider = this._createAmazonS3BuildCacheProvider(buildCacheJson.amazonS3Configuration);
                break;
            }
            default: {
                throw new Error(`Unexpected cache provider: ${buildCacheJson.cacheProvider}`);
            }
        }
    }
    /**
     * Attempts to load the build-cache.json data from the standard file path `common/config/rush/build-cache.json`.
     * If the file has not been created yet, then undefined is returned.
     */
    static async tryLoadAsync(terminal, rushConfiguration) {
        const jsonFilePath = BuildCacheConfiguration.getBuildCacheConfigFilePath(rushConfiguration);
        if (!node_core_library_1.FileSystem.exists(jsonFilePath)) {
            return undefined;
        }
        return await BuildCacheConfiguration._loadAsync(jsonFilePath, terminal, rushConfiguration);
    }
    /**
     * Loads the build-cache.json data from the standard file path `common/config/rush/build-cache.json`.
     * If the file has not been created yet, or if the feature is not enabled, then an error is reported.
     */
    static async loadAndRequireEnabledAsync(terminal, rushConfiguration) {
        const jsonFilePath = BuildCacheConfiguration.getBuildCacheConfigFilePath(rushConfiguration);
        if (!node_core_library_1.FileSystem.exists(jsonFilePath)) {
            terminal.writeErrorLine(`The build cache feature is not enabled. This config file is missing:\n` + jsonFilePath);
            terminal.writeLine(`\nThe Rush website documentation has instructions for enabling the build cache.`);
            throw new node_core_library_1.AlreadyReportedError();
        }
        const buildCacheConfiguration = await BuildCacheConfiguration._loadAsync(jsonFilePath, terminal, rushConfiguration);
        if (!buildCacheConfiguration.buildCacheEnabled) {
            terminal.writeErrorLine(`The build cache feature is not enabled. You can enable it by editing this config file:\n` +
                jsonFilePath);
            throw new node_core_library_1.AlreadyReportedError();
        }
        return buildCacheConfiguration;
    }
    static async _loadAsync(jsonFilePath, terminal, rushConfiguration) {
        const buildCacheJson = await node_core_library_1.JsonFile.loadAndValidateAsync(jsonFilePath, BuildCacheConfiguration._jsonSchema);
        const rushUserConfiguration = await RushUserConfiguration_1.RushUserConfiguration.initializeAsync();
        let getCacheEntryId;
        try {
            getCacheEntryId = CacheEntryId_1.CacheEntryId.parsePattern(buildCacheJson.cacheEntryNamePattern);
        }
        catch (e) {
            terminal.writeErrorLine(`Error parsing cache entry name pattern "${buildCacheJson.cacheEntryNamePattern}": ${e}`);
            throw new node_core_library_1.AlreadyReportedError();
        }
        return new BuildCacheConfiguration({
            buildCacheJson,
            getCacheEntryId,
            rushConfiguration,
            rushUserConfiguration
        });
    }
    static getBuildCacheConfigFilePath(rushConfiguration) {
        return path.resolve(rushConfiguration.commonRushConfigFolder, RushConstants_1.RushConstants.buildCacheFilename);
    }
    _createAzureStorageBuildCacheProvider(azureStorageConfigurationJson) {
        return new AzureStorageBuildCacheProviderModule.AzureStorageBuildCacheProvider({
            storageAccountName: azureStorageConfigurationJson.storageAccountName,
            storageContainerName: azureStorageConfigurationJson.storageContainerName,
            azureEnvironment: azureStorageConfigurationJson.azureEnvironment,
            blobPrefix: azureStorageConfigurationJson.blobPrefix,
            isCacheWriteAllowed: !!azureStorageConfigurationJson.isCacheWriteAllowed
        });
    }
    _createAmazonS3BuildCacheProvider(amazonS3ConfigurationJson) {
        return new AmazonS3BuildCacheProviderModule.AmazonS3BuildCacheProvider({
            s3Region: amazonS3ConfigurationJson.s3Region,
            s3Bucket: amazonS3ConfigurationJson.s3Bucket,
            s3Prefix: amazonS3ConfigurationJson.s3Prefix,
            isCacheWriteAllowed: !!amazonS3ConfigurationJson.isCacheWriteAllowed
        });
    }
}
exports.BuildCacheConfiguration = BuildCacheConfiguration;
BuildCacheConfiguration._jsonSchema = node_core_library_1.JsonSchema.fromFile(path.join(__dirname, '..', 'schemas', 'build-cache.schema.json'));
//# sourceMappingURL=BuildCacheConfiguration.js.map

/***/ }),

/***/ 49915:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChangeFile = void 0;
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const Git_1 = __webpack_require__(58361);
/**
 * This class represents a single change file.
 */
class ChangeFile {
    /**
     * @internal
     */
    constructor(changeFileData, rushConfiguration) {
        if (!changeFileData) {
            throw new Error(`changeFileData does not have a value`);
        }
        if (!rushConfiguration) {
            throw new Error(`rushConfiguration does not have a value`);
        }
        this._changeFileData = changeFileData;
        this._rushConfiguration = rushConfiguration;
    }
    /**
     * Adds a change entry into the change file
     * @param data - change information
     */
    addChange(data) {
        this._changeFileData.changes.push(data);
    }
    /**
     * Gets all the change entries about the specified package from the change file.
     * @param packageName - package name
     */
    getChanges(packageName) {
        const changes = [];
        for (const info of this._changeFileData.changes) {
            if (info.packageName === packageName) {
                changes.push(info);
            }
        }
        return changes;
    }
    /**
     * Writes the change file to disk in sync mode.
     * Returns the file path.
     * @returns the path to the file that was written (based on generatePath())
     */
    writeSync() {
        const filePath = this.generatePath();
        node_core_library_1.JsonFile.save(this._changeFileData, filePath, {
            ensureFolderExists: true
        });
        return filePath;
    }
    /**
     * Generates a file path for storing the change file to disk.
     * Note that this value may change if called twice in a row,
     * as it is partially based on the current date/time.
     */
    generatePath() {
        let branch = undefined;
        const git = new Git_1.Git(this._rushConfiguration);
        const repoInfo = git.getGitInfo();
        branch = repoInfo && repoInfo.branch;
        if (!branch) {
            console.log('Could not automatically detect git branch name, using timestamp instead.');
        }
        // example filename: yourbranchname_2017-05-01-20-20.json
        const filename = branch
            ? this._escapeFilename(`${branch}_${this._getTimestamp()}.json`)
            : `${this._getTimestamp()}.json`;
        const filePath = path.join(this._rushConfiguration.changesFolder, ...this._changeFileData.packageName.split('/'), filename);
        return filePath;
    }
    /**
     * Gets the current time, formatted as YYYY-MM-DD-HH-MM
     * Optionally will include seconds
     */
    _getTimestamp(useSeconds = false) {
        // Create a date string with the current time
        // dateString === "2016-10-19T22:47:49.606Z"
        const dateString = new Date().toJSON();
        // Parse out 2 capture groups, the date and the time
        const dateParseRegex = /([0-9]{4}-[0-9]{2}-[0-9]{2}).*([0-9]{2}:[0-9]{2}:[0-9]{2})/;
        // matches[1] === "2016-10-19"
        // matches[2] === "22:47:49"
        const matches = dateString.match(dateParseRegex);
        if (matches) {
            // formattedDate === "2016-10-19"
            const formattedDate = matches[1];
            let formattedTime;
            if (useSeconds) {
                // formattedTime === "22-47-49"
                formattedTime = matches[2].replace(':', '-');
            }
            else {
                // formattedTime === "22-47"
                const timeParts = matches[2].split(':');
                formattedTime = `${timeParts[0]}-${timeParts[1]}`;
            }
            return `${formattedDate}-${formattedTime}`;
        }
        return undefined;
    }
    _escapeFilename(filename, replacer = '-') {
        // Removes / ? < > \ : * | ", really anything that isn't a letter, number, '.' '_' or '-'
        const badCharacters = /[^a-zA-Z0-9._-]/g;
        return filename.replace(badCharacters, replacer);
    }
}
exports.ChangeFile = ChangeFile;
//# sourceMappingURL=ChangeFile.js.map

/***/ }),

/***/ 6877:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChangeType = void 0;
/**
 * Represents all of the types of change requests.
 */
var ChangeType;
(function (ChangeType) {
    ChangeType[ChangeType["none"] = 0] = "none";
    ChangeType[ChangeType["dependency"] = 1] = "dependency";
    ChangeType[ChangeType["hotfix"] = 2] = "hotfix";
    ChangeType[ChangeType["patch"] = 3] = "patch";
    ChangeType[ChangeType["minor"] = 4] = "minor";
    ChangeType[ChangeType["major"] = 5] = "major";
})(ChangeType = exports.ChangeType || (exports.ChangeType = {}));
//# sourceMappingURL=ChangeManagement.js.map

/***/ }),

/***/ 85508:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChangeManager = void 0;
const ChangeFile_1 = __webpack_require__(49915);
/**
 * A class that helps with programmatically interacting with Rush's change files.
 * @public
 */
class ChangeManager {
    /**
     * Creates a change file that has a 'none' type.
     * @param rushConfiguration - The rush configuration we are working with
     * @param projectName - The name of the project for which to create a change file
     * @param emailAddress - The email address which should be associated with this change
     * @returns the path to the file that was created, or undefined if no file was written
     */
    static createEmptyChangeFiles(rushConfiguration, projectName, emailAddress) {
        const projectInfo = rushConfiguration.getProjectByName(projectName);
        if (projectInfo && projectInfo.shouldPublish) {
            const changefile = {
                // eslint-disable-line @typescript-eslint/no-explicit-any
                changes: [
                    {
                        comment: '',
                        packageName: projectName,
                        type: 'none'
                    }
                ],
                packageName: projectName,
                email: emailAddress
            };
            return new ChangeFile_1.ChangeFile(changefile, rushConfiguration).writeSync();
        }
        return undefined;
    }
}
exports.ChangeManager = ChangeManager;
//# sourceMappingURL=ChangeManager.js.map

/***/ }),

/***/ 5347:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandLineConfiguration = void 0;
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const RushConstants_1 = __webpack_require__(63985);
const EXPECTED_PHASE_NAME_PREFIX = '_phase:';
/**
 * Custom Commands and Options for the Rush Command Line
 */
class CommandLineConfiguration {
    /**
     * Use CommandLineConfiguration.loadFromFile()
     *
     * @internal
     */
    constructor(commandLineJson) {
        var _a, _b;
        this.commands = new Map();
        this.phases = new Map();
        this.parameters = [];
        this._commandNames = new Set([
            RushConstants_1.RushConstants.buildCommandName,
            RushConstants_1.RushConstants.rebuildCommandName
        ]);
        if (commandLineJson) {
            if (commandLineJson.phases) {
                for (const phase of commandLineJson.phases) {
                    if (this.phases.has(phase.name)) {
                        throw new Error(`In ${RushConstants_1.RushConstants.commandLineFilename}, the phase "${phase.name}" is specified ` +
                            'more than once.');
                    }
                    if (phase.name.substring(0, EXPECTED_PHASE_NAME_PREFIX.length) !== EXPECTED_PHASE_NAME_PREFIX) {
                        throw new Error(`In ${RushConstants_1.RushConstants.commandLineFilename}, the phase "${phase.name}"'s name ` +
                            `does not begin with the required prefix "${EXPECTED_PHASE_NAME_PREFIX}".`);
                    }
                    if (phase.name.length <= EXPECTED_PHASE_NAME_PREFIX.length) {
                        throw new Error(`In ${RushConstants_1.RushConstants.commandLineFilename}, the phase "${phase.name}"'s name ` +
                            `must have characters after "${EXPECTED_PHASE_NAME_PREFIX}"`);
                    }
                    this.phases.set(phase.name, phase);
                }
            }
            for (const phase of this.phases.values()) {
                if ((_a = phase.dependencies) === null || _a === void 0 ? void 0 : _a.self) {
                    for (const dependencyName of phase.dependencies.self) {
                        const dependency = this.phases.get(dependencyName);
                        if (!dependency) {
                            throw new Error(`In ${RushConstants_1.RushConstants.commandLineFilename}, in the phase "${phase.name}", the self ` +
                                `dependency phase "${dependencyName}" does not exist.`);
                        }
                    }
                }
                if ((_b = phase.dependencies) === null || _b === void 0 ? void 0 : _b.upstream) {
                    for (const dependency of phase.dependencies.upstream) {
                        if (!this.phases.has(dependency)) {
                            throw new Error(`In ${RushConstants_1.RushConstants.commandLineFilename}, in the phase "${phase.name}", the upstream ` +
                                `dependency phase "${dependency}" does not exist.`);
                        }
                    }
                }
                this._checkForPhaseSelfCycles(phase);
            }
            if (commandLineJson.commands) {
                for (const command of commandLineJson.commands) {
                    if (this.commands.has(command.name)) {
                        throw new Error(`In ${RushConstants_1.RushConstants.commandLineFilename}, the command "${command.name}" is specified ` +
                            'more than once.');
                    }
                    if (command.commandKind === 'phased') {
                        const phasedCommand = command;
                        for (const phase of phasedCommand.phases) {
                            if (!this.phases.has(phase)) {
                                throw new Error(`In ${RushConstants_1.RushConstants.commandLineFilename}, in the "phases" property of the ` +
                                    `"${command.name}" command, the phase "${phase}" does not exist.`);
                            }
                        }
                        if (phasedCommand.skipPhasesForCommand) {
                            for (const phase of phasedCommand.skipPhasesForCommand) {
                                if (!this.phases.has(phase)) {
                                    throw new Error(`In ${RushConstants_1.RushConstants.commandLineFilename}, in the "skipPhasesForCommand" property of the ` +
                                        `"${command.name}" command, the phase "${phase}" does not exist.`);
                                }
                            }
                        }
                    }
                    this.commands.set(command.name, command);
                    this._commandNames.add(command.name);
                }
            }
            if (commandLineJson.parameters) {
                for (const parameter of commandLineJson.parameters) {
                    this.parameters.push(parameter);
                    let parameterHasAssociations = false;
                    // Do some basic validation
                    switch (parameter.parameterKind) {
                        case 'flag': {
                            const addPhasesToCommandSet = new Set();
                            if (parameter.addPhasesToCommand) {
                                for (const phase of parameter.addPhasesToCommand) {
                                    addPhasesToCommandSet.add(phase);
                                    if (!this.phases.has(phase)) {
                                        throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a parameter "${parameter.longName}" ` +
                                            `that lists phase "${phase}" in its "addPhasesToCommand" property that does not exist.`);
                                    }
                                    else {
                                        parameterHasAssociations = true;
                                    }
                                }
                            }
                            if (parameter.skipPhasesForCommand) {
                                for (const phase of parameter.skipPhasesForCommand) {
                                    if (!this.phases.has(phase)) {
                                        throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a parameter "${parameter.longName}" ` +
                                            `that lists phase "${phase}" in its skipPhasesForCommand" property that does not exist.`);
                                    }
                                    else if (addPhasesToCommandSet.has(phase)) {
                                        throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a parameter "${parameter.longName}" ` +
                                            `that lists phase "${phase}" in both its "addPhasesToCommand" and "skipPhasesForCommand" properties.`);
                                    }
                                    else {
                                        parameterHasAssociations = true;
                                    }
                                }
                            }
                            break;
                        }
                        case 'choice': {
                            const alternativeNames = parameter.alternatives.map((x) => x.name);
                            if (parameter.defaultValue && alternativeNames.indexOf(parameter.defaultValue) < 0) {
                                throw new Error(`In ${RushConstants_1.RushConstants.commandLineFilename}, the parameter "${parameter.longName}",` +
                                    ` specifies a default value "${parameter.defaultValue}"` +
                                    ` which is not one of the defined alternatives: "${alternativeNames.toString()}"`);
                            }
                            break;
                        }
                    }
                    for (const associatedCommand of parameter.associatedCommands || []) {
                        if (!this._commandNames.has(associatedCommand)) {
                            throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a parameter "${parameter.longName}" ` +
                                `that is associated with a command "${associatedCommand}" that does not exist or does ` +
                                'not support custom parameters.');
                        }
                        else {
                            parameterHasAssociations = true;
                        }
                    }
                    for (const associatedPhase of parameter.associatedPhases || []) {
                        if (!this.phases.has(associatedPhase)) {
                            throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a parameter "${parameter.longName}" ` +
                                `that is associated with a phase "${associatedPhase}" that does not exist.`);
                        }
                        else {
                            parameterHasAssociations = true;
                        }
                    }
                    if (!parameterHasAssociations) {
                        throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a parameter "${parameter.longName}"` +
                            ` that lists no associated commands or phases.`);
                    }
                }
            }
        }
    }
    _checkForPhaseSelfCycles(phase, checkedPhases = new Set()) {
        var _a;
        const dependencies = (_a = phase.dependencies) === null || _a === void 0 ? void 0 : _a.self;
        if (dependencies) {
            for (const dependencyName of dependencies) {
                if (checkedPhases.has(dependencyName)) {
                    throw new Error(`In ${RushConstants_1.RushConstants.commandLineFilename}, there exists a cycle within the ` +
                        `set of ${dependencyName} dependencies: ${Array.from(checkedPhases).join(', ')}`);
                }
                else {
                    checkedPhases.add(dependencyName);
                    const dependency = this.phases.get(dependencyName);
                    if (!dependency) {
                        return; // Ignore, we check for this separately
                    }
                    else {
                        if (dependencies.length > 1) {
                            this._checkForPhaseSelfCycles(dependency, 
                            // Clone the set of checked phases if there are multiple branches we need to check
                            new Set(checkedPhases));
                        }
                        else {
                            this._checkForPhaseSelfCycles(dependency, checkedPhases);
                        }
                    }
                }
            }
        }
    }
    /**
     * Loads the configuration from the specified file and applies any omitted default build
     * settings.  If the file does not exist, then an empty default instance is returned.
     * If the file contains errors, then an exception is thrown.
     */
    static loadFromFileOrDefault(jsonFilename) {
        let commandLineJson = undefined;
        if (node_core_library_1.FileSystem.exists(jsonFilename)) {
            commandLineJson = node_core_library_1.JsonFile.load(jsonFilename);
            // merge commands specified in command-line.json and default (re)build settings
            // Ensure both build commands are included and preserve any other commands specified
            if (commandLineJson && commandLineJson.commands) {
                for (let i = 0; i < commandLineJson.commands.length; i++) {
                    const command = commandLineJson.commands[i];
                    // Determine if we have a set of default parameters
                    let commandDefaultDefinition = {};
                    switch (command.commandKind) {
                        case RushConstants_1.RushConstants.bulkCommandKind: {
                            switch (command.name) {
                                case RushConstants_1.RushConstants.buildCommandName: {
                                    commandDefaultDefinition = CommandLineConfiguration.defaultBuildCommandJson;
                                    break;
                                }
                                case RushConstants_1.RushConstants.rebuildCommandName: {
                                    commandDefaultDefinition = CommandLineConfiguration.defaultRebuildCommandJson;
                                    break;
                                }
                            }
                            break;
                        }
                    }
                    // Merge the default parameters into the repo-specified parameters
                    commandLineJson.commands[i] = Object.assign(Object.assign({}, commandDefaultDefinition), command);
                }
                CommandLineConfiguration._jsonSchema.validateObject(commandLineJson, jsonFilename);
            }
        }
        return new CommandLineConfiguration(commandLineJson);
    }
}
exports.CommandLineConfiguration = CommandLineConfiguration;
CommandLineConfiguration._jsonSchema = node_core_library_1.JsonSchema.fromFile(path.join(__dirname, '../schemas/command-line.schema.json'));
CommandLineConfiguration.defaultBuildCommandJson = {
    commandKind: RushConstants_1.RushConstants.bulkCommandKind,
    name: RushConstants_1.RushConstants.buildCommandName,
    summary: "Build all projects that haven't been built, or have changed since they were last built.",
    description: 'This command is similar to "rush rebuild", except that "rush build" performs' +
        ' an incremental build. In other words, it only builds projects whose source files have changed' +
        ' since the last successful build. The analysis requires a Git working tree, and only considers' +
        ' source files that are tracked by Git and whose path is under the project folder. (For more details' +
        ' about this algorithm, see the documentation for the "package-deps-hash" NPM package.) The incremental' +
        ' build state is tracked in a per-project folder called ".rush/temp" which should NOT be added to Git. The' +
        ' build command is tracked by the "arguments" field in the "package-deps_build.json" file contained' +
        ' therein; a full rebuild is forced whenever the command has changed (e.g. "--production" or not).',
    enableParallelism: true,
    ignoreMissingScript: false,
    ignoreDependencyOrder: false,
    incremental: true,
    allowWarningsInSuccessfulBuild: false,
    safeForSimultaneousRushProcesses: false
};
CommandLineConfiguration.defaultRebuildCommandJson = {
    commandKind: RushConstants_1.RushConstants.bulkCommandKind,
    name: RushConstants_1.RushConstants.rebuildCommandName,
    summary: 'Clean and rebuild the entire set of projects',
    description: 'This command assumes that the package.json file for each project contains' +
        ' a "scripts" entry for "npm run build" that performs a full clean build.' +
        ' Rush invokes this script to build each project that is registered in rush.json.' +
        ' Projects are built in parallel where possible, but always respecting the dependency' +
        ' graph for locally linked projects.  The number of simultaneous processes will be' +
        ' based on the number of machine cores unless overridden by the --parallelism flag.' +
        ' (For an incremental build, see "rush build" instead of "rush rebuild".)',
    enableParallelism: true,
    ignoreMissingScript: false,
    ignoreDependencyOrder: false,
    incremental: false,
    allowWarningsInSuccessfulBuild: false,
    safeForSimultaneousRushProcesses: false
};
//# sourceMappingURL=CommandLineConfiguration.js.map

/***/ }),

/***/ 2465:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonVersionsConfiguration = void 0;
const crypto_1 = __importDefault(__webpack_require__(33373));
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const PackageNameParsers_1 = __webpack_require__(39458);
const JsonSchemaUrls_1 = __webpack_require__(66846);
/**
 * Use this class to load and save the "common/config/rush/common-versions.json" config file.
 * This config file stores dependency version information that affects all projects in the repo.
 * @public
 */
class CommonVersionsConfiguration {
    constructor(commonVersionsJson, filePath) {
        this._modified = false;
        this._preferredVersions = new node_core_library_1.ProtectableMap({
            onSet: this._onSetPreferredVersions.bind(this)
        });
        if (commonVersionsJson && commonVersionsJson.implicitlyPreferredVersions !== undefined) {
            this._implicitlyPreferredVersions = commonVersionsJson.implicitlyPreferredVersions;
        }
        else {
            this._implicitlyPreferredVersions = undefined;
        }
        this._xstitchPreferredVersions = new node_core_library_1.ProtectableMap({
            onSet: this._onSetPreferredVersions.bind(this)
        });
        this._allowedAlternativeVersions = new node_core_library_1.ProtectableMap({
            onSet: this._onSetAllowedAlternativeVersions.bind(this)
        });
        if (commonVersionsJson) {
            try {
                CommonVersionsConfiguration._deserializeTable(this.preferredVersions, commonVersionsJson.preferredVersions);
                CommonVersionsConfiguration._deserializeTable(this.xstitchPreferredVersions, commonVersionsJson.xstitchPreferredVersions);
                CommonVersionsConfiguration._deserializeTable(this.allowedAlternativeVersions, commonVersionsJson.allowedAlternativeVersions);
            }
            catch (e) {
                throw new Error(`Error loading "${path.basename(filePath)}": ${e.message}`);
            }
        }
        this._filePath = filePath;
    }
    /**
     * Loads the common-versions.json data from the specified file path.
     * If the file has not been created yet, then an empty object is returned.
     */
    static loadFromFile(jsonFilename) {
        let commonVersionsJson = undefined;
        if (node_core_library_1.FileSystem.exists(jsonFilename)) {
            commonVersionsJson = node_core_library_1.JsonFile.loadAndValidate(jsonFilename, CommonVersionsConfiguration._jsonSchema);
        }
        return new CommonVersionsConfiguration(commonVersionsJson, jsonFilename);
    }
    static _deserializeTable(map, object) {
        if (object) {
            for (const [key, value] of Object.entries(object)) {
                map.set(key, value);
            }
        }
    }
    static _serializeTable(map) {
        const table = {};
        const keys = [...map.keys()];
        keys.sort();
        for (const key of keys) {
            table[key] = map.get(key);
        }
        return table;
    }
    /**
     * Get the absolute file path of the common-versions.json file.
     */
    get filePath() {
        return this._filePath;
    }
    /**
     * Get a sha1 hash of the preferred versions.
     */
    getPreferredVersionsHash() {
        // Sort so that the hash is stable
        const orderedPreferredVersions = new Map(this._preferredVersions.protectedView);
        node_core_library_1.Sort.sortMapKeys(orderedPreferredVersions);
        // JSON.stringify does not support maps, so we need to convert to an object first
        const preferredVersionsObj = node_core_library_1.MapExtensions.toObject(orderedPreferredVersions);
        return crypto_1.default.createHash('sha1').update(JSON.stringify(preferredVersionsObj)).digest('hex');
    }
    /**
     * Writes the "common-versions.json" file to disk, using the filename that was passed to loadFromFile().
     */
    save() {
        if (this._modified) {
            node_core_library_1.JsonFile.save(this._serialize(), this._filePath, { updateExistingFile: true });
            this._modified = false;
            return true;
        }
        return false;
    }
    /**
     * A table that specifies a "preferred version" for a given NPM package.  This feature is typically used
     * to hold back an indirect dependency to a specific older version, or to reduce duplication of indirect dependencies.
     *
     * @remarks
     * The "preferredVersions" value can be any SemVer range specifier (e.g. `~1.2.3`).  Rush injects these values into
     * the "dependencies" field of the top-level common/temp/package.json, which influences how the package manager
     * will calculate versions.  The specific effect depends on your package manager.  Generally it will have no
     * effect on an incompatible or already constrained SemVer range.  If you are using PNPM, similar effects can be
     * achieved using the pnpmfile.js hook.  See the Rush documentation for more details.
     *
     * After modifying this field, it's recommended to run `rush update --full` so that the package manager
     * will recalculate all version selections.
     */
    get preferredVersions() {
        return this._preferredVersions.protectedView;
    }
    /**
     * When set to true, for all projects in the repo, all dependencies will be automatically added as preferredVersions,
     * except in cases where different projects specify different version ranges for a given dependency.  For older
     * package managers, this tended to reduce duplication of indirect dependencies.  However, it can sometimes cause
     * trouble for indirect dependencies with incompatible peerDependencies ranges.
     *
     * If the value is `undefined`, then the default value is `true`.
     */
    get implicitlyPreferredVersions() {
        return this._implicitlyPreferredVersions;
    }
    /**
     * A table of specifies preferred versions maintained by the XStitch tool.
     *
     * @remarks
     * This property has the same behavior as the "preferredVersions" property, except these entries
     * are automatically managed by the XStitch tool.  It is an error for the same dependency name
     * to appear in both tables.
     */
    get xstitchPreferredVersions() {
        return this._xstitchPreferredVersions.protectedView;
    }
    /**
     * A table that stores, for a given dependency, a list of SemVer ranges that will be accepted
     * by "rush check" in addition to the normal version range.
     *
     * @remarks
     * The "rush check" command can be used to enforce that every project in the repo
     * must specify the same SemVer range for a given dependency.  However, sometimes
     * exceptions are needed.  The allowedAlternativeVersions table allows you to list
     * other SemVer ranges that will be accepted by "rush check" for a given dependency.
     * Note that the normal version range (as inferred by looking at all projects in the repo)
     * should NOT be included in this list.
     */
    get allowedAlternativeVersions() {
        return this._allowedAlternativeVersions.protectedView;
    }
    /**
     * Returns the union of preferredVersions and xstitchPreferredVersions.
     */
    getAllPreferredVersions() {
        const allPreferredVersions = new Map();
        node_core_library_1.MapExtensions.mergeFromMap(allPreferredVersions, this.preferredVersions);
        node_core_library_1.MapExtensions.mergeFromMap(allPreferredVersions, this.xstitchPreferredVersions);
        return allPreferredVersions;
    }
    _onSetPreferredVersions(source, key, value) {
        PackageNameParsers_1.PackageNameParsers.permissive.validate(key);
        if (source === this._preferredVersions) {
            if (this._xstitchPreferredVersions.has(key)) {
                throw new Error(`The package "${key}" cannot be added to preferredVersions because it was already` +
                    ` added to xstitchPreferredVersions`);
            }
        }
        else {
            if (this._preferredVersions.has(key)) {
                throw new Error(`The package "${key}" cannot be added to xstitchPreferredVersions because it was already` +
                    ` added to preferredVersions`);
            }
        }
        this._modified = true;
        return value;
    }
    _onSetAllowedAlternativeVersions(source, key, value) {
        PackageNameParsers_1.PackageNameParsers.permissive.validate(key);
        this._modified = true;
        return value;
    }
    _serialize() {
        const result = {
            $schema: JsonSchemaUrls_1.JsonSchemaUrls.commonVersions
        };
        if (this._preferredVersions.size) {
            result.preferredVersions = CommonVersionsConfiguration._serializeTable(this.preferredVersions);
        }
        if (this._xstitchPreferredVersions.size) {
            result.xstitchPreferredVersions = CommonVersionsConfiguration._serializeTable(this.xstitchPreferredVersions);
        }
        if (this._allowedAlternativeVersions.size) {
            result.allowedAlternativeVersions = CommonVersionsConfiguration._serializeTable(this.allowedAlternativeVersions);
        }
        return result;
    }
}
exports.CommonVersionsConfiguration = CommonVersionsConfiguration;
CommonVersionsConfiguration._jsonSchema = node_core_library_1.JsonSchema.fromFile(path.join(__dirname, '../schemas/common-versions.schema.json'));
//# sourceMappingURL=CommonVersionsConfiguration.js.map

/***/ }),

/***/ 84018:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnvironmentConfiguration = void 0;
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const true_case_path_1 = __webpack_require__(76979);
/**
 * Provides Rush-specific environment variable data. All Rush environment variables must start with "RUSH_". This class
 * is designed to be used by RushConfiguration.
 *
 * @remarks
 * Initialize will throw if any unknown parameters are present.
 */
class EnvironmentConfiguration {
    /**
     * An override for the common/temp folder path.
     */
    static get rushTempFolderOverride() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._rushTempFolderOverride;
    }
    /**
     * If "1", create symlinks with absolute paths instead of relative paths.
     * See {@link EnvironmentVariableNames.RUSH_ABSOLUTE_SYMLINKS}
     */
    static get absoluteSymlinks() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._absoluteSymlinks;
    }
    /**
     * If this environment variable is set to "1", the Node.js version check will print a warning
     * instead of causing a hard error if the environment's Node.js version doesn't match the
     * version specifier in `rush.json`'s "nodeSupportedVersionRange" property.
     *
     * See {@link EnvironmentVariableNames.RUSH_ALLOW_UNSUPPORTED_NODEJS}.
     */
    static get allowUnsupportedNodeVersion() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._allowUnsupportedNodeVersion;
    }
    /**
     * Setting this environment variable overrides the value of `allowWarningsInSuccessfulBuild`
     * in the `command-line.json` configuration file. Specify `1` to allow warnings in a successful build,
     * or `0` to disallow them. (See the comments in the command-line.json file for more information).
     */
    static get allowWarningsInSuccessfulBuild() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._allowWarningsInSuccessfulBuild;
    }
    /**
     * An override for the PNPM store path, if `pnpmStore` configuration is set to 'path'
     * See {@link EnvironmentVariableNames.RUSH_PNPM_STORE_PATH}
     */
    static get pnpmStorePathOverride() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._pnpmStorePathOverride;
    }
    /**
     * Overrides the location of the `~/.rush` global folder where Rush stores temporary files.
     * See {@link EnvironmentVariableNames.RUSH_GLOBAL_FOLDER}
     */
    static get rushGlobalFolderOverride() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._rushGlobalFolderOverride;
    }
    /**
     * Provides a credential for reading from and writing to a remote build cache, if configured.
     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_CREDENTIAL}
     */
    static get buildCacheCredential() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._buildCacheCredential;
    }
    /**
     * If set, enables or disables the cloud build cache feature.
     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_ENABLED}
     */
    static get buildCacheEnabled() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._buildCacheEnabled;
    }
    /**
     * If set, enables or disables writing to the cloud build cache.
     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_WRITE_ALLOWED}
     */
    static get buildCacheWriteAllowed() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._buildCacheWriteAllowed;
    }
    /**
     * Allows the git binary path to be explicitly provided.
     * See {@link EnvironmentVariableNames.RUSH_GIT_BINARY_PATH}
     */
    static get gitBinaryPath() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._gitBinaryPath;
    }
    /**
     * Allows the tar binary path to be explicitly provided.
     * See {@link EnvironmentVariableNames.RUSH_TAR_BINARY_PATH}
     */
    static get tarBinaryPath() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._tarBinaryPath;
    }
    /**
     * The front-end RushVersionSelector relies on `RUSH_GLOBAL_FOLDER`, so its value must be read before
     * `EnvironmentConfiguration` is initialized (and actually before the correct version of `EnvironmentConfiguration`
     * is even installed). Thus we need to read this environment variable differently from all the others.
     * @internal
     */
    static _getRushGlobalFolderOverride(processEnv) {
        const value = processEnv["RUSH_GLOBAL_FOLDER" /* RUSH_GLOBAL_FOLDER */];
        if (value) {
            const normalizedValue = EnvironmentConfiguration._normalizeDeepestParentFolderPath(value);
            return normalizedValue;
        }
    }
    /**
     * Reads and validates environment variables. If any are invalid, this function will throw.
     */
    static validate(options = {}) {
        var _a, _b, _c;
        EnvironmentConfiguration.reset();
        const unknownEnvVariables = [];
        for (const envVarName in process.env) {
            if (process.env.hasOwnProperty(envVarName) && envVarName.match(/^RUSH_/i)) {
                const value = process.env[envVarName];
                // Environment variables are only case-insensitive on Windows
                const normalizedEnvVarName = os.platform() === 'win32' ? envVarName.toUpperCase() : envVarName;
                switch (normalizedEnvVarName) {
                    case "RUSH_TEMP_FOLDER" /* RUSH_TEMP_FOLDER */: {
                        EnvironmentConfiguration._rushTempFolderOverride =
                            value && !options.doNotNormalizePaths
                                ? EnvironmentConfiguration._normalizeDeepestParentFolderPath(value) || value
                                : value;
                        break;
                    }
                    case "RUSH_ABSOLUTE_SYMLINKS" /* RUSH_ABSOLUTE_SYMLINKS */: {
                        EnvironmentConfiguration._absoluteSymlinks =
                            (_a = EnvironmentConfiguration.parseBooleanEnvironmentVariable("RUSH_ABSOLUTE_SYMLINKS" /* RUSH_ABSOLUTE_SYMLINKS */, value)) !== null && _a !== void 0 ? _a : false;
                        break;
                    }
                    case "RUSH_ALLOW_UNSUPPORTED_NODEJS" /* RUSH_ALLOW_UNSUPPORTED_NODEJS */: {
                        if (value === 'true' || value === 'false') {
                            // Small, undocumented acceptance of old "true" and "false" values for
                            // users of RUSH_ALLOW_UNSUPPORTED_NODEJS in rush pre-v5.46.
                            EnvironmentConfiguration._allowUnsupportedNodeVersion = value === 'true';
                        }
                        else {
                            EnvironmentConfiguration._allowUnsupportedNodeVersion =
                                (_b = EnvironmentConfiguration.parseBooleanEnvironmentVariable("RUSH_ALLOW_UNSUPPORTED_NODEJS" /* RUSH_ALLOW_UNSUPPORTED_NODEJS */, value)) !== null && _b !== void 0 ? _b : false;
                        }
                        break;
                    }
                    case "RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD" /* RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD */: {
                        EnvironmentConfiguration._allowWarningsInSuccessfulBuild =
                            (_c = EnvironmentConfiguration.parseBooleanEnvironmentVariable("RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD" /* RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD */, value)) !== null && _c !== void 0 ? _c : false;
                        break;
                    }
                    case "RUSH_PNPM_STORE_PATH" /* RUSH_PNPM_STORE_PATH */: {
                        EnvironmentConfiguration._pnpmStorePathOverride =
                            value && !options.doNotNormalizePaths
                                ? EnvironmentConfiguration._normalizeDeepestParentFolderPath(value) || value
                                : value;
                        break;
                    }
                    case "RUSH_GLOBAL_FOLDER" /* RUSH_GLOBAL_FOLDER */: {
                        // Handled specially below
                        break;
                    }
                    case "RUSH_BUILD_CACHE_CREDENTIAL" /* RUSH_BUILD_CACHE_CREDENTIAL */: {
                        EnvironmentConfiguration._buildCacheCredential = value;
                        break;
                    }
                    case "RUSH_BUILD_CACHE_ENABLED" /* RUSH_BUILD_CACHE_ENABLED */: {
                        EnvironmentConfiguration._buildCacheEnabled =
                            EnvironmentConfiguration.parseBooleanEnvironmentVariable("RUSH_BUILD_CACHE_ENABLED" /* RUSH_BUILD_CACHE_ENABLED */, value);
                        break;
                    }
                    case "RUSH_BUILD_CACHE_WRITE_ALLOWED" /* RUSH_BUILD_CACHE_WRITE_ALLOWED */: {
                        EnvironmentConfiguration._buildCacheWriteAllowed =
                            EnvironmentConfiguration.parseBooleanEnvironmentVariable("RUSH_BUILD_CACHE_WRITE_ALLOWED" /* RUSH_BUILD_CACHE_WRITE_ALLOWED */, value);
                        break;
                    }
                    case "RUSH_GIT_BINARY_PATH" /* RUSH_GIT_BINARY_PATH */: {
                        EnvironmentConfiguration._gitBinaryPath = value;
                        break;
                    }
                    case "RUSH_TAR_BINARY_PATH" /* RUSH_TAR_BINARY_PATH */: {
                        EnvironmentConfiguration._tarBinaryPath = value;
                        break;
                    }
                    case "RUSH_PARALLELISM" /* RUSH_PARALLELISM */:
                    case "RUSH_PREVIEW_VERSION" /* RUSH_PREVIEW_VERSION */:
                    case "RUSH_VARIANT" /* RUSH_VARIANT */:
                    case "RUSH_DEPLOY_TARGET_FOLDER" /* RUSH_DEPLOY_TARGET_FOLDER */:
                        // Handled by @microsoft/rush front end
                        break;
                    case "RUSH_INVOKED_FOLDER" /* RUSH_INVOKED_FOLDER */:
                        // Assigned by Rush itself
                        break;
                    default:
                        unknownEnvVariables.push(envVarName);
                        break;
                }
            }
        }
        // This strictness intends to catch mistakes where variables are misspelled or not used correctly.
        if (unknownEnvVariables.length > 0) {
            throw new Error('The following environment variables were found with the "RUSH_" prefix, but they are not ' +
                `recognized by this version of Rush: ${unknownEnvVariables.join(', ')}`);
        }
        // See doc comment for EnvironmentConfiguration._getRushGlobalFolderOverride().
        EnvironmentConfiguration._rushGlobalFolderOverride =
            EnvironmentConfiguration._getRushGlobalFolderOverride(process.env);
        EnvironmentConfiguration._hasBeenValidated = true;
    }
    /**
     * Resets EnvironmentConfiguration into an un-initialized state.
     */
    static reset() {
        EnvironmentConfiguration._rushTempFolderOverride = undefined;
        EnvironmentConfiguration._hasBeenValidated = false;
    }
    static _ensureValidated() {
        if (!EnvironmentConfiguration._hasBeenValidated) {
            EnvironmentConfiguration.validate();
        }
    }
    static parseBooleanEnvironmentVariable(name, value) {
        if (value === '' || value === undefined) {
            return undefined;
        }
        else if (value === '0') {
            return false;
        }
        else if (value === '1') {
            return true;
        }
        else {
            throw new Error(`Invalid value "${value}" for the environment variable ${name}. Valid choices are 0 or 1.`);
        }
    }
    /**
     * Given a path to a folder (that may or may not exist), normalize the path, including casing,
     * to the first existing parent folder in the path.
     *
     * If no existing path can be found (for example, if the root is a volume that doesn't exist),
     * this function returns undefined.
     *
     * @example
     * If the following path exists on disk: C:\Folder1\folder2\
     * _normalizeFirstExistingFolderPath('c:\\folder1\\folder2\\temp\\subfolder')
     * returns 'C:\\Folder1\\folder2\\temp\\subfolder'
     */
    static _normalizeDeepestParentFolderPath(folderPath) {
        folderPath = path.normalize(folderPath);
        const endsWithSlash = folderPath.charAt(folderPath.length - 1) === path.sep;
        const parsedPath = path.parse(folderPath);
        const pathRoot = parsedPath.root;
        const pathWithoutRoot = parsedPath.dir.substr(pathRoot.length);
        const pathParts = [...pathWithoutRoot.split(path.sep), parsedPath.name].filter((part) => !!part);
        // Starting with all path sections, and eliminating one from the end during each loop iteration,
        // run trueCasePathSync. If trueCasePathSync returns without exception, we've found a subset
        // of the path that exists and we've now gotten the correct casing.
        //
        // Once we've found a parent folder that exists, append the path sections that didn't exist.
        for (let i = pathParts.length; i >= 0; i--) {
            const constructedPath = path.join(pathRoot, ...pathParts.slice(0, i));
            try {
                const normalizedConstructedPath = (0, true_case_path_1.trueCasePathSync)(constructedPath);
                const result = path.join(normalizedConstructedPath, ...pathParts.slice(i));
                if (endsWithSlash) {
                    return `${result}${path.sep}`;
                }
                else {
                    return result;
                }
            }
            catch (e) {
                // This path doesn't exist, continue to the next subpath
            }
        }
        return undefined;
    }
}
exports.EnvironmentConfiguration = EnvironmentConfiguration;
EnvironmentConfiguration._hasBeenValidated = false;
EnvironmentConfiguration._absoluteSymlinks = false;
EnvironmentConfiguration._allowUnsupportedNodeVersion = false;
EnvironmentConfiguration._allowWarningsInSuccessfulBuild = false;
//# sourceMappingURL=EnvironmentConfiguration.js.map

/***/ }),

/***/ 92330:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventHooks = exports.Event = void 0;
const node_core_library_1 = __webpack_require__(24019);
/**
 * Events happen during Rush runs.
 * @beta
 */
var Event;
(function (Event) {
    /**
     * Pre Rush install event
     */
    Event[Event["preRushInstall"] = 1] = "preRushInstall";
    /**
     * Post Rush install event
     */
    Event[Event["postRushInstall"] = 2] = "postRushInstall";
    /**
     * Pre Rush build event
     */
    Event[Event["preRushBuild"] = 3] = "preRushBuild";
    /**
     * Post Rush build event
     */
    Event[Event["postRushBuild"] = 4] = "postRushBuild";
})(Event = exports.Event || (exports.Event = {}));
/**
 * This class represents Rush event hooks configured for this repo.
 * Hooks are customized script actions that Rush executes when specific events occur.
 * The actions are expressed as a command-line that is executed using the operating system shell.
 * @beta
 */
class EventHooks {
    /**
     * @internal
     */
    constructor(eventHooksJson) {
        this._hooks = new Map();
        for (const [name, eventHooks] of Object.entries(eventHooksJson)) {
            const eventName = node_core_library_1.Enum.tryGetValueByKey(Event, name);
            if (eventName) {
                this._hooks.set(eventName, [...eventHooks] || []);
            }
        }
    }
    /**
     * Return all the scripts associated with the specified event.
     * @param event - Rush event
     */
    get(event) {
        return this._hooks.get(event) || [];
    }
}
exports.EventHooks = EventHooks;
//# sourceMappingURL=EventHooks.js.map

/***/ }),

/***/ 94539:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExperimentsConfiguration = void 0;
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
/**
 * Use this class to load the "common/config/rush/experiments.json" config file.
 * This file allows repo maintainers to enable and disable experimental Rush features.
 * @beta
 */
class ExperimentsConfiguration {
    /**
     * @internal
     */
    constructor(jsonFileName) {
        this._jsonFileName = jsonFileName;
        this._experimentConfiguration = {};
        if (!node_core_library_1.FileSystem.exists(this._jsonFileName)) {
            this._experimentConfiguration = {};
        }
        else {
            this._experimentConfiguration = node_core_library_1.JsonFile.loadAndValidate(this._jsonFileName, ExperimentsConfiguration._jsonSchema);
        }
    }
    /**
     * Get the experiments configuration.
     */
    get configuration() {
        return this._experimentConfiguration;
    }
}
exports.ExperimentsConfiguration = ExperimentsConfiguration;
ExperimentsConfiguration._jsonSchema = node_core_library_1.JsonSchema.fromFile(path.resolve(__dirname, '..', 'schemas', 'experiments.schema.json'));
//# sourceMappingURL=ExperimentsConfiguration.js.map

/***/ }),

/***/ 57013:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LastInstallFlagFactory = exports.LastInstallFlag = exports.LAST_INSTALL_FLAG_FILE_NAME = void 0;
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const lodash = node_core_library_1.Import.lazy('lodash', require);
exports.LAST_INSTALL_FLAG_FILE_NAME = 'last-install.flag';
/**
 * A helper class for managing last-install flags, which are persistent and
 * indicate that something installed in the folder was successfully completed.
 * It also compares state, so that if something like the Node.js version has changed,
 * it can invalidate the last install.
 * @internal
 */
class LastInstallFlag {
    /**
     * Creates a new LastInstall flag
     * @param folderPath - the folder that this flag is managing
     * @param state - optional, the state that should be managed or compared
     */
    constructor(folderPath, state = {}) {
        this._path = path.join(folderPath, this.flagName);
        this._state = state;
    }
    /**
     * Returns true if the file exists and the contents match the current state.
     */
    isValid() {
        return this._isValid(false);
    }
    /**
     * Same as isValid(), but with an additional check:  If the current state is not equal to the previous
     * state, and an the current state causes an error, then throw an exception with a friendly message.
     *
     * @internal
     */
    checkValidAndReportStoreIssues() {
        return this._isValid(true);
    }
    _isValid(checkValidAndReportStoreIssues) {
        let oldState;
        try {
            oldState = node_core_library_1.JsonFile.load(this._path);
        }
        catch (err) {
            return false;
        }
        const newState = this._state;
        if (!lodash.isEqual(oldState, newState)) {
            if (checkValidAndReportStoreIssues) {
                const pkgManager = newState.packageManager;
                if (pkgManager === 'pnpm') {
                    if (
                    // Only throw an error if the package manager hasn't changed from PNPM
                    oldState.packageManager === pkgManager &&
                        // Throw if the store path changed
                        oldState.storePath !== newState.storePath) {
                        const oldStorePath = oldState.storePath || '<global>';
                        const newStorePath = newState.storePath || '<global>';
                        throw new Error('Current PNPM store path does not match the last one used. This may cause inconsistency in your builds.\n\n' +
                            'If you wish to install with the new store path, please run "rush update --purge"\n\n' +
                            `Old Path: ${oldStorePath}\n` +
                            `New Path: ${newStorePath}`);
                    }
                }
            }
            return false;
        }
        return true;
    }
    /**
     * Writes the flag file to disk with the current state
     */
    create() {
        node_core_library_1.JsonFile.save(this._state, this._path, {
            ensureFolderExists: true
        });
    }
    /**
     * Removes the flag file
     */
    clear() {
        node_core_library_1.FileSystem.deleteFile(this._path);
    }
    /**
     * Returns the full path to the flag file
     */
    get path() {
        return this._path;
    }
    /**
     * Returns the name of the flag file
     */
    get flagName() {
        return exports.LAST_INSTALL_FLAG_FILE_NAME;
    }
}
exports.LastInstallFlag = LastInstallFlag;
/**
 * A helper class for LastInstallFlag
 *
 * @internal
 */
class LastInstallFlagFactory {
    /**
     * Gets the LastInstall flag and sets the current state. This state is used to compare
     * against the last-known-good state tracked by the LastInstall flag.
     * @param rushConfiguration - the configuration of the Rush repo to get the install
     * state from
     *
     * @internal
     */
    static getCommonTempFlag(rushConfiguration) {
        const currentState = {
            node: process.versions.node,
            packageManager: rushConfiguration.packageManager,
            packageManagerVersion: rushConfiguration.packageManagerToolVersion
        };
        if (currentState.packageManager === 'pnpm' && rushConfiguration.pnpmOptions) {
            currentState.storePath = rushConfiguration.pnpmOptions.pnpmStorePath;
            if (rushConfiguration.pnpmOptions.useWorkspaces) {
                currentState.workspaces = rushConfiguration.pnpmOptions.useWorkspaces;
            }
        }
        return new LastInstallFlag(rushConfiguration.commonTempFolder, currentState);
    }
}
exports.LastInstallFlagFactory = LastInstallFlagFactory;
//# sourceMappingURL=LastInstallFlag.js.map

/***/ }),

/***/ 10508:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LastLinkFlagFactory = exports.LastLinkFlag = exports.LAST_LINK_FLAG_FILE_NAME = void 0;
const LastInstallFlag_1 = __webpack_require__(57013);
const node_core_library_1 = __webpack_require__(24019);
exports.LAST_LINK_FLAG_FILE_NAME = 'last-link.flag';
/**
 * A helper class for managing the last-link flag, which is persistent and
 * indicates that linking was completed successfully.
 * @internal
 */
class LastLinkFlag extends LastInstallFlag_1.LastInstallFlag {
    /**
     * @override
     */
    isValid() {
        let oldState;
        try {
            oldState = node_core_library_1.JsonFile.load(this.path);
        }
        catch (err) {
            // Swallow error
        }
        return !!oldState;
    }
    /**
     * @override
     */
    checkValidAndReportStoreIssues() {
        throw new node_core_library_1.InternalError('Not implemented');
    }
    get flagName() {
        return exports.LAST_LINK_FLAG_FILE_NAME;
    }
}
exports.LastLinkFlag = LastLinkFlag;
/**
 * A helper class for LastLinkFlag
 *
 * @internal
 */
class LastLinkFlagFactory {
    /**
     * Gets the LastLink flag and sets the current state. This state is used to compare
     * against the last-known-good state tracked by the LastLink flag.
     * @param rushConfiguration - the configuration of the Rush repo to get the install
     * state from
     *
     * @internal
     */
    static getCommonTempFlag(rushConfiguration) {
        return new LastLinkFlag(rushConfiguration.commonTempFolder, {});
    }
}
exports.LastLinkFlagFactory = LastLinkFlagFactory;
//# sourceMappingURL=LastLinkFlag.js.map

/***/ }),

/***/ 32373:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageJsonEditor = exports.PackageJsonDependency = void 0;
const semver = __importStar(__webpack_require__(11383));
const node_core_library_1 = __webpack_require__(24019);
const lodash = node_core_library_1.Import.lazy('lodash', require);
/**
 * @beta
 */
class PackageJsonDependency {
    constructor(name, version, type, onChange) {
        this._name = name;
        this._version = version;
        this._type = type;
        this._onChange = onChange;
    }
    get name() {
        return this._name;
    }
    get version() {
        return this._version;
    }
    setVersion(newVersion) {
        if (!semver.valid(newVersion) && !semver.validRange(newVersion)) {
            throw new Error(`Cannot set version to invalid value: "${newVersion}"`);
        }
        this._version = newVersion;
        this._onChange();
    }
    get dependencyType() {
        return this._type;
    }
}
exports.PackageJsonDependency = PackageJsonDependency;
/**
 * @beta
 */
class PackageJsonEditor {
    constructor(filepath, data) {
        this._filePath = filepath;
        this._sourceData = data;
        this._modified = false;
        this._dependencies = new Map();
        this._devDependencies = new Map();
        this._resolutions = new Map();
        const dependencies = data.dependencies || {};
        const optionalDependencies = data.optionalDependencies || {};
        const peerDependencies = data.peerDependencies || {};
        const devDependencies = data.devDependencies || {};
        const resolutions = data.resolutions || {};
        const _onChange = this._onChange.bind(this);
        try {
            Object.keys(dependencies || {}).forEach((packageName) => {
                if (Object.prototype.hasOwnProperty.call(optionalDependencies, packageName)) {
                    throw new Error(`The package "${packageName}" cannot be listed in both ` +
                        `"dependencies" and "optionalDependencies"`);
                }
                if (Object.prototype.hasOwnProperty.call(peerDependencies, packageName)) {
                    throw new Error(`The package "${packageName}" cannot be listed in both "dependencies" and "peerDependencies"`);
                }
                this._dependencies.set(packageName, new PackageJsonDependency(packageName, dependencies[packageName], "dependencies" /* Regular */, _onChange));
            });
            Object.keys(optionalDependencies || {}).forEach((packageName) => {
                if (Object.prototype.hasOwnProperty.call(peerDependencies, packageName)) {
                    throw new Error(`The package "${packageName}" cannot be listed in both ` +
                        `"optionalDependencies" and "peerDependencies"`);
                }
                this._dependencies.set(packageName, new PackageJsonDependency(packageName, optionalDependencies[packageName], "optionalDependencies" /* Optional */, _onChange));
            });
            Object.keys(peerDependencies || {}).forEach((packageName) => {
                this._dependencies.set(packageName, new PackageJsonDependency(packageName, peerDependencies[packageName], "peerDependencies" /* Peer */, _onChange));
            });
            Object.keys(devDependencies || {}).forEach((packageName) => {
                this._devDependencies.set(packageName, new PackageJsonDependency(packageName, devDependencies[packageName], "devDependencies" /* Dev */, _onChange));
            });
            Object.keys(resolutions || {}).forEach((packageName) => {
                this._resolutions.set(packageName, new PackageJsonDependency(packageName, resolutions[packageName], "resolutions" /* YarnResolutions */, _onChange));
            });
            // (Do not sort this._resolutions because order may be significant; the RFC is unclear about that.)
            node_core_library_1.Sort.sortMapKeys(this._dependencies);
            node_core_library_1.Sort.sortMapKeys(this._devDependencies);
        }
        catch (e) {
            throw new Error(`Error loading "${filepath}": ${e.message}`);
        }
    }
    static load(filePath) {
        return new PackageJsonEditor(filePath, node_core_library_1.JsonFile.load(filePath));
    }
    static fromObject(object, filename) {
        return new PackageJsonEditor(filename, object);
    }
    get name() {
        return this._sourceData.name;
    }
    get version() {
        return this._sourceData.version;
    }
    get filePath() {
        return this._filePath;
    }
    /**
     * The list of dependencies of type DependencyType.Regular, DependencyType.Optional, or DependencyType.Peer.
     */
    get dependencyList() {
        return [...this._dependencies.values()];
    }
    /**
     * The list of dependencies of type DependencyType.Dev.
     */
    get devDependencyList() {
        return [...this._devDependencies.values()];
    }
    /**
     * This field is a Yarn-specific feature that allows overriding of package resolution.
     *
     * @remarks
     * See the {@link https://github.com/yarnpkg/rfcs/blob/master/implemented/0000-selective-versions-resolutions.md
     * | 0000-selective-versions-resolutions.md RFC} for details.
     */
    get resolutionsList() {
        return [...this._resolutions.values()];
    }
    tryGetDependency(packageName) {
        return this._dependencies.get(packageName);
    }
    tryGetDevDependency(packageName) {
        return this._devDependencies.get(packageName);
    }
    addOrUpdateDependency(packageName, newVersion, dependencyType) {
        const dependency = new PackageJsonDependency(packageName, newVersion, dependencyType, this._onChange.bind(this));
        // Rush collapses everything that isn't a devDependency into the dependencies
        // field, so we need to set the value depending on dependency type
        switch (dependencyType) {
            case "dependencies" /* Regular */:
            case "optionalDependencies" /* Optional */:
            case "peerDependencies" /* Peer */:
                this._dependencies.set(packageName, dependency);
                break;
            case "devDependencies" /* Dev */:
                this._devDependencies.set(packageName, dependency);
                break;
            case "resolutions" /* YarnResolutions */:
                this._resolutions.set(packageName, dependency);
                break;
            default:
                throw new node_core_library_1.InternalError('Unsupported DependencyType');
        }
        this._modified = true;
    }
    saveIfModified() {
        if (this._modified) {
            this._modified = false;
            this._sourceData = this._normalize(this._sourceData);
            node_core_library_1.JsonFile.save(this._sourceData, this._filePath, { updateExistingFile: true });
            return true;
        }
        return false;
    }
    /**
     * Get the normalized package.json that represents the current state of the
     * PackageJsonEditor. This method does not save any changes that were made to the
     * package.json, but instead returns the object representation of what would be saved
     * if saveIfModified() is called.
     */
    saveToObject() {
        // Only normalize if we need to
        const sourceData = this._modified ? this._normalize(this._sourceData) : this._sourceData;
        // Provide a clone to avoid reference back to the original data object
        return lodash.cloneDeep(sourceData);
    }
    _onChange() {
        this._modified = true;
    }
    /**
     * Create a normalized shallow copy of the provided package.json without modifying the
     * original. If the result of this method is being returned via a public facing method,
     * it will still need to be deep-cloned to avoid propogating changes back to the
     * original dataset.
     */
    _normalize(source) {
        const normalizedData = Object.assign({}, source);
        delete normalizedData.dependencies;
        delete normalizedData.optionalDependencies;
        delete normalizedData.peerDependencies;
        delete normalizedData.devDependencies;
        delete normalizedData.resolutions;
        const keys = [...this._dependencies.keys()].sort();
        for (const packageName of keys) {
            const dependency = this._dependencies.get(packageName);
            switch (dependency.dependencyType) {
                case "dependencies" /* Regular */:
                    if (!normalizedData.dependencies) {
                        normalizedData.dependencies = {};
                    }
                    normalizedData.dependencies[dependency.name] = dependency.version;
                    break;
                case "optionalDependencies" /* Optional */:
                    if (!normalizedData.optionalDependencies) {
                        normalizedData.optionalDependencies = {};
                    }
                    normalizedData.optionalDependencies[dependency.name] = dependency.version;
                    break;
                case "peerDependencies" /* Peer */:
                    if (!normalizedData.peerDependencies) {
                        normalizedData.peerDependencies = {};
                    }
                    normalizedData.peerDependencies[dependency.name] = dependency.version;
                    break;
                case "devDependencies" /* Dev */: // uses this._devDependencies instead
                case "resolutions" /* YarnResolutions */: // uses this._resolutions instead
                default:
                    throw new node_core_library_1.InternalError('Unsupported DependencyType');
            }
        }
        const devDependenciesKeys = [...this._devDependencies.keys()].sort();
        for (const packageName of devDependenciesKeys) {
            const dependency = this._devDependencies.get(packageName);
            if (!normalizedData.devDependencies) {
                normalizedData.devDependencies = {};
            }
            normalizedData.devDependencies[dependency.name] = dependency.version;
        }
        // (Do not sort this._resolutions because order may be significant; the RFC is unclear about that.)
        for (const packageName of this._resolutions.keys()) {
            const dependency = this._resolutions.get(packageName);
            if (!normalizedData.resolutions) {
                normalizedData.resolutions = {};
            }
            normalizedData.resolutions[dependency.name] = dependency.version;
        }
        return normalizedData;
    }
}
exports.PackageJsonEditor = PackageJsonEditor;
//# sourceMappingURL=PackageJsonEditor.js.map

/***/ }),

/***/ 39458:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageNameParsers = void 0;
const node_core_library_1 = __webpack_require__(24019);
class PackageNameParsers {
}
exports.PackageNameParsers = PackageNameParsers;
/**
 * This is the default for `RushConfiguration.packageNameParser`.
 */
PackageNameParsers.rushDefault = new node_core_library_1.PackageNameParser({});
/**
 * This is the `RushConfiguration.packageNameParser` used when `allowMostlyStandardPackageNames = true`
 * in rush.json.
 */
PackageNameParsers.mostlyStandard = new node_core_library_1.PackageNameParser({
    allowUpperCase: true
});
/**
 * Use this in contexts where we don't have easy access to `RushConfiguration.packageNameParser`
 * AND the package name was already validated at some earlier stage.
 */
PackageNameParsers.permissive = PackageNameParsers.mostlyStandard;
//# sourceMappingURL=PackageNameParsers.js.map

/***/ }),

/***/ 4876:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Rush = void 0;
const node_core_library_1 = __webpack_require__(24019);
const RushCommandLineParser_1 = __webpack_require__(4585);
const RushStartupBanner_1 = __webpack_require__(91811);
const RushXCommandLine_1 = __webpack_require__(6251);
const CommandLineMigrationAdvisor_1 = __webpack_require__(25574);
const Utilities_1 = __webpack_require__(89521);
/**
 * General operations for the Rush engine.
 *
 * @public
 */
class Rush {
    /**
     * This API is used by the `@microsoft/rush` front end to launch the "rush" command-line.
     * Third-party tools should not use this API.  Instead, they should execute the "rush" binary
     * and start a new Node.js process.
     *
     * @param launcherVersion - The version of the `@microsoft/rush` wrapper used to call invoke the CLI.
     *
     * @remarks
     * Earlier versions of the rush frontend used a different API contract. In the old contract,
     * the second argument was the `isManaged` value of the {@link ILaunchOptions} object.
     *
     * Even though this API isn't documented, it is still supported for legacy compatibility.
     */
    static launch(launcherVersion, arg) {
        const options = Rush._normalizeLaunchOptions(arg);
        if (!Utilities_1.Utilities.shouldRestrictConsoleOutput()) {
            RushStartupBanner_1.RushStartupBanner.logBanner(Rush.version, options.isManaged);
        }
        if (!CommandLineMigrationAdvisor_1.CommandLineMigrationAdvisor.checkArgv(process.argv)) {
            // The migration advisor recognized an obsolete command-line
            process.exitCode = 1;
            return;
        }
        Rush._assignRushInvokedFolder();
        const parser = new RushCommandLineParser_1.RushCommandLineParser({
            alreadyReportedNodeTooNewError: options.alreadyReportedNodeTooNewError
        });
        parser.execute().catch(console.error); // CommandLineParser.execute() should never reject the promise
    }
    /**
     * This API is used by the `@microsoft/rush` front end to launch the "rushx" command-line.
     * Third-party tools should not use this API.  Instead, they should execute the "rushx" binary
     * and start a new Node.js process.
     *
     * @param launcherVersion - The version of the `@microsoft/rush` wrapper used to call invoke the CLI.
     */
    static launchRushX(launcherVersion, options) {
        options = Rush._normalizeLaunchOptions(options);
        Rush._assignRushInvokedFolder();
        RushXCommandLine_1.RushXCommandLine._launchRushXInternal(launcherVersion, Object.assign({}, options));
    }
    /**
     * The currently executing version of the "rush-lib" library.
     * This is the same as the Rush tool version for that release.
     */
    static get version() {
        if (!this._version) {
            this._version = node_core_library_1.PackageJsonLookup.loadOwnPackageJson(__dirname).version;
        }
        return this._version;
    }
    /**
     * Assign the `RUSH_INVOKED_FOLDER` environment variable during startup.  This is only applied when
     * Rush is invoked via the CLI, not via the `@microsoft/rush-lib` automation API.
     *
     * @remarks
     * Modifying the parent process's environment is not a good design.  The better design is (1) to consolidate
     * Rush's code paths that invoke scripts, and (2) to pass down the invoked folder with each code path,
     * so that it can finally be applied in a centralized helper like `Utilities._createEnvironmentForRushCommand()`.
     * The natural time to do that refactoring is when we rework `Utilities.executeCommand()` to use
     * `Executable.spawn()` or rushell.
     */
    static _assignRushInvokedFolder() {
        process.env["RUSH_INVOKED_FOLDER" /* RUSH_INVOKED_FOLDER */] = process.cwd();
    }
    /**
     * This function normalizes legacy options to the current {@link ILaunchOptions} object.
     */
    static _normalizeLaunchOptions(arg) {
        return typeof arg === 'boolean'
            ? { isManaged: arg } // In older versions of Rush, this the `launch` functions took a boolean arg for "isManaged"
            : arg;
    }
}
exports.Rush = Rush;
Rush._version = undefined;
//# sourceMappingURL=Rush.js.map

/***/ }),

/***/ 92905:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RushConfiguration = exports.YarnOptionsConfiguration = exports.PnpmOptionsConfiguration = exports.NpmOptionsConfiguration = exports.PackageManagerOptionsConfigurationBase = void 0;
/* eslint max-lines: off */
const path = __importStar(__webpack_require__(85622));
const semver = __importStar(__webpack_require__(11383));
const node_core_library_1 = __webpack_require__(24019);
const true_case_path_1 = __webpack_require__(76979);
const Rush_1 = __webpack_require__(4876);
const RushConfigurationProject_1 = __webpack_require__(90554);
const RushConstants_1 = __webpack_require__(63985);
const ApprovedPackagesPolicy_1 = __webpack_require__(73162);
const EventHooks_1 = __webpack_require__(92330);
const VersionPolicyConfiguration_1 = __webpack_require__(6375);
const EnvironmentConfiguration_1 = __webpack_require__(84018);
const CommonVersionsConfiguration_1 = __webpack_require__(2465);
const Utilities_1 = __webpack_require__(89521);
const NpmPackageManager_1 = __webpack_require__(94980);
const YarnPackageManager_1 = __webpack_require__(44457);
const PnpmPackageManager_1 = __webpack_require__(27584);
const ExperimentsConfiguration_1 = __webpack_require__(94539);
const PackageNameParsers_1 = __webpack_require__(39458);
const RepoStateFile_1 = __webpack_require__(67213);
const LookupByPath_1 = __webpack_require__(83431);
const MINIMUM_SUPPORTED_RUSH_JSON_VERSION = '0.0.0';
const DEFAULT_BRANCH = 'master';
const DEFAULT_REMOTE = 'origin';
/**
 * A list of known config filenames that are expected to appear in the "./common/config/rush" folder.
 * To avoid confusion/mistakes, any extra files will be reported as an error.
 */
const knownRushConfigFilenames = [
    '.npmrc-publish',
    '.npmrc',
    'deploy.json',
    RushConstants_1.RushConstants.artifactoryFilename,
    RushConstants_1.RushConstants.browserApprovedPackagesFilename,
    RushConstants_1.RushConstants.buildCacheFilename,
    RushConstants_1.RushConstants.commandLineFilename,
    RushConstants_1.RushConstants.commonVersionsFilename,
    RushConstants_1.RushConstants.experimentsFilename,
    RushConstants_1.RushConstants.nonbrowserApprovedPackagesFilename,
    RushConstants_1.RushConstants.pinnedVersionsFilename,
    RushConstants_1.RushConstants.repoStateFilename,
    RushConstants_1.RushConstants.versionPoliciesFilename
];
/**
 * Options that all package managers share.
 *
 * @public
 */
class PackageManagerOptionsConfigurationBase {
    /** @internal */
    constructor(json) {
        this.environmentVariables = json.environmentVariables;
    }
}
exports.PackageManagerOptionsConfigurationBase = PackageManagerOptionsConfigurationBase;
/**
 * Options that are only used when the NPM package manager is selected.
 *
 * @remarks
 * It is valid to define these options in rush.json even if the NPM package manager
 * is not being used.
 *
 * @public
 */
class NpmOptionsConfiguration extends PackageManagerOptionsConfigurationBase {
    /** @internal */
    constructor(json) {
        super(json);
    }
}
exports.NpmOptionsConfiguration = NpmOptionsConfiguration;
/**
 * Options that are only used when the PNPM package manager is selected.
 *
 * @remarks
 * It is valid to define these options in rush.json even if the PNPM package manager
 * is not being used.
 *
 * @public
 */
class PnpmOptionsConfiguration extends PackageManagerOptionsConfigurationBase {
    /** @internal */
    constructor(json, commonTempFolder) {
        super(json);
        this.pnpmStore = json.pnpmStore || 'local';
        if (EnvironmentConfiguration_1.EnvironmentConfiguration.pnpmStorePathOverride) {
            this.pnpmStorePath = EnvironmentConfiguration_1.EnvironmentConfiguration.pnpmStorePathOverride;
        }
        else if (this.pnpmStore === 'global') {
            this.pnpmStorePath = '';
        }
        else {
            this.pnpmStorePath = path.resolve(path.join(commonTempFolder, 'pnpm-store'));
        }
        this.strictPeerDependencies = !!json.strictPeerDependencies;
        this.preventManualShrinkwrapChanges = !!json.preventManualShrinkwrapChanges;
        this.useWorkspaces = !!json.useWorkspaces;
    }
}
exports.PnpmOptionsConfiguration = PnpmOptionsConfiguration;
/**
 * Options that are only used when the yarn package manager is selected.
 *
 * @remarks
 * It is valid to define these options in rush.json even if the yarn package manager
 * is not being used.
 *
 * @public
 */
class YarnOptionsConfiguration extends PackageManagerOptionsConfigurationBase {
    /** @internal */
    constructor(json) {
        super(json);
        this.ignoreEngines = !!json.ignoreEngines;
    }
}
exports.YarnOptionsConfiguration = YarnOptionsConfiguration;
/**
 * This represents the Rush configuration for a repository, based on the "rush.json"
 * configuration file.
 * @public
 */
class RushConfiguration {
    /**
     * Use RushConfiguration.loadFromConfigurationFile() or Use RushConfiguration.loadFromDefaultLocation()
     * instead.
     */
    constructor(rushConfigurationJson, rushJsonFilename) {
        this._rushConfigurationJson = rushConfigurationJson;
        EnvironmentConfiguration_1.EnvironmentConfiguration.validate();
        if (rushConfigurationJson.nodeSupportedVersionRange) {
            if (!semver.validRange(rushConfigurationJson.nodeSupportedVersionRange)) {
                throw new Error('Error parsing the node-semver expression in the "nodeSupportedVersionRange"' +
                    ` field from rush.json: "${rushConfigurationJson.nodeSupportedVersionRange}"`);
            }
            if (!semver.satisfies(process.version, rushConfigurationJson.nodeSupportedVersionRange)) {
                const message = `Your dev environment is running Node.js version ${process.version} which does` +
                    ` not meet the requirements for building this repository.  (The rush.json configuration` +
                    ` requires nodeSupportedVersionRange="${rushConfigurationJson.nodeSupportedVersionRange}")`;
                if (EnvironmentConfiguration_1.EnvironmentConfiguration.allowUnsupportedNodeVersion) {
                    console.warn(message);
                }
                else {
                    throw new Error(message);
                }
            }
        }
        this._rushJsonFile = rushJsonFilename;
        this._rushJsonFolder = path.dirname(rushJsonFilename);
        this._commonFolder = path.resolve(path.join(this._rushJsonFolder, RushConstants_1.RushConstants.commonFolderName));
        this._commonRushConfigFolder = path.join(this._commonFolder, 'config', 'rush');
        this._commonTempFolder =
            EnvironmentConfiguration_1.EnvironmentConfiguration.rushTempFolderOverride ||
                path.join(this._commonFolder, RushConstants_1.RushConstants.rushTempFolderName);
        this._commonScriptsFolder = path.join(this._commonFolder, 'scripts');
        this._npmCacheFolder = path.resolve(path.join(this._commonTempFolder, 'npm-cache'));
        this._npmTmpFolder = path.resolve(path.join(this._commonTempFolder, 'npm-tmp'));
        this._yarnCacheFolder = path.resolve(path.join(this._commonTempFolder, 'yarn-cache'));
        this._changesFolder = path.join(this._commonFolder, RushConstants_1.RushConstants.changeFilesFolderName);
        this._currentVariantJsonFilename = path.join(this._commonTempFolder, 'current-variant.json');
        this._suppressNodeLtsWarning = !!rushConfigurationJson.suppressNodeLtsWarning;
        this._ensureConsistentVersions = !!rushConfigurationJson.ensureConsistentVersions;
        const experimentsConfigFile = path.join(this._commonRushConfigFolder, RushConstants_1.RushConstants.experimentsFilename);
        this._experimentsConfiguration = new ExperimentsConfiguration_1.ExperimentsConfiguration(experimentsConfigFile);
        this._npmOptions = new NpmOptionsConfiguration(rushConfigurationJson.npmOptions || {});
        this._pnpmOptions = new PnpmOptionsConfiguration(rushConfigurationJson.pnpmOptions || {}, this._commonTempFolder);
        this._yarnOptions = new YarnOptionsConfiguration(rushConfigurationJson.yarnOptions || {});
        // TODO: Add an actual "packageManager" field in rush.json
        const packageManagerFields = [];
        if (rushConfigurationJson.npmVersion) {
            this._packageManager = 'npm';
            this._packageManagerConfigurationOptions = this._npmOptions;
            packageManagerFields.push('npmVersion');
        }
        if (rushConfigurationJson.pnpmVersion) {
            this._packageManager = 'pnpm';
            this._packageManagerConfigurationOptions = this._pnpmOptions;
            packageManagerFields.push('pnpmVersion');
        }
        if (rushConfigurationJson.yarnVersion) {
            this._packageManager = 'yarn';
            this._packageManagerConfigurationOptions = this._yarnOptions;
            packageManagerFields.push('yarnVersion');
        }
        if (packageManagerFields.length === 0) {
            throw new Error(`The rush.json configuration must specify one of: npmVersion, pnpmVersion, or yarnVersion`);
        }
        if (packageManagerFields.length > 1) {
            throw new Error(`The rush.json configuration cannot specify both ${packageManagerFields[0]}` +
                ` and ${packageManagerFields[1]} `);
        }
        if (this._packageManager === 'npm') {
            this._packageManagerToolVersion = rushConfigurationJson.npmVersion;
            this._packageManagerWrapper = new NpmPackageManager_1.NpmPackageManager(this._packageManagerToolVersion);
        }
        else if (this._packageManager === 'pnpm') {
            this._packageManagerToolVersion = rushConfigurationJson.pnpmVersion;
            this._packageManagerWrapper = new PnpmPackageManager_1.PnpmPackageManager(this._packageManagerToolVersion);
        }
        else {
            this._packageManagerToolVersion = rushConfigurationJson.yarnVersion;
            this._packageManagerWrapper = new YarnPackageManager_1.YarnPackageManager(this._packageManagerToolVersion);
        }
        this._shrinkwrapFilename = this._packageManagerWrapper.shrinkwrapFilename;
        this._tempShrinkwrapFilename = path.join(this._commonTempFolder, this._shrinkwrapFilename);
        this._packageManagerToolFilename = path.resolve(path.join(this._commonTempFolder, `${this.packageManager}-local`, 'node_modules', '.bin', `${this.packageManager}`));
        /// From "C:\repo\common\temp\pnpm-lock.yaml" --> "C:\repo\common\temp\pnpm-lock-preinstall.yaml"
        const parsedPath = path.parse(this._tempShrinkwrapFilename);
        this._tempShrinkwrapPreinstallFilename = path.join(parsedPath.dir, parsedPath.name + '-preinstall' + parsedPath.ext);
        RushConfiguration._validateCommonRushConfigFolder(this._commonRushConfigFolder, this._packageManagerWrapper, this._experimentsConfiguration);
        this._projectFolderMinDepth =
            rushConfigurationJson.projectFolderMinDepth !== undefined
                ? rushConfigurationJson.projectFolderMinDepth
                : 1;
        if (this._projectFolderMinDepth < 1) {
            throw new Error('Invalid projectFolderMinDepth; the minimum possible value is 1');
        }
        this._projectFolderMaxDepth =
            rushConfigurationJson.projectFolderMaxDepth !== undefined
                ? rushConfigurationJson.projectFolderMaxDepth
                : 2;
        if (this._projectFolderMaxDepth < this._projectFolderMinDepth) {
            throw new Error('The projectFolderMaxDepth cannot be smaller than the projectFolderMinDepth');
        }
        this._allowMostlyStandardPackageNames = !!rushConfigurationJson.allowMostlyStandardPackageNames;
        this._packageNameParser = this._allowMostlyStandardPackageNames
            ? PackageNameParsers_1.PackageNameParsers.mostlyStandard
            : PackageNameParsers_1.PackageNameParsers.rushDefault;
        this._approvedPackagesPolicy = new ApprovedPackagesPolicy_1.ApprovedPackagesPolicy(this, rushConfigurationJson);
        this._gitAllowedEmailRegExps = [];
        this._gitSampleEmail = '';
        if (rushConfigurationJson.gitPolicy) {
            if (rushConfigurationJson.gitPolicy.sampleEmail) {
                this._gitSampleEmail = rushConfigurationJson.gitPolicy.sampleEmail;
            }
            if (rushConfigurationJson.gitPolicy.allowedEmailRegExps) {
                this._gitAllowedEmailRegExps = rushConfigurationJson.gitPolicy.allowedEmailRegExps;
                if (this._gitSampleEmail.trim().length < 1) {
                    throw new Error('The rush.json file is missing the "sampleEmail" option, ' +
                        'which is required when using "allowedEmailRegExps"');
                }
            }
            if (rushConfigurationJson.gitPolicy.versionBumpCommitMessage) {
                this._gitVersionBumpCommitMessage = rushConfigurationJson.gitPolicy.versionBumpCommitMessage;
            }
            if (rushConfigurationJson.gitPolicy.changeLogUpdateCommitMessage) {
                this._gitChangeLogUpdateCommitMessage = rushConfigurationJson.gitPolicy.changeLogUpdateCommitMessage;
            }
            if (rushConfigurationJson.gitPolicy.tagSeparator) {
                this._gitTagSeparator = rushConfigurationJson.gitPolicy.tagSeparator;
            }
        }
        this._hotfixChangeEnabled = false;
        if (rushConfigurationJson.hotfixChangeEnabled) {
            this._hotfixChangeEnabled = rushConfigurationJson.hotfixChangeEnabled;
        }
        if (!rushConfigurationJson.repository) {
            rushConfigurationJson.repository = {};
        }
        this._repositoryUrl = rushConfigurationJson.repository.url;
        this._repositoryDefaultBranch = rushConfigurationJson.repository.defaultBranch || DEFAULT_BRANCH;
        this._repositoryDefaultRemote = rushConfigurationJson.repository.defaultRemote || DEFAULT_REMOTE;
        this._telemetryEnabled = !!rushConfigurationJson.telemetryEnabled;
        this._eventHooks = new EventHooks_1.EventHooks(rushConfigurationJson.eventHooks || {});
        this._versionPolicyConfigurationFilePath = path.join(this._commonRushConfigFolder, RushConstants_1.RushConstants.versionPoliciesFilename);
        this._versionPolicyConfiguration = new VersionPolicyConfiguration_1.VersionPolicyConfiguration(this._versionPolicyConfigurationFilePath);
        this._variants = new Set();
        if (rushConfigurationJson.variants) {
            for (const variantOptions of rushConfigurationJson.variants) {
                const { variantName } = variantOptions;
                if (this._variants.has(variantName)) {
                    throw new Error(`Duplicate variant named '${variantName}' specified in configuration.`);
                }
                this._variants.add(variantName);
            }
        }
        const pathTree = new LookupByPath_1.LookupByPath();
        for (const project of this.projects) {
            const relativePath = node_core_library_1.Path.convertToSlashes(project.projectRelativeFolder);
            pathTree.setItem(relativePath, project);
        }
        this._projectByRelativePath = pathTree;
    }
    _initializeAndValidateLocalProjects() {
        this._projects = [];
        this._projectsByName = new Map();
        // We sort the projects array in alphabetical order.  This ensures that the packages
        // are processed in a deterministic order by the various Rush algorithms.
        const sortedProjectJsons = this._rushConfigurationJson.projects.slice(0);
        sortedProjectJsons.sort((a, b) => a.packageName.localeCompare(b.packageName));
        const tempNamesByProject = RushConfiguration._generateTempNamesForProjects(sortedProjectJsons);
        for (const projectJson of sortedProjectJsons) {
            const tempProjectName = tempNamesByProject.get(projectJson);
            if (tempProjectName) {
                const project = new RushConfigurationProject_1.RushConfigurationProject(projectJson, this, tempProjectName);
                this._projects.push(project);
                if (this._projectsByName.has(project.packageName)) {
                    throw new Error(`The project name "${project.packageName}" was specified more than once` +
                        ` in the rush.json configuration file.`);
                }
                this._projectsByName.set(project.packageName, project);
            }
        }
        for (const project of this._projects) {
            project.cyclicDependencyProjects.forEach((cyclicDependencyProject) => {
                if (!this.getProjectByName(cyclicDependencyProject)) {
                    throw new Error(`In rush.json, the "${cyclicDependencyProject}" project does not exist,` +
                        ` but was referenced by the cyclicDependencyProjects for ${project.packageName}`);
                }
            });
            // Compute the downstream dependencies within the list of Rush projects.
            this._populateDownstreamDependencies(project.packageJson.dependencies, project.packageName);
            this._populateDownstreamDependencies(project.packageJson.devDependencies, project.packageName);
            this._populateDownstreamDependencies(project.packageJson.optionalDependencies, project.packageName);
            this._versionPolicyConfiguration.validate(this.projectsByName);
        }
    }
    /**
     * Loads the configuration data from an Rush.json configuration file and returns
     * an RushConfiguration object.
     */
    static loadFromConfigurationFile(rushJsonFilename) {
        let resolvedRushJsonFilename = path.resolve(rushJsonFilename);
        // Load the rush.json before we fix the casing. If the case is wrong on a case-sensitive filesystem,
        // the next line show throw.
        const rushConfigurationJson = node_core_library_1.JsonFile.load(resolvedRushJsonFilename);
        try {
            resolvedRushJsonFilename = (0, true_case_path_1.trueCasePathSync)(resolvedRushJsonFilename);
        }
        catch (error) {
            /* ignore errors from true-case-path */
        }
        // Check the Rush version *before* we validate the schema, since if the version is outdated
        // then the schema may have changed. This should no longer be a problem after Rush 4.0 and the C2R wrapper,
        // but we'll validate anyway.
        const expectedRushVersion = rushConfigurationJson.rushVersion;
        const rushJsonBaseName = path.basename(resolvedRushJsonFilename);
        // If the version is missing or malformed, fall through and let the schema handle it.
        if (expectedRushVersion && semver.valid(expectedRushVersion)) {
            // Make sure the requested version isn't too old
            if (semver.lt(expectedRushVersion, MINIMUM_SUPPORTED_RUSH_JSON_VERSION)) {
                throw new Error(`${rushJsonBaseName} is version ${expectedRushVersion}, which is too old for this tool. ` +
                    `The minimum supported version is ${MINIMUM_SUPPORTED_RUSH_JSON_VERSION}.`);
            }
            // Make sure the requested version isn't too new.
            //
            // If the major/minor versions are the same, then we consider the file to be compatible.
            // This is somewhat lax, e.g. "5.0.2-dev.3" will be assumed to be loadable by rush-lib 5.0.0.
            //
            // IMPORTANT: Whenever a breaking change is introduced for one of the config files, we must
            // increment the minor version number for Rush.
            if (semver.major(Rush_1.Rush.version) !== semver.major(expectedRushVersion) ||
                semver.minor(Rush_1.Rush.version) !== semver.minor(expectedRushVersion)) {
                // If the major/minor are different, then make sure it's an older version.
                if (semver.lt(Rush_1.Rush.version, expectedRushVersion)) {
                    throw new Error(`Unable to load ${rushJsonBaseName} because its RushVersion is` +
                        ` ${rushConfigurationJson.rushVersion}, whereas @microsoft/rush-lib is version ${Rush_1.Rush.version}.` +
                        ` Consider upgrading the library.`);
                }
            }
        }
        RushConfiguration._jsonSchema.validateObject(rushConfigurationJson, resolvedRushJsonFilename);
        return new RushConfiguration(rushConfigurationJson, resolvedRushJsonFilename);
    }
    static loadFromDefaultLocation(options) {
        const rushJsonLocation = RushConfiguration.tryFindRushJsonLocation(options);
        if (rushJsonLocation) {
            return RushConfiguration.loadFromConfigurationFile(rushJsonLocation);
        }
        else {
            throw Utilities_1.Utilities.getRushConfigNotFoundError();
        }
    }
    /**
     * Find the rush.json location and return the path, or undefined if a rush.json can't be found.
     */
    static tryFindRushJsonLocation(options) {
        const optionsIn = options || {};
        const verbose = optionsIn.showVerbose || false;
        let currentFolder = optionsIn.startingFolder || process.cwd();
        // Look upwards at parent folders until we find a folder containing rush.json
        for (let i = 0; i < 10; ++i) {
            const rushJsonFilename = path.join(currentFolder, 'rush.json');
            if (node_core_library_1.FileSystem.exists(rushJsonFilename)) {
                if (i > 0 && verbose) {
                    console.log('Found configuration in ' + rushJsonFilename);
                }
                if (verbose) {
                    console.log('');
                }
                return rushJsonFilename;
            }
            const parentFolder = path.dirname(currentFolder);
            if (parentFolder === currentFolder) {
                break;
            }
            currentFolder = parentFolder;
        }
        return undefined;
    }
    /**
     * This generates the unique names that are used to create temporary projects
     * in the Rush common folder.
     * NOTE: sortedProjectJsons is sorted by the caller.
     */
    static _generateTempNamesForProjects(sortedProjectJsons) {
        const tempNamesByProject = new Map();
        const usedTempNames = new Set();
        // NOTE: projectJsons was already sorted in alphabetical order by the caller.
        for (const projectJson of sortedProjectJsons) {
            // If the name is "@ms/MyProject", extract the "MyProject" part
            const unscopedName = PackageNameParsers_1.PackageNameParsers.permissive.getUnscopedName(projectJson.packageName);
            // Generate a unique like name "@rush-temp/MyProject", or "@rush-temp/MyProject-2" if
            // there is a naming conflict
            let counter = 0;
            let tempProjectName = `${RushConstants_1.RushConstants.rushTempNpmScope}/${unscopedName}`;
            while (usedTempNames.has(tempProjectName)) {
                ++counter;
                tempProjectName = `${RushConstants_1.RushConstants.rushTempNpmScope}/${unscopedName}-${counter}`;
            }
            usedTempNames.add(tempProjectName);
            tempNamesByProject.set(projectJson, tempProjectName);
        }
        return tempNamesByProject;
    }
    /**
     * If someone adds a config file in the "common/rush/config" folder, it would be a bad
     * experience for Rush to silently ignore their file simply because they misspelled the
     * filename, or maybe it's an old format that's no longer supported.  The
     * _validateCommonRushConfigFolder() function makes sure that this folder only contains
     * recognized config files.
     */
    static _validateCommonRushConfigFolder(commonRushConfigFolder, packageManagerWrapper, experiments) {
        if (!node_core_library_1.FileSystem.exists(commonRushConfigFolder)) {
            console.log(`Creating folder: ${commonRushConfigFolder}`);
            node_core_library_1.FileSystem.ensureFolder(commonRushConfigFolder);
            return;
        }
        for (const filename of node_core_library_1.FileSystem.readFolder(commonRushConfigFolder)) {
            // Ignore things that aren't actual files
            const stat = node_core_library_1.FileSystem.getLinkStatistics(path.join(commonRushConfigFolder, filename));
            if (!stat.isFile() && !stat.isSymbolicLink()) {
                continue;
            }
            // Ignore harmless file extensions
            const fileExtension = path.extname(filename);
            if (['.bak', '.disabled', '.md', '.old', '.orig'].indexOf(fileExtension) >= 0) {
                continue;
            }
            // Ignore hidden files such as ".DS_Store"
            if (filename.startsWith('.')) {
                continue;
            }
            if (filename.startsWith('deploy-') && fileExtension === '.json') {
                // Ignore "rush deploy" files, which use the naming pattern "deploy-<scenario-name>.json".
                continue;
            }
            const knownSet = new Set(knownRushConfigFilenames.map((x) => x.toUpperCase()));
            // Add the shrinkwrap filename for the package manager to the known set.
            knownSet.add(packageManagerWrapper.shrinkwrapFilename.toUpperCase());
            // If the package manager is pnpm, then also add the pnpm file to the known set.
            if (packageManagerWrapper.packageManager === 'pnpm') {
                knownSet.add(packageManagerWrapper.pnpmfileFilename.toUpperCase());
            }
            // Is the filename something we know?  If not, report an error.
            if (!knownSet.has(filename.toUpperCase())) {
                throw new Error(`An unrecognized file "${filename}" was found in the Rush config folder:` +
                    ` ${commonRushConfigFolder}`);
            }
        }
        const pinnedVersionsFilename = path.join(commonRushConfigFolder, RushConstants_1.RushConstants.pinnedVersionsFilename);
        if (node_core_library_1.FileSystem.exists(pinnedVersionsFilename)) {
            throw new Error('The "pinned-versions.json" config file is no longer supported;' +
                ' please move your settings to the "preferredVersions" field of a "common-versions.json" config file.' +
                ` (See the ${RushConstants_1.RushConstants.rushWebSiteUrl} documentation for details.)\n\n` +
                pinnedVersionsFilename);
        }
    }
    /**
     * The name of the package manager being used to install dependencies
     */
    get packageManager() {
        return this._packageManager;
    }
    /**
     * {@inheritdoc PackageManager}
     *
     * @privateremarks
     * In the next major breaking API change, we will rename this property to "packageManager" and eliminate the
     * old property with that name.
     *
     * @beta
     */
    get packageManagerWrapper() {
        return this._packageManagerWrapper;
    }
    /**
     * Gets the JSON data structure for the "rush.json" configuration file.
     *
     * @internal
     */
    get rushConfigurationJson() {
        return this._rushConfigurationJson;
    }
    /**
     * The absolute path to the "rush.json" configuration file that was loaded to construct this object.
     */
    get rushJsonFile() {
        return this._rushJsonFile;
    }
    /**
     * The absolute path of the folder that contains rush.json for this project.
     */
    get rushJsonFolder() {
        return this._rushJsonFolder;
    }
    /**
     * The folder that contains all change files.
     */
    get changesFolder() {
        return this._changesFolder;
    }
    /**
     * The fully resolved path for the "common" folder where Rush will store settings that
     * affect all Rush projects.  This is always a subfolder of the folder containing "rush.json".
     * Example: `C:\MyRepo\common`
     */
    get commonFolder() {
        return this._commonFolder;
    }
    /**
     * The folder where Rush's additional config files are stored.  This folder is always a
     * subfolder called `config\rush` inside the common folder.  (The `common\config` folder
     * is reserved for configuration files used by other tools.)  To avoid confusion or mistakes,
     * Rush will report an error if this this folder contains any unrecognized files.
     *
     * Example: `C:\MyRepo\common\config\rush`
     */
    get commonRushConfigFolder() {
        return this._commonRushConfigFolder;
    }
    /**
     * The folder where temporary files will be stored.  This is always a subfolder called "temp"
     * under the common folder.
     * Example: `C:\MyRepo\common\temp`
     */
    get commonTempFolder() {
        return this._commonTempFolder;
    }
    /**
     * The folder where automation scripts are stored.  This is always a subfolder called "scripts"
     * under the common folder.
     * Example: `C:\MyRepo\common\scripts`
     */
    get commonScriptsFolder() {
        return this._commonScriptsFolder;
    }
    /**
     * The fully resolved path for the "autoinstallers" folder.
     * Example: `C:\MyRepo\common\autoinstallers`
     */
    get commonAutoinstallersFolder() {
        return path.join(this._commonFolder, 'autoinstallers');
    }
    /**
     * The local folder that will store the NPM package cache.  Rush does not rely on the
     * npm's default global cache folder, because npm's caching implementation does not
     * reliably handle multiple processes.  (For example, if a build box is running
     * "rush install" simultaneously for two different working folders, it may fail randomly.)
     *
     * Example: `C:\MyRepo\common\temp\npm-cache`
     */
    get npmCacheFolder() {
        return this._npmCacheFolder;
    }
    /**
     * The local folder where npm's temporary files will be written during installation.
     * Rush does not rely on the global default folder, because it may be on a different
     * hard disk.
     *
     * Example: `C:\MyRepo\common\temp\npm-tmp`
     */
    get npmTmpFolder() {
        return this._npmTmpFolder;
    }
    /**
     * The local folder that will store the Yarn package cache.
     *
     * Example: `C:\MyRepo\common\temp\yarn-cache`
     */
    get yarnCacheFolder() {
        return this._yarnCacheFolder;
    }
    /**
     * The full path of the shrinkwrap file that is tracked by Git.  (The "rush install"
     * command uses a temporary copy, whose path is tempShrinkwrapFilename.)
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: `C:\MyRepo\common\npm-shrinkwrap.json` or `C:\MyRepo\common\pnpm-lock.yaml`
     *
     * @deprecated Use `getCommittedShrinkwrapFilename` instead, which gets the correct common
     * shrinkwrap file name for a given active variant.
     */
    get committedShrinkwrapFilename() {
        return this.getCommittedShrinkwrapFilename();
    }
    /**
     * The filename (without any path) of the shrinkwrap file that is used by the package manager.
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: `npm-shrinkwrap.json` or `pnpm-lock.yaml`
     */
    get shrinkwrapFilename() {
        return this._shrinkwrapFilename;
    }
    /**
     * The full path of the temporary shrinkwrap file that is used during "rush install".
     * This file may get rewritten by the package manager during installation.
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: `C:\MyRepo\common\temp\npm-shrinkwrap.json` or `C:\MyRepo\common\temp\pnpm-lock.yaml`
     */
    get tempShrinkwrapFilename() {
        return this._tempShrinkwrapFilename;
    }
    /**
     * The full path of a backup copy of tempShrinkwrapFilename. This backup copy is made
     * before installation begins, and can be compared to determine how the package manager
     * modified tempShrinkwrapFilename.
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: `C:\MyRepo\common\temp\npm-shrinkwrap-preinstall.json`
     * or `C:\MyRepo\common\temp\pnpm-lock-preinstall.yaml`
     */
    get tempShrinkwrapPreinstallFilename() {
        return this._tempShrinkwrapPreinstallFilename;
    }
    /**
     * Returns an English phrase such as "shrinkwrap file" that can be used in logging messages
     * to refer to the shrinkwrap file using appropriate terminology for the currently selected
     * package manager.
     */
    get shrinkwrapFilePhrase() {
        if (this._packageManager === 'yarn') {
            // Eventually we'd like to be consistent with Yarn's terminology of calling this a "lock file",
            // but a lot of Rush documentation uses "shrinkwrap" file and would all need to be updated.
            return 'shrinkwrap file (yarn.lock)';
        }
        else {
            return 'shrinkwrap file';
        }
    }
    /**
     * The filename of the build dependency data file.  By default this is
     * called 'rush-link.json' resides in the Rush common folder.
     * Its data structure is defined by IRushLinkJson.
     *
     * Example: `C:\MyRepo\common\temp\rush-link.json`
     *
     * @deprecated The "rush-link.json" file was removed in Rush 5.30.0.
     * Use `RushConfigurationProject.localDependencyProjects` instead.
     */
    get rushLinkJsonFilename() {
        throw new Error('The "rush-link.json" file was removed in Rush 5.30.0. Use ' +
            'RushConfigurationProject.localDependencyProjects instead.');
    }
    /**
     * The filename of the variant dependency data file.  By default this is
     * called 'current-variant.json' resides in the Rush common folder.
     * Its data structure is defined by ICurrentVariantJson.
     *
     * Example: `C:\MyRepo\common\temp\current-variant.json`
     */
    get currentVariantJsonFilename() {
        return this._currentVariantJsonFilename;
    }
    /**
     * The version of the locally installed NPM tool.  (Example: "1.2.3")
     */
    get packageManagerToolVersion() {
        return this._packageManagerToolVersion;
    }
    /**
     * The absolute path to the locally installed NPM tool.  If "rush install" has not
     * been run, then this file may not exist yet.
     * Example: `C:\MyRepo\common\temp\npm-local\node_modules\.bin\npm`
     */
    get packageManagerToolFilename() {
        return this._packageManagerToolFilename;
    }
    /**
     * The minimum allowable folder depth for the projectFolder field in the rush.json file.
     * This setting provides a way for repository maintainers to discourage nesting of project folders
     * that makes the directory tree more difficult to navigate.  The default value is 2,
     * which implements a standard 2-level hierarchy of <categoryFolder>/<projectFolder>/package.json.
     */
    get projectFolderMinDepth() {
        return this._projectFolderMinDepth;
    }
    /**
     * The maximum allowable folder depth for the projectFolder field in the rush.json file.
     * This setting provides a way for repository maintainers to discourage nesting of project folders
     * that makes the directory tree more difficult to navigate.  The default value is 2,
     * which implements on a standard convention of <categoryFolder>/<projectFolder>/package.json.
     */
    get projectFolderMaxDepth() {
        return this._projectFolderMaxDepth;
    }
    /**
     * Today the npmjs.com registry enforces fairly strict naming rules for packages, but in the early
     * days there was no standard and hardly any enforcement.  A few large legacy projects are still using
     * nonstandard package names, and private registries sometimes allow it.  Set "allowMostlyStandardPackageNames"
     * to true to relax Rush's enforcement of package names.  This allows upper case letters and in the future may
     * relax other rules, however we want to minimize these exceptions.  Many popular tools use certain punctuation
     * characters as delimiters, based on the assumption that they will never appear in a package name; thus if we relax
     * the rules too much it is likely to cause very confusing malfunctions.
     *
     * The default value is false.
     */
    get allowMostlyStandardPackageNames() {
        return this._allowMostlyStandardPackageNames;
    }
    /**
     * The "approvedPackagesPolicy" settings.
     */
    get approvedPackagesPolicy() {
        return this._approvedPackagesPolicy;
    }
    /**
     * [Part of the "gitPolicy" feature.]
     * A list of regular expressions describing allowable email patterns for Git commits.
     * They are case-insensitive anchored JavaScript RegExps.
     * Example: `".*@example\.com"`
     * This array will never be undefined.
     */
    get gitAllowedEmailRegExps() {
        return this._gitAllowedEmailRegExps;
    }
    /**
     * [Part of the "gitPolicy" feature.]
     * An example valid email address that conforms to one of the allowedEmailRegExps.
     * Example: `"foxtrot@example\.com"`
     * This will never be undefined, and will always be nonempty if gitAllowedEmailRegExps is used.
     */
    get gitSampleEmail() {
        return this._gitSampleEmail;
    }
    /**
     * [Part of the "gitPolicy" feature.]
     * The commit message to use when committing changes during 'rush publish'
     */
    get gitVersionBumpCommitMessage() {
        return this._gitVersionBumpCommitMessage;
    }
    /**
     * [Part of the "gitPolicy" feature.]
     * The commit message to use when committing change log files 'rush version'
     */
    get gitChangeLogUpdateCommitMessage() {
        return this._gitChangeLogUpdateCommitMessage;
    }
    /**
     * [Part of the "gitPolicy" feature.]
     * The separator between package name and version in git tag.
     */
    get gitTagSeparator() {
        return this._gitTagSeparator;
    }
    /**
     * [Part of the "hotfixChange" feature.]
     * Enables creating hotfix changes
     */
    get hotfixChangeEnabled() {
        return this._hotfixChangeEnabled;
    }
    /**
     * The remote url of the repository. This helps "rush change" find the right remote to compare against.
     */
    get repositoryUrl() {
        return this._repositoryUrl;
    }
    /**
     * The default branch name. This tells "rush change" which remote branch to compare against.
     */
    get repositoryDefaultBranch() {
        return this._repositoryDefaultBranch;
    }
    /**
     * The default remote. This tells "rush change" which remote to compare against if the remote URL is not set
     * or if a remote matching the provided remote URL is not found.
     */
    get repositoryDefaultRemote() {
        return this._repositoryDefaultRemote;
    }
    /**
     * The default fully-qualified git remote branch of the repository. This helps "rush change" find the right branch to compare against.
     */
    get repositoryDefaultFullyQualifiedRemoteBranch() {
        return `${this.repositoryDefaultRemote}/${this.repositoryDefaultBranch}`;
    }
    /**
     * Odd-numbered major versions of Node.js are experimental.  Even-numbered releases
     * spend six months in a stabilization period before the first Long Term Support (LTS) version.
     * For example, 8.9.0 was the first LTS version of Node.js 8.  Pre-LTS versions are not recommended
     * for production usage because they frequently have bugs.  They may cause Rush itself
     * to malfunction.
     *
     * Rush normally prints a warning if it detects a pre-LTS Node.js version.  If you are testing
     * pre-LTS versions in preparation for supporting the first LTS version, you can use this setting
     * to disable Rush's warning.
     */
    get suppressNodeLtsWarning() {
        return this._suppressNodeLtsWarning;
    }
    /**
     * If true, then consistent version specifiers for dependencies will be enforced.
     * I.e. "rush check" is run before some commands.
     */
    get ensureConsistentVersions() {
        return this._ensureConsistentVersions;
    }
    /**
     * Indicates whether telemetry collection is enabled for Rush runs.
     * @beta
     */
    get telemetryEnabled() {
        return this._telemetryEnabled;
    }
    get projects() {
        if (!this._projects) {
            this._initializeAndValidateLocalProjects();
        }
        return this._projects;
    }
    get projectsByName() {
        if (!this._projectsByName) {
            this._initializeAndValidateLocalProjects();
        }
        return this._projectsByName;
    }
    /**
     * {@inheritDoc NpmOptionsConfiguration}
     */
    get npmOptions() {
        return this._npmOptions;
    }
    /**
     * {@inheritDoc PnpmOptionsConfiguration}
     */
    get pnpmOptions() {
        return this._pnpmOptions;
    }
    /**
     * {@inheritDoc YarnOptionsConfiguration}
     */
    get yarnOptions() {
        return this._yarnOptions;
    }
    /**
     * The configuration options used by the current package manager.
     * @remarks
     * For package manager specific variants, reference {@link RushConfiguration.npmOptions | npmOptions},
     * {@link RushConfiguration.pnpmOptions | pnpmOptions}, or {@link RushConfiguration.yarnOptions | yarnOptions}.
     */
    get packageManagerOptions() {
        return this._packageManagerConfigurationOptions;
    }
    /**
     * Settings from the common-versions.json config file.
     * @remarks
     * If the common-versions.json file is missing, this property will not be undefined.
     * Instead it will be initialized in an empty state, and calling CommonVersionsConfiguration.save()
     * will create the file.
     *
     * @deprecated Use `getCommonVersions` instead, which gets the correct common version data
     * for a given active variant.
     */
    get commonVersions() {
        return this.getCommonVersions();
    }
    /**
     * Gets the currently-installed variant, if an installation has occurred.
     * For Rush operations which do not take a --variant parameter, this method
     * determines which variant, if any, was last specified when performing "rush install"
     * or "rush update".
     */
    get currentInstalledVariant() {
        let variant;
        if (node_core_library_1.FileSystem.exists(this._currentVariantJsonFilename)) {
            const currentVariantJson = node_core_library_1.JsonFile.load(this._currentVariantJsonFilename);
            variant = currentVariantJson.variant || undefined;
        }
        return variant;
    }
    /**
     * The rush hooks. It allows customized scripts to run at the specified point.
     * @beta
     */
    get eventHooks() {
        return this._eventHooks;
    }
    /**
     * The rush hooks. It allows customized scripts to run at the specified point.
     */
    get packageNameParser() {
        return this._packageNameParser;
    }
    /**
     * Gets the path to the common-versions.json config file for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     */
    getCommonVersionsFilePath(variant) {
        const commonVersionsFilename = path.join(this.commonRushConfigFolder, ...(variant ? [RushConstants_1.RushConstants.rushVariantsFolderName, variant] : []), RushConstants_1.RushConstants.commonVersionsFilename);
        return commonVersionsFilename;
    }
    /**
     * Gets the settings from the common-versions.json config file for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     */
    getCommonVersions(variant) {
        if (!this._commonVersionsConfigurations) {
            this._commonVersionsConfigurations = new Map();
        }
        // Use an empty string as the key when no variant provided. Anything else would possibly conflict
        // with a varient created by the user
        const variantKey = variant || '';
        let commonVersionsConfiguration = this._commonVersionsConfigurations.get(variantKey);
        if (!commonVersionsConfiguration) {
            const commonVersionsFilename = this.getCommonVersionsFilePath(variant);
            commonVersionsConfiguration = CommonVersionsConfiguration_1.CommonVersionsConfiguration.loadFromFile(commonVersionsFilename);
            this._commonVersionsConfigurations.set(variantKey, commonVersionsConfiguration);
        }
        return commonVersionsConfiguration;
    }
    /**
     * Returns a map of all direct dependencies that only have a single semantic version specifier.
     * @param variant - The name of the current variant in use by the active command.
     *
     * @returns A map of dependency name --\> version specifier for implicitly preferred versions.
     */
    getImplicitlyPreferredVersions(variant) {
        if (!this._implicitlyPreferredVersions) {
            this._implicitlyPreferredVersions = new Map();
        }
        // Use an empty string as the key when no variant provided. Anything else would possibly conflict
        // with a varient created by the user
        const variantKey = variant || '';
        let implicitlyPreferredVersions = this._implicitlyPreferredVersions.get(variantKey);
        if (!implicitlyPreferredVersions) {
            // First, collect all the direct dependencies of all local projects, and their versions:
            // direct dependency name --> set of version specifiers
            const versionsForDependencies = new Map();
            // Only generate implicitly preferred versions for variants that request it
            const commonVersionsConfiguration = this.getCommonVersions(variant);
            const useImplicitlyPreferredVersions = commonVersionsConfiguration.implicitlyPreferredVersions !== undefined
                ? commonVersionsConfiguration.implicitlyPreferredVersions
                : true;
            if (useImplicitlyPreferredVersions) {
                for (const project of this.projects) {
                    this._collectVersionsForDependencies(versionsForDependencies, [...project.packageJsonEditor.dependencyList, ...project.packageJsonEditor.devDependencyList], project.cyclicDependencyProjects, variant);
                }
                // If any dependency has more than one version, then filter it out (since we don't know which version
                // should be preferred).  What remains will be the list of preferred dependencies.
                // dependency --> version specifier
                const implicitlyPreferred = new Map();
                for (const [dep, versions] of versionsForDependencies) {
                    if (versions.size === 1) {
                        const version = Array.from(versions)[0];
                        implicitlyPreferred.set(dep, version);
                    }
                }
                implicitlyPreferredVersions = implicitlyPreferred;
            }
            else {
                implicitlyPreferredVersions = new Map();
            }
            this._implicitlyPreferredVersions.set(variantKey, implicitlyPreferredVersions);
        }
        return implicitlyPreferredVersions;
    }
    /**
     * Gets the path to the repo-state.json file for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     */
    getRepoStateFilePath(variant) {
        const repoStateFilename = path.join(this.commonRushConfigFolder, ...(variant ? [RushConstants_1.RushConstants.rushVariantsFolderName, variant] : []), RushConstants_1.RushConstants.repoStateFilename);
        return repoStateFilename;
    }
    /**
     * Gets the contents from the repo-state.json file for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     */
    getRepoState(variant) {
        const repoStateFilename = this.getRepoStateFilePath(variant);
        return RepoStateFile_1.RepoStateFile.loadFromFile(repoStateFilename, variant);
    }
    /**
     * Gets the committed shrinkwrap file name for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     */
    getCommittedShrinkwrapFilename(variant) {
        if (variant) {
            if (!this._variants.has(variant)) {
                throw new Error(`Invalid variant name '${variant}'. The provided variant parameter needs to be ` +
                    `one of the following from rush.json: ` +
                    `${Array.from(this._variants.values())
                        .map((name) => `"${name}"`)
                        .join(', ')}.`);
            }
        }
        const variantConfigFolderPath = this._getVariantConfigFolderPath(variant);
        return path.join(variantConfigFolderPath, this._shrinkwrapFilename);
    }
    /**
     * Gets the absolute path for "pnpmfile.js" for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     * @remarks
     * The file path is returned even if PNPM is not configured as the package manager.
     */
    getPnpmfilePath(variant) {
        const variantConfigFolderPath = this._getVariantConfigFolderPath(variant);
        return path.join(variantConfigFolderPath, this.packageManagerWrapper.pnpmfileFilename);
    }
    /**
     * Looks up a project in the projectsByName map.  If the project is not found,
     * then undefined is returned.
     */
    getProjectByName(projectName) {
        return this.projectsByName.get(projectName);
    }
    /**
     * This is used e.g. by command-line interfaces such as "rush build --to example".
     * If "example" is not a project name, then it also looks for a scoped name
     * like `@something/example`.  If exactly one project matches this heuristic, it
     * is returned.  Otherwise, undefined is returned.
     */
    findProjectByShorthandName(shorthandProjectName) {
        // Is there an exact match?
        let result = this.projectsByName.get(shorthandProjectName);
        if (result) {
            return result;
        }
        // Is there an approximate match?
        for (const project of this.projects) {
            if (this.packageNameParser.getUnscopedName(project.packageName) === shorthandProjectName) {
                if (result) {
                    // Ambiguous -- there is more than one match
                    return undefined;
                }
                else {
                    result = project;
                }
            }
        }
        return result;
    }
    /**
     * Looks up a project by its RushConfigurationProject.tempProjectName field.
     * @returns The found project, or undefined if no match was found.
     */
    findProjectByTempName(tempProjectName) {
        // Is there an approximate match?
        for (const project of this.projects) {
            if (project.tempProjectName === tempProjectName) {
                return project;
            }
        }
        return undefined;
    }
    /**
     * Finds the project that owns the specified POSIX relative path (e.g. apps/rush-lib).
     * The path is case-sensitive, so will only return a project if its projectRelativePath matches the casing.
     * @returns The found project, or undefined if no match was found
     */
    findProjectForPosixRelativePath(posixRelativePath) {
        return this._projectByRelativePath.findChildPath(posixRelativePath);
    }
    /**
     * @beta
     */
    get versionPolicyConfiguration() {
        return this._versionPolicyConfiguration;
    }
    /**
     * @beta
     */
    get versionPolicyConfigurationFilePath() {
        return this._versionPolicyConfigurationFilePath;
    }
    /**
     * This configuration object contains settings repo maintainers have specified to enable
     * and disable experimental Rush features.
     *
     * @beta
     */
    get experimentsConfiguration() {
        return this._experimentsConfiguration;
    }
    /**
     * Returns the project for which the specified path is underneath that project's folder.
     * If the path is not under any project's folder, returns undefined.
     */
    tryGetProjectForPath(currentFolderPath) {
        const resolvedPath = path.resolve(currentFolderPath);
        for (const project of this.projects) {
            if (node_core_library_1.Path.isUnderOrEqual(resolvedPath, project.projectFolder)) {
                return project;
            }
        }
        return undefined;
    }
    _collectVersionsForDependencies(versionsForDependencies, dependencies, cyclicDependencies, variant) {
        const commonVersions = this.getCommonVersions(variant);
        const allowedAlternativeVersions = commonVersions.allowedAlternativeVersions;
        for (const dependency of dependencies) {
            const alternativesForThisDependency = allowedAlternativeVersions.get(dependency.name) || [];
            // For each dependency, collectImplicitlyPreferredVersions() is collecting the set of all version specifiers
            // that appear across the repo.  If there is only one version specifier, then that's the "preferred" one.
            // However, there are a few cases where additional version specifiers can be safely ignored.
            let ignoreVersion = false;
            // 1. If the version specifier was listed in "allowedAlternativeVersions", then it's never a candidate.
            //    (Even if it's the only version specifier anywhere in the repo, we still ignore it, because
            //    otherwise the rule would be difficult to explain.)
            if (alternativesForThisDependency.indexOf(dependency.version) > 0) {
                ignoreVersion = true;
            }
            else {
                // Is it a local project?
                const localProject = this.getProjectByName(dependency.name);
                if (localProject) {
                    // 2. If it's a symlinked local project, then it's not a candidate, because the package manager will
                    //    never even see it.
                    // However there are two ways that a local project can NOT be symlinked:
                    // - if the local project doesn't satisfy the referenced semver specifier; OR
                    // - if the local project was specified in "cyclicDependencyProjects" in rush.json
                    if (!cyclicDependencies.has(dependency.name) &&
                        semver.satisfies(localProject.packageJsonEditor.version, dependency.version)) {
                        ignoreVersion = true;
                    }
                }
                if (!ignoreVersion) {
                    let versionForDependency = versionsForDependencies.get(dependency.name);
                    if (!versionForDependency) {
                        versionForDependency = new Set();
                        versionsForDependencies.set(dependency.name, versionForDependency);
                    }
                    versionForDependency.add(dependency.version);
                }
            }
        }
    }
    _populateDownstreamDependencies(dependencies, packageName) {
        if (!dependencies) {
            return;
        }
        Object.keys(dependencies).forEach((dependencyName) => {
            const depProject = this.projectsByName.get(dependencyName);
            if (depProject) {
                depProject._consumingProjectNames.add(packageName);
            }
        });
    }
    _getVariantConfigFolderPath(variant) {
        if (variant) {
            if (!this._variants.has(variant)) {
                throw new Error(`Invalid variant name '${variant}'. The provided variant parameter needs to be ` +
                    `one of the following from rush.json: ` +
                    `${Array.from(this._variants.values())
                        .map((name) => `"${name}"`)
                        .join(', ')}.`);
            }
        }
        return path.join(this._commonRushConfigFolder, ...(variant ? [RushConstants_1.RushConstants.rushVariantsFolderName, variant] : []));
    }
}
exports.RushConfiguration = RushConfiguration;
RushConfiguration._jsonSchema = node_core_library_1.JsonSchema.fromFile(path.join(__dirname, '../schemas/rush.schema.json'));
//# sourceMappingURL=RushConfiguration.js.map

/***/ }),

/***/ 90554:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RushConfigurationProject = void 0;
const path = __importStar(__webpack_require__(85622));
const semver = __importStar(__webpack_require__(11383));
const node_core_library_1 = __webpack_require__(24019);
const PackageJsonEditor_1 = __webpack_require__(32373);
const RushConstants_1 = __webpack_require__(63985);
const PackageNameParsers_1 = __webpack_require__(39458);
const DependencySpecifier_1 = __webpack_require__(179);
const Selection_1 = __webpack_require__(13857);
/**
 * This represents the configuration of a project that is built by Rush, based on
 * the Rush.json configuration file.
 * @public
 */
class RushConfigurationProject {
    /** @internal */
    constructor(projectJson, rushConfiguration, tempProjectName) {
        this._rushConfiguration = rushConfiguration;
        this._packageName = projectJson.packageName;
        this._projectRelativeFolder = projectJson.projectFolder;
        // For example, the depth of "a/b/c" would be 3.  The depth of "a" is 1.
        const projectFolderDepth = projectJson.projectFolder.split('/').length;
        if (projectFolderDepth < rushConfiguration.projectFolderMinDepth) {
            throw new Error(`To keep things organized, this repository has a projectFolderMinDepth policy` +
                ` requiring project folders to be at least ${rushConfiguration.projectFolderMinDepth} levels deep.` +
                `  Problem folder: "${projectJson.projectFolder}"`);
        }
        if (projectFolderDepth > rushConfiguration.projectFolderMaxDepth) {
            throw new Error(`To keep things organized, this repository has a projectFolderMaxDepth policy` +
                ` preventing project folders from being deeper than ${rushConfiguration.projectFolderMaxDepth} levels.` +
                `  Problem folder:  "${projectJson.projectFolder}"`);
        }
        this._projectFolder = path.join(rushConfiguration.rushJsonFolder, projectJson.projectFolder);
        if (!node_core_library_1.FileSystem.exists(this._projectFolder)) {
            throw new Error(`Project folder not found: ${projectJson.projectFolder}`);
        }
        this._projectRushConfigFolder = path.join(this._projectFolder, 'config', 'rush');
        this._projectRushTempFolder = path.join(this._projectFolder, RushConstants_1.RushConstants.projectRushFolderName, RushConstants_1.RushConstants.rushTempFolderName);
        // Are we using a package review file?
        if (rushConfiguration.approvedPackagesPolicy.enabled) {
            // If so, then every project needs to have a reviewCategory that was defined
            // by the reviewCategories array.
            if (!projectJson.reviewCategory) {
                throw new Error(`The "approvedPackagesPolicy" feature is enabled rush.json, but a reviewCategory` +
                    ` was not specified for the project "${projectJson.packageName}".`);
            }
            if (!rushConfiguration.approvedPackagesPolicy.reviewCategories.has(projectJson.reviewCategory)) {
                throw new Error(`The project "${projectJson.packageName}" specifies its reviewCategory as` +
                    `"${projectJson.reviewCategory}" which is not one of the defined reviewCategories.`);
            }
            this._reviewCategory = projectJson.reviewCategory;
        }
        const packageJsonFilename = path.join(this._projectFolder, "package.json" /* PackageJson */);
        this._packageJson = node_core_library_1.JsonFile.load(packageJsonFilename);
        if (this._packageJson.name !== this._packageName) {
            throw new Error(`The package name "${this._packageName}" specified in rush.json does not` +
                ` match the name "${this._packageJson.name}" from package.json`);
        }
        this._packageJsonEditor = PackageJsonEditor_1.PackageJsonEditor.fromObject(this._packageJson, packageJsonFilename);
        this._tempProjectName = tempProjectName;
        // The "rushProject.tempProjectName" is guaranteed to be unique name (e.g. by adding the "-2"
        // suffix).  Even after we strip the NPM scope, it will still be unique.
        // Example: "my-project-2"
        this._unscopedTempProjectName = PackageNameParsers_1.PackageNameParsers.permissive.getUnscopedName(tempProjectName);
        this._cyclicDependencyProjects = new Set();
        if (projectJson.cyclicDependencyProjects) {
            for (const cyclicDependencyProject of projectJson.cyclicDependencyProjects) {
                this._cyclicDependencyProjects.add(cyclicDependencyProject);
            }
        }
        this._shouldPublish = !!projectJson.shouldPublish;
        this._skipRushCheck = !!projectJson.skipRushCheck;
        this._consumingProjectNames = new Set();
        this._versionPolicyName = projectJson.versionPolicyName;
        this._publishFolder = this._projectFolder;
        if (projectJson.publishFolder) {
            this._publishFolder = path.join(this._publishFolder, projectJson.publishFolder);
        }
    }
    /**
     * The name of the NPM package.  An error is reported if this name is not
     * identical to packageJson.name.
     *
     * Example: `@scope/MyProject`
     */
    get packageName() {
        return this._packageName;
    }
    /**
     * The full path of the folder that contains the project to be built by Rush.
     *
     * Example: `C:\MyRepo\libraries\my-project`
     */
    get projectFolder() {
        return this._projectFolder;
    }
    /**
     * The relative path of the folder that contains the project to be built by Rush.
     *
     * Example: `libraries/my-project`
     */
    get projectRelativeFolder() {
        return this._projectRelativeFolder;
    }
    /**
     * The project-specific Rush configuration folder.
     *
     * Example: `C:\MyRepo\libraries\my-project\config\rush`
     */
    get projectRushConfigFolder() {
        return this._projectRushConfigFolder;
    }
    /**
     * The project-specific Rush temp folder. This folder is used to store Rush-specific temporary files.
     *
     * Example: `C:\MyRepo\libraries\my-project\.rush\temp`
     */
    get projectRushTempFolder() {
        return this._projectRushTempFolder;
    }
    /**
     * The Rush configuration for the monorepo that the project belongs to.
     */
    get rushConfiguration() {
        return this._rushConfiguration;
    }
    /**
     * The review category name, or undefined if no category was assigned.
     * This name must be one of the valid choices listed in RushConfiguration.reviewCategories.
     */
    get reviewCategory() {
        return this._reviewCategory;
    }
    /**
     * A list of local projects that appear as devDependencies for this project, but cannot be
     * locally linked because it would create a cyclic dependency; instead, the last published
     * version will be installed in the Common folder.
     *
     * These are package names that would be found by RushConfiguration.getProjectByName().
     */
    get cyclicDependencyProjects() {
        return this._cyclicDependencyProjects;
    }
    /**
     * An array of projects within the Rush configuration which directly depend on this package.
     * @deprecated Use `consumingProjectNames` instead, as it has Set semantics, which better reflect the nature
     * of the data.
     */
    get downstreamDependencyProjects() {
        return [...this._consumingProjectNames];
    }
    /**
     * An array of projects within the Rush configuration which this project declares as dependencies.
     * @deprecated Use `dependencyProjects` instead, as it has Set semantics, which better reflect the nature
     * of the data.
     */
    get localDependencyProjects() {
        return [...this.dependencyProjects];
    }
    /**
     * The set of projects within the Rush configuration which this project declares as dependencies.
     *
     * @remarks
     * Can be used recursively to walk the project dependency graph to find all projects that are directly or indirectly
     * referenced from this project.
     */
    get dependencyProjects() {
        if (!this._dependencyProjects) {
            this._dependencyProjects = Selection_1.Selection.union(this._getDependencyProjects(this.packageJson.dependencies), this._getDependencyProjects(this.packageJson.devDependencies), this._getDependencyProjects(this.packageJson.optionalDependencies));
        }
        return this._dependencyProjects;
    }
    /**
     * The set of projects within the Rush configuration which declare this project as a dependency.
     * Excludes those that declare this project as a `cyclicDependencyProject`.
     *
     * @remarks
     * This field is the counterpart to `dependencyProjects`, and can be used recursively to walk the project dependency
     * graph to find all projects which will be impacted by changes to this project.
     */
    get consumingProjects() {
        if (!this._consumingProjects) {
            this._consumingProjects = this._getConsumingProjects();
        }
        return this._consumingProjects;
    }
    /**
     * The parsed NPM "package.json" file from projectFolder.
     * @deprecated Use packageJsonEditor instead
     */
    get packageJson() {
        return this._packageJson;
    }
    /**
     * A useful wrapper around the package.json file for making modifications
     * @beta
     */
    get packageJsonEditor() {
        return this._packageJsonEditor;
    }
    /**
     * The unique name for the temporary project that will be generated in the Common folder.
     * For example, if the project name is `@scope/MyProject`, the temporary project name
     * might be `@rush-temp/MyProject-2`.
     *
     * Example: `@rush-temp/MyProject-2`
     */
    get tempProjectName() {
        return this._tempProjectName;
    }
    /**
     * The unscoped temporary project name
     *
     * Example: `my-project-2`
     */
    get unscopedTempProjectName() {
        return this._unscopedTempProjectName;
    }
    /**
     * A flag which indicates whether changes to this project should be published. This controls
     * whether or not the project would show up when running `rush change`, and whether or not it
     * should be published during `rush publish`.
     */
    get shouldPublish() {
        return this._shouldPublish || !!this._versionPolicyName;
    }
    /**
     * If true, then this project will be ignored by the "rush check" command.
     * The default value is false.
     */
    get skipRushCheck() {
        return this._skipRushCheck;
    }
    /**
     * Name of the version policy used by this project.
     * @beta
     */
    get versionPolicyName() {
        return this._versionPolicyName;
    }
    /**
     * The full path of the folder that will get published by Rush.
     *
     * @remarks
     * By default this is the same as the project folder, but a custom folder can be specified
     * using the the "publishFolder" setting in rush.json.
     *
     * Example: `C:\MyRepo\libraries\my-project\temp\publish`
     */
    get publishFolder() {
        return this._publishFolder;
    }
    /**
     * Version policy of the project
     * @beta
     */
    get versionPolicy() {
        if (!this._versionPolicy) {
            if (this.versionPolicyName && this._rushConfiguration.versionPolicyConfiguration) {
                this._versionPolicy = this._rushConfiguration.versionPolicyConfiguration.getVersionPolicy(this.versionPolicyName);
            }
        }
        return this._versionPolicy;
    }
    /**
     * Indicate whether this project is the main project for the related version policy.
     *
     * False if the project is not for publishing.
     * True if the project is individually versioned or if its lockstep version policy does not specify main project.
     * False if the project is lockstepped and is not the main project for its version policy.
     *
     * @beta
     */
    get isMainProject() {
        if (!this.shouldPublish) {
            return false;
        }
        let isMain = true;
        if (this.versionPolicy && this.versionPolicy.isLockstepped) {
            const lockStepPolicy = this.versionPolicy;
            if (lockStepPolicy.mainProject && lockStepPolicy.mainProject !== this.packageName) {
                isMain = false;
            }
        }
        return isMain;
    }
    /**
     * Compute the local rush projects that this project immediately depends on,
     * according to the specific dependency group from package.json
     */
    _getDependencyProjects(dependencies = {}) {
        const dependencyProjects = new Set();
        for (const dependency of Object.keys(dependencies)) {
            // Skip if we can't find the local project or it's a cyclic dependency
            const localProject = this._rushConfiguration.getProjectByName(dependency);
            if (localProject && !this._cyclicDependencyProjects.has(dependency)) {
                // Set the value if it's a workspace project, or if we have a local project and the semver is satisfied
                const dependencySpecifier = new DependencySpecifier_1.DependencySpecifier(dependency, dependencies[dependency]);
                switch (dependencySpecifier.specifierType) {
                    case DependencySpecifier_1.DependencySpecifierType.Version:
                    case DependencySpecifier_1.DependencySpecifierType.Range:
                        if (semver.satisfies(localProject.packageJson.version, dependencySpecifier.versionSpecifier)) {
                            dependencyProjects.add(localProject);
                        }
                        break;
                    case DependencySpecifier_1.DependencySpecifierType.Workspace:
                        dependencyProjects.add(localProject);
                        break;
                }
            }
        }
        return dependencyProjects;
    }
    /**
     * Compute the local rush projects that declare this project as a dependency
     */
    _getConsumingProjects() {
        const consumingProjects = new Set();
        for (const projectName of this._consumingProjectNames) {
            const localProject = this._rushConfiguration.getProjectByName(projectName);
            if (localProject && localProject.dependencyProjects.has(this)) {
                consumingProjects.add(localProject);
            }
        }
        return consumingProjects;
    }
}
exports.RushConfigurationProject = RushConfigurationProject;
//# sourceMappingURL=RushConfigurationProject.js.map

/***/ }),

/***/ 96337:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RushGlobalFolder = void 0;
const path = __importStar(__webpack_require__(85622));
const Utilities_1 = __webpack_require__(89521);
const EnvironmentConfiguration_1 = __webpack_require__(84018);
/**
 * This class provides global folders that are used for rush's internal install locations.
 *
 * @internal
 */
class RushGlobalFolder {
    constructor() {
        // Because RushGlobalFolder is used by the front-end VersionSelector before EnvironmentConfiguration
        // is initialized, we need to read it using a special internal API.
        const rushGlobalFolderOverride = EnvironmentConfiguration_1.EnvironmentConfiguration._getRushGlobalFolderOverride(process.env);
        if (rushGlobalFolderOverride !== undefined) {
            this._rushGlobalFolder = rushGlobalFolderOverride;
        }
        else {
            this._rushGlobalFolder = path.join(Utilities_1.Utilities.getHomeFolder(), '.rush');
        }
        const normalizedNodeVersion = process.version.match(/^[a-z0-9\-\.]+$/i)
            ? process.version
            : 'unknown-version';
        this._rushNodeSpecificUserFolder = path.join(this._rushGlobalFolder, `node-${normalizedNodeVersion}`);
    }
    /**
     * The global folder where Rush stores temporary files.
     *
     * @remarks
     *
     * Most of the temporary files created by Rush are stored separately for each monorepo working folder,
     * to avoid issues of concurrency and compatibility between tool versions.  However, a small set
     * of files (e.g. installations of the `@microsoft/rush-lib` engine and the package manager) are stored
     * in a global folder to speed up installations.  The default location is `~/.rush` on POSIX-like
     * operating systems or `C:\Users\YourName` on Windows.
     *
     * You can use the {@link EnvironmentVariableNames.RUSH_GLOBAL_FOLDER} environment  variable to specify
     * a different folder path.  This is useful for example if a Windows group policy forbids executing scripts
     * installed in a user's home directory.
     *
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    get path() {
        return this._rushGlobalFolder;
    }
    /**
     * The absolute path to Rush's storage in the home directory for the current user and node version.
     * On Windows, it would be something like `C:\Users\YourName\.rush\node-v3.4.5`.
     */
    get nodeSpecificPath() {
        return this._rushNodeSpecificUserFolder;
    }
}
exports.RushGlobalFolder = RushGlobalFolder;
//# sourceMappingURL=RushGlobalFolder.js.map

/***/ }),

/***/ 19847:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RushProjectConfiguration = void 0;
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const heft_config_file_1 = __webpack_require__(42166);
const rig_package_1 = __webpack_require__(24289);
const RushConstants_1 = __webpack_require__(63985);
const OverlappingPathAnalyzer_1 = __webpack_require__(48892);
/**
 * Use this class to load the "config/rush-project.json" config file.
 *
 * This file provides project-specific configuration options.
 * @public
 */
class RushProjectConfiguration {
    constructor(project, rushProjectJson, projectOutputFolderNamesForPhases) {
        var _a, _b;
        this.project = project;
        this.projectOutputFolderNames = rushProjectJson.projectOutputFolderNames;
        this.projectOutputFolderNamesForPhases = projectOutputFolderNamesForPhases;
        this.incrementalBuildIgnoredGlobs = rushProjectJson.incrementalBuildIgnoredGlobs;
        const optionsForCommandsByName = new Map();
        if ((_a = rushProjectJson.buildCacheOptions) === null || _a === void 0 ? void 0 : _a.optionsForCommands) {
            for (const cacheOptionsForCommand of rushProjectJson.buildCacheOptions.optionsForCommands) {
                optionsForCommandsByName.set(cacheOptionsForCommand.name, cacheOptionsForCommand);
            }
        }
        this.cacheOptions = {
            disableBuildCache: (_b = rushProjectJson.buildCacheOptions) === null || _b === void 0 ? void 0 : _b.disableBuildCache,
            optionsForCommandsByName
        };
    }
    /**
     * Loads the rush-project.json data for the specified project.
     */
    static async tryLoadForProjectAsync(project, repoCommandLineConfiguration, terminal, skipCache) {
        // false is a signal that the project config does not exist
        const cacheEntry = skipCache
            ? undefined
            : RushProjectConfiguration._configCache.get(project);
        if (cacheEntry !== undefined) {
            return cacheEntry || undefined;
        }
        const rigConfig = await rig_package_1.RigConfig.loadForProjectFolderAsync({
            projectFolderPath: project.projectFolder
        });
        const rushProjectJson = await this._projectBuildCacheConfigurationFile.tryLoadConfigurationFileForProjectAsync(terminal, project.projectFolder, rigConfig);
        if (rushProjectJson) {
            const result = RushProjectConfiguration._getRushProjectConfiguration(project, rushProjectJson, repoCommandLineConfiguration, terminal);
            RushProjectConfiguration._configCache.set(project, result);
            return result;
        }
        else {
            RushProjectConfiguration._configCache.set(project, false);
            return undefined;
        }
    }
    static _getRushProjectConfiguration(project, rushProjectJson, repoCommandLineConfiguration, terminal) {
        var _a;
        if (rushProjectJson.projectOutputFolderNames) {
            const overlappingPathAnalyzer = new OverlappingPathAnalyzer_1.OverlappingPathAnalyzer();
            const invalidFolderNames = [];
            for (const projectOutputFolder of rushProjectJson.projectOutputFolderNames) {
                if (projectOutputFolder.match(/[\\]/)) {
                    invalidFolderNames.push(projectOutputFolder);
                }
                const overlaps = !!overlappingPathAnalyzer.addPathAndGetFirstEncounteredLabels(projectOutputFolder, true);
                if (overlaps) {
                    terminal.writeErrorLine(`The project output folder name "${projectOutputFolder}" is invalid because it overlaps with another folder name.`);
                    throw new node_core_library_1.AlreadyReportedError();
                }
            }
            if (invalidFolderNames.length > 0) {
                terminal.writeErrorLine(`Invalid project configuration for project "${project.packageName}". Entries in ` +
                    '"projectOutputFolderNames" must not contain backslashes and the following entries do: ' +
                    invalidFolderNames.join(', '));
            }
        }
        const duplicateCommandNames = new Set();
        const invalidCommandNames = [];
        if ((_a = rushProjectJson.buildCacheOptions) === null || _a === void 0 ? void 0 : _a.optionsForCommands) {
            const commandNames = new Set([
                RushConstants_1.RushConstants.buildCommandName,
                RushConstants_1.RushConstants.rebuildCommandName
            ]);
            if (repoCommandLineConfiguration) {
                for (const [commandName, command] of repoCommandLineConfiguration.commands) {
                    if (command.commandKind === RushConstants_1.RushConstants.bulkCommandKind) {
                        commandNames.add(commandName);
                    }
                }
            }
            const alreadyEncounteredCommandNames = new Set();
            for (const cacheOptionsForCommand of rushProjectJson.buildCacheOptions.optionsForCommands) {
                const commandName = cacheOptionsForCommand.name;
                if (!commandNames.has(commandName)) {
                    invalidCommandNames.push(commandName);
                }
                else if (alreadyEncounteredCommandNames.has(commandName)) {
                    duplicateCommandNames.add(commandName);
                }
                else {
                    alreadyEncounteredCommandNames.add(commandName);
                }
            }
        }
        if (invalidCommandNames.length > 0) {
            terminal.writeErrorLine(`Invalid project configuration fpr project "${project.packageName}". The following ` +
                'command names in cacheOptions.optionsForCommands are not specified in this repo: ' +
                invalidCommandNames.join(', '));
        }
        if (duplicateCommandNames.size > 0) {
            terminal.writeErrorLine(`Invalid project configuration fpr project "${project.packageName}". The following ` +
                'command names in cacheOptions.optionsForCommands are specified more than once: ' +
                Array.from(duplicateCommandNames).join(', '));
        }
        let projectOutputFolderNamesForPhases;
        if (rushProjectJson.phaseOptions) {
            const overlappingPathAnalyzer = new OverlappingPathAnalyzer_1.OverlappingPathAnalyzer();
            projectOutputFolderNamesForPhases = new Map();
            const phaseOptionsByPhase = new Map();
            for (const phaseOptions of rushProjectJson.phaseOptions) {
                const phaseName = phaseOptions.phaseName;
                const existingPhaseOptions = phaseOptionsByPhase.get(phaseName);
                if (existingPhaseOptions) {
                    const existingPhaseOptionsJsonPath = RushProjectConfiguration._projectBuildCacheConfigurationFile.getObjectSourceFilePath(existingPhaseOptions);
                    const phaseOptionsJsonPath = RushProjectConfiguration._projectBuildCacheConfigurationFile.getObjectSourceFilePath(phaseOptions);
                    let errorMessage = `The phase "${phaseName}" appears multiple times in the "${project.packageName}" project's ` +
                        `${RushProjectConfiguration._projectBuildCacheConfigurationFile.projectRelativeFilePath} file's ` +
                        'phaseOptions property.';
                    if (existingPhaseOptionsJsonPath && phaseOptionsJsonPath) {
                        if (existingPhaseOptionsJsonPath !== phaseOptionsJsonPath) {
                            errorMessage +=
                                ` It first appears in "${existingPhaseOptionsJsonPath}" and again ` +
                                    `in "${phaseOptionsJsonPath}".`;
                        }
                        else if (!node_core_library_1.Path.convertToSlashes(existingPhaseOptionsJsonPath).startsWith(node_core_library_1.Path.convertToSlashes(project.projectFolder))) {
                            errorMessage += ` It appears multiple times in "${phaseOptionsJsonPath}".`;
                        }
                    }
                    terminal.writeErrorLine(errorMessage);
                }
                else if (!(repoCommandLineConfiguration === null || repoCommandLineConfiguration === void 0 ? void 0 : repoCommandLineConfiguration.phases.has(phaseName))) {
                    terminal.writeErrorLine(`Invalid "${RushProjectConfiguration._projectBuildCacheConfigurationFile.projectRelativeFilePath}"` +
                        ` for project "${project.packageName}". Phase "${phaseName}" is not defined in the repo's ${RushConstants_1.RushConstants.commandLineFilename}.`);
                }
                else {
                    phaseOptionsByPhase.set(phaseOptions.phaseName, phaseOptions);
                    if (phaseOptions.projectOutputFolderNames) {
                        projectOutputFolderNamesForPhases.set(phaseOptions.phaseName, phaseOptions.projectOutputFolderNames);
                    }
                }
                if (phaseOptions.projectOutputFolderNames) {
                    for (const projectOutputFolderName of phaseOptions.projectOutputFolderNames) {
                        const overlappingPhaseNames = overlappingPathAnalyzer.addPathAndGetFirstEncounteredLabels(projectOutputFolderName, phaseName);
                        if (overlappingPhaseNames) {
                            const overlapsWithOwnPhase = overlappingPhaseNames === null || overlappingPhaseNames === void 0 ? void 0 : overlappingPhaseNames.includes(phaseName);
                            if (overlapsWithOwnPhase) {
                                if (overlappingPhaseNames.length === 1) {
                                    terminal.writeErrorLine(`Invalid "${RushProjectConfiguration._projectBuildCacheConfigurationFile.projectRelativeFilePath}" ` +
                                        `for project "${project.packageName}". The project output folder name "${projectOutputFolderName}" in ` +
                                        `phase ${phaseName} overlaps with other another folder name in the same phase.`);
                                }
                                else {
                                    const otherPhaseNames = overlappingPhaseNames.filter((overlappingPhaseName) => overlappingPhaseName !== phaseName);
                                    terminal.writeErrorLine(`Invalid "${RushProjectConfiguration._projectBuildCacheConfigurationFile.projectRelativeFilePath}" ` +
                                        `for project "${project.packageName}". The project output folder name "${projectOutputFolderName}" in ` +
                                        `phase ${phaseName} overlaps with other another folder names in the same phase and with ` +
                                        `folder names in the following other phases: ${otherPhaseNames.join(', ')}.`);
                                }
                            }
                            else {
                                terminal.writeErrorLine(`Invalid "${RushProjectConfiguration._projectBuildCacheConfigurationFile.projectRelativeFilePath}" ` +
                                    `for project "${project.packageName}". The project output folder name "${projectOutputFolderName}" in ` +
                                    `phase ${phaseName} overlaps with other folder name(s) in the following other phases: ` +
                                    `${overlappingPhaseNames.join(', ')}.`);
                            }
                            throw new node_core_library_1.AlreadyReportedError();
                        }
                    }
                }
            }
        }
        return new RushProjectConfiguration(project, rushProjectJson, projectOutputFolderNamesForPhases);
    }
}
exports.RushProjectConfiguration = RushProjectConfiguration;
RushProjectConfiguration._projectBuildCacheConfigurationFile = new heft_config_file_1.ConfigurationFile({
    projectRelativeFilePath: `config/${RushConstants_1.RushConstants.rushProjectConfigFilename}`,
    jsonSchemaPath: path.resolve(__dirname, '..', 'schemas', 'rush-project.schema.json'),
    propertyInheritance: {
        projectOutputFolderNames: {
            inheritanceType: heft_config_file_1.InheritanceType.append
        },
        phaseOptions: {
            inheritanceType: heft_config_file_1.InheritanceType.append
        },
        incrementalBuildIgnoredGlobs: {
            inheritanceType: heft_config_file_1.InheritanceType.replace
        },
        buildCacheOptions: {
            inheritanceType: heft_config_file_1.InheritanceType.custom,
            inheritanceFunction: (current, parent) => {
                if (!current) {
                    return parent;
                }
                else if (!parent) {
                    return current;
                }
                else {
                    return Object.assign(Object.assign(Object.assign({}, parent), current), { optionsForCommands: [
                            ...(parent.optionsForCommands || []),
                            ...(current.optionsForCommands || [])
                        ] });
                }
            }
        }
    }
});
RushProjectConfiguration._configCache = new Map();
//# sourceMappingURL=RushProjectConfiguration.js.map

/***/ }),

/***/ 78221:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RushUserConfiguration = void 0;
const node_core_library_1 = __webpack_require__(24019);
const path = __importStar(__webpack_require__(85622));
const Utilities_1 = __webpack_require__(89521);
const RushConstants_1 = __webpack_require__(63985);
/**
 * Rush per-user configuration data.
 *
 * @beta
 */
class RushUserConfiguration {
    constructor(rushUserConfigurationJson) {
        this.buildCacheFolder = rushUserConfigurationJson === null || rushUserConfigurationJson === void 0 ? void 0 : rushUserConfigurationJson.buildCacheFolder;
        if (this.buildCacheFolder && !path.isAbsolute(this.buildCacheFolder)) {
            throw new Error('buildCacheFolder must be an absolute path');
        }
    }
    static async initializeAsync() {
        const rushUserFolderPath = RushUserConfiguration.getRushUserFolderPath();
        const rushUserSettingsFilePath = path.join(rushUserFolderPath, 'settings.json');
        let rushUserSettingsJson;
        try {
            rushUserSettingsJson = await node_core_library_1.JsonFile.loadAndValidateAsync(rushUserSettingsFilePath, RushUserConfiguration._schema);
        }
        catch (e) {
            if (!node_core_library_1.FileSystem.isNotExistError(e)) {
                throw e;
            }
        }
        return new RushUserConfiguration(rushUserSettingsJson);
    }
    static getRushUserFolderPath() {
        const homeFolderPath = Utilities_1.Utilities.getHomeFolder();
        const rushUserSettingsFilePath = path.join(homeFolderPath, RushConstants_1.RushConstants.rushUserConfigurationFolderName);
        return rushUserSettingsFilePath;
    }
}
exports.RushUserConfiguration = RushUserConfiguration;
RushUserConfiguration._schema = node_core_library_1.JsonSchema.fromFile(path.resolve(__dirname, '..', 'schemas', 'rush-user-settings.schema.json'));
//# sourceMappingURL=RushUserConfiguration.js.map

/***/ }),

/***/ 36315:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Variants = void 0;
/**
 * Namespace for utilities relating to the Variants feature.
 */
class Variants {
}
exports.Variants = Variants;
/**
 * Provides the parameter configuration for '--variant'.
 */
Variants.VARIANT_PARAMETER = {
    parameterLongName: '--variant',
    argumentName: 'VARIANT',
    description: 'Run command using a variant installation configuration',
    environmentVariable: 'RUSH_VARIANT'
};
//# sourceMappingURL=Variants.js.map

/***/ }),

/***/ 78075:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IndividualVersionPolicy = exports.LockStepVersionPolicy = exports.VersionPolicy = exports.VersionPolicyDefinitionName = exports.BumpType = void 0;
const semver = __importStar(__webpack_require__(11383));
const node_core_library_1 = __webpack_require__(24019);
const VersionPolicyConfiguration_1 = __webpack_require__(6375);
const lodash = node_core_library_1.Import.lazy('lodash', require);
/**
 * Type of version bumps
 * @beta
 */
var BumpType;
(function (BumpType) {
    // No version bump
    BumpType[BumpType["none"] = 0] = "none";
    // Prerelease version bump
    BumpType[BumpType["prerelease"] = 1] = "prerelease";
    // Patch version bump
    BumpType[BumpType["patch"] = 2] = "patch";
    // Preminor version bump
    BumpType[BumpType["preminor"] = 3] = "preminor";
    // Minor version bump
    BumpType[BumpType["minor"] = 4] = "minor";
    // Major version bump
    BumpType[BumpType["major"] = 5] = "major";
})(BumpType = exports.BumpType || (exports.BumpType = {}));
/**
 * Version policy base type names
 * @beta
 */
var VersionPolicyDefinitionName;
(function (VersionPolicyDefinitionName) {
    VersionPolicyDefinitionName[VersionPolicyDefinitionName["lockStepVersion"] = 0] = "lockStepVersion";
    VersionPolicyDefinitionName[VersionPolicyDefinitionName["individualVersion"] = 1] = "individualVersion";
})(VersionPolicyDefinitionName = exports.VersionPolicyDefinitionName || (exports.VersionPolicyDefinitionName = {}));
/**
 * This is the base class for version policy which controls how versions get bumped.
 * @beta
 */
class VersionPolicy {
    /**
     * @internal
     */
    constructor(versionPolicyJson) {
        this._policyName = versionPolicyJson.policyName;
        this._definitionName = node_core_library_1.Enum.getValueByKey(VersionPolicyDefinitionName, versionPolicyJson.definitionName);
        this._exemptFromRushChange = versionPolicyJson.exemptFromRushChange || false;
        this._includeEmailInChangeFile = versionPolicyJson.includeEmailInChangeFile || false;
        const jsonDependencies = versionPolicyJson.dependencies || {};
        this._versionFormatForCommit = jsonDependencies.versionFormatForCommit || VersionPolicyConfiguration_1.VersionFormatForCommit.original;
        this._versionFormatForPublish =
            jsonDependencies.versionFormatForPublish || VersionPolicyConfiguration_1.VersionFormatForPublish.original;
    }
    /**
     * Loads from version policy json
     *
     * @param versionPolicyJson - version policy Json
     *
     * @internal
     */
    static load(versionPolicyJson) {
        const definition = node_core_library_1.Enum.getValueByKey(VersionPolicyDefinitionName, versionPolicyJson.definitionName);
        if (definition === VersionPolicyDefinitionName.lockStepVersion) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            return new LockStepVersionPolicy(versionPolicyJson);
        }
        else if (definition === VersionPolicyDefinitionName.individualVersion) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            return new IndividualVersionPolicy(versionPolicyJson);
        }
        return undefined;
    }
    /**
     * Version policy name
     */
    get policyName() {
        return this._policyName;
    }
    /**
     * Version policy definition name
     */
    get definitionName() {
        return this._definitionName;
    }
    /**
     * Whether it is a lockstepped version policy
     */
    get isLockstepped() {
        return this.definitionName === VersionPolicyDefinitionName.lockStepVersion;
    }
    /**
     * Determines if a version policy wants to opt out of changelog files.
     */
    get exemptFromRushChange() {
        return this._exemptFromRushChange;
    }
    /**
     * Determines if a version policy wants to opt in to including email.
     */
    get includeEmailInChangeFile() {
        return this._includeEmailInChangeFile;
    }
    /**
     * Tells the version policy to modify any dependencies in the target package
     * to values used for publishing.
     */
    setDependenciesBeforePublish(packageName, configuration) {
        if (this._versionFormatForPublish === VersionPolicyConfiguration_1.VersionFormatForPublish.exact) {
            const project = configuration.getProjectByName(packageName);
            const packageJsonEditor = project.packageJsonEditor;
            for (const dependency of packageJsonEditor.dependencyList) {
                const rushDependencyProject = configuration.getProjectByName(dependency.name);
                if (rushDependencyProject) {
                    const dependencyVersion = rushDependencyProject.packageJson.version;
                    dependency.setVersion(dependencyVersion);
                }
            }
            packageJsonEditor.saveIfModified();
        }
    }
    /**
     * Tells the version policy to modify any dependencies in the target package
     * to values used for checked-in source.
     */
    setDependenciesBeforeCommit(packageName, configuration) {
        if (this._versionFormatForCommit === VersionPolicyConfiguration_1.VersionFormatForCommit.wildcard) {
            const project = configuration.getProjectByName(packageName);
            const packageJsonEditor = project.packageJsonEditor;
            for (const dependency of packageJsonEditor.dependencyList) {
                const rushDependencyProject = configuration.getProjectByName(dependency.name);
                if (rushDependencyProject) {
                    dependency.setVersion('*');
                }
            }
            packageJsonEditor.saveIfModified();
        }
    }
}
exports.VersionPolicy = VersionPolicy;
/**
 * This policy indicates all related projects should use the same version.
 * @beta
 */
class LockStepVersionPolicy extends VersionPolicy {
    /**
     * @internal
     */
    constructor(versionPolicyJson) {
        super(versionPolicyJson);
        this._version = new semver.SemVer(versionPolicyJson.version);
        this._nextBump = node_core_library_1.Enum.getValueByKey(BumpType, versionPolicyJson.nextBump);
        this._mainProject = versionPolicyJson.mainProject;
    }
    /**
     * The value of the lockstep version
     */
    get version() {
        return this._version.format();
    }
    /**
     * The type of bump for next bump.
     */
    get nextBump() {
        return this._nextBump;
    }
    /**
     * The main project for the version policy.
     *
     * If the value is provided, change logs will only be generated in that project.
     * If the value is not provided, change logs will be hosted in each project associated with the policy.
     */
    get mainProject() {
        return this._mainProject;
    }
    /**
     * Serialized json for this policy
     *
     * @internal
     */
    get _json() {
        const json = {
            policyName: this.policyName,
            definitionName: VersionPolicyDefinitionName[this.definitionName],
            version: this.version,
            nextBump: BumpType[this.nextBump]
        };
        if (this._mainProject) {
            json.mainProject = this._mainProject;
        }
        return json;
    }
    /**
     * Returns an updated package json that satisfies the version policy.
     *
     * @param project - input package json
     * @param force - force update even when the project version is higher than the policy version.
     */
    ensure(project, force) {
        const packageVersion = new semver.SemVer(project.version);
        const compareResult = packageVersion.compare(this._version);
        if (compareResult === 0) {
            return undefined;
        }
        else if (compareResult > 0 && !force) {
            const errorMessage = `Version ${project.version} in package ${project.name}` +
                ` is higher than locked version ${this._version.format()}.`;
            throw new Error(errorMessage);
        }
        return this._updatePackageVersion(project, this._version);
    }
    /**
     * Bumps the version of the lockstep policy
     *
     * @param bumpType - Overwrite bump type in version-policy.json with the provided value.
     * @param identifier - Prerelease identifier if bump type is prerelease.
     */
    bump(bumpType, identifier) {
        this._version.inc(this._getReleaseType(bumpType || this.nextBump), identifier);
    }
    /**
     * Updates the version of the policy directly with a new value
     * @param newVersionString - New version
     */
    update(newVersionString) {
        const newVersion = new semver.SemVer(newVersionString);
        if (!newVersion || this._version === newVersion) {
            return false;
        }
        this._version = newVersion;
        return true;
    }
    /**
     * Validates the specified version and throws if the version does not satisfy lockstep version.
     *
     * @param versionString - version string
     * @param packageName - package name
     */
    validate(versionString, packageName) {
        const versionToTest = new semver.SemVer(versionString, false);
        if (this._version.compare(versionToTest) !== 0) {
            throw new Error(`Invalid version ${versionString} in ${packageName}`);
        }
    }
    _updatePackageVersion(project, newVersion) {
        const updatedProject = lodash.cloneDeep(project);
        updatedProject.version = newVersion.format();
        return updatedProject;
    }
    _getReleaseType(bumpType) {
        // Eventually we should just use ReleaseType and get rid of bump type.
        return BumpType[bumpType];
    }
}
exports.LockStepVersionPolicy = LockStepVersionPolicy;
/**
 * This policy indicates all related projects get version bump driven by their own changes.
 * @beta
 */
class IndividualVersionPolicy extends VersionPolicy {
    /**
     * @internal
     */
    constructor(versionPolicyJson) {
        super(versionPolicyJson);
        this._lockedMajor = versionPolicyJson.lockedMajor;
    }
    /**
     * The major version that has been locked
     */
    get lockedMajor() {
        return this._lockedMajor;
    }
    /**
     * Serialized json for this policy
     *
     * @internal
     */
    get _json() {
        const json = {
            policyName: this.policyName,
            definitionName: VersionPolicyDefinitionName[this.definitionName]
        };
        if (this.lockedMajor !== undefined) {
            json.lockedMajor = this.lockedMajor;
        }
        return json;
    }
    /**
     * Returns an updated package json that satisfies the version policy.
     *
     * @param project - input package json
     * @param force - force update even when the project version is higher than the policy version.
     */
    ensure(project, force) {
        if (this.lockedMajor) {
            const version = new semver.SemVer(project.version);
            if (version.major < this.lockedMajor) {
                const updatedProject = lodash.cloneDeep(project);
                updatedProject.version = `${this._lockedMajor}.0.0`;
                return updatedProject;
            }
            else if (version.major > this.lockedMajor) {
                const errorMessage = `Version ${project.version} in package ${project.name}` +
                    ` is higher than locked major version ${this._lockedMajor}.`;
                throw new Error(errorMessage);
            }
        }
        return undefined;
    }
    /**
     * Bumps version.
     * Individual version policy lets change files drive version bump. This method currently does not do anything.
     *
     * @param bumpType - bump type
     * @param identifier - prerelease id
     */
    bump(bumpType, identifier) {
        // individual version policy lets change files drive version bump.
    }
    /**
     * Validates the specified version and throws if the version does not satisfy the policy.
     *
     * @param versionString - version string
     * @param packageName - package name
     */
    validate(versionString, packageName) {
        const versionToTest = new semver.SemVer(versionString, false);
        if (this._lockedMajor !== undefined) {
            if (this._lockedMajor !== versionToTest.major) {
                throw new Error(`Invalid major version ${versionString} in ${packageName}`);
            }
        }
    }
}
exports.IndividualVersionPolicy = IndividualVersionPolicy;
//# sourceMappingURL=VersionPolicy.js.map

/***/ }),

/***/ 6375:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VersionPolicyConfiguration = exports.VersionFormatForCommit = exports.VersionFormatForPublish = void 0;
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const VersionPolicy_1 = __webpack_require__(78075);
/**
 * @beta
 */
var VersionFormatForPublish;
(function (VersionFormatForPublish) {
    VersionFormatForPublish["original"] = "original";
    VersionFormatForPublish["exact"] = "exact";
})(VersionFormatForPublish = exports.VersionFormatForPublish || (exports.VersionFormatForPublish = {}));
/**
 * @beta
 */
var VersionFormatForCommit;
(function (VersionFormatForCommit) {
    VersionFormatForCommit["wildcard"] = "wildcard";
    VersionFormatForCommit["original"] = "original";
})(VersionFormatForCommit = exports.VersionFormatForCommit || (exports.VersionFormatForCommit = {}));
/**
 * Use this class to load and save the "common/config/rush/version-policies.json" config file.
 * This config file configures how different groups of projects will be published by Rush,
 * and how their version numbers will be determined.
 * @beta
 */
class VersionPolicyConfiguration {
    /**
     * @internal
     */
    constructor(jsonFileName) {
        this._jsonFileName = jsonFileName;
        this._versionPolicies = new Map();
        this._loadFile();
    }
    /**
     * Validate the version policy configuration against the rush config
     */
    validate(projectsByName) {
        if (!this.versionPolicies) {
            return;
        }
        this.versionPolicies.forEach((policy) => {
            const lockStepPolicy = policy;
            if (lockStepPolicy.mainProject && !projectsByName.get(lockStepPolicy.mainProject)) {
                throw new Error(`Version policy \"${policy.policyName}\" has a non-existing mainProject:` +
                    ` ${lockStepPolicy.mainProject}.`);
            }
        });
    }
    /**
     * Gets the version policy by its name.
     * Throws error if the version policy is not found.
     * @param policyName - Name of the version policy
     */
    getVersionPolicy(policyName) {
        const policy = this._versionPolicies.get(policyName);
        if (!policy) {
            throw new Error(`Failed to find version policy by name \'${policyName}\'`);
        }
        return policy;
    }
    /**
     * Gets all the version policies
     */
    get versionPolicies() {
        return this._versionPolicies;
    }
    /**
     * Bumps up versions for the specified version policy or all version policies
     *
     * @param versionPolicyName - version policy name
     * @param bumpType - bump type to override what policy has defined.
     * @param identifier - prerelease identifier to override what policy has defined.
     * @param shouldCommit - should save to disk
     */
    bump(versionPolicyName, bumpType, identifier, shouldCommit) {
        if (versionPolicyName) {
            const policy = this.versionPolicies.get(versionPolicyName);
            if (policy) {
                policy.bump(bumpType, identifier);
            }
        }
        else {
            this.versionPolicies.forEach((versionPolicy) => {
                if (versionPolicy) {
                    versionPolicy.bump(bumpType, identifier);
                }
            });
        }
        this._saveFile(!!shouldCommit);
    }
    /**
     * Updates the version directly for the specified version policy
     * @param versionPolicyName - version policy name
     * @param newVersion - new version
     */
    update(versionPolicyName, newVersion) {
        const policy = this.versionPolicies.get(versionPolicyName);
        if (!policy || !policy.isLockstepped) {
            throw new Error(`Lockstep Version policy with name "${versionPolicyName}" cannot be found`);
        }
        const lockStepVersionPolicy = policy;
        if (lockStepVersionPolicy.update(newVersion)) {
            this._saveFile(true);
        }
    }
    _loadFile() {
        if (!node_core_library_1.FileSystem.exists(this._jsonFileName)) {
            return;
        }
        const versionPolicyJson = node_core_library_1.JsonFile.loadAndValidate(this._jsonFileName, VersionPolicyConfiguration._jsonSchema);
        versionPolicyJson.forEach((policyJson) => {
            const policy = VersionPolicy_1.VersionPolicy.load(policyJson);
            if (policy) {
                this._versionPolicies.set(policy.policyName, policy);
            }
        });
    }
    _saveFile(shouldCommit) {
        const versionPolicyJson = [];
        this.versionPolicies.forEach((versionPolicy) => {
            versionPolicyJson.push(versionPolicy._json);
        });
        if (shouldCommit) {
            node_core_library_1.JsonFile.save(versionPolicyJson, this._jsonFileName, { updateExistingFile: true });
        }
    }
}
exports.VersionPolicyConfiguration = VersionPolicyConfiguration;
VersionPolicyConfiguration._jsonSchema = node_core_library_1.JsonSchema.fromFile(path.join(__dirname, '../schemas/version-policies.schema.json'));
//# sourceMappingURL=VersionPolicyConfiguration.js.map

/***/ }),

/***/ 94980:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NpmPackageManager = void 0;
const RushConstants_1 = __webpack_require__(63985);
const PackageManager_1 = __webpack_require__(37421);
/**
 * Support for interacting with the NPM package manager.
 */
class NpmPackageManager extends PackageManager_1.PackageManager {
    /** @internal */
    constructor(version) {
        super(version, 'npm');
        this._shrinkwrapFilename = RushConstants_1.RushConstants.npmShrinkwrapFilename;
    }
}
exports.NpmPackageManager = NpmPackageManager;
//# sourceMappingURL=NpmPackageManager.js.map

/***/ }),

/***/ 37421:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageManager = void 0;
/**
 * An abstraction for controlling the supported package managers: PNPM, NPM, and Yarn.
 * @beta
 */
class PackageManager {
    /** @internal */
    constructor(version, packageManager) {
        this.version = version;
        this.packageManager = packageManager;
    }
    /**
     * The filename of the shrinkwrap file that is used by the package manager.
     *
     * @remarks
     * Example: `npm-shrinkwrap.json` or `pnpm-lock.yaml`
     */
    get shrinkwrapFilename() {
        return this._shrinkwrapFilename;
    }
}
exports.PackageManager = PackageManager;
//# sourceMappingURL=PackageManager.js.map

/***/ }),

/***/ 27584:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PnpmPackageManager = void 0;
const semver = __importStar(__webpack_require__(11383));
const path = __importStar(__webpack_require__(85622));
const RushConstants_1 = __webpack_require__(63985);
const PackageManager_1 = __webpack_require__(37421);
/**
 * Support for interacting with the PNPM package manager.
 */
class PnpmPackageManager extends PackageManager_1.PackageManager {
    /** @internal */
    constructor(version) {
        super(version, 'pnpm');
        const parsedVersion = new semver.SemVer(version);
        if (parsedVersion.major >= 6) {
            // Introduced in version 6.0.0
            this._pnpmfileFilename = RushConstants_1.RushConstants.pnpmfileV6Filename;
        }
        else {
            this._pnpmfileFilename = RushConstants_1.RushConstants.pnpmfileV1Filename;
        }
        this._shrinkwrapFilename = RushConstants_1.RushConstants.pnpmV3ShrinkwrapFilename;
        // node_modules/.pnpm/lock.yaml
        // See https://github.com/pnpm/pnpm/releases/tag/v4.0.0 for more details.
        this.internalShrinkwrapRelativePath = path.join('node_modules', '.pnpm', 'lock.yaml');
    }
    /**
     * The filename of the shrinkwrap file that is used by the package manager.
     *
     * @remarks
     * Example: `pnpmfile.js` or `.pnpmfile.cjs`
     */
    get pnpmfileFilename() {
        return this._pnpmfileFilename;
    }
}
exports.PnpmPackageManager = PnpmPackageManager;
//# sourceMappingURL=PnpmPackageManager.js.map

/***/ }),

/***/ 44457:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.YarnPackageManager = void 0;
const RushConstants_1 = __webpack_require__(63985);
const PackageManager_1 = __webpack_require__(37421);
/**
 * Support for interacting with the Yarn package manager.
 */
class YarnPackageManager extends PackageManager_1.PackageManager {
    /** @internal */
    constructor(version) {
        super(version, 'yarn');
        this._shrinkwrapFilename = RushConstants_1.RushConstants.yarnShrinkwrapFilename;
    }
}
exports.YarnPackageManager = YarnPackageManager;
//# sourceMappingURL=YarnPackageManager.js.map

/***/ }),

/***/ 25574:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandLineMigrationAdvisor = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const terminal_1 = __webpack_require__(11253);
const RushConstants_1 = __webpack_require__(63985);
class CommandLineMigrationAdvisor {
    // NOTE: THIS RUNS BEFORE THE REAL COMMAND-LINE PARSING.
    // TAKE EXTREME CARE THAT THE HEURISTICS CANNOT FALSELY MATCH A VALID COMMAND LINE.
    static checkArgv(argv) {
        // 0=node.exe, 1=script name
        const args = process.argv.slice(2);
        if (args.length > 0) {
            if (args[0] === 'generate') {
                CommandLineMigrationAdvisor._reportDeprecated('Instead of "rush generate", use "rush update" or "rush update --full".');
                return false;
            }
            if (args[0] === 'install') {
                if (args.indexOf('--full-clean') >= 0) {
                    CommandLineMigrationAdvisor._reportDeprecated('Instead of "rush install --full-clean", use "rush purge --unsafe".');
                    return false;
                }
                if (args.indexOf('-C') >= 0) {
                    CommandLineMigrationAdvisor._reportDeprecated('Instead of "rush install -C", use "rush purge --unsafe".');
                    return false;
                }
                if (args.indexOf('--clean') >= 0) {
                    CommandLineMigrationAdvisor._reportDeprecated('Instead of "rush install --clean", use "rush install --purge".');
                    return false;
                }
                if (args.indexOf('-c') >= 0) {
                    CommandLineMigrationAdvisor._reportDeprecated('Instead of "rush install -c", use "rush install --purge".');
                    return false;
                }
            }
        }
        // Everything is okay
        return true;
    }
    static _reportDeprecated(message) {
        console.error(safe_1.default.red(terminal_1.PrintUtilities.wrapWords('ERROR: You specified an outdated command-line that is no longer supported by this version of Rush:')));
        console.error(safe_1.default.yellow(terminal_1.PrintUtilities.wrapWords(message)));
        console.error();
        console.error(terminal_1.PrintUtilities.wrapWords(`For command-line help, type "rush -h".  For migration instructions,` +
            ` please visit ${RushConstants_1.RushConstants.rushWebSiteUrl}`));
    }
}
exports.CommandLineMigrationAdvisor = CommandLineMigrationAdvisor;
//# sourceMappingURL=CommandLineMigrationAdvisor.js.map

/***/ }),

/***/ 4585:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RushCommandLineParser = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const ts_command_line_1 = __webpack_require__(36972);
const node_core_library_1 = __webpack_require__(24019);
const terminal_1 = __webpack_require__(11253);
const RushConfiguration_1 = __webpack_require__(92905);
const RushConstants_1 = __webpack_require__(63985);
const CommandLineConfiguration_1 = __webpack_require__(5347);
const Utilities_1 = __webpack_require__(89521);
const AddAction_1 = __webpack_require__(25679);
const ChangeAction_1 = __webpack_require__(45696);
const CheckAction_1 = __webpack_require__(18047);
const DeployAction_1 = __webpack_require__(57796);
const InitAction_1 = __webpack_require__(79123);
const InitAutoinstallerAction_1 = __webpack_require__(57977);
const InitDeployAction_1 = __webpack_require__(43441);
const InstallAction_1 = __webpack_require__(81507);
const LinkAction_1 = __webpack_require__(29693);
const ListAction_1 = __webpack_require__(9341);
const PublishAction_1 = __webpack_require__(26157);
const PurgeAction_1 = __webpack_require__(8596);
const ScanAction_1 = __webpack_require__(40379);
const UnlinkAction_1 = __webpack_require__(16287);
const UpdateAction_1 = __webpack_require__(35414);
const UpdateAutoinstallerAction_1 = __webpack_require__(34824);
const VersionAction_1 = __webpack_require__(85081);
const UpdateCloudCredentialsAction_1 = __webpack_require__(28714);
const WriteBuildCacheAction_1 = __webpack_require__(64575);
const BulkScriptAction_1 = __webpack_require__(19534);
const GlobalScriptAction_1 = __webpack_require__(7692);
const Telemetry_1 = __webpack_require__(48375);
const RushGlobalFolder_1 = __webpack_require__(96337);
const NodeJsCompatibility_1 = __webpack_require__(5252);
const SetupAction_1 = __webpack_require__(61296);
const EnvironmentConfiguration_1 = __webpack_require__(84018);
class RushCommandLineParser extends ts_command_line_1.CommandLineParser {
    constructor(options) {
        super({
            toolFilename: 'rush',
            toolDescription: 'Rush makes life easier for JavaScript developers who develop, build, and publish' +
                ' many packages from a central Git repo.  It is designed to handle very large repositories' +
                ' supporting many projects and people.  Rush provides policies, protections, and customizations' +
                ' that help coordinate teams and safely onboard new contributors.  Rush also generates change logs' +
                ' and automates package publishing.  It can manage decoupled subsets of projects with different' +
                ' release and versioning strategies.  A full API is included to facilitate integration with other' +
                ' automation tools.  If you are looking for a proven turnkey solution for monorepo management,' +
                ' Rush is for you.',
            enableTabCompletionAction: true
        });
        this._rushOptions = this._normalizeOptions(options || {});
        try {
            const rushJsonFilename = RushConfiguration_1.RushConfiguration.tryFindRushJsonLocation({
                startingFolder: this._rushOptions.cwd,
                showVerbose: !Utilities_1.Utilities.shouldRestrictConsoleOutput()
            });
            if (rushJsonFilename) {
                this.rushConfiguration = RushConfiguration_1.RushConfiguration.loadFromConfigurationFile(rushJsonFilename);
            }
        }
        catch (error) {
            this._reportErrorAndSetExitCode(error);
        }
        NodeJsCompatibility_1.NodeJsCompatibility.warnAboutCompatibilityIssues({
            isRushLib: true,
            alreadyReportedNodeTooNewError: this._rushOptions.alreadyReportedNodeTooNewError,
            rushConfiguration: this.rushConfiguration
        });
        this._populateActions();
    }
    get isDebug() {
        return this._debugParameter.value;
    }
    flushTelemetry() {
        if (this.telemetry) {
            this.telemetry.flush();
        }
    }
    onDefineParameters() {
        this._debugParameter = this.defineFlagParameter({
            parameterLongName: '--debug',
            parameterShortName: '-d',
            description: 'Show the full call stack if an error occurs while executing the tool'
        });
    }
    async onExecute() {
        // Defensively set the exit code to 1 so if Rush crashes for whatever reason, we'll have a nonzero exit code.
        // For example, Node.js currently has the inexcusable design of terminating with zero exit code when
        // there is an uncaught promise exception.  This will supposedly be fixed in Node.js 9.
        // Ideally we should do this for all the Rush actions, but "rush build" is the most critical one
        // -- if it falsely appears to succeed, we could merge bad PRs, publish empty packages, etc.
        process.exitCode = 1;
        if (this._debugParameter.value) {
            node_core_library_1.InternalError.breakInDebugger = true;
        }
        try {
            await this._wrapOnExecuteAsync();
            // If we make it here, everything went fine, so reset the exit code back to 0
            process.exitCode = 0;
        }
        catch (error) {
            this._reportErrorAndSetExitCode(error);
        }
    }
    _normalizeOptions(options) {
        return {
            cwd: options.cwd || process.cwd(),
            alreadyReportedNodeTooNewError: options.alreadyReportedNodeTooNewError || false
        };
    }
    async _wrapOnExecuteAsync() {
        if (this.rushConfiguration) {
            this.telemetry = new Telemetry_1.Telemetry(this.rushConfiguration);
        }
        await super.onExecute();
        if (this.telemetry) {
            this.flushTelemetry();
        }
    }
    _populateActions() {
        try {
            this.rushGlobalFolder = new RushGlobalFolder_1.RushGlobalFolder();
            // Alphabetical order
            this.addAction(new AddAction_1.AddAction(this));
            this.addAction(new ChangeAction_1.ChangeAction(this));
            this.addAction(new CheckAction_1.CheckAction(this));
            this.addAction(new DeployAction_1.DeployAction(this));
            this.addAction(new InitAction_1.InitAction(this));
            this.addAction(new InitAutoinstallerAction_1.InitAutoinstallerAction(this));
            this.addAction(new InitDeployAction_1.InitDeployAction(this));
            this.addAction(new InstallAction_1.InstallAction(this));
            this.addAction(new LinkAction_1.LinkAction(this));
            this.addAction(new ListAction_1.ListAction(this));
            this.addAction(new PublishAction_1.PublishAction(this));
            this.addAction(new PurgeAction_1.PurgeAction(this));
            this.addAction(new ScanAction_1.ScanAction(this));
            this.addAction(new SetupAction_1.SetupAction(this));
            this.addAction(new UnlinkAction_1.UnlinkAction(this));
            this.addAction(new UpdateAction_1.UpdateAction(this));
            this.addAction(new UpdateAutoinstallerAction_1.UpdateAutoinstallerAction(this));
            this.addAction(new UpdateCloudCredentialsAction_1.UpdateCloudCredentialsAction(this));
            this.addAction(new VersionAction_1.VersionAction(this));
            this.addAction(new WriteBuildCacheAction_1.WriteBuildCacheAction(this));
            this._populateScriptActions();
        }
        catch (error) {
            this._reportErrorAndSetExitCode(error);
        }
    }
    _populateScriptActions() {
        let commandLineConfiguration = undefined;
        // If there is not a rush.json file, we still want "build" and "rebuild" to appear in the
        // command-line help
        if (this.rushConfiguration) {
            const commandLineConfigFilePath = path.join(this.rushConfiguration.commonRushConfigFolder, RushConstants_1.RushConstants.commandLineFilename);
            commandLineConfiguration = CommandLineConfiguration_1.CommandLineConfiguration.loadFromFileOrDefault(commandLineConfigFilePath);
        }
        // Build actions from the command line configuration supersede default build actions.
        this._addCommandLineConfigActions(commandLineConfiguration);
        this._addDefaultBuildActions(commandLineConfiguration);
    }
    _addDefaultBuildActions(commandLineConfiguration) {
        if (!this.tryGetAction(RushConstants_1.RushConstants.buildCommandName)) {
            this._addCommandLineConfigAction(commandLineConfiguration, CommandLineConfiguration_1.CommandLineConfiguration.defaultBuildCommandJson);
        }
        if (!this.tryGetAction(RushConstants_1.RushConstants.rebuildCommandName)) {
            this._addCommandLineConfigAction(commandLineConfiguration, CommandLineConfiguration_1.CommandLineConfiguration.defaultRebuildCommandJson, RushConstants_1.RushConstants.buildCommandName);
        }
    }
    _addCommandLineConfigActions(commandLineConfiguration) {
        if (!commandLineConfiguration) {
            return;
        }
        // Register each custom command
        for (const command of commandLineConfiguration.commands.values()) {
            this._addCommandLineConfigAction(commandLineConfiguration, command);
        }
    }
    _addCommandLineConfigAction(commandLineConfiguration, command, commandToRun) {
        if (this.tryGetAction(command.name)) {
            throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a command "${command.name}"` +
                ` using a name that already exists`);
        }
        this._validateCommandLineConfigCommand(command);
        const overrideAllowWarnings = EnvironmentConfiguration_1.EnvironmentConfiguration.allowWarningsInSuccessfulBuild;
        switch (command.commandKind) {
            case RushConstants_1.RushConstants.bulkCommandKind: {
                this.addAction(new BulkScriptAction_1.BulkScriptAction({
                    actionName: command.name,
                    // By default, the "rebuild" action runs the "build" script. However, if the command-line.json file
                    // overrides "rebuild," the "rebuild" script should be run.
                    commandToRun: commandToRun,
                    summary: command.summary,
                    documentation: command.description || command.summary,
                    safeForSimultaneousRushProcesses: command.safeForSimultaneousRushProcesses,
                    parser: this,
                    commandLineConfiguration: commandLineConfiguration,
                    enableParallelism: command.enableParallelism,
                    ignoreMissingScript: command.ignoreMissingScript || false,
                    ignoreDependencyOrder: command.ignoreDependencyOrder || false,
                    incremental: command.incremental || false,
                    allowWarningsInSuccessfulBuild: overrideAllowWarnings || !!command.allowWarningsInSuccessfulBuild,
                    watchForChanges: command.watchForChanges || false,
                    disableBuildCache: command.disableBuildCache || false
                }));
                break;
            }
            case RushConstants_1.RushConstants.globalCommandKind: {
                this.addAction(new GlobalScriptAction_1.GlobalScriptAction({
                    actionName: command.name,
                    summary: command.summary,
                    documentation: command.description || command.summary,
                    safeForSimultaneousRushProcesses: command.safeForSimultaneousRushProcesses,
                    parser: this,
                    commandLineConfiguration: commandLineConfiguration,
                    shellCommand: command.shellCommand,
                    autoinstallerName: command.autoinstallerName
                }));
                break;
            }
            case RushConstants_1.RushConstants.phasedCommandKind: {
                if (!this.rushConfiguration.experimentsConfiguration.configuration._multiPhaseCommands) {
                    throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a command "${command.name}" ` +
                        `that uses the "${RushConstants_1.RushConstants.phasedCommandKind}" command kind. To use this command kind, ` +
                        'the "_multiPhaseCommands" experiment must be enabled. Note that this feature is not complete ' +
                        'and will not work as expected.');
                }
                // TODO
                break;
            }
            default:
                throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a command "${command.name}"` +
                    ` using an unsupported command kind "${command.commandKind}"`);
        }
    }
    _validateCommandLineConfigCommand(command) {
        // There are some restrictions on the 'build' and 'rebuild' commands.
        if (command.name !== RushConstants_1.RushConstants.buildCommandName &&
            command.name !== RushConstants_1.RushConstants.rebuildCommandName) {
            return;
        }
        if (command.commandKind !== RushConstants_1.RushConstants.bulkCommandKind &&
            command.commandKind !== RushConstants_1.RushConstants.phasedCommandKind) {
            throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a command "${command.name}" using ` +
                `the command kind "${RushConstants_1.RushConstants.globalCommandKind}". This command can only be designated as a command ` +
                `kind "${RushConstants_1.RushConstants.bulkCommandKind}" or "${RushConstants_1.RushConstants.phasedCommandKind}".`);
        }
        if (command.safeForSimultaneousRushProcesses) {
            throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a command "${command.name}" using ` +
                `"safeForSimultaneousRushProcesses=true". This configuration is not supported for "${command.name}".`);
        }
    }
    _reportErrorAndSetExitCode(error) {
        if (!(error instanceof node_core_library_1.AlreadyReportedError)) {
            const prefix = 'ERROR: ';
            console.error(os.EOL + safe_1.default.red(terminal_1.PrintUtilities.wrapWords(prefix + error.message)));
        }
        if (this._debugParameter.value) {
            // If catchSyncErrors() called this, then show a call stack similar to what Node.js
            // would show for an uncaught error
            console.error(os.EOL + error.stack);
        }
        this.flushTelemetry();
        // Ideally we want to eliminate all calls to process.exit() from our code, and replace them
        // with normal control flow that properly cleans up its data structures.
        // For this particular call, we have a problem that the RushCommandLineParser constructor
        // performs nontrivial work that can throw an exception.  Either the Rush class would need
        // to handle reporting for those exceptions, or else _populateActions() should be moved
        // to a RushCommandLineParser lifecycle stage that can handle it.
        if (process.exitCode !== undefined) {
            process.exit(process.exitCode);
        }
        else {
            process.exit(1);
        }
    }
}
exports.RushCommandLineParser = RushCommandLineParser;
//# sourceMappingURL=RushCommandLineParser.js.map

/***/ }),

/***/ 91811:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RushStartupBanner = void 0;
const os_1 = __webpack_require__(12087);
const safe_1 = __importDefault(__webpack_require__(41997));
const RushConstants_1 = __webpack_require__(63985);
const NodeJsCompatibility_1 = __webpack_require__(5252);
class RushStartupBanner {
    static logBanner(rushVersion, isManaged) {
        const nodeVersion = this._formatNodeVersion();
        const versionSuffix = rushVersion ? ' ' + this._formatRushVersion(rushVersion, isManaged) : '';
        console.log(os_1.EOL +
            safe_1.default.bold(`Rush Multi-Project Build Tool${versionSuffix}`) +
            safe_1.default.cyan(` - ${RushConstants_1.RushConstants.rushWebSiteUrl}`) +
            os_1.EOL +
            `Node.js version is ${nodeVersion}` +
            os_1.EOL);
    }
    static logStreamlinedBanner(rushVersion, isManaged) {
        const nodeVersion = this._formatNodeVersion();
        const versionSuffix = rushVersion ? ' ' + this._formatRushVersion(rushVersion, isManaged) : '';
        console.log(safe_1.default.bold(`Rush Multi-Project Build Tool${versionSuffix}`) + ` - Node.js ${nodeVersion}`);
    }
    static _formatNodeVersion() {
        const nodeVersion = process.versions.node;
        const nodeReleaseLabel = NodeJsCompatibility_1.NodeJsCompatibility.isOddNumberedVersion
            ? 'unstable'
            : NodeJsCompatibility_1.NodeJsCompatibility.isLtsVersion
                ? 'LTS'
                : 'pre-LTS';
        return `${nodeVersion} (${nodeReleaseLabel})`;
    }
    static _formatRushVersion(rushVersion, isManaged) {
        return rushVersion + safe_1.default.yellow(isManaged ? '' : ' (unmanaged)');
    }
}
exports.RushStartupBanner = RushStartupBanner;
//# sourceMappingURL=RushStartupBanner.js.map

/***/ }),

/***/ 6251:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RushXCommandLine = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const terminal_1 = __webpack_require__(11253);
const Utilities_1 = __webpack_require__(89521);
const ProjectCommandSet_1 = __webpack_require__(85777);
const Rush_1 = __webpack_require__(4876);
const RushConfiguration_1 = __webpack_require__(92905);
const NodeJsCompatibility_1 = __webpack_require__(5252);
const RushStartupBanner_1 = __webpack_require__(91811);
class RushXCommandLine {
    static launchRushX(launcherVersion, isManaged) {
        RushXCommandLine._launchRushXInternal(launcherVersion, { isManaged });
    }
    /**
     * @internal
     */
    static _launchRushXInternal(launcherVersion, options) {
        // Node.js can sometimes accidentally terminate with a zero exit code  (e.g. for an uncaught
        // promise exception), so we start with the assumption that the exit code is 1
        // and set it to 0 only on success.
        process.exitCode = 1;
        const args = this._getCommandLineArguments();
        if (!args.quiet) {
            RushStartupBanner_1.RushStartupBanner.logStreamlinedBanner(Rush_1.Rush.version, options.isManaged);
        }
        try {
            // Are we in a Rush repo?
            let rushConfiguration = undefined;
            if (RushConfiguration_1.RushConfiguration.tryFindRushJsonLocation()) {
                rushConfiguration = RushConfiguration_1.RushConfiguration.loadFromDefaultLocation({ showVerbose: false });
            }
            NodeJsCompatibility_1.NodeJsCompatibility.warnAboutCompatibilityIssues({
                isRushLib: true,
                alreadyReportedNodeTooNewError: !!options.alreadyReportedNodeTooNewError,
                rushConfiguration
            });
            // Find the governing package.json for this folder:
            const packageJsonLookup = new node_core_library_1.PackageJsonLookup();
            const packageJsonFilePath = packageJsonLookup.tryGetPackageJsonFilePathFor(process.cwd());
            if (!packageJsonFilePath) {
                console.log(safe_1.default.red('This command should be used inside a project folder.'));
                console.log(`Unable to find a package.json file in the current working directory or any of its parents.`);
                return;
            }
            if (rushConfiguration && !rushConfiguration.tryGetProjectForPath(process.cwd())) {
                // GitHub #2713: Users reported confusion resulting from a situation where "rush install"
                // did not install the project's dependencies, because the project was not registered.
                console.log(safe_1.default.yellow('Warning: You are invoking "rushx" inside a Rush repository, but this project is not registered in rush.json.'));
            }
            const packageJson = packageJsonLookup.loadPackageJson(packageJsonFilePath);
            const projectCommandSet = new ProjectCommandSet_1.ProjectCommandSet(packageJson);
            if (args.help) {
                RushXCommandLine._showUsage(packageJson, projectCommandSet);
                return;
            }
            const scriptBody = projectCommandSet.tryGetScriptBody(args.commandName);
            if (scriptBody === undefined) {
                console.log(safe_1.default.red(`Error: The command "${args.commandName}" is not defined in the` +
                    ` package.json file for this project.`));
                if (projectCommandSet.commandNames.length > 0) {
                    console.log(os.EOL +
                        'Available commands for this project are: ' +
                        projectCommandSet.commandNames.map((x) => `"${x}"`).join(', '));
                }
                console.log(`Use ${safe_1.default.yellow('"rushx --help"')} for more information.`);
                return;
            }
            let commandWithArgs = scriptBody;
            let commandWithArgsForDisplay = scriptBody;
            if (args.commandArgs.length > 0) {
                // This approach is based on what NPM 7 now does:
                // https://github.com/npm/run-script/blob/47a4d539fb07220e7215cc0e482683b76407ef9b/lib/run-script-pkg.js#L34
                const escapedRemainingArgs = args.commandArgs.map((x) => Utilities_1.Utilities.escapeShellParameter(x));
                commandWithArgs += ' ' + escapedRemainingArgs.join(' ');
                // Display it nicely without the extra quotes
                commandWithArgsForDisplay += ' ' + args.commandArgs.join(' ');
            }
            if (!args.quiet) {
                console.log('> ' + JSON.stringify(commandWithArgsForDisplay) + os.EOL);
            }
            const packageFolder = path.dirname(packageJsonFilePath);
            const exitCode = Utilities_1.Utilities.executeLifecycleCommand(commandWithArgs, {
                rushConfiguration,
                workingDirectory: packageFolder,
                // If there is a rush.json then use its .npmrc from the temp folder.
                // Otherwise look for npmrc in the project folder.
                initCwd: rushConfiguration ? rushConfiguration.commonTempFolder : packageFolder,
                handleOutput: false,
                environmentPathOptions: {
                    includeProjectBin: true
                }
            });
            if (exitCode > 0) {
                console.log(safe_1.default.red(`The script failed with exit code ${exitCode}`));
            }
            process.exitCode = exitCode;
        }
        catch (error) {
            console.log(safe_1.default.red('Error: ' + error.message));
        }
    }
    static _getCommandLineArguments() {
        // 0 = node.exe
        // 1 = rushx
        const args = process.argv.slice(2);
        const unknownArgs = [];
        let help = false;
        let quiet = false;
        let commandName = '';
        const commandArgs = [];
        for (let index = 0; index < args.length; index++) {
            const argValue = args[index];
            if (!commandName) {
                if (argValue === '-q' || argValue === '--quiet') {
                    quiet = true;
                }
                else if (argValue === '-h' || argValue === '--help') {
                    help = true;
                }
                else if (argValue.startsWith('-')) {
                    unknownArgs.push(args[index]);
                }
                else {
                    commandName = args[index];
                }
            }
            else {
                commandArgs.push(args[index]);
            }
        }
        if (!commandName) {
            help = true;
        }
        if (unknownArgs.length > 0) {
            // Future TODO: Instead of just displaying usage info, we could display a
            // specific error about the unknown flag the user tried to pass to rushx.
            help = true;
        }
        return {
            help,
            quiet,
            commandName,
            commandArgs
        };
    }
    static _showUsage(packageJson, projectCommandSet) {
        console.log('usage: rushx [-h]');
        console.log('       rushx [-q/--quiet] <command> ...' + os.EOL);
        console.log('Optional arguments:');
        console.log('  -h, --help            Show this help message and exit.');
        console.log('  -q, --quiet           Hide rushx startup information.' + os.EOL);
        if (projectCommandSet.commandNames.length > 0) {
            console.log(`Project commands for ${safe_1.default.cyan(packageJson.name)}:`);
            // Calculate the length of the longest script name, for formatting
            let maxLength = 0;
            for (const commandName of projectCommandSet.commandNames) {
                maxLength = Math.max(maxLength, commandName.length);
            }
            for (const commandName of projectCommandSet.commandNames) {
                const escapedScriptBody = JSON.stringify(projectCommandSet.getScriptBody(commandName));
                // The length of the string e.g. "  command: "
                const firstPartLength = 2 + maxLength + 2;
                // The length for truncating the escaped escapedScriptBody so it doesn't wrap
                // to the next line
                const consoleWidth = terminal_1.PrintUtilities.getConsoleWidth() || terminal_1.DEFAULT_CONSOLE_WIDTH;
                const truncateLength = Math.max(0, consoleWidth - firstPartLength) - 1;
                console.log(
                // Example: "  command: "
                '  ' +
                    safe_1.default.cyan(node_core_library_1.Text.padEnd(commandName + ':', maxLength + 2)) +
                    // Example: "do some thin..."
                    node_core_library_1.Text.truncateWithEllipsis(escapedScriptBody, truncateLength));
            }
            if (projectCommandSet.malformedScriptNames.length > 0) {
                console.log(os.EOL +
                    safe_1.default.yellow('Warning: Some "scripts" entries in the package.json file' +
                        ' have malformed names: ' +
                        projectCommandSet.malformedScriptNames.map((x) => `"${x}"`).join(', ')));
            }
        }
        else {
            console.log(safe_1.default.yellow('Warning: No commands are defined yet for this project.'));
            console.log('You can define a command by adding a "scripts" table to the project\'s package.json file.');
        }
    }
}
exports.RushXCommandLine = RushXCommandLine;
//# sourceMappingURL=RushXCommandLine.js.map

/***/ }),

/***/ 96724:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionParameterSet = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const node_core_library_1 = __webpack_require__(24019);
const Selection_1 = __webpack_require__(13857);
/**
 * This class is provides the set of command line parameters used to select projects
 * based on dependencies.
 *
 * It is a separate component such that unrelated actions can share the same parameters.
 */
class SelectionParameterSet {
    constructor(rushConfiguration, action) {
        this._rushConfiguration = rushConfiguration;
        const getProjectNames = this._getProjectNames.bind(this);
        this._toProject = action.defineStringListParameter({
            parameterLongName: '--to',
            parameterShortName: '-t',
            argumentName: 'PROJECT',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' Each "--to" parameter expands this selection to include PROJECT and all its dependencies.' +
                ' "." can be used as shorthand for the project in the current working directory.' +
                ' For details, refer to the website article "Selecting subsets of projects".',
            completions: getProjectNames
        });
        this._toExceptProject = action.defineStringListParameter({
            parameterLongName: '--to-except',
            parameterShortName: '-T',
            argumentName: 'PROJECT',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' Each "--to-except" parameter expands this selection to include all dependencies of PROJECT,' +
                ' but not PROJECT itself.' +
                ' "." can be used as shorthand for the project in the current working directory.' +
                ' For details, refer to the website article "Selecting subsets of projects".',
            completions: getProjectNames
        });
        this._fromProject = action.defineStringListParameter({
            parameterLongName: '--from',
            parameterShortName: '-f',
            argumentName: 'PROJECT',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' Each "--from" parameter expands this selection to include PROJECT and all projects that depend on it,' +
                ' plus all dependencies of this set.' +
                ' "." can be used as shorthand for the project in the current working directory.' +
                ' For details, refer to the website article "Selecting subsets of projects".',
            completions: getProjectNames
        });
        this._onlyProject = action.defineStringListParameter({
            parameterLongName: '--only',
            parameterShortName: '-o',
            argumentName: 'PROJECT',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' Each "--only" parameter expands this selection to include PROJECT; its dependencies are not added.' +
                ' "." can be used as shorthand for the project in the current working directory.' +
                ' Note that this parameter is "unsafe" as it may produce a selection that excludes some dependencies.' +
                ' For details, refer to the website article "Selecting subsets of projects".',
            completions: getProjectNames
        });
        this._impactedByProject = action.defineStringListParameter({
            parameterLongName: '--impacted-by',
            parameterShortName: '-i',
            argumentName: 'PROJECT',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' Each "--impacted-by" parameter expands this selection to include PROJECT and any projects that' +
                ' depend on PROJECT (and thus might be broken by changes to PROJECT).' +
                ' "." can be used as shorthand for the project in the current working directory.' +
                ' Note that this parameter is "unsafe" as it may produce a selection that excludes some dependencies.' +
                ' For details, refer to the website article "Selecting subsets of projects".',
            completions: getProjectNames
        });
        this._impactedByExceptProject = action.defineStringListParameter({
            parameterLongName: '--impacted-by-except',
            parameterShortName: '-I',
            argumentName: 'PROJECT',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' Each "--impacted-by-except" parameter works the same as "--impacted-by" except that PROJECT itself' +
                ' is not added to the selection.' +
                ' "." can be used as shorthand for the project in the current working directory.' +
                ' Note that this parameter is "unsafe" as it may produce a selection that excludes some dependencies.' +
                ' For details, refer to the website article "Selecting subsets of projects".',
            completions: getProjectNames
        });
        this._toVersionPolicy = action.defineStringListParameter({
            parameterLongName: '--to-version-policy',
            argumentName: 'VERSION_POLICY_NAME',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' The "--to-version-policy" parameter is equivalent to specifying "--to" for each of the projects' +
                ' belonging to VERSION_POLICY_NAME.' +
                ' For details, refer to the website article "Selecting subsets of projects".'
        });
        this._fromVersionPolicy = action.defineStringListParameter({
            parameterLongName: '--from-version-policy',
            argumentName: 'VERSION_POLICY_NAME',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' The "--from-version-policy" parameter is equivalent to specifying "--from" for each of the projects' +
                ' belonging to VERSION_POLICY_NAME.' +
                ' For details, refer to the website article "Selecting subsets of projects".'
        });
    }
    /**
     * Computes the set of selected projects based on all parameter values.
     *
     * If no parameters are specified, returns all projects in the Rush config file.
     */
    getSelectedProjects() {
        // Check if any of the selection parameters have a value specified on the command line
        const isSelectionSpecified = [
            this._onlyProject,
            this._fromProject,
            this._fromVersionPolicy,
            this._toProject,
            this._toVersionPolicy,
            this._toExceptProject,
            this._impactedByProject,
            this._impactedByExceptProject
        ].some((param) => param.values.length > 0);
        // If no selection parameters are specified, return everything
        if (!isSelectionSpecified) {
            return new Set(this._rushConfiguration.projects);
        }
        // Include exactly these projects (--only)
        const onlyProjects = this._evaluateProjectParameter(this._onlyProject);
        // Include all projects that depend on these projects, and all dependencies thereof
        const fromProjects = Selection_1.Selection.union(
        // --from
        this._evaluateProjectParameter(this._fromProject), 
        // --from-version-policy
        this._evaluateVersionPolicyProjects(this._fromVersionPolicy));
        // Include dependencies of these projects
        const toProjects = Selection_1.Selection.union(
        // --to
        this._evaluateProjectParameter(this._toProject), 
        // --to-version-policy
        this._evaluateVersionPolicyProjects(this._toVersionPolicy), 
        // --to-except
        Selection_1.Selection.directDependenciesOf(this._evaluateProjectParameter(this._toExceptProject)), 
        // --from / --from-version-policy
        Selection_1.Selection.expandAllConsumers(fromProjects));
        // These projects will not have their dependencies included
        const impactedByProjects = Selection_1.Selection.union(
        // --impacted-by
        this._evaluateProjectParameter(this._impactedByProject), 
        // --impacted-by-except
        Selection_1.Selection.directConsumersOf(this._evaluateProjectParameter(this._impactedByExceptProject)));
        const selection = Selection_1.Selection.union(onlyProjects, Selection_1.Selection.expandAllDependencies(toProjects), 
        // Only dependents of these projects, not dependencies
        Selection_1.Selection.expandAllConsumers(impactedByProjects));
        return selection;
    }
    /**
     * Represents the selection as `--filter` parameters to pnpm.
     *
     * @remarks
     * This is a separate from the selection to allow the filters to be represented more concisely.
     *
     * @see https://pnpm.js.org/en/filtering
     */
    getPnpmFilterArguments() {
        const args = [];
        // Include exactly these projects (--only)
        for (const project of this._evaluateProjectParameter(this._onlyProject)) {
            args.push('--filter', project.packageName);
        }
        // Include all projects that depend on these projects, and all dependencies thereof
        const fromProjects = Selection_1.Selection.union(
        // --from
        this._evaluateProjectParameter(this._fromProject), 
        // --from-version-policy
        this._evaluateVersionPolicyProjects(this._fromVersionPolicy));
        // All specified projects and all projects that they depend on
        for (const project of Selection_1.Selection.union(
        // --to
        this._evaluateProjectParameter(this._toProject), 
        // --to-version-policy
        this._evaluateVersionPolicyProjects(this._toVersionPolicy), 
        // --from / --from-version-policy
        Selection_1.Selection.expandAllConsumers(fromProjects))) {
            args.push('--filter', `${project.packageName}...`);
        }
        // --to-except
        // All projects that the project directly or indirectly declares as a dependency
        for (const project of this._evaluateProjectParameter(this._toExceptProject)) {
            args.push('--filter', `${project.packageName}^...`);
        }
        // --impacted-by
        // The project and all projects directly or indirectly declare it as a dependency
        for (const project of this._evaluateProjectParameter(this._impactedByProject)) {
            args.push('--filter', `...${project.packageName}`);
        }
        // --impacted-by-except
        // All projects that directly or indirectly declare the specified project as a dependency
        for (const project of this._evaluateProjectParameter(this._impactedByExceptProject)) {
            args.push('--filter', `...^${project.packageName}`);
        }
        return args;
    }
    /**
     * Usage telemetry for selection parameters. Only saved locally, and if requested in the config.
     */
    getTelemetry() {
        return {
            command_from: `${this._fromProject.values.length > 0}`,
            command_impactedBy: `${this._impactedByProject.values.length > 0}`,
            command_impactedByExcept: `${this._impactedByExceptProject.values.length > 0}`,
            command_only: `${this._onlyProject.values.length > 0}`,
            command_to: `${this._toProject.values.length > 0}`,
            command_toExcept: `${this._toExceptProject.values.length > 0}`,
            command_fromVersionPolicy: `${this._fromVersionPolicy.values.length > 0}`,
            command_toVersionPolicy: `${this._toVersionPolicy.values.length > 0}`
        };
    }
    /**
     * Computes the referents of parameters that accept a project identifier.
     * Handles '.', unscoped names, and scoped names.
     */
    *_evaluateProjectParameter(projectsParameters) {
        const packageJsonLookup = node_core_library_1.PackageJsonLookup.instance;
        for (const projectParameter of projectsParameters.values) {
            if (projectParameter === '.') {
                const packageJson = packageJsonLookup.tryLoadPackageJsonFor(process.cwd());
                if (packageJson) {
                    const project = this._rushConfiguration.getProjectByName(packageJson.name);
                    if (project) {
                        yield project;
                    }
                    else {
                        console.log(safe_1.default.red('Rush is not currently running in a project directory specified in rush.json. ' +
                            `The "." value for the ${projectsParameters.longName} parameter is not allowed.`));
                        throw new node_core_library_1.AlreadyReportedError();
                    }
                }
                else {
                    console.log(safe_1.default.red('Rush is not currently running in a project directory. ' +
                        `The "." value for the ${projectsParameters.longName} parameter is not allowed.`));
                    throw new node_core_library_1.AlreadyReportedError();
                }
            }
            else {
                const project = this._rushConfiguration.findProjectByShorthandName(projectParameter);
                if (!project) {
                    console.log(safe_1.default.red(`The project '${projectParameter}' does not exist in rush.json.`));
                    throw new node_core_library_1.AlreadyReportedError();
                }
                yield project;
            }
        }
    }
    /**
     * Computes the set of available project names, for use by tab completion.
     */
    async _getProjectNames() {
        const unscopedNamesMap = new Map();
        const scopedNames = new Set();
        for (const project of this._rushConfiguration.rushConfigurationJson.projects) {
            scopedNames.add(project.packageName);
            const unscopedName = node_core_library_1.PackageName.getUnscopedName(project.packageName);
            const count = unscopedNamesMap.get(unscopedName) || 0;
            unscopedNamesMap.set(unscopedName, count + 1);
        }
        const unscopedNames = [];
        for (const [unscopedName, unscopedNameCount] of unscopedNamesMap) {
            // don't suggest ambiguous unscoped names
            if (unscopedNameCount === 1 && !scopedNames.has(unscopedName)) {
                unscopedNames.push(unscopedName);
            }
        }
        return unscopedNames.sort().concat([...scopedNames].sort());
    }
    /**
     * Computes the set of projects that have the specified version policy
     */
    *_evaluateVersionPolicyProjects(versionPoliciesParameters) {
        if (versionPoliciesParameters.values && versionPoliciesParameters.values.length > 0) {
            const policyNames = new Set(versionPoliciesParameters.values);
            for (const policyName of policyNames) {
                if (!this._rushConfiguration.versionPolicyConfiguration.versionPolicies.has(policyName)) {
                    console.log(safe_1.default.red(`The version policy '${policyName}' does not exist in version-policies.json.`));
                    throw new node_core_library_1.AlreadyReportedError();
                }
            }
            for (const project of this._rushConfiguration.projects) {
                const matches = !!project.versionPolicyName && policyNames.has(project.versionPolicyName);
                if (matches) {
                    yield project;
                }
            }
        }
    }
}
exports.SelectionParameterSet = SelectionParameterSet;
//# sourceMappingURL=SelectionParameterSet.js.map

/***/ }),

/***/ 25679:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddAction = void 0;
const os = __importStar(__webpack_require__(12087));
const semver = __importStar(__webpack_require__(11383));
const node_core_library_1 = __webpack_require__(24019);
const BaseRushAction_1 = __webpack_require__(46677);
const DependencySpecifier_1 = __webpack_require__(179);
const packageJsonUpdaterModule = node_core_library_1.Import.lazy('../../logic/PackageJsonUpdater', require);
class AddAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        const documentation = [
            'Adds specified package(s) to the dependencies of the current project (as determined by the current working directory)' +
                ' and then runs "rush update". If no version is specified, a version will be automatically detected (typically' +
                ' either the latest version or a version that won\'t break the "ensureConsistentVersions" policy). If a version' +
                ' range (or a workspace range) is specified, the latest version in the range will be used. The version will be' +
                ' automatically prepended with a tilde, unless the "--exact" or "--caret" flags are used. The "--make-consistent"' +
                ' flag can be used to update all packages with the dependency.'
        ];
        super({
            actionName: 'add',
            summary: 'Adds one or more dependencies to the package.json and runs rush upgrade.',
            documentation: documentation.join(os.EOL),
            safeForSimultaneousRushProcesses: false,
            parser
        });
    }
    onDefineParameters() {
        this._packageNameList = this.defineStringListParameter({
            parameterLongName: '--package',
            parameterShortName: '-p',
            required: true,
            argumentName: 'PACKAGE',
            description: '(Required) The name of the package which should be added as a dependency.' +
                ' A SemVer version specifier can be appended after an "@" sign.  WARNING: Symbol characters' +
                " are usually interpreted by your shell, so it's recommended to use quotes." +
                ' For example, write "rush add --package "example@^1.2.3"" instead of "rush add --package example@^1.2.3".' +
                ' To add multiple packages, write "rush add --package foo --package bar".'
        });
        this._exactFlag = this.defineFlagParameter({
            parameterLongName: '--exact',
            description: 'If specified, the SemVer specifier added to the' +
                ' package.json will be an exact version (e.g. without tilde or caret).'
        });
        this._caretFlag = this.defineFlagParameter({
            parameterLongName: '--caret',
            description: 'If specified, the SemVer specifier added to the' +
                ' package.json will be a prepended with a "caret" specifier ("^").'
        });
        this._devDependencyFlag = this.defineFlagParameter({
            parameterLongName: '--dev',
            description: 'If specified, the package will be added to the "devDependencies" section of the package.json'
        });
        this._makeConsistentFlag = this.defineFlagParameter({
            parameterLongName: '--make-consistent',
            parameterShortName: '-m',
            description: 'If specified, other packages with this dependency will have their package.json' +
                ' files updated to use the same version of the dependency.'
        });
        this._skipUpdateFlag = this.defineFlagParameter({
            parameterLongName: '--skip-update',
            parameterShortName: '-s',
            description: 'If specified, the "rush update" command will not be run after updating the package.json files.'
        });
        this._allFlag = this.defineFlagParameter({
            parameterLongName: '--all',
            description: 'If specified, the dependency will be added to all projects.'
        });
    }
    async runAsync() {
        let projects;
        if (this._allFlag.value) {
            projects = this.rushConfiguration.projects;
        }
        else {
            const currentProject = this.rushConfiguration.tryGetProjectForPath(process.cwd());
            if (!currentProject) {
                throw new Error('The "rush add" command must be invoked under a project' +
                    ` folder that is registered in rush.json unless the ${this._allFlag.longName} is used.`);
            }
            projects = [currentProject];
        }
        if (this._caretFlag.value && this._exactFlag.value) {
            throw new Error(`Only one of "${this._caretFlag.longName}" and "${this._exactFlag.longName}" should be specified`);
        }
        const specifiedPackageNameList = this._packageNameList.values;
        const packageNames = [];
        const initialVersions = new Map();
        const rangeStyles = new Map();
        for (const specifiedPackageName of specifiedPackageNameList) {
            /**
             * Name & Version
             */
            let packageName = specifiedPackageName;
            let version = undefined;
            const parts = packageName.split('@');
            if (parts[0] === '') {
                // this is a scoped package
                packageName = '@' + parts[1];
                version = parts[2];
            }
            else {
                packageName = parts[0];
                version = parts[1];
            }
            if (!this.rushConfiguration.packageNameParser.isValidName(packageName)) {
                throw new Error(`The package name "${packageName}" is not valid.`);
            }
            if (version && version !== 'latest') {
                const specifier = new DependencySpecifier_1.DependencySpecifier(packageName, version);
                if (!semver.validRange(specifier.versionSpecifier) && !semver.valid(specifier.versionSpecifier)) {
                    throw new Error(`The SemVer specifier "${version}" is not valid.`);
                }
            }
            packageNames.push(packageName);
            initialVersions.set(packageName, version);
            /**
             * RangeStyle
             */
            let rangeStyle;
            if (version && version !== 'latest') {
                if (this._exactFlag.value || this._caretFlag.value) {
                    throw new Error(`The "${this._caretFlag.longName}" and "${this._exactFlag.longName}" flags may not be specified if a ` +
                        `version is provided in the ${this._packageNameList.longName} specifier. In this case "${version}" was provided.`);
                }
                rangeStyle = "passthrough" /* Passthrough */;
            }
            else {
                rangeStyle = this._caretFlag.value
                    ? "caret" /* Caret */
                    : this._exactFlag.value
                        ? "exact" /* Exact */
                        : "tilde" /* Tilde */;
            }
            rangeStyles.set(packageName, rangeStyle);
        }
        const updater = new packageJsonUpdaterModule.PackageJsonUpdater(this.rushConfiguration, this.rushGlobalFolder);
        await updater.doRushAdd({
            projects: projects,
            packageNames,
            initialVersions,
            devDependency: this._devDependencyFlag.value,
            updateOtherPackages: this._makeConsistentFlag.value,
            skipUpdate: this._skipUpdateFlag.value,
            debugInstall: this.parser.isDebug,
            rangeStyles
        });
    }
}
exports.AddAction = AddAction;
//# sourceMappingURL=AddAction.js.map

/***/ }),

/***/ 91343:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseInstallAction = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const os = __importStar(__webpack_require__(12087));
const node_core_library_1 = __webpack_require__(24019);
const BaseRushAction_1 = __webpack_require__(46677);
const EventHooks_1 = __webpack_require__(92330);
const PurgeManager_1 = __webpack_require__(28805);
const SetupChecks_1 = __webpack_require__(96766);
const StandardScriptUpdater_1 = __webpack_require__(18821);
const Stopwatch_1 = __webpack_require__(80414);
const VersionMismatchFinder_1 = __webpack_require__(81372);
const Variants_1 = __webpack_require__(36315);
const RushConstants_1 = __webpack_require__(63985);
const installManagerFactoryModule = node_core_library_1.Import.lazy('../../logic/InstallManagerFactory', require);
/**
 * This is the common base class for InstallAction and UpdateAction.
 */
class BaseInstallAction extends BaseRushAction_1.BaseRushAction {
    onDefineParameters() {
        this._purgeParameter = this.defineFlagParameter({
            parameterLongName: '--purge',
            parameterShortName: '-p',
            description: 'Perform "rush purge" before starting the installation'
        });
        this._bypassPolicyParameter = this.defineFlagParameter({
            parameterLongName: '--bypass-policy',
            description: 'Overrides enforcement of the "gitPolicy" rules from rush.json (use honorably!)'
        });
        this._noLinkParameter = this.defineFlagParameter({
            parameterLongName: '--no-link',
            description: 'If "--no-link" is specified, then project symlinks will NOT be created' +
                ' after the installation completes.  You will need to run "rush link" manually.' +
                ' This flag is useful for automated builds that want to report stages individually' +
                ' or perform extra operations in between the two stages. This flag is not supported' +
                ' when using workspaces.'
        });
        this._networkConcurrencyParameter = this.defineIntegerParameter({
            parameterLongName: '--network-concurrency',
            argumentName: 'COUNT',
            description: 'If specified, limits the maximum number of concurrent network requests.' +
                '  This is useful when troubleshooting network failures.'
        });
        this._debugPackageManagerParameter = this.defineFlagParameter({
            parameterLongName: '--debug-package-manager',
            description: 'Activates verbose logging for the package manager. You will probably want to pipe' +
                ' the output of Rush to a file when using this command.'
        });
        this._maxInstallAttempts = this.defineIntegerParameter({
            parameterLongName: '--max-install-attempts',
            argumentName: 'NUMBER',
            description: `Overrides the default maximum number of install attempts.`,
            defaultValue: RushConstants_1.RushConstants.defaultMaxInstallAttempts
        });
        this._ignoreHooksParameter = this.defineFlagParameter({
            parameterLongName: '--ignore-hooks',
            description: `Skips execution of the "eventHooks" scripts defined in rush.json. Make sure you know what you are skipping.`
        });
        this._variant = this.defineStringParameter(Variants_1.Variants.VARIANT_PARAMETER);
    }
    async runAsync() {
        VersionMismatchFinder_1.VersionMismatchFinder.ensureConsistentVersions(this.rushConfiguration, {
            variant: this._variant.value
        });
        const stopwatch = Stopwatch_1.Stopwatch.start();
        SetupChecks_1.SetupChecks.validate(this.rushConfiguration);
        let warnAboutScriptUpdate = false;
        if (this.actionName === 'update') {
            warnAboutScriptUpdate = StandardScriptUpdater_1.StandardScriptUpdater.update(this.rushConfiguration);
        }
        else {
            StandardScriptUpdater_1.StandardScriptUpdater.validate(this.rushConfiguration);
        }
        this.eventHooksManager.handle(EventHooks_1.Event.preRushInstall, this.parser.isDebug, this._ignoreHooksParameter.value);
        const purgeManager = new PurgeManager_1.PurgeManager(this.rushConfiguration, this.rushGlobalFolder);
        if (this._purgeParameter.value) {
            console.log('The --purge flag was specified, so performing "rush purge"');
            purgeManager.purgeNormal();
            console.log('');
        }
        if (this._networkConcurrencyParameter.value) {
            if (this.rushConfiguration.packageManager !== 'pnpm') {
                throw new Error(`The "${this._networkConcurrencyParameter.longName}" parameter is` +
                    ` only supported when using the PNPM package manager.`);
            }
        }
        // Because the 'defaultValue' option on the _maxInstallAttempts parameter is set,
        // it is safe to assume that the value is not null
        if (this._maxInstallAttempts.value < 1) {
            throw new Error(`The value of "${this._maxInstallAttempts.longName}" must be positive and nonzero.`);
        }
        const installManagerOptions = this.buildInstallOptions();
        const installManager = installManagerFactoryModule.InstallManagerFactory.getInstallManager(this.rushConfiguration, this.rushGlobalFolder, purgeManager, installManagerOptions);
        let installSuccessful = true;
        try {
            await installManager.doInstallAsync();
            this.eventHooksManager.handle(EventHooks_1.Event.postRushInstall, this.parser.isDebug, this._ignoreHooksParameter.value);
            if (warnAboutScriptUpdate) {
                console.log(os.EOL +
                    safe_1.default.yellow('Rush refreshed some files in the "common/scripts" folder.' +
                        '  Please commit this change to Git.'));
            }
            console.log(os.EOL + safe_1.default.green(`Rush ${this.actionName} finished successfully. (${stopwatch.toString()})`));
        }
        catch (error) {
            installSuccessful = false;
            throw error;
        }
        finally {
            purgeManager.deleteAll();
            stopwatch.stop();
            this._collectTelemetry(stopwatch, installManagerOptions, installSuccessful);
        }
    }
    _collectTelemetry(stopwatch, installManagerOptions, success) {
        var _a;
        if (this.parser.telemetry) {
            const extraData = Object.assign(Object.assign({ mode: this.actionName, clean: (!!this._purgeParameter.value).toString(), debug: installManagerOptions.debug.toString(), full: installManagerOptions.fullUpgrade.toString() }, this.getParameterStringMap()), (_a = this._selectionParameters) === null || _a === void 0 ? void 0 : _a.getTelemetry());
            this.parser.telemetry.log({
                name: 'install',
                duration: stopwatch.duration,
                result: success ? 'Succeeded' : 'Failed',
                extraData
            });
        }
    }
}
exports.BaseInstallAction = BaseInstallAction;
//# sourceMappingURL=BaseInstallAction.js.map

/***/ }),

/***/ 46677:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseRushAction = exports.BaseConfiglessRushAction = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const ts_command_line_1 = __webpack_require__(36972);
const node_core_library_1 = __webpack_require__(24019);
const EventHooksManager_1 = __webpack_require__(96461);
const Utilities_1 = __webpack_require__(89521);
/**
 * The base class for a few specialized Rush command-line actions that
 * can be used without a rush.json configuration.
 */
class BaseConfiglessRushAction extends ts_command_line_1.CommandLineAction {
    constructor(options) {
        super(options);
        this._parser = options.parser;
        this._safeForSimultaneousRushProcesses = !!options.safeForSimultaneousRushProcesses;
    }
    get rushConfiguration() {
        return this._parser.rushConfiguration;
    }
    get rushGlobalFolder() {
        return this._parser.rushGlobalFolder;
    }
    get parser() {
        return this._parser;
    }
    onExecute() {
        this._ensureEnvironment();
        if (this.rushConfiguration) {
            if (!this._safeForSimultaneousRushProcesses) {
                if (!node_core_library_1.LockFile.tryAcquire(this.rushConfiguration.commonTempFolder, 'rush')) {
                    console.log(safe_1.default.red(`Another Rush command is already running in this repository.`));
                    process.exit(1);
                }
            }
        }
        if (!Utilities_1.Utilities.shouldRestrictConsoleOutput()) {
            console.log(`Starting "rush ${this.actionName}"${os.EOL}`);
        }
        return this.runAsync();
    }
    _ensureEnvironment() {
        if (this.rushConfiguration) {
            // eslint-disable-next-line dot-notation
            let environmentPath = process.env['PATH'];
            environmentPath =
                path.join(this.rushConfiguration.commonTempFolder, 'node_modules', '.bin') +
                    path.delimiter +
                    environmentPath;
            // eslint-disable-next-line dot-notation
            process.env['PATH'] = environmentPath;
        }
    }
}
exports.BaseConfiglessRushAction = BaseConfiglessRushAction;
/**
 * The base class that most Rush command-line actions should extend.
 */
class BaseRushAction extends BaseConfiglessRushAction {
    get eventHooksManager() {
        if (!this._eventHooksManager) {
            this._eventHooksManager = new EventHooksManager_1.EventHooksManager(this.rushConfiguration);
        }
        return this._eventHooksManager;
    }
    get rushConfiguration() {
        return super.rushConfiguration;
    }
    onExecute() {
        if (!this.rushConfiguration) {
            throw Utilities_1.Utilities.getRushConfigNotFoundError();
        }
        return super.onExecute();
    }
}
exports.BaseRushAction = BaseRushAction;
//# sourceMappingURL=BaseRushAction.js.map

/***/ }),

/***/ 45696:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChangeAction = void 0;
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const child_process = __importStar(__webpack_require__(63129));
const safe_1 = __importDefault(__webpack_require__(41997));
const node_core_library_1 = __webpack_require__(24019);
const ChangeManagement_1 = __webpack_require__(6877);
const ChangeFile_1 = __webpack_require__(49915);
const BaseRushAction_1 = __webpack_require__(46677);
const ChangeFiles_1 = __webpack_require__(63799);
const VersionPolicy_1 = __webpack_require__(78075);
const ProjectChangeAnalyzer_1 = __webpack_require__(15504);
const Git_1 = __webpack_require__(58361);
const inquirer = node_core_library_1.Import.lazy('inquirer', require);
class ChangeAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        const documentation = [
            'Asks a series of questions and then generates a <branchname>-<timestamp>.json file ' +
                'in the common folder. The `publish` command will consume these files and perform the proper ' +
                'version bumps. Note these changes will eventually be published in a changelog.md file in each package.',
            '',
            'The possible types of changes are: ',
            '',
            'MAJOR - these are breaking changes that are not backwards compatible. ' +
                'Examples are: renaming a public class, adding/removing a non-optional ' +
                'parameter from a public API, or renaming an variable or function that ' +
                'is exported.',
            '',
            'MINOR - these are changes that are backwards compatible (but not ' +
                'forwards compatible). Examples are: adding a new public API or adding an ' +
                'optional parameter to a public API',
            '',
            'PATCH - these are changes that are backwards and forwards compatible. ' +
                'Examples are: Modifying a private API or fixing a bug in the logic ' +
                'of how an existing API works.',
            '',
            'HOTFIX (EXPERIMENTAL) - these are changes that are hotfixes targeting a ' +
                'specific older version of the package. When a hotfix change is added, ' +
                'other changes will not be able to increment the version number. ' +
                "Enable this feature by setting 'hotfixChangeEnabled' in your rush.json.",
            ''
        ];
        super({
            actionName: 'change',
            summary: 'Records changes made to projects, indicating how the package version number should be bumped ' +
                'for the next publish.',
            documentation: documentation.join(os.EOL),
            safeForSimultaneousRushProcesses: true,
            parser
        });
        this._git = new Git_1.Git(this.rushConfiguration);
        this._terminal = new node_core_library_1.Terminal(new node_core_library_1.ConsoleTerminalProvider({ verboseEnabled: parser.isDebug }));
    }
    onDefineParameters() {
        const BULK_LONG_NAME = '--bulk';
        const BULK_MESSAGE_LONG_NAME = '--message';
        const BULK_BUMP_TYPE_LONG_NAME = '--bump-type';
        this._verifyParameter = this.defineFlagParameter({
            parameterLongName: '--verify',
            parameterShortName: '-v',
            description: 'Verify the change file has been generated and that it is a valid JSON file'
        });
        this._noFetchParameter = this.defineFlagParameter({
            parameterLongName: '--no-fetch',
            description: 'Skips fetching the baseline branch before running "git diff" to detect changes.'
        });
        this._targetBranchParameter = this.defineStringParameter({
            parameterLongName: '--target-branch',
            parameterShortName: '-b',
            argumentName: 'BRANCH',
            description: 'If this parameter is specified, compare the checked out branch with the specified branch to ' +
                'determine which projects were changed. If this parameter is not specified, the checked out branch ' +
                'is compared against the "master" branch.'
        });
        this._overwriteFlagParameter = this.defineFlagParameter({
            parameterLongName: '--overwrite',
            description: `If a changefile already exists, overwrite without prompting ` +
                `(or erroring in ${BULK_LONG_NAME} mode).`
        });
        this._changeEmailParameter = this.defineStringParameter({
            parameterLongName: '--email',
            argumentName: 'EMAIL',
            description: 'The email address to use in changefiles. If this parameter is not provided, the email address ' +
                'will be detected or prompted for in interactive mode.'
        });
        this._bulkChangeParameter = this.defineFlagParameter({
            parameterLongName: BULK_LONG_NAME,
            description: 'If this flag is specified, apply the same change message and bump type to all changed projects. ' +
                `The ${BULK_MESSAGE_LONG_NAME} and the ${BULK_BUMP_TYPE_LONG_NAME} parameters must be specified if the ` +
                `${BULK_LONG_NAME} parameter is specified`
        });
        this._bulkChangeMessageParameter = this.defineStringParameter({
            parameterLongName: BULK_MESSAGE_LONG_NAME,
            argumentName: 'MESSAGE',
            description: `The message to apply to all changed projects if the ${BULK_LONG_NAME} flag is provided.`
        });
        this._bulkChangeBumpTypeParameter = this.defineChoiceParameter({
            parameterLongName: BULK_BUMP_TYPE_LONG_NAME,
            alternatives: [...Object.keys(this._getBumpOptions()), ChangeManagement_1.ChangeType[ChangeManagement_1.ChangeType.none]],
            description: `The bump type to apply to all changed projects if the ${BULK_LONG_NAME} flag is provided.`
        });
    }
    async runAsync() {
        console.log(`The target branch is ${this._targetBranch}`);
        if (this._verifyParameter.value) {
            const errors = [
                this._bulkChangeParameter,
                this._bulkChangeMessageParameter,
                this._bulkChangeBumpTypeParameter,
                this._overwriteFlagParameter
            ]
                .map((parameter) => {
                return parameter.value
                    ? `The {${this._bulkChangeParameter.longName} parameter cannot be provided with the ` +
                        `${this._verifyParameter.longName} parameter`
                    : '';
            })
                .filter((error) => error !== '');
            if (errors.length > 0) {
                errors.forEach((error) => console.error(error));
                throw new node_core_library_1.AlreadyReportedError();
            }
            await this._verifyAsync();
            return;
        }
        const sortedProjectList = (await this._getChangedProjectNamesAsync()).sort();
        if (sortedProjectList.length === 0) {
            this._logNoChangeFileRequired();
            this._warnUncommittedChanges();
            return;
        }
        this._warnUncommittedChanges();
        const promptModule = inquirer.createPromptModule();
        let changeFileData = new Map();
        let interactiveMode = false;
        if (this._bulkChangeParameter.value) {
            if (!this._bulkChangeBumpTypeParameter.value ||
                (!this._bulkChangeMessageParameter.value &&
                    this._bulkChangeBumpTypeParameter.value !== ChangeManagement_1.ChangeType[ChangeManagement_1.ChangeType.none])) {
                throw new Error(`The ${this._bulkChangeBumpTypeParameter.longName} and ${this._bulkChangeMessageParameter.longName} ` +
                    `parameters must provided if the ${this._bulkChangeParameter.longName} flag is provided. If the value ` +
                    `"${ChangeManagement_1.ChangeType[ChangeManagement_1.ChangeType.none]}" is provided to the ${this._bulkChangeBumpTypeParameter.longName} ` +
                    `parameter, the ${this._bulkChangeMessageParameter.longName} parameter may be omitted.`);
            }
            const email = this._changeEmailParameter.value || this._detectEmail();
            if (!email) {
                throw new Error("Unable to detect Git email and an email address wasn't provided using the " +
                    `${this._changeEmailParameter.longName} parameter.`);
            }
            const errors = [];
            const comment = this._bulkChangeMessageParameter.value || '';
            const changeType = this._bulkChangeBumpTypeParameter.value;
            for (const packageName of sortedProjectList) {
                const allowedBumpTypes = Object.keys(this._getBumpOptions(packageName));
                let projectChangeType = changeType;
                if (allowedBumpTypes.length === 0) {
                    projectChangeType = ChangeManagement_1.ChangeType[ChangeManagement_1.ChangeType.none];
                }
                else if (projectChangeType !== ChangeManagement_1.ChangeType[ChangeManagement_1.ChangeType.none] &&
                    allowedBumpTypes.indexOf(projectChangeType) === -1) {
                    errors.push(`The "${projectChangeType}" change type is not allowed for package "${packageName}".`);
                }
                changeFileData.set(packageName, {
                    changes: [
                        {
                            comment,
                            type: projectChangeType,
                            packageName
                        }
                    ],
                    packageName,
                    email
                });
            }
            if (errors.length > 0) {
                for (const error of errors) {
                    console.error(error);
                }
                throw new node_core_library_1.AlreadyReportedError();
            }
        }
        else if (this._bulkChangeBumpTypeParameter.value || this._bulkChangeMessageParameter.value) {
            throw new Error(`The ${this._bulkChangeParameter.longName} flag must be provided with the ` +
                `${this._bulkChangeBumpTypeParameter.longName} and ${this._bulkChangeMessageParameter.longName} parameters.`);
        }
        else {
            interactiveMode = true;
            const existingChangeComments = ChangeFiles_1.ChangeFiles.getChangeComments(this._getChangeFiles());
            changeFileData = await this._promptForChangeFileData(promptModule, sortedProjectList, existingChangeComments);
            if (this._isEmailRequired(changeFileData)) {
                const email = this._changeEmailParameter.value
                    ? this._changeEmailParameter.value
                    : await this._detectOrAskForEmail(promptModule);
                changeFileData.forEach((changeFile) => {
                    var _a, _b;
                    changeFile.email = ((_b = (_a = this.rushConfiguration.getProjectByName(changeFile.packageName)) === null || _a === void 0 ? void 0 : _a.versionPolicy) === null || _b === void 0 ? void 0 : _b.includeEmailInChangeFile)
                        ? email
                        : '';
                });
            }
        }
        try {
            return await this._writeChangeFiles(promptModule, changeFileData, this._overwriteFlagParameter.value, interactiveMode);
        }
        catch (error) {
            throw new Error(`There was an error creating a change file: ${error.toString()}`);
        }
    }
    _generateHostMap() {
        const hostMap = new Map();
        this.rushConfiguration.projects.forEach((project) => {
            let hostProjectName = project.packageName;
            if (project.versionPolicy && project.versionPolicy.isLockstepped) {
                const lockstepPolicy = project.versionPolicy;
                hostProjectName = lockstepPolicy.mainProject || project.packageName;
            }
            hostMap.set(project.packageName, hostProjectName);
        });
        return hostMap;
    }
    async _verifyAsync() {
        const changedPackages = await this._getChangedProjectNamesAsync();
        if (changedPackages.length > 0) {
            this._validateChangeFile(changedPackages);
        }
        else {
            this._logNoChangeFileRequired();
        }
    }
    get _targetBranch() {
        if (!this._targetBranchName) {
            this._targetBranchName = this._targetBranchParameter.value || this._git.getRemoteDefaultBranch();
        }
        return this._targetBranchName;
    }
    async _getChangedProjectNamesAsync() {
        var e_1, _a;
        var _b;
        const projectChangeAnalyzer = new ProjectChangeAnalyzer_1.ProjectChangeAnalyzer(this.rushConfiguration);
        const changedProjects = projectChangeAnalyzer.getChangedProjectsAsync({
            targetBranchName: this._targetBranch,
            terminal: this._terminal,
            shouldFetch: !this._noFetchParameter.value
        });
        const projectHostMap = this._generateHostMap();
        const changedProjectNames = new Set();
        try {
            for (var changedProjects_1 = __asyncValues(changedProjects), changedProjects_1_1; changedProjects_1_1 = await changedProjects_1.next(), !changedProjects_1_1.done;) {
                const changedProject = changedProjects_1_1.value;
                if (changedProject.shouldPublish && !((_b = changedProject.versionPolicy) === null || _b === void 0 ? void 0 : _b.exemptFromRushChange)) {
                    const hostName = projectHostMap.get(changedProject.packageName);
                    if (hostName) {
                        changedProjectNames.add(hostName);
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (changedProjects_1_1 && !changedProjects_1_1.done && (_a = changedProjects_1.return)) await _a.call(changedProjects_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return Array.from(changedProjectNames);
    }
    _validateChangeFile(changedPackages) {
        const files = this._getChangeFiles();
        ChangeFiles_1.ChangeFiles.validate(files, changedPackages, this.rushConfiguration);
    }
    _getChangeFiles() {
        return this._git
            .getChangedFiles(this._targetBranch, this._terminal, true, `common/changes/`)
            .map((relativePath) => {
            return path.join(this.rushConfiguration.rushJsonFolder, relativePath);
        });
    }
    /**
     * The main loop which prompts the user for information on changed projects.
     */
    async _promptForChangeFileData(promptModule, sortedProjectList, existingChangeComments) {
        const changedFileData = new Map();
        for (const projectName of sortedProjectList) {
            const changeInfo = await this._askQuestions(promptModule, projectName, existingChangeComments);
            if (changeInfo) {
                // Save the info into the change file
                let changeFile = changedFileData.get(changeInfo.packageName);
                if (!changeFile) {
                    changeFile = {
                        changes: [],
                        packageName: changeInfo.packageName,
                        email: undefined
                    };
                    changedFileData.set(changeInfo.packageName, changeFile);
                }
                changeFile.changes.push(changeInfo);
            }
        }
        return changedFileData;
    }
    /**
     * Asks all questions which are needed to generate changelist for a project.
     */
    async _askQuestions(promptModule, packageName, existingChangeComments) {
        console.log(`${os.EOL}${packageName}`);
        const comments = existingChangeComments.get(packageName);
        if (comments) {
            console.log(`Found existing comments:`);
            comments.forEach((comment) => {
                console.log(`    > ${comment}`);
            });
            const { appendComment } = await promptModule({
                name: 'appendComment',
                type: 'list',
                default: 'skip',
                message: 'Append to existing comments or skip?',
                choices: [
                    {
                        name: 'Skip',
                        value: 'skip'
                    },
                    {
                        name: 'Append',
                        value: 'append'
                    }
                ]
            });
            if (appendComment === 'skip') {
                return undefined;
            }
            else {
                return await this._promptForComments(promptModule, packageName);
            }
        }
        else {
            return await this._promptForComments(promptModule, packageName);
        }
    }
    async _promptForComments(promptModule, packageName) {
        const bumpOptions = this._getBumpOptions(packageName);
        const { comment } = await promptModule({
            name: 'comment',
            type: 'input',
            message: `Describe changes, or ENTER if no changes:`
        });
        if (Object.keys(bumpOptions).length === 0 || !comment) {
            return {
                packageName: packageName,
                comment: comment || '',
                type: ChangeManagement_1.ChangeType[ChangeManagement_1.ChangeType.none]
            };
        }
        else {
            const { bumpType } = await promptModule({
                choices: Object.keys(bumpOptions).map((option) => {
                    return {
                        value: option,
                        name: bumpOptions[option]
                    };
                }),
                default: 'patch',
                message: 'Select the type of change:',
                name: 'bumpType',
                type: 'list'
            });
            return {
                packageName: packageName,
                comment: comment,
                type: bumpType
            };
        }
    }
    _getBumpOptions(packageName) {
        let bumpOptions = this.rushConfiguration && this.rushConfiguration.hotfixChangeEnabled
            ? {
                [ChangeManagement_1.ChangeType[ChangeManagement_1.ChangeType.hotfix]]: 'hotfix - for changes that need to be published in a separate hotfix package'
            }
            : {
                [ChangeManagement_1.ChangeType[ChangeManagement_1.ChangeType.major]]: 'major - for changes that break compatibility, e.g. removing an API',
                [ChangeManagement_1.ChangeType[ChangeManagement_1.ChangeType.minor]]: 'minor - for backwards compatible changes, e.g. adding a new API',
                [ChangeManagement_1.ChangeType[ChangeManagement_1.ChangeType.patch]]: 'patch - for changes that do not affect compatibility, e.g. fixing a bug'
            };
        if (packageName) {
            const project = this.rushConfiguration.getProjectByName(packageName);
            const versionPolicy = project.versionPolicy;
            if (versionPolicy) {
                if (versionPolicy.definitionName === VersionPolicy_1.VersionPolicyDefinitionName.lockStepVersion) {
                    // No need to ask for bump types if project is lockstep versioned.
                    bumpOptions = {};
                }
                else if (versionPolicy.definitionName === VersionPolicy_1.VersionPolicyDefinitionName.individualVersion) {
                    const individualPolicy = versionPolicy;
                    if (individualPolicy.lockedMajor !== undefined) {
                        delete bumpOptions[ChangeManagement_1.ChangeType[ChangeManagement_1.ChangeType.major]];
                    }
                }
            }
        }
        return bumpOptions;
    }
    _isEmailRequired(changeFileData) {
        return [...changeFileData.values()].some((changeFile) => {
            var _a, _b;
            return !!((_b = (_a = this.rushConfiguration.getProjectByName(changeFile.packageName)) === null || _a === void 0 ? void 0 : _a.versionPolicy) === null || _b === void 0 ? void 0 : _b.includeEmailInChangeFile);
        });
    }
    /**
     * Will determine a user's email by first detecting it from their Git config,
     * or will ask for it if it is not found or the Git config is wrong.
     */
    async _detectOrAskForEmail(promptModule) {
        return (await this._detectAndConfirmEmail(promptModule)) || (await this._promptForEmail(promptModule));
    }
    _detectEmail() {
        try {
            return child_process
                .execSync('git config user.email')
                .toString()
                .replace(/(\r\n|\n|\r)/gm, '');
        }
        catch (err) {
            console.log('There was an issue detecting your Git email...');
            return undefined;
        }
    }
    /**
     * Detects the user's email address from their Git configuration, prompts the user to approve the
     * detected email. It returns undefined if it cannot be detected.
     */
    async _detectAndConfirmEmail(promptModule) {
        const email = this._detectEmail();
        if (email) {
            const { isCorrectEmail } = await promptModule([
                {
                    type: 'confirm',
                    name: 'isCorrectEmail',
                    default: 'Y',
                    message: `Is your email address ${email}?`
                }
            ]);
            return isCorrectEmail ? email : undefined;
        }
        else {
            return undefined;
        }
    }
    /**
     * Asks the user for their email address
     */
    async _promptForEmail(promptModule) {
        const { email } = await promptModule([
            {
                type: 'input',
                name: 'email',
                message: 'What is your email address?',
                validate: (input) => {
                    return true; // @todo should be an email
                }
            }
        ]);
        return email;
    }
    _warnUncommittedChanges() {
        try {
            if (this._git.hasUncommittedChanges()) {
                console.log(os.EOL +
                    safe_1.default.yellow('Warning: You have uncommitted changes, which do not trigger prompting for change ' +
                        'descriptions.'));
            }
        }
        catch (error) {
            console.log(`An error occurred when detecting uncommitted changes: ${error}`);
        }
    }
    /**
     * Writes change files to the common/changes folder. Will prompt for overwrite if file already exists.
     */
    async _writeChangeFiles(promptModule, changeFileData, overwrite, interactiveMode) {
        await changeFileData.forEach(async (changeFile) => {
            await this._writeChangeFile(promptModule, changeFile, overwrite, interactiveMode);
        });
    }
    async _writeChangeFile(promptModule, changeFileData, overwrite, interactiveMode) {
        const output = JSON.stringify(changeFileData, undefined, 2);
        const changeFile = new ChangeFile_1.ChangeFile(changeFileData, this.rushConfiguration);
        const filePath = changeFile.generatePath();
        const fileExists = node_core_library_1.FileSystem.exists(filePath);
        const shouldWrite = !fileExists ||
            overwrite ||
            (interactiveMode ? await this._promptForOverwrite(promptModule, filePath) : false);
        if (!interactiveMode && fileExists && !overwrite) {
            throw new Error(`Changefile ${filePath} already exists`);
        }
        if (shouldWrite) {
            this._writeFile(filePath, output, shouldWrite && fileExists);
        }
    }
    async _promptForOverwrite(promptModule, filePath) {
        const overwrite = await promptModule([
            {
                name: 'overwrite',
                type: 'confirm',
                message: `Overwrite ${filePath}?`
            }
        ]);
        if (overwrite) {
            return true;
        }
        else {
            console.log(`Not overwriting ${filePath}`);
            return false;
        }
    }
    /**
     * Writes a file to disk, ensuring the directory structure up to that point exists
     */
    _writeFile(fileName, output, isOverwrite) {
        node_core_library_1.FileSystem.writeFile(fileName, output, { ensureFolderExists: true });
        if (isOverwrite) {
            console.log(`Overwrote file: ${fileName}`);
        }
        else {
            console.log(`Created file: ${fileName}`);
        }
    }
    _logNoChangeFileRequired() {
        console.log('No changes were detected to relevant packages on this branch. Nothing to do.');
    }
}
exports.ChangeAction = ChangeAction;
//# sourceMappingURL=ChangeAction.js.map

/***/ }),

/***/ 18047:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckAction = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const BaseRushAction_1 = __webpack_require__(46677);
const VersionMismatchFinder_1 = __webpack_require__(81372);
const Variants_1 = __webpack_require__(36315);
class CheckAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'check',
            summary: "Checks each project's package.json files and ensures that all dependencies are of the same " +
                'version throughout the repository.',
            documentation: "Checks each project's package.json files and ensures that all dependencies are of the " +
                'same version throughout the repository.',
            safeForSimultaneousRushProcesses: true,
            parser
        });
    }
    onDefineParameters() {
        this._variant = this.defineStringParameter(Variants_1.Variants.VARIANT_PARAMETER);
        this._jsonFlag = this.defineFlagParameter({
            parameterLongName: '--json',
            description: 'If this flag is specified, output will be in JSON format.'
        });
    }
    async runAsync() {
        const variant = this.rushConfiguration.currentInstalledVariant;
        if (!this._variant.value && variant) {
            console.log(safe_1.default.yellow(`Variant '${variant}' has been installed, but 'rush check' is currently checking the default variant. ` +
                `Use 'rush check --variant '${variant}' to check the current installation.`));
        }
        VersionMismatchFinder_1.VersionMismatchFinder.rushCheck(this.rushConfiguration, {
            variant: this._variant.value,
            printAsJson: this._jsonFlag.value
        });
    }
}
exports.CheckAction = CheckAction;
//# sourceMappingURL=CheckAction.js.map

/***/ }),

/***/ 57796:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeployAction = void 0;
const node_core_library_1 = __webpack_require__(24019);
const BaseRushAction_1 = __webpack_require__(46677);
const deployManagerModule = node_core_library_1.Import.lazy('../../logic/deploy/DeployManager', require);
class DeployAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'deploy',
            summary: 'Prepares a deployment by copying a subset of Rush projects and their dependencies' +
                ' to a target folder',
            documentation: 'After building the repo, "rush deploy" can be used to prepare a deployment by copying' +
                ' a subset of Rush projects and their dependencies to a target folder, which can then be uploaded to' +
                ' a production server.  The "rush deploy" behavior is specified by a scenario config file that must' +
                ' be created first, using the "rush init-deploy" command.',
            parser,
            // It is okay to invoke multiple instances of "rush deploy" simultaneously, if they are writing
            // to different target folders.
            safeForSimultaneousRushProcesses: true
        });
    }
    onDefineParameters() {
        this._project = this.defineStringParameter({
            parameterLongName: '--project',
            parameterShortName: '-p',
            argumentName: 'PROJECT_NAME',
            description: 'Specifies the name of the main Rush project to be deployed. It must appear in the' +
                ' "deploymentProjectNames" setting in the deployment config file.'
        });
        this._scenario = this.defineStringParameter({
            parameterLongName: '--scenario',
            parameterShortName: '-s',
            argumentName: 'SCENARIO_NAME',
            description: 'By default, the deployment configuration is specified in "common/config/rush/deploy.json".' +
                ' You can use "--scenario" to specify an alternate name. The name must be lowercase and separated by dashes.' +
                ' For example, if SCENARIO_NAME is "web", then the config file would be "common/config/rush/deploy-web.json".'
        });
        this._overwrite = this.defineFlagParameter({
            parameterLongName: '--overwrite',
            description: 'By default, deployment will fail if the target folder is not empty.  SPECIFYING THIS FLAG' +
                ' WILL RECURSIVELY DELETE EXISTING CONTENTS OF THE TARGET FOLDER.'
        });
        this._targetFolder = this.defineStringParameter({
            parameterLongName: '--target-folder',
            parameterShortName: '-t',
            argumentName: 'PATH',
            environmentVariable: 'RUSH_DEPLOY_TARGET_FOLDER',
            description: 'By default, files are deployed to the "common/deploy" folder inside the Rush repo.' +
                ' Use this parameter to specify a different location. ' +
                ' WARNING: USE CAUTION WHEN COMBINING WITH "--overwrite"'
        });
        this._createArchivePath = this.defineStringParameter({
            parameterLongName: '--create-archive',
            argumentName: 'ARCHIVE_PATH',
            description: 'If specified, after the deployment has been prepared, "rush deploy"' +
                ' will create an archive containing the contents of the target folder.' +
                ' The newly created archive file will be placed according to the designated path, relative' +
                ' to the target folder. Supported file extensions: .zip'
        });
    }
    async runAsync() {
        const deployManager = new deployManagerModule.DeployManager(this.rushConfiguration);
        await deployManager.deployAsync(this._project.value, this._scenario.value, !!this._overwrite.value, this._targetFolder.value, this._createArchivePath.value);
    }
}
exports.DeployAction = DeployAction;
//# sourceMappingURL=DeployAction.js.map

/***/ }),

/***/ 79123:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InitAction = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const BaseRushAction_1 = __webpack_require__(46677);
const node_core_library_1 = __webpack_require__(24019);
const Rush_1 = __webpack_require__(4876);
class InitAction extends BaseRushAction_1.BaseConfiglessRushAction {
    constructor(parser) {
        super({
            actionName: 'init',
            summary: 'Initializes a new repository to be managed by Rush',
            documentation: 'When invoked in an empty folder, this command provisions a standard' +
                ' set of config file templates to start managing projects using Rush.',
            parser
        });
        // template section name --> whether it should be commented out
        this._commentedBySectionName = new Map();
    }
    onDefineParameters() {
        // abstract
        this._overwriteParameter = this.defineFlagParameter({
            parameterLongName: '--overwrite-existing',
            description: 'By default "rush init" will not overwrite existing config files.' +
                ' Specify this switch to override that. This can be useful when upgrading' +
                ' your repo to a newer release of Rush. WARNING: USE WITH CARE!'
        });
        this._rushExampleParameter = this.defineFlagParameter({
            parameterLongName: '--rush-example-repo',
            description: 'When copying the template config files, this uncomments fragments that are used' +
                ' by the "rush-example" GitHub repo, which is a sample monorepo that illustrates many Rush' +
                ' features. This option is primarily intended for maintaining that example.'
        });
    }
    async runAsync() {
        const initFolder = process.cwd();
        if (!this._overwriteParameter.value) {
            if (!this._validateFolderIsEmpty(initFolder)) {
                throw new node_core_library_1.AlreadyReportedError();
            }
        }
        this._defineMacroSections();
        this._copyTemplateFiles(initFolder);
    }
    _defineMacroSections() {
        this._commentedBySectionName.clear();
        // The "HYPOTHETICAL" sections are always commented out by "rush init".
        // They are uncommented in the "assets" source folder so that we can easily validate
        // that they conform to their JSON schema.
        this._commentedBySectionName.set('HYPOTHETICAL', true);
        // The "DEMO" sections are uncommented only when "--rush-example-repo" is specified.
        this._commentedBySectionName.set('DEMO', !this._rushExampleParameter.value);
    }
    // Check whether it's safe to run "rush init" in the current working directory.
    _validateFolderIsEmpty(initFolder) {
        if (this.rushConfiguration !== undefined) {
            console.error(safe_1.default.red('ERROR: Found an existing configuration in: ' + this.rushConfiguration.rushJsonFile));
            console.log(os.EOL +
                'The "rush init" command must be run in a new folder without ' +
                'an existing Rush configuration.');
            return false;
        }
        for (const itemName of node_core_library_1.FileSystem.readFolder(initFolder)) {
            if (itemName.substr(0, 1) === '.') {
                // Ignore any items that start with ".", for example ".git"
                continue;
            }
            const itemPath = path.join(initFolder, itemName);
            const stats = node_core_library_1.FileSystem.getStatistics(itemPath);
            // Ignore any loose files in the current folder, e.g. "README.md"
            // or "CONTRIBUTING.md"
            if (stats.isDirectory()) {
                console.error(safe_1.default.red(`ERROR: Found a subdirectory: "${itemName}"`));
                console.log(os.EOL + 'The "rush init" command must be run in a new folder with no projects added yet.');
                return false;
            }
            else {
                if (itemName.toLowerCase() === 'package.json') {
                    console.error(safe_1.default.red(`ERROR: Found a package.json file in this folder`));
                    console.log(os.EOL + 'The "rush init" command must be run in a new folder with no projects added yet.');
                    return false;
                }
            }
        }
        return true;
    }
    _copyTemplateFiles(initFolder) {
        // The "[dot]" base name is used for hidden files to prevent various tools from interpreting them.
        // For example, "npm publish" will always exclude the filename ".gitignore"
        const templateFilePaths = [
            'rush.json',
            '[dot]gitattributes',
            '[dot]gitignore',
            '[dot]travis.yml',
            'common/config/rush/[dot]npmrc',
            'common/config/rush/[dot]npmrc-publish',
            'common/config/rush/artifactory.json',
            'common/config/rush/build-cache.json',
            'common/config/rush/command-line.json',
            'common/config/rush/common-versions.json',
            'common/config/rush/experiments.json',
            'common/config/rush/.pnpmfile.cjs',
            'common/config/rush/version-policies.json',
            'common/git-hooks/commit-msg.sample'
        ];
        const assetsSubfolder = path.resolve(__dirname, '../../../assets/rush-init');
        for (const templateFilePath of templateFilePaths) {
            const sourcePath = path.join(assetsSubfolder, templateFilePath);
            if (!node_core_library_1.FileSystem.exists(sourcePath)) {
                // If this happens, please report a Rush bug
                throw new node_core_library_1.InternalError('Unable to find template input file: ' + sourcePath);
            }
            const destinationPath = path.join(initFolder, templateFilePath).replace('[dot]', '.');
            this._copyTemplateFile(sourcePath, destinationPath);
        }
    }
    // Copy the template from sourcePath, transform any macros, and write the output to destinationPath.
    //
    // We implement a simple template engine.  "Single-line section" macros have this form:
    //
    //     /*[LINE "NAME"]*/ (content goes here)
    //
    // ...and when commented out will look like this:
    //
    //     // (content goes here)
    //
    // "Block section" macros have this form:
    //
    //     /*[BEGIN "NAME"]*/
    //     (content goes
    //     here)
    //     /*[END "NAME"]*/
    //
    // ...and when commented out will look like this:
    //
    //     // (content goes
    //     // here)
    //
    // Lastly, a variable expansion has this form:
    //
    //     // The value is [%NAME%].
    //
    // ...and when expanded with e.g. "123" will look like this:
    //
    //     // The value is 123.
    //
    // The section names must be one of the predefined names used by "rush init".
    // A single-line section may appear inside a block section, in which case it will get
    // commented twice.
    _copyTemplateFile(sourcePath, destinationPath) {
        if (!this._overwriteParameter.value) {
            if (node_core_library_1.FileSystem.exists(destinationPath)) {
                console.log(safe_1.default.yellow('Not overwriting already existing file: ') + destinationPath);
                return;
            }
        }
        if (node_core_library_1.FileSystem.exists(destinationPath)) {
            console.log(safe_1.default.yellow(`Overwriting: ${destinationPath}`));
        }
        else {
            console.log(`Generating: ${destinationPath}`);
        }
        const outputLines = [];
        const lines = node_core_library_1.FileSystem.readFile(sourcePath, { convertLineEndings: "\n" /* Lf */ }).split('\n');
        let activeBlockSectionName = undefined;
        let activeBlockIndent = '';
        for (const line of lines) {
            let match;
            // Check for a block section start
            // Example:  /*[BEGIN "DEMO"]*/
            match = line.match(InitAction._beginMacroRegExp);
            if (match) {
                if (activeBlockSectionName) {
                    // If this happens, please report a Rush bug
                    throw new node_core_library_1.InternalError(`The template contains an unmatched BEGIN macro for "${activeBlockSectionName}"`);
                }
                activeBlockSectionName = match[2];
                activeBlockIndent = match[1];
                // Remove the entire line containing the macro
                continue;
            }
            // Check for a block section end
            // Example:  /*[END "DEMO"]*/
            match = line.match(InitAction._endMacroRegExp);
            if (match) {
                if (activeBlockSectionName === undefined) {
                    // If this happens, please report a Rush bug
                    throw new node_core_library_1.InternalError(`The template contains an unmatched END macro for "${activeBlockSectionName}"`);
                }
                if (activeBlockSectionName !== match[2]) {
                    // If this happens, please report a Rush bug
                    throw new node_core_library_1.InternalError(`The template contains an mismatched END macro for "${activeBlockSectionName}"`);
                }
                if (activeBlockIndent !== match[1]) {
                    // If this happens, please report a Rush bug
                    throw new node_core_library_1.InternalError(`The template contains an inconsistently indented section "${activeBlockSectionName}"`);
                }
                activeBlockSectionName = undefined;
                // Remove the entire line containing the macro
                continue;
            }
            let transformedLine = line;
            // Check for a single-line section
            // Example:  /*[LINE "HYPOTHETICAL"]*/
            match = transformedLine.match(InitAction._lineMacroRegExp);
            if (match) {
                const sectionName = match[1];
                const replacement = this._isSectionCommented(sectionName) ? '// ' : '';
                transformedLine = transformedLine.replace(InitAction._lineMacroRegExp, replacement);
            }
            // Check for variable expansions
            // Example:  [%RUSH_VERSION%]
            while ((match = transformedLine.match(InitAction._variableMacroRegExp))) {
                const variableName = match[1];
                const replacement = this._expandMacroVariable(variableName);
                transformedLine = transformedLine.replace(InitAction._variableMacroRegExp, replacement);
            }
            // Verify that all macros were handled
            match = transformedLine.match(InitAction._anyMacroRegExp);
            if (match) {
                // If this happens, please report a Rush bug
                throw new node_core_library_1.InternalError('The template contains a malformed macro expression: ' + JSON.stringify(match[0]));
            }
            // If we are inside a block section that is commented out, then insert the "//" after indentation
            if (activeBlockSectionName !== undefined) {
                if (this._isSectionCommented(activeBlockSectionName)) {
                    // Is the line indented properly?
                    if (transformedLine.substr(0, activeBlockIndent.length).trim().length > 0) {
                        // If this happens, please report a Rush bug
                        throw new node_core_library_1.InternalError(`The template contains inconsistently indented lines inside` +
                            ` the "${activeBlockSectionName}" section`);
                    }
                    // Insert comment characters after the indentation
                    const contentAfterIndent = transformedLine.substr(activeBlockIndent.length);
                    transformedLine = activeBlockIndent + '// ' + contentAfterIndent;
                }
            }
            outputLines.push(transformedLine);
        }
        // Write the output
        node_core_library_1.FileSystem.writeFile(destinationPath, outputLines.join('\r\n'), {
            ensureFolderExists: true
        });
    }
    _isSectionCommented(sectionName) {
        const value = this._commentedBySectionName.get(sectionName);
        if (value === undefined) {
            // If this happens, please report a Rush bug
            throw new node_core_library_1.InternalError(`The template references an undefined section name ${sectionName}`);
        }
        return value;
    }
    _expandMacroVariable(variableName) {
        switch (variableName) {
            case '%RUSH_VERSION%':
                return Rush_1.Rush.version;
            default:
                throw new node_core_library_1.InternalError(`The template references an undefined variable "${variableName}"`);
        }
    }
}
exports.InitAction = InitAction;
// Matches a well-formed BEGIN macro starting a block section.
// Example:  /*[BEGIN "DEMO"]*/
//
// Group #1 is the indentation spaces before the macro
// Group #2 is the section name
InitAction._beginMacroRegExp = /^(\s*)\/\*\[BEGIN "([A-Z]+)"\]\s*\*\/\s*$/;
// Matches a well-formed END macro ending a block section.
// Example:  /*[END "DEMO"]*/
//
// Group #1 is the indentation spaces before the macro
// Group #2 is the section name
InitAction._endMacroRegExp = /^(\s*)\/\*\[END "([A-Z]+)"\]\s*\*\/\s*$/;
// Matches a well-formed single-line section, including the space character after it
// if present.
// Example:  /*[LINE "HYPOTHETICAL"]*/
//
// Group #1 is the section name
InitAction._lineMacroRegExp = /\/\*\[LINE "([A-Z]+)"\]\s*\*\/\s?/;
// Matches a variable expansion.
// Example:  [%RUSH_VERSION%]
//
// Group #1 is the variable name including the dollar sign
InitAction._variableMacroRegExp = /\[(%[A-Z0-9_]+%)\]/;
// Matches anything that starts with "/*[" and ends with "]*/"
// Used to catch malformed macro expressions
InitAction._anyMacroRegExp = /\/\*\s*\[.*\]\s*\*\//;
//# sourceMappingURL=InitAction.js.map

/***/ }),

/***/ 57977:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InitAutoinstallerAction = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const node_core_library_1 = __webpack_require__(24019);
const BaseRushAction_1 = __webpack_require__(46677);
const Autoinstaller_1 = __webpack_require__(78226);
class InitAutoinstallerAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'init-autoinstaller',
            summary: 'Initializes a new autoinstaller',
            documentation: 'Use this command to initialize a new autoinstaller folder.  Autoinstallers provide a way to' +
                ' manage a set of related dependencies that are used for scripting scenarios outside of the usual' +
                ' "rush install" context.  See the command-line.json documentation for an example.',
            parser
        });
    }
    onDefineParameters() {
        this._name = this.defineStringParameter({
            parameterLongName: '--name',
            argumentName: 'AUTOINSTALLER_NAME',
            required: true,
            description: 'Specifies the name of the autoinstaller folder, which must conform to the naming rules for NPM packages.'
        });
    }
    async runAsync() {
        const autoinstallerName = this._name.value;
        const autoinstaller = new Autoinstaller_1.Autoinstaller(autoinstallerName, this.rushConfiguration);
        if (node_core_library_1.FileSystem.exists(autoinstaller.folderFullPath)) {
            // It's okay if the folder is empty
            if (node_core_library_1.FileSystem.readFolder(autoinstaller.folderFullPath).length > 0) {
                throw new Error('The target folder already exists: ' + autoinstaller.folderFullPath);
            }
        }
        const packageJson = {
            name: autoinstallerName,
            version: '1.0.0',
            private: true,
            dependencies: {}
        };
        console.log(safe_1.default.green('Creating package: ') + autoinstaller.packageJsonPath);
        node_core_library_1.JsonFile.save(packageJson, autoinstaller.packageJsonPath, {
            ensureFolderExists: true,
            newlineConversion: "os" /* OsDefault */
        });
        console.log('\nFile successfully written. Add your dependencies before committing.');
    }
}
exports.InitAutoinstallerAction = InitAutoinstallerAction;
//# sourceMappingURL=InitAutoinstallerAction.js.map

/***/ }),

/***/ 43441:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InitDeployAction = void 0;
const path = __importStar(__webpack_require__(85622));
const safe_1 = __importDefault(__webpack_require__(41997));
const BaseRushAction_1 = __webpack_require__(46677);
const node_core_library_1 = __webpack_require__(24019);
const DeployScenarioConfiguration_1 = __webpack_require__(90893);
class InitDeployAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'init-deploy',
            summary: 'Creates a deployment scenario config file for use with "rush deploy".',
            documentation: 'Use this command to initialize a new scenario config file for use with "rush deploy".' +
                ' The default filename is common/config/rush/deploy.json. However, if you need to manage multiple' +
                ' deployments with different settings, you can use use "--scenario" to create additional config files.',
            parser
        });
    }
    onDefineParameters() {
        this._project = this.defineStringParameter({
            parameterLongName: '--project',
            parameterShortName: '-p',
            argumentName: 'PROJECT_NAME',
            required: true,
            description: 'Specifies the name of the main Rush project to be deployed in this scenario.' +
                ' It will be added to the "deploymentProjectNames" setting.'
        });
        this._scenario = this.defineStringParameter({
            parameterLongName: '--scenario',
            parameterShortName: '-s',
            argumentName: 'SCENARIO',
            description: 'By default, the deployment configuration will be written to "common/config/rush/deploy.json".' +
                ' You can use "--scenario" to specify an alternate name. The name must be lowercase and separated by dashes.' +
                ' For example, if the name is "web", then the config file would be "common/config/rush/deploy-web.json".'
        });
    }
    async runAsync() {
        const scenarioFilePath = DeployScenarioConfiguration_1.DeployScenarioConfiguration.getConfigFilePath(this._scenario.value, this.rushConfiguration);
        if (node_core_library_1.FileSystem.exists(scenarioFilePath)) {
            throw new Error('The target file already exists:\n' +
                scenarioFilePath +
                '\nIf you intend to replace it, please delete the old file first.');
        }
        console.log(safe_1.default.green('Creating scenario file: ') + scenarioFilePath);
        const shortProjectName = this._project.value;
        const rushProject = this.rushConfiguration.findProjectByShorthandName(shortProjectName);
        if (!rushProject) {
            throw new Error(`The specified project was not found in rush.json: "${shortProjectName}"`);
        }
        const templateContent = node_core_library_1.FileSystem.readFile(InitDeployAction._CONFIG_TEMPLATE_PATH);
        const expandedContent = templateContent.replace('[%PROJECT_NAME_TO_DEPLOY%]', rushProject.packageName);
        node_core_library_1.FileSystem.writeFile(scenarioFilePath, expandedContent, {
            ensureFolderExists: true,
            convertLineEndings: "os" /* OsDefault */
        });
        console.log('\nFile successfully written. Please review the file contents before committing.');
    }
}
exports.InitDeployAction = InitDeployAction;
InitDeployAction._CONFIG_TEMPLATE_PATH = path.join(__dirname, '../../../assets/rush-init-deploy/scenario-template.json');
//# sourceMappingURL=InitDeployAction.js.map

/***/ }),

/***/ 81507:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InstallAction = void 0;
const BaseInstallAction_1 = __webpack_require__(91343);
const SelectionParameterSet_1 = __webpack_require__(96724);
class InstallAction extends BaseInstallAction_1.BaseInstallAction {
    constructor(parser) {
        super({
            actionName: 'install',
            summary: 'Install package dependencies for all projects in the repo according to the shrinkwrap file',
            documentation: 'The "rush install" command installs package dependencies for all your projects,' +
                ' based on the shrinkwrap file that is created/updated using "rush update".' +
                ' (This "shrinkwrap" file stores a central inventory of all dependencies and versions' +
                ' for projects in your repo. It is found in the "common/config/rush" folder.)' +
                ' If the shrinkwrap file is missing or outdated (e.g. because project package.json files have' +
                ' changed), "rush install" will fail and tell you to run "rush update" instead.' +
                ' This read-only nature is the main feature:  Continuous integration builds should use' +
                ' "rush install" instead of "rush update" to catch developers who forgot to commit their' +
                ' shrinkwrap changes.  Cautious people can also use "rush install" if they want to avoid' +
                ' accidentally updating their shrinkwrap file.',
            parser
        });
    }
    /**
     * @override
     */
    onDefineParameters() {
        super.onDefineParameters();
        this._selectionParameters = new SelectionParameterSet_1.SelectionParameterSet(this.rushConfiguration, this);
        this._checkOnlyParameter = this.defineFlagParameter({
            parameterLongName: '--check-only',
            description: `Only check the validity of the shrinkwrap file without performing an install.`
        });
    }
    buildInstallOptions() {
        return {
            debug: this.parser.isDebug,
            allowShrinkwrapUpdates: false,
            bypassPolicy: this._bypassPolicyParameter.value,
            noLink: this._noLinkParameter.value,
            fullUpgrade: false,
            recheckShrinkwrap: false,
            networkConcurrency: this._networkConcurrencyParameter.value,
            collectLogFile: this._debugPackageManagerParameter.value,
            variant: this._variant.value,
            // Because the 'defaultValue' option on the _maxInstallAttempts parameter is set,
            // it is safe to assume that the value is not null
            maxInstallAttempts: this._maxInstallAttempts.value,
            // These are derived independently of the selection for command line brevity
            pnpmFilterArguments: this._selectionParameters.getPnpmFilterArguments(),
            checkOnly: this._checkOnlyParameter.value
        };
    }
}
exports.InstallAction = InstallAction;
//# sourceMappingURL=InstallAction.js.map

/***/ }),

/***/ 29693:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkAction = void 0;
const node_core_library_1 = __webpack_require__(24019);
const BaseRushAction_1 = __webpack_require__(46677);
const linkManagerFactoryModule = node_core_library_1.Import.lazy('../../logic/LinkManagerFactory', require);
class LinkAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'link',
            summary: 'Create node_modules symlinks for all projects',
            documentation: 'Create node_modules symlinks for all projects.  This operation is normally performed' +
                ' automatically as part of "rush install" or "rush update".  You should only need to use "rush link"' +
                ' if you performed "rush unlink" for some reason, or if you specified the "--no-link" option' +
                ' for "rush install" or "rush update".',
            parser
        });
    }
    onDefineParameters() {
        this._force = this.defineFlagParameter({
            parameterLongName: '--force',
            parameterShortName: '-f',
            description: 'Deletes and recreates all links, even if the filesystem state seems to indicate that this is ' +
                'unnecessary.'
        });
    }
    async runAsync() {
        const linkManager = linkManagerFactoryModule.LinkManagerFactory.getLinkManager(this.rushConfiguration);
        await linkManager.createSymlinksForProjects(this._force.value);
    }
}
exports.LinkAction = LinkAction;
//# sourceMappingURL=LinkAction.js.map

/***/ }),

/***/ 9341:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListAction = void 0;
const node_core_library_1 = __webpack_require__(24019);
const BaseRushAction_1 = __webpack_require__(46677);
const VersionPolicy_1 = __webpack_require__(78075);
const SelectionParameterSet_1 = __webpack_require__(96724);
const cliTable = node_core_library_1.Import.lazy('cli-table', require);
class ListAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'list',
            summary: 'List package information for all projects in the repo',
            documentation: 'List package names, and optionally version (--version) and ' +
                'path (--path) or full path (--full-path), for projects in the ' +
                'current rush config.',
            parser
        });
    }
    onDefineParameters() {
        this._version = this.defineFlagParameter({
            parameterLongName: '--version',
            parameterShortName: '-v',
            description: 'If this flag is specified, the project version will be ' +
                'displayed in a column along with the package name.'
        });
        this._path = this.defineFlagParameter({
            parameterLongName: '--path',
            parameterShortName: '-p',
            description: 'If this flag is specified, the project path will be ' +
                'displayed in a column along with the package name.'
        });
        this._fullPath = this.defineFlagParameter({
            parameterLongName: '--full-path',
            description: 'If this flag is specified, the project full path will ' +
                'be displayed in a column along with the package name.'
        });
        this._detailedFlag = this.defineFlagParameter({
            parameterLongName: '--detailed',
            description: 'For the non --json view, if this flag is specified, ' +
                'include path (-p), version (-v) columns along with ' +
                'the projects applicable: versionPolicy, versionPolicyName, ' +
                'shouldPublish, and reviewPolicy fields.'
        });
        this._jsonFlag = this.defineFlagParameter({
            parameterLongName: '--json',
            description: 'If this flag is specified, output will be in JSON format.'
        });
        this._selectionParameters = new SelectionParameterSet_1.SelectionParameterSet(this.rushConfiguration, this);
    }
    async runAsync() {
        const selection = this._selectionParameters.getSelectedProjects();
        node_core_library_1.Sort.sortSetBy(selection, (x) => x.packageName);
        if (this._jsonFlag.value && this._detailedFlag.value) {
            throw new Error(`The parameters "--json" and "--detailed" cannot be used together.`);
        }
        if (this._jsonFlag.value) {
            this._printJson(selection);
        }
        else if (this._version.value || this._path.value || this._fullPath.value || this._detailedFlag.value) {
            this._printListTable(selection);
        }
        else {
            this._printList(selection);
        }
    }
    _printJson(selection) {
        const projects = Array.from(selection, (config) => {
            let reviewCategory;
            let shouldPublish;
            let versionPolicy;
            let versionPolicyName;
            if (config.versionPolicy !== undefined) {
                const definitionName = VersionPolicy_1.VersionPolicyDefinitionName[config.versionPolicy.definitionName];
                versionPolicy = `${definitionName}`;
                versionPolicyName = config.versionPolicy.policyName;
            }
            else {
                shouldPublish = config.shouldPublish;
            }
            if (config.reviewCategory) {
                reviewCategory = config.reviewCategory;
            }
            return {
                name: config.packageName,
                version: config.packageJson.version,
                path: config.projectRelativeFolder,
                fullPath: config.projectFolder,
                versionPolicy,
                versionPolicyName,
                shouldPublish,
                reviewCategory
            };
        });
        const output = {
            projects
        };
        console.log(JSON.stringify(output, undefined, 2));
    }
    _printList(selection) {
        for (const project of selection) {
            console.log(project.packageName);
        }
    }
    _printListTable(selection) {
        const tableHeader = ['Project'];
        if (this._version.value || this._detailedFlag.value) {
            tableHeader.push('Version');
        }
        if (this._path.value || this._detailedFlag.value) {
            tableHeader.push('Path');
        }
        if (this._fullPath.value) {
            tableHeader.push('Full Path');
        }
        if (this._detailedFlag.value) {
            tableHeader.push('Version policy');
            tableHeader.push('Version policy name');
            tableHeader.push('Should publish');
            tableHeader.push('Review category');
        }
        // eslint-disable-next-line @typescript-eslint/typedef
        const table = new cliTable({
            head: tableHeader
        });
        for (const project of selection) {
            const packageRow = [project.packageName];
            if (this._version.value || this._detailedFlag.value) {
                packageRow.push(project.packageJson.version);
            }
            if (this._path.value || this._detailedFlag.value) {
                packageRow.push(project.projectRelativeFolder);
            }
            if (this._fullPath.value) {
                packageRow.push(project.projectFolder);
            }
            if (this._detailedFlag.value) {
                // When we HAVE a version policy
                let versionPolicyDefinitionName = '';
                let versionPolicyName = '';
                // When we DO NOT have version policy, fallback to shouldPublish boolean
                let shouldPublish = '';
                let reviewCategory = '';
                if (project.versionPolicy !== undefined) {
                    const definitionName = VersionPolicy_1.VersionPolicyDefinitionName[project.versionPolicy.definitionName];
                    versionPolicyDefinitionName = definitionName;
                    versionPolicyName = project.versionPolicy.policyName;
                }
                else {
                    shouldPublish = `${String(project.shouldPublish)}`;
                }
                if (project.reviewCategory) {
                    reviewCategory = project.reviewCategory;
                }
                packageRow.push(versionPolicyDefinitionName);
                packageRow.push(versionPolicyName);
                packageRow.push(shouldPublish);
                packageRow.push(reviewCategory);
            }
            table.push(packageRow);
        }
        console.log(table.toString());
    }
}
exports.ListAction = ListAction;
//# sourceMappingURL=ListAction.js.map

/***/ }),

/***/ 26157:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PublishAction = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const os_1 = __webpack_require__(12087);
const path = __importStar(__webpack_require__(85622));
const semver = __importStar(__webpack_require__(11383));
const node_core_library_1 = __webpack_require__(24019);
const ChangeManagement_1 = __webpack_require__(6877);
const Npm_1 = __webpack_require__(39482);
const PublishUtilities_1 = __webpack_require__(16397);
const ChangelogGenerator_1 = __webpack_require__(18198);
const PrereleaseToken_1 = __webpack_require__(82397);
const ChangeManager_1 = __webpack_require__(97562);
const BaseRushAction_1 = __webpack_require__(46677);
const PublishGit_1 = __webpack_require__(66953);
const PolicyValidator_1 = __webpack_require__(40499);
const VersionAction_1 = __webpack_require__(85081);
const Utilities_1 = __webpack_require__(89521);
const Git_1 = __webpack_require__(58361);
class PublishAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'publish',
            summary: 'Reads and processes package publishing change requests generated by "rush change".',
            documentation: 'Reads and processes package publishing change requests generated by "rush change". This will perform a ' +
                'read-only operation by default, printing operations executed to the console. To commit ' +
                'changes and publish packages, you must use the --commit flag and/or the --publish flag.',
            parser
        });
    }
    onDefineParameters() {
        this._apply = this.defineFlagParameter({
            parameterLongName: '--apply',
            parameterShortName: '-a',
            description: 'If this flag is specified, the change requests will be applied to package.json files.'
        });
        this._targetBranch = this.defineStringParameter({
            parameterLongName: '--target-branch',
            parameterShortName: '-b',
            argumentName: 'BRANCH',
            description: 'If this flag is specified, applied changes and deleted change requests will be ' +
                'committed and merged into the target branch.'
        });
        this._publish = this.defineFlagParameter({
            parameterLongName: '--publish',
            parameterShortName: '-p',
            description: 'If this flag is specified, applied changes will be published to the NPM registry.'
        });
        this._addCommitDetails = this.defineFlagParameter({
            parameterLongName: '--add-commit-details',
            parameterShortName: undefined,
            description: 'Adds commit author and hash to the changelog.json files for each change.'
        });
        this._regenerateChangelogs = this.defineFlagParameter({
            parameterLongName: '--regenerate-changelogs',
            parameterShortName: undefined,
            description: 'Regenerates all changelog files based on the current JSON content.'
        });
        // NPM registry related parameters
        this._registryUrl = this.defineStringParameter({
            parameterLongName: '--registry',
            parameterShortName: '-r',
            argumentName: 'REGISTRY',
            description: `Publishes to a specified NPM registry. If this is specified, it will prevent the current commit will not be ` +
                'tagged.'
        });
        this._npmAuthToken = this.defineStringParameter({
            parameterLongName: '--npm-auth-token',
            parameterShortName: '-n',
            argumentName: 'TOKEN',
            description: '(DEPRECATED) Specifies the authentication token to use during publishing. This parameter is deprecated' +
                ' because command line parameters may be readable by unrelated processes on a lab machine. Instead, a' +
                ' safer practice is to pass the token via an environment variable and reference it from your ' +
                ' common/config/rush/.npmrc-publish file.'
        });
        this._npmTag = this.defineStringParameter({
            parameterLongName: '--tag',
            parameterShortName: '-t',
            argumentName: 'TAG',
            description: `The tag option to pass to npm publish. By default NPM will publish using the 'latest' tag, even if ` +
                `the package is older than the current latest, so in publishing workflows for older releases, providing ` +
                `a tag is important. When hotfix changes are made, this parameter defaults to 'hotfix'.`
        });
        this._npmAccessLevel = this.defineChoiceParameter({
            alternatives: ['public', 'restricted'],
            parameterLongName: '--set-access-level',
            parameterShortName: undefined,
            description: `By default, when Rush invokes "npm publish" it will publish scoped packages with an access level ` +
                `of "restricted". Scoped packages can be published with an access level of "public" by specifying ` +
                `that value for this flag with the initial publication. NPM always publishes unscoped packages with ` +
                `an access level of "public". For more information, see the NPM documentation for the "--access" ` +
                `option of "npm publish".`
        });
        // NPM pack tarball related parameters
        this._pack = this.defineFlagParameter({
            parameterLongName: '--pack',
            description: `Packs projects into tarballs instead of publishing to npm repository. It can only be used when ` +
                `--include-all is specified. If this flag is specified, NPM registry related parameters will be ignored.`
        });
        this._releaseFolder = this.defineStringParameter({
            parameterLongName: '--release-folder',
            argumentName: 'FOLDER',
            description: `This parameter is used with --pack parameter to provide customized location for the tarballs instead of ` +
                `the default value. `
        });
        // End of NPM pack tarball related parameters
        this._includeAll = this.defineFlagParameter({
            parameterLongName: '--include-all',
            parameterShortName: undefined,
            description: 'If this flag is specified, all packages with shouldPublish=true in rush.json ' +
                'or with a specified version policy ' +
                'will be published if their version is newer than published version.'
        });
        this._versionPolicy = this.defineStringParameter({
            parameterLongName: '--version-policy',
            argumentName: 'POLICY',
            description: 'Version policy name. Only projects with this version policy will be published if used ' +
                'with --include-all.'
        });
        this._prereleaseName = this.defineStringParameter({
            parameterLongName: '--prerelease-name',
            argumentName: 'NAME',
            description: 'Bump up to a prerelease version with the provided prerelease name. Cannot be used with --suffix'
        });
        this._partialPrerelease = this.defineFlagParameter({
            parameterLongName: '--partial-prerelease',
            parameterShortName: undefined,
            description: 'Used with --prerelease-name. Only bump packages to a prerelease version if they have changes.'
        });
        this._suffix = this.defineStringParameter({
            parameterLongName: '--suffix',
            argumentName: 'SUFFIX',
            description: 'Append a suffix to all changed versions. Cannot be used with --prerelease-name.'
        });
        this._force = this.defineFlagParameter({
            parameterLongName: '--force',
            parameterShortName: undefined,
            description: 'If this flag is specified with --publish, packages will be published with --force on npm'
        });
        this._applyGitTagsOnPack = this.defineFlagParameter({
            parameterLongName: '--apply-git-tags-on-pack',
            description: `If specified with --publish and --pack, git tags will be applied for packages` +
                ` as if a publish was being run without --pack.`
        });
        this._commitId = this.defineStringParameter({
            parameterLongName: '--commit',
            parameterShortName: '-c',
            argumentName: 'COMMIT_ID',
            description: `Used in conjunction with git tagging -- apply git tags at the commit hash` +
                ` specified. If not provided, the current HEAD will be tagged.`
        });
        this._ignoreGitHooksParameter = this.defineFlagParameter({
            parameterLongName: '--ignore-git-hooks',
            description: `Skips execution of all git hooks. Make sure you know what you are skipping.`
        });
    }
    /**
     * Executes the publish action, which will read change request files, apply changes to package.jsons,
     */
    async runAsync() {
        PolicyValidator_1.PolicyValidator.validatePolicy(this.rushConfiguration, { bypassPolicy: false });
        // Example: "common\temp\publish-home"
        this._targetNpmrcPublishFolder = path.join(this.rushConfiguration.commonTempFolder, 'publish-home');
        // Example: "common\temp\publish-home\.npmrc"
        this._targetNpmrcPublishPath = path.join(this._targetNpmrcPublishFolder, '.npmrc');
        const allPackages = this.rushConfiguration.projectsByName;
        if (this._regenerateChangelogs.value) {
            console.log('Regenerating changelogs');
            ChangelogGenerator_1.ChangelogGenerator.regenerateChangelogs(allPackages, this.rushConfiguration);
            return;
        }
        this._validate();
        this._addNpmPublishHome();
        const git = new Git_1.Git(this.rushConfiguration);
        const publishGit = new PublishGit_1.PublishGit(git, this._targetBranch.value);
        if (this._includeAll.value) {
            this._publishAll(publishGit, allPackages);
        }
        else {
            this._prereleaseToken = new PrereleaseToken_1.PrereleaseToken(this._prereleaseName.value, this._suffix.value, this._partialPrerelease.value);
            this._publishChanges(git, publishGit, allPackages);
        }
        console.log(os_1.EOL + safe_1.default.green('Rush publish finished successfully.'));
    }
    /**
     * Validate some input parameters
     */
    _validate() {
        if (this._pack.value && !this._includeAll.value) {
            throw new Error('--pack can only be used with --include-all');
        }
        if (this._releaseFolder.value && !this._pack.value) {
            throw new Error(`--release-folder can only be used with --pack`);
        }
        if (this._applyGitTagsOnPack.value && !this._pack.value) {
            throw new Error(`${this._applyGitTagsOnPack.longName} must be used with ${this._pack.longName}`);
        }
    }
    _publishChanges(git, publishGit, allPackages) {
        const changeManager = new ChangeManager_1.ChangeManager(this.rushConfiguration);
        changeManager.load(this.rushConfiguration.changesFolder, this._prereleaseToken, this._addCommitDetails.value);
        if (changeManager.hasChanges()) {
            const orderedChanges = changeManager.changes;
            const tempBranchName = `publish-${Date.now()}`;
            // Make changes in temp branch.
            publishGit.checkout(tempBranchName, true);
            this._setDependenciesBeforePublish();
            // Make changes to package.json and change logs.
            changeManager.apply(this._apply.value);
            changeManager.updateChangelog(this._apply.value);
            this._setDependenciesBeforeCommit();
            if (git.hasUncommittedChanges()) {
                // Stage, commit, and push the changes to remote temp branch.
                publishGit.addChanges(':/*');
                publishGit.commit(this.rushConfiguration.gitVersionBumpCommitMessage || VersionAction_1.DEFAULT_PACKAGE_UPDATE_MESSAGE, !this._ignoreGitHooksParameter.value);
                publishGit.push(tempBranchName, !this._ignoreGitHooksParameter.value);
                this._setDependenciesBeforePublish();
                // Override tag parameter if there is a hotfix change.
                for (const change of orderedChanges) {
                    if (change.changeType === ChangeManagement_1.ChangeType.hotfix) {
                        this._hotfixTagOverride = 'hotfix';
                        break;
                    }
                }
                // npm publish the things that need publishing.
                for (const change of orderedChanges) {
                    if (change.changeType && change.changeType > ChangeManagement_1.ChangeType.dependency) {
                        const project = allPackages.get(change.packageName);
                        if (project) {
                            if (!this._packageExists(project)) {
                                this._npmPublish(change.packageName, project.publishFolder);
                            }
                            else {
                                console.log(`Skip ${change.packageName}. Package exists.`);
                            }
                        }
                        else {
                            console.log(`Skip ${change.packageName}. Failed to find its project.`);
                        }
                    }
                }
                this._setDependenciesBeforeCommit();
                // Create and push appropriate Git tags.
                this._gitAddTags(publishGit, orderedChanges);
                publishGit.push(tempBranchName, !this._ignoreGitHooksParameter.value);
                // Now merge to target branch.
                publishGit.checkout(this._targetBranch.value);
                publishGit.pull(!this._ignoreGitHooksParameter.value);
                publishGit.merge(tempBranchName, !this._ignoreGitHooksParameter.value);
                publishGit.push(this._targetBranch.value, !this._ignoreGitHooksParameter.value);
                publishGit.deleteBranch(tempBranchName, true, !this._ignoreGitHooksParameter.value);
            }
            else {
                publishGit.checkout(this._targetBranch.value);
                publishGit.deleteBranch(tempBranchName, false, !this._ignoreGitHooksParameter.value);
            }
        }
    }
    _publishAll(git, allPackages) {
        console.log(`Rush publish starts with includeAll and version policy ${this._versionPolicy.value}`);
        let updated = false;
        allPackages.forEach((packageConfig, packageName) => {
            if (packageConfig.shouldPublish &&
                (!this._versionPolicy.value || this._versionPolicy.value === packageConfig.versionPolicyName)) {
                const applyTag = (apply) => {
                    if (!apply) {
                        return;
                    }
                    const packageVersion = packageConfig.packageJson.version;
                    // Do not create a new tag if one already exists, this will result in a fatal error
                    if (git.hasTag(packageConfig)) {
                        console.log(`Not tagging ${packageName}@${packageVersion}. A tag already exists for this version.`);
                        return;
                    }
                    git.addTag(!!this._publish.value, packageName, packageVersion, this._commitId.value);
                    updated = true;
                };
                if (this._pack.value) {
                    // packs to tarball instead of publishing to NPM repository
                    this._npmPack(packageName, packageConfig);
                    applyTag(this._applyGitTagsOnPack.value);
                }
                else if (this._force.value || !this._packageExists(packageConfig)) {
                    // Publish to npm repository
                    this._npmPublish(packageName, packageConfig.publishFolder);
                    applyTag(true);
                }
                else {
                    console.log(`Skip ${packageName}. Not updated.`);
                }
            }
        });
        if (updated) {
            git.push(this._targetBranch.value, !this._ignoreGitHooksParameter.value);
        }
    }
    _gitAddTags(git, orderedChanges) {
        for (const change of orderedChanges) {
            if (change.changeType &&
                change.changeType > ChangeManagement_1.ChangeType.dependency &&
                this.rushConfiguration.projectsByName.get(change.packageName).shouldPublish) {
                git.addTag(!!this._publish.value && !this._registryUrl.value, change.packageName, change.newVersion, this._commitId.value);
            }
        }
    }
    _npmPublish(packageName, packagePath) {
        const env = PublishUtilities_1.PublishUtilities.getEnvArgs();
        const args = ['publish'];
        if (this.rushConfiguration.projectsByName.get(packageName).shouldPublish) {
            this._addSharedNpmConfig(env, args);
            if (this._npmTag.value) {
                args.push(`--tag`, this._npmTag.value);
            }
            else if (this._hotfixTagOverride) {
                args.push(`--tag`, this._hotfixTagOverride);
            }
            if (this._force.value) {
                args.push(`--force`);
            }
            if (this._npmAccessLevel.value) {
                args.push(`--access`, this._npmAccessLevel.value);
            }
            if (this.rushConfiguration.packageManager === 'pnpm') {
                // PNPM 4.11.0 introduced a feature that may interrupt publishing and prompt the user for input.
                // See this issue for details: https://github.com/microsoft/rushstack/issues/1940
                args.push('--no-git-checks');
            }
            // TODO: Yarn's "publish" command line is fairly different from NPM and PNPM.  The right thing to do here
            // would be to remap our options to the Yarn equivalents.  But until we get around to that, we'll simply invoke
            // whatever NPM binary happens to be installed in the global path.
            const packageManagerToolFilename = this.rushConfiguration.packageManager === 'yarn'
                ? 'npm'
                : this.rushConfiguration.packageManagerToolFilename;
            // If the auth token was specified via the command line, avoid printing it on the console
            const secretSubstring = this._npmAuthToken.value;
            PublishUtilities_1.PublishUtilities.execCommand(!!this._publish.value, packageManagerToolFilename, args, packagePath, env, secretSubstring);
        }
    }
    _packageExists(packageConfig) {
        const env = PublishUtilities_1.PublishUtilities.getEnvArgs();
        const args = [];
        this._addSharedNpmConfig(env, args);
        const publishedVersions = Npm_1.Npm.publishedVersions(packageConfig.packageName, packageConfig.publishFolder, env, args);
        const packageVersion = packageConfig.packageJsonEditor.version;
        // SemVer supports an obscure (and generally deprecated) feature where "build metadata" can be
        // appended to a version.  For example if our version is "1.2.3-beta.4+extra567", then "+extra567" is the
        // build metadata part.  The suffix has no effect on version comparisons and is mostly ignored by
        // the NPM registry.  Importantly, the queried version number will not include it, so we need to discard
        // it before comparing against the list of already published versions.
        const parsedVersion = semver.parse(packageVersion);
        if (!parsedVersion) {
            throw new Error(`The package "${packageConfig.packageName}" has an invalid "version" value`);
        }
        // For example, normalize "1.2.3-beta.4+extra567" -->"1.2.3-beta.4".
        //
        // This is redundant in the current API, but might change in the future:
        // https://github.com/npm/node-semver/issues/264
        parsedVersion.build = [];
        const normalizedVersion = parsedVersion.format();
        return publishedVersions.indexOf(normalizedVersion) >= 0;
    }
    _npmPack(packageName, project) {
        const args = ['pack'];
        const env = PublishUtilities_1.PublishUtilities.getEnvArgs();
        PublishUtilities_1.PublishUtilities.execCommand(!!this._publish.value, this.rushConfiguration.packageManagerToolFilename, args, project.publishFolder, env);
        if (this._publish.value) {
            // Copy the tarball the release folder
            const tarballName = this._calculateTarballName(project);
            const tarballPath = path.join(project.publishFolder, tarballName);
            const destFolder = this._releaseFolder.value
                ? this._releaseFolder.value
                : path.join(this.rushConfiguration.commonTempFolder, 'artifacts', 'packages');
            node_core_library_1.FileSystem.move({
                sourcePath: tarballPath,
                destinationPath: path.join(destFolder, tarballName),
                overwrite: true
            });
        }
    }
    _calculateTarballName(project) {
        // Same logic as how npm forms the tarball name
        const packageName = project.packageName;
        const name = packageName[0] === '@' ? packageName.substr(1).replace(/\//g, '-') : packageName;
        if (this.rushConfiguration.packageManager === 'yarn') {
            // yarn tarballs have a "v" before the version number
            return `${name}-v${project.packageJson.version}.tgz`;
        }
        else {
            return `${name}-${project.packageJson.version}.tgz`;
        }
    }
    _setDependenciesBeforePublish() {
        for (const project of this.rushConfiguration.projects) {
            if (!this._versionPolicy.value || this._versionPolicy.value === project.versionPolicyName) {
                const versionPolicy = project.versionPolicy;
                if (versionPolicy) {
                    versionPolicy.setDependenciesBeforePublish(project.packageName, this.rushConfiguration);
                }
            }
        }
    }
    _setDependenciesBeforeCommit() {
        for (const project of this.rushConfiguration.projects) {
            if (!this._versionPolicy.value || this._versionPolicy.value === project.versionPolicyName) {
                const versionPolicy = project.versionPolicy;
                if (versionPolicy) {
                    versionPolicy.setDependenciesBeforePublish(project.packageName, this.rushConfiguration);
                }
            }
        }
    }
    _addNpmPublishHome() {
        // Create "common\temp\publish-home" folder, if it doesn't exist
        Utilities_1.Utilities.createFolderWithRetry(this._targetNpmrcPublishFolder);
        // Copy down the committed "common\config\rush\.npmrc-publish" file, if there is one
        Utilities_1.Utilities.syncNpmrc(this.rushConfiguration.commonRushConfigFolder, this._targetNpmrcPublishFolder, true);
    }
    _addSharedNpmConfig(env, args) {
        const userHomeEnvVariable = process.platform === 'win32' ? 'USERPROFILE' : 'HOME';
        let registry = '//registry.npmjs.org/';
        // Check if .npmrc file exists in "common\temp\publish-home"
        if (node_core_library_1.FileSystem.exists(this._targetNpmrcPublishPath)) {
            // Redirect userHomeEnvVariable, NPM will use config in "common\temp\publish-home\.npmrc"
            env[userHomeEnvVariable] = this._targetNpmrcPublishFolder;
        }
        // Check if registryUrl and token are specified via command-line
        if (this._registryUrl.value) {
            const registryUrl = this._registryUrl.value;
            env['npm_config_registry'] = registryUrl; // eslint-disable-line dot-notation
            registry = registryUrl.substring(registryUrl.indexOf('//'));
        }
        if (this._npmAuthToken.value) {
            args.push(`--${registry}:_authToken=${this._npmAuthToken.value}`);
        }
    }
}
exports.PublishAction = PublishAction;
//# sourceMappingURL=PublishAction.js.map

/***/ }),

/***/ 8596:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PurgeAction = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const os = __importStar(__webpack_require__(12087));
const BaseRushAction_1 = __webpack_require__(46677);
const Stopwatch_1 = __webpack_require__(80414);
const PurgeManager_1 = __webpack_require__(28805);
const UnlinkManager_1 = __webpack_require__(1984);
class PurgeAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'purge',
            summary: 'For diagnostic purposes, use this command to delete caches and other temporary files used by Rush',
            documentation: 'The "rush purge" command is used to delete temporary files created by Rush.  This is' +
                ' useful if you are having problems and suspect that cache files may be corrupt.',
            parser
        });
    }
    onDefineParameters() {
        this._unsafeParameter = this.defineFlagParameter({
            parameterLongName: '--unsafe',
            description: '(UNSAFE!) Also delete shared files such as the package manager instances stored in' +
                ' the ".rush" folder in the user\'s home directory.  This is a more aggressive fix that is' +
                ' NOT SAFE to run in a live environment because it will cause other concurrent Rush processes to fail.'
        });
    }
    async runAsync() {
        const stopwatch = Stopwatch_1.Stopwatch.start();
        const unlinkManager = new UnlinkManager_1.UnlinkManager(this.rushConfiguration);
        const purgeManager = new PurgeManager_1.PurgeManager(this.rushConfiguration, this.rushGlobalFolder);
        unlinkManager.unlink(/*force:*/ true);
        if (this._unsafeParameter.value) {
            purgeManager.purgeUnsafe();
        }
        else {
            purgeManager.purgeNormal();
        }
        purgeManager.deleteAll();
        console.log(os.EOL +
            safe_1.default.green(`Rush purge started successfully and will complete asynchronously. (${stopwatch.toString()})`));
    }
}
exports.PurgeAction = PurgeAction;
//# sourceMappingURL=PurgeAction.js.map

/***/ }),

/***/ 40379:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScanAction = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const path = __importStar(__webpack_require__(85622));
const builtin_modules_1 = __importDefault(__webpack_require__(980));
const node_core_library_1 = __webpack_require__(24019);
const BaseRushAction_1 = __webpack_require__(46677);
const glob = node_core_library_1.Import.lazy('glob', require);
class ScanAction extends BaseRushAction_1.BaseConfiglessRushAction {
    constructor(parser) {
        super({
            actionName: 'scan',
            summary: 'When migrating projects into a Rush repo, this command is helpful for detecting' +
                ' undeclared dependencies.',
            documentation: `The Node.js module system allows a project to import NPM packages without explicitly` +
                ` declaring them as dependencies in the package.json file.  Such "phantom dependencies"` +
                ` can cause problems.  Rush and PNPM use symlinks specifically to protect against phantom dependencies.` +
                ` These protections may cause runtime errors for existing projects when they are first migrated into` +
                ` a Rush monorepo.  The "rush scan" command is a handy tool for fixing these errors. It scans the "./src"` +
                ` and "./lib" folders for import syntaxes such as "import __ from '__'", "require('__')",` +
                ` and "System.import('__').  It prints a report of the referenced packages.  This heuristic is` +
                ` not perfect, but it can save a lot of time when migrating projects.`,
            safeForSimultaneousRushProcesses: true,
            parser
        });
    }
    onDefineParameters() {
        this._jsonFlag = this.defineFlagParameter({
            parameterLongName: '--json',
            description: 'If this flag is specified, output will be in JSON format.'
        });
        this._allFlag = this.defineFlagParameter({
            parameterLongName: '--all',
            description: 'If this flag is specified, output will list all detected dependencies.'
        });
    }
    async runAsync() {
        const packageJsonFilename = path.resolve('./package.json');
        if (!node_core_library_1.FileSystem.exists(packageJsonFilename)) {
            throw new Error('You must run "rush scan" in a project folder containing a package.json file.');
        }
        const requireRegExps = [
            // Example: require('something')
            /\brequire\s*\(\s*[']([^']+\s*)[']\)/,
            /\brequire\s*\(\s*["]([^"]+)["]\s*\)/,
            // Example: require.ensure('something')
            /\brequire.ensure\s*\(\s*[']([^']+\s*)[']\)/,
            /\brequire.ensure\s*\(\s*["]([^"]+)["]\s*\)/,
            // Example: require.resolve('something')
            /\brequire.resolve\s*\(\s*[']([^']+\s*)[']\)/,
            /\brequire.resolve\s*\(\s*["]([^"]+)["]\s*\)/,
            // Example: System.import('something')
            /\bSystem.import\s*\(\s*[']([^']+\s*)[']\)/,
            /\bSystem.import\s*\(\s*["]([^"]+)["]\s*\)/,
            // Example:
            //
            // import {
            //   A, B
            // } from 'something';
            /\bfrom\s*[']([^']+)[']/,
            /\bfrom\s*["]([^"]+)["]/,
            // Example:  import 'something';
            /\bimport\s*[']([^']+)[']\s*\;/,
            /\bimport\s*["]([^"]+)["]\s*\;/,
            // Example:
            // /// <reference types="something" />
            /\/\/\/\s*<\s*reference\s+types\s*=\s*["]([^"]+)["]\s*\/>/
        ];
        // Example: "my-package/lad/dee/dah" --> "my-package"
        // Example: "@ms/my-package" --> "@ms/my-package"
        const packageRegExp = /^((@[a-z\-0-9!_]+\/)?[a-z\-0-9!_]+)\/?/;
        const requireMatches = new Set();
        for (const filename of glob.sync('{./*.{ts,js,tsx,jsx},./{src,lib}/**/*.{ts,js,tsx,jsx}}')) {
            try {
                const contents = node_core_library_1.FileSystem.readFile(filename);
                const lines = contents.split('\n');
                for (const line of lines) {
                    for (const requireRegExp of requireRegExps) {
                        const requireRegExpResult = requireRegExp.exec(line);
                        if (requireRegExpResult) {
                            requireMatches.add(requireRegExpResult[1]);
                        }
                    }
                }
            }
            catch (error) {
                console.log(safe_1.default.bold('Skipping file due to error: ' + filename));
            }
        }
        const packageMatches = new Set();
        requireMatches.forEach((requireMatch) => {
            const packageRegExpResult = packageRegExp.exec(requireMatch);
            if (packageRegExpResult) {
                packageMatches.add(packageRegExpResult[1]);
            }
        });
        const detectedPackageNames = [];
        packageMatches.forEach((packageName) => {
            if (builtin_modules_1.default.indexOf(packageName) < 0) {
                detectedPackageNames.push(packageName);
            }
        });
        detectedPackageNames.sort();
        const declaredDependencies = new Set();
        const declaredDevDependencies = new Set();
        const missingDependencies = [];
        const unusedDependencies = [];
        const packageJsonContent = node_core_library_1.FileSystem.readFile(packageJsonFilename);
        try {
            const manifest = JSON.parse(packageJsonContent);
            if (manifest.dependencies) {
                for (const depName of Object.keys(manifest.dependencies)) {
                    declaredDependencies.add(depName);
                }
            }
            if (manifest.devDependencies) {
                for (const depName of Object.keys(manifest.devDependencies)) {
                    declaredDevDependencies.add(depName);
                }
            }
        }
        catch (e) {
            console.error(`JSON.parse ${packageJsonFilename} error`);
        }
        for (const detectedPkgName of detectedPackageNames) {
            /**
             * Missing(phantom) dependencies are
             * - used in source code
             * - not decalred in dependencies and devDependencies in package.json
             */
            if (!declaredDependencies.has(detectedPkgName) && !declaredDevDependencies.has(detectedPkgName)) {
                missingDependencies.push(detectedPkgName);
            }
        }
        for (const declaredPkgName of declaredDependencies) {
            /**
             * Unused dependencies are
             * - declared in dependencies in package.json (devDependencies not included)
             * - not used in source code
             */
            if (!detectedPackageNames.includes(declaredPkgName) && !declaredPkgName.startsWith('@types/')) {
                unusedDependencies.push(declaredPkgName);
            }
        }
        const output = {
            detectedDependencies: detectedPackageNames,
            missingDependencies: missingDependencies,
            unusedDependencies: unusedDependencies
        };
        if (this._jsonFlag.value) {
            console.log(JSON.stringify(output, undefined, 2));
        }
        else if (this._allFlag.value) {
            if (detectedPackageNames.length !== 0) {
                console.log('Dependencies that seem to be imported by this project:');
                for (const packageName of detectedPackageNames) {
                    console.log('  ' + packageName);
                }
            }
            else {
                console.log('This project does not seem to import any NPM packages.');
            }
        }
        else {
            let wroteAnything = false;
            if (missingDependencies.length > 0) {
                console.log(safe_1.default.yellow('Possible phantom dependencies') +
                    " - these seem to be imported but aren't listed in package.json:");
                for (const packageName of missingDependencies) {
                    console.log('  ' + packageName);
                }
                wroteAnything = true;
            }
            if (unusedDependencies.length > 0) {
                if (wroteAnything) {
                    console.log('');
                }
                console.log(safe_1.default.yellow('Possible unused dependencies') +
                    " - these are listed in package.json but don't seem to be imported:");
                for (const packageName of unusedDependencies) {
                    console.log('  ' + packageName);
                }
                wroteAnything = true;
            }
            if (!wroteAnything) {
                console.log(safe_1.default.green('Everything looks good.') + '  No missing or unused dependencies were found.');
            }
        }
    }
}
exports.ScanAction = ScanAction;
//# sourceMappingURL=ScanAction.js.map

/***/ }),

/***/ 61296:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetupAction = void 0;
const SetupPackageRegistry_1 = __webpack_require__(61295);
const BaseRushAction_1 = __webpack_require__(46677);
class SetupAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'setup',
            summary: '(EXPERIMENTAL) Invoke this command before working in a new repo to ensure that any required' +
                ' prerequisites are installed and permissions are configured.',
            documentation: '(EXPERIMENTAL) Invoke this command before working in a new repo to ensure that any required' +
                ' prerequisites are installed and permissions are configured.  The initial implementation' +
                ' configures the NPM registry credentials.  More features will be added later.',
            parser
        });
    }
    onDefineParameters() {
        // abstract
    }
    async runAsync() {
        const setupPackageRegistry = new SetupPackageRegistry_1.SetupPackageRegistry({
            rushConfiguration: this.rushConfiguration,
            isDebug: this.parser.isDebug,
            syncNpmrcAlreadyCalled: false
        });
        await setupPackageRegistry.checkAndSetup();
    }
}
exports.SetupAction = SetupAction;
//# sourceMappingURL=SetupAction.js.map

/***/ }),

/***/ 16287:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnlinkAction = void 0;
const os = __importStar(__webpack_require__(12087));
const BaseRushAction_1 = __webpack_require__(46677);
const UnlinkManager_1 = __webpack_require__(1984);
class UnlinkAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'unlink',
            summary: 'Delete node_modules symlinks for all projects in the repo',
            documentation: 'This removes the symlinks created by the "rush link" command. This is useful for' +
                ' cleaning a repo using "git clean" without accidentally deleting source files, or for using standard NPM' +
                ' commands on a project.',
            parser
        });
    }
    onDefineParameters() {
        // No parameters
    }
    async runAsync() {
        const unlinkManager = new UnlinkManager_1.UnlinkManager(this.rushConfiguration);
        if (!unlinkManager.unlink()) {
            console.log('Nothing to do.');
        }
        else {
            console.log(os.EOL + 'Done.');
        }
    }
}
exports.UnlinkAction = UnlinkAction;
//# sourceMappingURL=UnlinkAction.js.map

/***/ }),

/***/ 35414:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateAction = void 0;
const BaseInstallAction_1 = __webpack_require__(91343);
class UpdateAction extends BaseInstallAction_1.BaseInstallAction {
    constructor(parser) {
        super({
            actionName: 'update',
            summary: 'Install package dependencies for all projects in the repo,' +
                ' and create or update the shrinkwrap file as needed',
            documentation: 'The "rush update" command installs the dependencies described in your' +
                ' package.json files, and updates the shrinkwrap file as needed.' +
                ' (This "shrinkwrap" file stores a central inventory of all dependencies and versions' +
                ' for projects in your repo. It is found in the "common/config/rush" folder.)' +
                ' Note that Rush always performs a single install for all projects in your repo.' +
                ' You should run "rush update" whenever you start working in a Rush repo,' +
                ' after you pull from Git, and after you modify a package.json file.' +
                ' If there is nothing to do, "rush update" is instantaneous.' +
                ' NOTE: In certain cases "rush install" should be used instead of "rush update"' +
                ' -- for details, see the command help for "rush install".',
            parser
        });
    }
    onDefineParameters() {
        super.onDefineParameters();
        this._fullParameter = this.defineFlagParameter({
            parameterLongName: '--full',
            description: 'Normally "rush update" tries to preserve your existing installed versions' +
                ' and only makes the minimum updates needed to satisfy the package.json files.' +
                ' This conservative approach prevents your PR from getting involved with package updates that' +
                ' are unrelated to your work. Use "--full" when you really want to update all dependencies' +
                ' to the latest SemVer-compatible version.  This should be done periodically by a person' +
                ' or robot whose role is to deal with potential upgrade regressions.'
        });
        this._recheckParameter = this.defineFlagParameter({
            parameterLongName: '--recheck',
            description: 'If the shrinkwrap file appears to already satisfy the package.json files,' +
                ' then "rush update" will skip invoking the package manager at all.  In certain situations' +
                ' this heuristic may be inaccurate.  Use the "--recheck" flag to force the package manager' +
                " to process the shrinkwrap file.  This will also update your shrinkwrap file with Rush's fixups." +
                ' (To minimize shrinkwrap churn, these fixups are normally performed only in the temporary folder.)'
        });
    }
    buildInstallOptions() {
        return {
            debug: this.parser.isDebug,
            allowShrinkwrapUpdates: true,
            bypassPolicy: this._bypassPolicyParameter.value,
            noLink: this._noLinkParameter.value,
            fullUpgrade: this._fullParameter.value,
            recheckShrinkwrap: this._recheckParameter.value,
            networkConcurrency: this._networkConcurrencyParameter.value,
            collectLogFile: this._debugPackageManagerParameter.value,
            variant: this._variant.value,
            // Because the 'defaultValue' option on the _maxInstallAttempts parameter is set,
            // it is safe to assume that the value is not null
            maxInstallAttempts: this._maxInstallAttempts.value,
            pnpmFilterArguments: [],
            checkOnly: false
        };
    }
}
exports.UpdateAction = UpdateAction;
//# sourceMappingURL=UpdateAction.js.map

/***/ }),

/***/ 34824:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateAutoinstallerAction = void 0;
const BaseRushAction_1 = __webpack_require__(46677);
const Autoinstaller_1 = __webpack_require__(78226);
class UpdateAutoinstallerAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'update-autoinstaller',
            summary: 'Updates autoinstaller package dependenices',
            documentation: 'Use this command to regenerate the shrinkwrap file for an autoinstaller folder.',
            parser
        });
    }
    onDefineParameters() {
        this._name = this.defineStringParameter({
            parameterLongName: '--name',
            argumentName: 'AUTOINSTALLER_NAME',
            required: true,
            description: 'Specifies the name of the autoinstaller, which must be one of the folders under common/autoinstallers.'
        });
    }
    async runAsync() {
        const autoinstallerName = this._name.value;
        const autoinstaller = new Autoinstaller_1.Autoinstaller(autoinstallerName, this.rushConfiguration);
        autoinstaller.update();
        console.log('\nSuccess.');
    }
}
exports.UpdateAutoinstallerAction = UpdateAutoinstallerAction;
//# sourceMappingURL=UpdateAutoinstallerAction.js.map

/***/ }),

/***/ 28714:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateCloudCredentialsAction = void 0;
const node_core_library_1 = __webpack_require__(24019);
const BaseRushAction_1 = __webpack_require__(46677);
const BuildCacheConfiguration_1 = __webpack_require__(7538);
const RushConstants_1 = __webpack_require__(63985);
class UpdateCloudCredentialsAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        super({
            actionName: RushConstants_1.RushConstants.updateCloudCredentialsCommandName,
            summary: '(EXPERIMENTAL) Update the credentials used by the build cache provider.',
            documentation: '(EXPERIMENTAL) If the build caching feature is configured, this command facilitates ' +
                'updating the credentials used by a cloud-based provider.',
            safeForSimultaneousRushProcesses: false,
            parser
        });
    }
    onDefineParameters() {
        this._interactiveModeFlag = this.defineFlagParameter({
            parameterLongName: '--interactive',
            parameterShortName: '-i',
            description: 'Run the credential update operation in interactive mode, if supported by the provider.'
        });
        this._credentialParameter = this.defineStringParameter({
            parameterLongName: '--credential',
            argumentName: 'CREDENTIAL_STRING',
            description: 'A static credential, to be cached.'
        });
        this._deleteFlag = this.defineFlagParameter({
            parameterLongName: '--delete',
            parameterShortName: '-d',
            description: 'If specified, delete stored credentials.'
        });
    }
    async runAsync() {
        const terminal = new node_core_library_1.Terminal(new node_core_library_1.ConsoleTerminalProvider());
        const buildCacheConfiguration = await BuildCacheConfiguration_1.BuildCacheConfiguration.loadAndRequireEnabledAsync(terminal, this.rushConfiguration);
        if (this._deleteFlag.value) {
            if (this._interactiveModeFlag.value || this._credentialParameter.value !== undefined) {
                terminal.writeErrorLine(`If the ${this._deleteFlag.longName} is provided, no other parameters may be provided.`);
                throw new node_core_library_1.AlreadyReportedError();
            }
            else if (buildCacheConfiguration.cloudCacheProvider) {
                await buildCacheConfiguration.cloudCacheProvider.deleteCachedCredentialsAsync(terminal);
            }
            else {
                terminal.writeLine('A cloud build cache is not configured; there is nothing to delete.');
            }
        }
        else if (this._interactiveModeFlag.value && this._credentialParameter.value !== undefined) {
            terminal.writeErrorLine(`Both the ${this._interactiveModeFlag.longName} and the ` +
                `${this._credentialParameter.longName} parameters were provided. Only one ` +
                'or the other may be used at a time.');
            throw new node_core_library_1.AlreadyReportedError();
        }
        else if (this._interactiveModeFlag.value) {
            if (buildCacheConfiguration.cloudCacheProvider) {
                await buildCacheConfiguration.cloudCacheProvider.updateCachedCredentialInteractiveAsync(terminal);
            }
            else {
                terminal.writeLine('A cloud build cache is not configured. Credentials are not required.');
            }
        }
        else if (this._credentialParameter.value !== undefined) {
            if (buildCacheConfiguration.cloudCacheProvider) {
                await buildCacheConfiguration.cloudCacheProvider.updateCachedCredentialAsync(terminal, this._credentialParameter.value);
            }
            else {
                terminal.writeErrorLine('A cloud build cache is not configured. Credentials are not supported.');
                throw new node_core_library_1.AlreadyReportedError();
            }
        }
        else {
            terminal.writeErrorLine(`One of the ${this._interactiveModeFlag.longName} parameter, the ` +
                `${this._credentialParameter.longName} parameter, or the ` +
                `${this._deleteFlag.longName} parameter must be provided.`);
            throw new node_core_library_1.AlreadyReportedError();
        }
    }
}
exports.UpdateCloudCredentialsAction = UpdateCloudCredentialsAction;
//# sourceMappingURL=UpdateCloudCredentialsAction.js.map

/***/ }),

/***/ 85081:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VersionAction = exports.DEFAULT_CHANGELOG_UPDATE_MESSAGE = exports.DEFAULT_PACKAGE_UPDATE_MESSAGE = void 0;
const semver = __importStar(__webpack_require__(11383));
const node_core_library_1 = __webpack_require__(24019);
const VersionPolicy_1 = __webpack_require__(78075);
const RushConfiguration_1 = __webpack_require__(92905);
const VersionMismatchFinder_1 = __webpack_require__(81372);
const PolicyValidator_1 = __webpack_require__(40499);
const BaseRushAction_1 = __webpack_require__(46677);
const PublishGit_1 = __webpack_require__(66953);
const Git_1 = __webpack_require__(58361);
const versionManagerModule = node_core_library_1.Import.lazy('../../logic/VersionManager', require);
exports.DEFAULT_PACKAGE_UPDATE_MESSAGE = 'Bump versions [skip ci]';
exports.DEFAULT_CHANGELOG_UPDATE_MESSAGE = 'Update changelogs [skip ci]';
class VersionAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'version',
            summary: 'Manage package versions in the repo.',
            documentation: 'use this "rush version" command to ensure version policies and bump versions.',
            parser
        });
    }
    onDefineParameters() {
        this._targetBranch = this.defineStringParameter({
            parameterLongName: '--target-branch',
            parameterShortName: '-b',
            argumentName: 'BRANCH',
            description: 'If this flag is specified, changes will be committed and merged into the target branch.'
        });
        this._ensureVersionPolicy = this.defineFlagParameter({
            parameterLongName: '--ensure-version-policy',
            description: 'Updates package versions if needed to satisfy version policies.'
        });
        this._overrideVersion = this.defineStringParameter({
            parameterLongName: '--override-version',
            argumentName: 'NEW_VERSION',
            description: 'Override the version in the specified --version-policy. ' +
                'This setting only works for lock-step version policy and when --ensure-version-policy is specified.'
        });
        this._bumpVersion = this.defineFlagParameter({
            parameterLongName: '--bump',
            description: 'Bumps package version based on version policies.'
        });
        this._bypassPolicy = this.defineFlagParameter({
            parameterLongName: '--bypass-policy',
            description: 'Overrides "gitPolicy" enforcement (use honorably!)'
        });
        this._versionPolicy = this.defineStringParameter({
            parameterLongName: '--version-policy',
            argumentName: 'POLICY',
            description: 'The name of the version policy'
        });
        this._overwriteBump = this.defineStringParameter({
            parameterLongName: '--override-bump',
            argumentName: 'BUMPTYPE',
            description: 'Overrides the bump type in the version-policy.json for the specified version policy. ' +
                'Valid BUMPTYPE values include: prerelease, patch, preminor, minor, major. ' +
                'This setting only works for lock-step version policy in bump action.'
        });
        this._prereleaseIdentifier = this.defineStringParameter({
            parameterLongName: '--override-prerelease-id',
            argumentName: 'ID',
            description: 'Overrides the prerelease identifier in the version value of version-policy.json ' +
                'for the specified version policy. ' +
                'This setting only works for lock-step version policy. ' +
                'This setting increases to new prerelease id when "--bump" is provided but only replaces the ' +
                'prerelease name when "--ensure-version-policy" is provided.'
        });
        this._ignoreGitHooksParameter = this.defineFlagParameter({
            parameterLongName: '--ignore-git-hooks',
            description: `Skips execution of all git hooks. Make sure you know what you are skipping.`
        });
    }
    async runAsync() {
        PolicyValidator_1.PolicyValidator.validatePolicy(this.rushConfiguration, { bypassPolicy: this._bypassPolicy.value });
        const git = new Git_1.Git(this.rushConfiguration);
        const userEmail = git.getGitEmail();
        this._validateInput();
        const versionManager = new versionManagerModule.VersionManager(this.rushConfiguration, userEmail, this.rushConfiguration.versionPolicyConfiguration);
        if (this._ensureVersionPolicy.value) {
            this._overwritePolicyVersionIfNeeded();
            const tempBranch = 'version/ensure-' + new Date().getTime();
            versionManager.ensure(this._versionPolicy.value, true, !!this._overrideVersion.value || !!this._prereleaseIdentifier.value);
            const updatedPackages = versionManager.updatedProjects;
            if (updatedPackages.size > 0) {
                console.log(`${updatedPackages.size} packages are getting updated.`);
                this._gitProcess(tempBranch, this._targetBranch.value);
            }
        }
        else if (this._bumpVersion.value) {
            const tempBranch = 'version/bump-' + new Date().getTime();
            await versionManager.bumpAsync(this._versionPolicy.value, this._overwriteBump.value ? node_core_library_1.Enum.getValueByKey(VersionPolicy_1.BumpType, this._overwriteBump.value) : undefined, this._prereleaseIdentifier.value, true);
            this._gitProcess(tempBranch, this._targetBranch.value);
        }
    }
    _overwritePolicyVersionIfNeeded() {
        if (!this._overrideVersion.value && !this._prereleaseIdentifier.value) {
            // No need to overwrite policy version
            return;
        }
        if (this._overrideVersion.value && this._prereleaseIdentifier.value) {
            throw new Error(`The parameters "--override-version" and "--override-prerelease-id" cannot be used together.`);
        }
        if (this._versionPolicy.value) {
            const versionConfig = this.rushConfiguration.versionPolicyConfiguration;
            const policy = versionConfig.getVersionPolicy(this._versionPolicy.value);
            if (!policy || !policy.isLockstepped) {
                throw new Error(`The lockstep version policy "${policy.policyName}" is not found.`);
            }
            let newVersion = undefined;
            if (this._overrideVersion.value) {
                newVersion = this._overrideVersion.value;
            }
            else if (this._prereleaseIdentifier.value) {
                const newPolicyVersion = new semver.SemVer(policy.version);
                if (newPolicyVersion.prerelease.length) {
                    // Update 1.5.0-alpha.10 to 1.5.0-beta.10
                    // For example, if we are parsing "1.5.0-alpha.10" then the newPolicyVersion.prerelease array
                    // would contain [ "alpha", 10 ], so we would replace "alpha" with "beta"
                    newPolicyVersion.prerelease = [
                        this._prereleaseIdentifier.value,
                        ...newPolicyVersion.prerelease.slice(1)
                    ];
                }
                else {
                    // Update 1.5.0 to 1.5.0-beta
                    // Since there is no length, we can just set to a new array
                    newPolicyVersion.prerelease = [this._prereleaseIdentifier.value];
                }
                newVersion = newPolicyVersion.format();
            }
            if (newVersion) {
                console.log(`Update version policy ${policy.policyName} from ${policy.version} to ${newVersion}`);
                versionConfig.update(this._versionPolicy.value, newVersion);
            }
        }
        else {
            throw new Error('Missing --version-policy parameter to specify which version policy should be overwritten.');
        }
    }
    _validateInput() {
        if (this._bumpVersion.value && this._ensureVersionPolicy.value) {
            throw new Error('Please choose --bump or --ensure-version-policy but not together.');
        }
        if (this._overwriteBump.value && !node_core_library_1.Enum.tryGetValueByKey(VersionPolicy_1.BumpType, this._overwriteBump.value)) {
            throw new Error('The value of override-bump is not valid.  ' +
                'Valid values include prerelease, patch, preminor, minor, and major');
        }
    }
    _validateResult() {
        // Load the config from file to avoid using inconsistent in-memory data.
        const rushConfig = RushConfiguration_1.RushConfiguration.loadFromConfigurationFile(this.rushConfiguration.rushJsonFile);
        const mismatchFinder = VersionMismatchFinder_1.VersionMismatchFinder.getMismatches(rushConfig);
        if (mismatchFinder.numberOfMismatches) {
            throw new Error('Unable to finish version bump because inconsistencies were encountered. ' +
                'Run "rush check" to find more details.');
        }
    }
    _gitProcess(tempBranch, targetBranch) {
        // Validate the result before commit.
        this._validateResult();
        const git = new Git_1.Git(this.rushConfiguration);
        const publishGit = new PublishGit_1.PublishGit(git, targetBranch);
        // Make changes in temp branch.
        publishGit.checkout(tempBranch, true);
        const uncommittedChanges = git.getUncommittedChanges();
        // Stage, commit, and push the changes to remote temp branch.
        // Need to commit the change log updates in its own commit
        const changeLogUpdated = uncommittedChanges.some((changePath) => {
            return changePath.indexOf('CHANGELOG.json') > 0;
        });
        if (changeLogUpdated) {
            publishGit.addChanges('.', this.rushConfiguration.changesFolder);
            publishGit.addChanges(':/**/CHANGELOG.json');
            publishGit.addChanges(':/**/CHANGELOG.md');
            publishGit.commit(this.rushConfiguration.gitChangeLogUpdateCommitMessage || exports.DEFAULT_CHANGELOG_UPDATE_MESSAGE, !this._ignoreGitHooksParameter.value);
        }
        // Commit the package.json and change files updates.
        const packageJsonUpdated = uncommittedChanges.some((changePath) => {
            return changePath.indexOf("package.json" /* PackageJson */) > 0;
        });
        if (packageJsonUpdated) {
            publishGit.addChanges(this.rushConfiguration.versionPolicyConfigurationFilePath);
            publishGit.addChanges(':/**/package.json');
            publishGit.commit(this.rushConfiguration.gitVersionBumpCommitMessage || exports.DEFAULT_PACKAGE_UPDATE_MESSAGE, !this._ignoreGitHooksParameter.value);
        }
        if (changeLogUpdated || packageJsonUpdated) {
            publishGit.push(tempBranch, !this._ignoreGitHooksParameter.value);
            // Now merge to target branch.
            publishGit.fetch();
            publishGit.checkout(targetBranch);
            publishGit.pull(!this._ignoreGitHooksParameter.value);
            publishGit.merge(tempBranch, !this._ignoreGitHooksParameter.value);
            publishGit.push(targetBranch, !this._ignoreGitHooksParameter.value);
            publishGit.deleteBranch(tempBranch, true, !this._ignoreGitHooksParameter.value);
        }
        else {
            // skip commits
            publishGit.fetch();
            publishGit.checkout(targetBranch);
            publishGit.deleteBranch(tempBranch, false, !this._ignoreGitHooksParameter.value);
        }
    }
}
exports.VersionAction = VersionAction;
//# sourceMappingURL=VersionAction.js.map

/***/ }),

/***/ 64575:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WriteBuildCacheAction = void 0;
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const BaseRushAction_1 = __webpack_require__(46677);
const BuildCacheConfiguration_1 = __webpack_require__(7538);
const ProjectBuilder_1 = __webpack_require__(57081);
const ProjectChangeAnalyzer_1 = __webpack_require__(15504);
const Utilities_1 = __webpack_require__(89521);
const TaskSelector_1 = __webpack_require__(84153);
const RushConstants_1 = __webpack_require__(63985);
const CommandLineConfiguration_1 = __webpack_require__(5347);
class WriteBuildCacheAction extends BaseRushAction_1.BaseRushAction {
    constructor(parser) {
        super({
            actionName: 'write-build-cache',
            summary: 'Writes the current state of the current project to the cache.',
            documentation: '(EXPERIMENTAL) If the build cache is configured, when this command is run in the folder of ' +
                'a project, write the current state of the project to the cache.',
            safeForSimultaneousRushProcesses: true,
            parser
        });
    }
    onDefineParameters() {
        this._command = this.defineStringParameter({
            parameterLongName: '--command',
            parameterShortName: '-c',
            required: true,
            argumentName: 'COMMAND',
            description: '(Required) The command run in the current project that produced the current project state.'
        });
        this._verboseFlag = this.defineFlagParameter({
            parameterLongName: '--verbose',
            parameterShortName: '-v',
            description: 'Display verbose log information.'
        });
    }
    async runAsync() {
        const project = this.rushConfiguration.tryGetProjectForPath(process.cwd());
        if (!project) {
            throw new Error(`The "rush ${this.actionName}" command must be invoked under a project` +
                ` folder that is registered in rush.json.`);
        }
        const terminal = new node_core_library_1.Terminal(new node_core_library_1.ConsoleTerminalProvider({ verboseEnabled: this._verboseFlag.value }));
        const buildCacheConfiguration = await BuildCacheConfiguration_1.BuildCacheConfiguration.loadAndRequireEnabledAsync(terminal, this.rushConfiguration);
        const command = this._command.value;
        const commandToRun = TaskSelector_1.TaskSelector.getScriptToRun(project, command, []);
        const projectChangeAnalyzer = new ProjectChangeAnalyzer_1.ProjectChangeAnalyzer(this.rushConfiguration);
        const projectBuilder = new ProjectBuilder_1.ProjectBuilder({
            rushProject: project,
            rushConfiguration: this.rushConfiguration,
            buildCacheConfiguration,
            commandName: command,
            commandToRun: commandToRun || '',
            isIncrementalBuildAllowed: false,
            projectChangeAnalyzer,
            packageDepsFilename: Utilities_1.Utilities.getPackageDepsFilenameForCommand(command)
        });
        const trackedFiles = Array.from((await projectChangeAnalyzer._tryGetProjectDependenciesAsync(project.packageName, terminal)).keys());
        const commandLineConfigFilePath = path.join(this.rushConfiguration.commonRushConfigFolder, RushConstants_1.RushConstants.commandLineFilename);
        const repoCommandLineConfiguration = CommandLineConfiguration_1.CommandLineConfiguration.loadFromFileOrDefault(commandLineConfigFilePath);
        const cacheWriteSuccess = await projectBuilder.tryWriteCacheEntryAsync(terminal, trackedFiles, repoCommandLineConfiguration);
        if (cacheWriteSuccess === undefined) {
            terminal.writeErrorLine('This project does not support caching or Git is not present.');
            throw new node_core_library_1.AlreadyReportedError();
        }
        else if (cacheWriteSuccess === false) {
            terminal.writeErrorLine('Writing cache entry failed.');
        }
    }
}
exports.WriteBuildCacheAction = WriteBuildCacheAction;
//# sourceMappingURL=WriteBuildCacheAction.js.map

/***/ }),

/***/ 77121:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseScriptAction = void 0;
const BaseRushAction_1 = __webpack_require__(46677);
const RushConstants_1 = __webpack_require__(63985);
/**
 * Base class for command-line actions that are implemented using user-defined scripts.
 *
 * @remarks
 * Compared to the normal built-in actions, these actions are special because (1) they
 * can be discovered dynamically via common/config/command-line.json, and (2)
 * user-defined command-line parameters can be passed through to the script.
 *
 * The two subclasses are BulkScriptAction and GlobalScriptAction.
 */
class BaseScriptAction extends BaseRushAction_1.BaseRushAction {
    constructor(options) {
        super(options);
        this.customParameters = [];
        this._commandLineConfiguration = options.commandLineConfiguration;
    }
    defineScriptParameters() {
        if (!this._commandLineConfiguration) {
            return;
        }
        // Find any parameters that are associated with this command
        for (const parameterJson of this._commandLineConfiguration.parameters) {
            let associated = false;
            for (const associatedCommand of parameterJson.associatedCommands || []) {
                if (associatedCommand === this.actionName) {
                    associated = true;
                }
            }
            if (associated) {
                let customParameter;
                switch (parameterJson.parameterKind) {
                    case 'flag':
                        customParameter = this.defineFlagParameter({
                            parameterShortName: parameterJson.shortName,
                            parameterLongName: parameterJson.longName,
                            description: parameterJson.description,
                            required: parameterJson.required
                        });
                        break;
                    case 'choice':
                        customParameter = this.defineChoiceParameter({
                            parameterShortName: parameterJson.shortName,
                            parameterLongName: parameterJson.longName,
                            description: parameterJson.description,
                            required: parameterJson.required,
                            alternatives: parameterJson.alternatives.map((x) => x.name),
                            defaultValue: parameterJson.defaultValue
                        });
                        break;
                    case 'string':
                        customParameter = this.defineStringParameter({
                            parameterLongName: parameterJson.longName,
                            parameterShortName: parameterJson.shortName,
                            description: parameterJson.description,
                            required: parameterJson.required,
                            argumentName: parameterJson.argumentName
                        });
                        break;
                    default:
                        throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a parameter "${parameterJson.longName}" using an unsupported parameter kind "${parameterJson.parameterKind}"`);
                }
                if (customParameter) {
                    this.customParameters.push(customParameter);
                }
            }
        }
    }
}
exports.BaseScriptAction = BaseScriptAction;
//# sourceMappingURL=BaseScriptAction.js.map

/***/ }),

/***/ 19534:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BulkScriptAction = void 0;
const os = __importStar(__webpack_require__(12087));
const safe_1 = __importDefault(__webpack_require__(41997));
const node_core_library_1 = __webpack_require__(24019);
const index_1 = __webpack_require__(57088);
const SetupChecks_1 = __webpack_require__(96766);
const TaskSelector_1 = __webpack_require__(84153);
const Stopwatch_1 = __webpack_require__(80414);
const BaseScriptAction_1 = __webpack_require__(77121);
const TaskRunner_1 = __webpack_require__(58883);
const Utilities_1 = __webpack_require__(89521);
const RushConstants_1 = __webpack_require__(63985);
const LastLinkFlag_1 = __webpack_require__(10508);
const BuildCacheConfiguration_1 = __webpack_require__(7538);
const Selection_1 = __webpack_require__(13857);
const SelectionParameterSet_1 = __webpack_require__(96724);
/**
 * This class implements bulk commands which are run individually for each project in the repo,
 * possibly in parallel.  The action executes a script found in the project's package.json file.
 *
 * @remarks
 * Bulk commands can be defined via common/config/command-line.json.  Rush's predefined "build"
 * and "rebuild" commands are also modeled as bulk commands, because they essentially just
 * execute scripts from package.json in the same as any custom command.
 */
class BulkScriptAction extends BaseScriptAction_1.BaseScriptAction {
    constructor(options) {
        super(options);
        this._enableParallelism = options.enableParallelism;
        this._ignoreMissingScript = options.ignoreMissingScript;
        this._isIncrementalBuildAllowed = options.incremental;
        this._commandToRun = options.commandToRun || options.actionName;
        this._ignoreDependencyOrder = options.ignoreDependencyOrder;
        this._allowWarningsInSuccessfulBuild = options.allowWarningsInSuccessfulBuild;
        this._watchForChanges = options.watchForChanges;
        this._disableBuildCache = options.disableBuildCache;
        this._repoCommandLineConfiguration = options.commandLineConfiguration;
    }
    async runAsync() {
        // TODO: Replace with last-install.flag when "rush link" and "rush unlink" are deprecated
        const lastLinkFlag = LastLinkFlag_1.LastLinkFlagFactory.getCommonTempFlag(this.rushConfiguration);
        if (!lastLinkFlag.isValid()) {
            const useWorkspaces = this.rushConfiguration.pnpmOptions && this.rushConfiguration.pnpmOptions.useWorkspaces;
            if (useWorkspaces) {
                throw new Error(`Link flag invalid.${os.EOL}Did you run "rush install" or "rush update"?`);
            }
            else {
                throw new Error(`Link flag invalid.${os.EOL}Did you run "rush link"?`);
            }
        }
        this._doBeforeTask();
        const stopwatch = Stopwatch_1.Stopwatch.start();
        const isQuietMode = !this._verboseParameter.value;
        const isDebugMode = !!this.parser.isDebug;
        // if this is parallelizable, then use the value from the flag (undefined or a number),
        // if parallelism is not enabled, then restrict to 1 core
        const parallelism = this._enableParallelism ? this._parallelismParameter.value : '1';
        // Collect all custom parameter values
        const customParameterValues = [];
        for (const customParameter of this.customParameters) {
            customParameter.appendToArgList(customParameterValues);
        }
        const changedProjectsOnly = this._isIncrementalBuildAllowed && this._changedProjectsOnly.value;
        const terminal = new node_core_library_1.Terminal(new node_core_library_1.ConsoleTerminalProvider());
        let buildCacheConfiguration;
        if (!this._disableBuildCache) {
            buildCacheConfiguration = await BuildCacheConfiguration_1.BuildCacheConfiguration.tryLoadAsync(terminal, this.rushConfiguration);
        }
        const selection = this._selectionParameters.getSelectedProjects();
        if (!selection.size) {
            terminal.writeLine(safe_1.default.yellow(`The command line selection parameters did not match any projects.`));
            return;
        }
        const taskSelectorOptions = {
            rushConfiguration: this.rushConfiguration,
            buildCacheConfiguration,
            selection,
            commandName: this.actionName,
            commandToRun: this._commandToRun,
            customParameterValues,
            isQuietMode: isQuietMode,
            isDebugMode: isDebugMode,
            isIncrementalBuildAllowed: this._isIncrementalBuildAllowed,
            ignoreMissingScript: this._ignoreMissingScript,
            ignoreDependencyOrder: this._ignoreDependencyOrder,
            allowWarningsInSuccessfulBuild: this._allowWarningsInSuccessfulBuild,
            packageDepsFilename: Utilities_1.Utilities.getPackageDepsFilenameForCommand(this._commandToRun)
        };
        const taskRunnerOptions = {
            quietMode: isQuietMode,
            debugMode: this.parser.isDebug,
            parallelism: parallelism,
            changedProjectsOnly: changedProjectsOnly,
            allowWarningsInSuccessfulBuild: this._allowWarningsInSuccessfulBuild,
            repoCommandLineConfiguration: this._repoCommandLineConfiguration
        };
        const executeOptions = {
            taskSelectorOptions,
            taskRunnerOptions,
            stopwatch,
            terminal
        };
        if (this._watchForChanges) {
            await this._runWatch(executeOptions);
        }
        else {
            await this._runOnce(executeOptions);
        }
    }
    /**
     * Runs the command in watch mode. Fundamentally is a simple loop:
     * 1) Wait for a change to one or more projects in the selection (skipped initially)
     * 2) Invoke the command on the changed projects, and, if applicable, impacted projects
     *    Uses the same algorithm as --impacted-by
     * 3) Goto (1)
     */
    async _runWatch(options) {
        const { taskSelectorOptions: { selection: projectsToWatch }, stopwatch, terminal } = options;
        // Use async import so that we don't pay the cost for sync builds
        const { ProjectWatcher } = await Promise.resolve().then(() => __importStar(__webpack_require__(2329)));
        const projectWatcher = new ProjectWatcher({
            debounceMilliseconds: 1000,
            rushConfiguration: this.rushConfiguration,
            projectsToWatch,
            terminal
        });
        const onWatchingFiles = () => {
            // Report so that the developer can always see that it is in watch mode as the latest console line.
            terminal.writeLine(`Watching for changes to ${projectsToWatch.size} ${projectsToWatch.size === 1 ? 'project' : 'projects'}. Press Ctrl+C to exit.`);
        };
        // Loop until Ctrl+C
        // eslint-disable-next-line no-constant-condition
        while (true) {
            // On the initial invocation, this promise will return immediately with the full set of projects
            const { changedProjects, state } = await projectWatcher.waitForChange(onWatchingFiles);
            let selection = changedProjects;
            if (stopwatch.state === Stopwatch_1.StopwatchState.Stopped) {
                // Clear and reset the stopwatch so that we only report time from a single execution at a time
                stopwatch.reset();
                stopwatch.start();
            }
            terminal.writeLine(`Detected changes in ${selection.size} project${selection.size === 1 ? '' : 's'}:`);
            const names = [...selection].map((x) => x.packageName).sort();
            for (const name of names) {
                terminal.writeLine(`    ${safe_1.default.cyan(name)}`);
            }
            // If the command ignores dependency order, that means that only the changed projects should be affected
            // That said, running watch for commands that ignore dependency order may have unexpected results
            if (!this._ignoreDependencyOrder) {
                selection = Selection_1.Selection.intersection(Selection_1.Selection.expandAllConsumers(selection), projectsToWatch);
            }
            const executeOptions = {
                taskSelectorOptions: Object.assign(Object.assign({}, options.taskSelectorOptions), { 
                    // Revise down the set of projects to execute the command on
                    selection, 
                    // Pass the ProjectChangeAnalyzer from the state differ to save a bit of overhead
                    projectChangeAnalyzer: state }),
                taskRunnerOptions: options.taskRunnerOptions,
                stopwatch,
                // For now, don't run pre-build or post-build in watch mode
                ignoreHooks: true,
                terminal
            };
            try {
                // Delegate the the underlying command, for only the projects that need reprocessing
                await this._runOnce(executeOptions);
            }
            catch (err) {
                // In watch mode, we want to rebuild even if the original build failed.
                if (!(err instanceof node_core_library_1.AlreadyReportedError)) {
                    throw err;
                }
            }
        }
    }
    onDefineParameters() {
        if (this._enableParallelism) {
            this._parallelismParameter = this.defineStringParameter({
                parameterLongName: '--parallelism',
                parameterShortName: '-p',
                argumentName: 'COUNT',
                environmentVariable: "RUSH_PARALLELISM" /* RUSH_PARALLELISM */,
                description: 'Specifies the maximum number of concurrent processes to launch during a build.' +
                    ' The COUNT should be a positive integer or else the word "max" to specify a count that is equal to' +
                    ' the number of CPU cores. If this parameter is omitted, then the default value depends on the' +
                    ' operating system and number of CPU cores.'
            });
        }
        this._selectionParameters = new SelectionParameterSet_1.SelectionParameterSet(this.rushConfiguration, this);
        this._verboseParameter = this.defineFlagParameter({
            parameterLongName: '--verbose',
            parameterShortName: '-v',
            description: 'Display the logs during the build, rather than just displaying the build status summary'
        });
        if (this._isIncrementalBuildAllowed) {
            this._changedProjectsOnly = this.defineFlagParameter({
                parameterLongName: '--changed-projects-only',
                parameterShortName: '-c',
                description: 'Normally the incremental build logic will rebuild changed projects as well as' +
                    ' any projects that directly or indirectly depend on a changed project. Specify "--changed-projects-only"' +
                    ' to ignore dependent projects, only rebuilding those projects whose files were changed.' +
                    ' Note that this parameter is "unsafe"; it is up to the developer to ensure that the ignored projects' +
                    ' are okay to ignore.'
            });
        }
        this._ignoreHooksParameter = this.defineFlagParameter({
            parameterLongName: '--ignore-hooks',
            description: `Skips execution of the "eventHooks" scripts defined in rush.json. Make sure you know what you are skipping.`
        });
        this.defineScriptParameters();
    }
    /**
     * Runs a single invocation of the command
     */
    async _runOnce(options) {
        const taskSelector = new TaskSelector_1.TaskSelector(options.taskSelectorOptions);
        // Register all tasks with the task collection
        const taskRunner = new TaskRunner_1.TaskRunner(taskSelector.registerTasks().getOrderedTasks(), options.taskRunnerOptions);
        const { ignoreHooks, stopwatch } = options;
        try {
            await taskRunner.executeAsync();
            stopwatch.stop();
            console.log(safe_1.default.green(`rush ${this.actionName} (${stopwatch.toString()})`));
            if (!ignoreHooks) {
                this._doAfterTask(stopwatch, true);
            }
        }
        catch (error) {
            stopwatch.stop();
            if (error instanceof node_core_library_1.AlreadyReportedError) {
                console.log(`rush ${this.actionName} (${stopwatch.toString()})`);
            }
            else {
                if (error && error.message) {
                    if (this.parser.isDebug) {
                        console.log('Error: ' + error.stack);
                    }
                    else {
                        console.log('Error: ' + error.message);
                    }
                }
                console.log(safe_1.default.red(`rush ${this.actionName} - Errors! (${stopwatch.toString()})`));
            }
            if (!ignoreHooks) {
                this._doAfterTask(stopwatch, false);
            }
            throw new node_core_library_1.AlreadyReportedError();
        }
    }
    _doBeforeTask() {
        if (this.actionName !== RushConstants_1.RushConstants.buildCommandName &&
            this.actionName !== RushConstants_1.RushConstants.rebuildCommandName) {
            // Only collects information for built-in tasks like build or rebuild.
            return;
        }
        SetupChecks_1.SetupChecks.validate(this.rushConfiguration);
        this.eventHooksManager.handle(index_1.Event.preRushBuild, this.parser.isDebug, this._ignoreHooksParameter.value);
    }
    _doAfterTask(stopwatch, success) {
        if (this.actionName !== RushConstants_1.RushConstants.buildCommandName &&
            this.actionName !== RushConstants_1.RushConstants.rebuildCommandName) {
            // Only collects information for built-in tasks like build or rebuild.
            return;
        }
        this._collectTelemetry(stopwatch, success);
        this.parser.flushTelemetry();
        this.eventHooksManager.handle(index_1.Event.postRushBuild, this.parser.isDebug, this._ignoreHooksParameter.value);
    }
    _collectTelemetry(stopwatch, success) {
        const extraData = Object.assign(Object.assign({}, this._selectionParameters.getTelemetry()), this.getParameterStringMap());
        if (this.parser.telemetry) {
            this.parser.telemetry.log({
                name: this.actionName,
                duration: stopwatch.duration,
                result: success ? 'Succeeded' : 'Failed',
                extraData
            });
        }
    }
}
exports.BulkScriptAction = BulkScriptAction;
//# sourceMappingURL=BulkScriptAction.js.map

/***/ }),

/***/ 7692:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GlobalScriptAction = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const BaseScriptAction_1 = __webpack_require__(77121);
const Utilities_1 = __webpack_require__(89521);
const InstallHelpers_1 = __webpack_require__(54939);
const RushConstants_1 = __webpack_require__(63985);
const LastInstallFlag_1 = __webpack_require__(57013);
const Autoinstaller_1 = __webpack_require__(78226);
/**
 * This class implements custom commands that are run once globally for the entire repo
 * (versus bulk commands, which run separately for each project).  The action executes
 * a user-defined script file.
 *
 * @remarks
 * Bulk commands can be defined via common/config/command-line.json.  Rush's predefined "build"
 * and "rebuild" commands are also modeled as bulk commands, because they essentially just
 * invoke scripts from package.json in the same way as a custom command.
 */
class GlobalScriptAction extends BaseScriptAction_1.BaseScriptAction {
    constructor(options) {
        super(options);
        this._shellCommand = options.shellCommand;
        this._autoinstallerName = options.autoinstallerName || '';
        if (this._autoinstallerName) {
            Autoinstaller_1.Autoinstaller.validateName(this._autoinstallerName);
            // Example: .../common/autoinstallers/my-task
            this._autoinstallerFullPath = path.join(this.rushConfiguration.commonAutoinstallersFolder, this._autoinstallerName);
            if (!node_core_library_1.FileSystem.exists(this._autoinstallerFullPath)) {
                throw new Error(`The custom command "${this.actionName}" specifies an "autoinstallerName" setting` +
                    ' but the path does not exist: ' +
                    this._autoinstallerFullPath);
            }
            // Example: .../common/autoinstallers/my-task/package.json
            const packageJsonPath = path.join(this._autoinstallerFullPath, 'package.json');
            if (!node_core_library_1.FileSystem.exists(packageJsonPath)) {
                throw new Error(`The custom command "${this.actionName}" specifies an "autoinstallerName" setting` +
                    ` whose package.json file was not found: ` +
                    packageJsonPath);
            }
            const packageJson = node_core_library_1.JsonFile.load(packageJsonPath);
            if (packageJson.name !== this._autoinstallerName) {
                throw new Error(`The custom command "${this.actionName}" specifies an "autoinstallerName" setting,` +
                    ` but the package.json file's "name" field is not "${this._autoinstallerName}": ` +
                    packageJsonPath);
            }
        }
        else {
            this._autoinstallerFullPath = '';
        }
    }
    async _prepareAutoinstallerName() {
        await InstallHelpers_1.InstallHelpers.ensureLocalPackageManager(this.rushConfiguration, this.rushGlobalFolder, RushConstants_1.RushConstants.defaultMaxInstallAttempts);
        // Example: common/autoinstallers/my-task/package.json
        const relativePathForLogs = path.relative(this.rushConfiguration.rushJsonFolder, this._autoinstallerFullPath);
        console.log(`Acquiring lock for "${relativePathForLogs}" folder...`);
        const lock = await node_core_library_1.LockFile.acquire(this._autoinstallerFullPath, 'autoinstaller');
        // Example: .../common/autoinstallers/my-task/.rush/temp
        const lastInstallFlagPath = path.join(this._autoinstallerFullPath, RushConstants_1.RushConstants.projectRushFolderName, 'temp');
        const packageJsonPath = path.join(this._autoinstallerFullPath, 'package.json');
        const packageJson = node_core_library_1.JsonFile.load(packageJsonPath);
        const lastInstallFlag = new LastInstallFlag_1.LastInstallFlag(lastInstallFlagPath, {
            node: process.versions.node,
            packageManager: this.rushConfiguration.packageManager,
            packageManagerVersion: this.rushConfiguration.packageManagerToolVersion,
            packageJson: packageJson
        });
        if (!lastInstallFlag.isValid() || lock.dirtyWhenAcquired) {
            // Example: ../common/autoinstallers/my-task/node_modules
            const nodeModulesFolder = path.join(this._autoinstallerFullPath, 'node_modules');
            if (node_core_library_1.FileSystem.exists(nodeModulesFolder)) {
                console.log('Deleting old files from ' + nodeModulesFolder);
                node_core_library_1.FileSystem.ensureEmptyFolder(nodeModulesFolder);
            }
            // Copy: .../common/autoinstallers/my-task/.npmrc
            Utilities_1.Utilities.syncNpmrc(this.rushConfiguration.commonRushConfigFolder, this._autoinstallerFullPath);
            console.log(`Installing dependencies under ${this._autoinstallerFullPath}...\n`);
            Utilities_1.Utilities.executeCommand({
                command: this.rushConfiguration.packageManagerToolFilename,
                args: ['install', '--frozen-lockfile'],
                workingDirectory: this._autoinstallerFullPath,
                keepEnvironment: true
            });
            // Create file: ../common/autoinstallers/my-task/.rush/temp/last-install.flag
            lastInstallFlag.create();
            console.log('Autoinstall completed successfully\n');
        }
        else {
            console.log('Autoinstaller folder is already up to date\n');
        }
        lock.release();
    }
    async runAsync() {
        const additionalPathFolders = [];
        if (this._autoinstallerName) {
            await this._prepareAutoinstallerName();
            const autoinstallerNameBinPath = path.join(this._autoinstallerFullPath, 'node_modules', '.bin');
            additionalPathFolders.push(autoinstallerNameBinPath);
        }
        // Collect all custom parameter values
        const customParameterValues = [];
        for (const customParameter of this.customParameters) {
            customParameter.appendToArgList(customParameterValues);
        }
        let shellCommand = this._shellCommand;
        if (customParameterValues.length > 0) {
            shellCommand += ' ' + customParameterValues.join(' ');
        }
        const exitCode = Utilities_1.Utilities.executeLifecycleCommand(shellCommand, {
            rushConfiguration: this.rushConfiguration,
            workingDirectory: this.rushConfiguration.rushJsonFolder,
            initCwd: this.rushConfiguration.commonTempFolder,
            handleOutput: false,
            environmentPathOptions: {
                includeRepoBin: true,
                additionalPathFolders: additionalPathFolders
            }
        });
        process.exitCode = exitCode;
        if (exitCode > 0) {
            console.log(os.EOL + safe_1.default.red(`The script failed with exit code ${exitCode}`));
            throw new node_core_library_1.AlreadyReportedError();
        }
    }
    onDefineParameters() {
        this.defineScriptParameters();
    }
}
exports.GlobalScriptAction = GlobalScriptAction;
//# sourceMappingURL=GlobalScriptAction.js.map

/***/ }),

/***/ 57088:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProjectChangeAnalyzer = exports.ExperimentsConfiguration = exports.Rush = exports.VersionPolicyConfiguration = exports.VersionPolicy = exports.IndividualVersionPolicy = exports.LockStepVersionPolicy = exports.BumpType = exports.VersionPolicyDefinitionName = exports._LastInstallFlag = exports.ChangeManager = exports.Event = exports.EventHooks = exports.RepoStateFile = exports.PackageJsonDependency = exports.PackageJsonEditor = exports.CommonVersionsConfiguration = exports.ApprovedPackagesConfiguration = exports.ApprovedPackagesItem = exports._RushGlobalFolder = exports.RushConfigurationProject = exports.PackageManager = exports.YarnOptionsConfiguration = exports.NpmOptionsConfiguration = exports.PnpmOptionsConfiguration = exports.PackageManagerOptionsConfigurationBase = exports.RushConfiguration = exports.ApprovedPackagesPolicy = void 0;
/**
 * A library for writing scripts that interact with the {@link https://rushjs.io/ | Rush} tool.
 * @packageDocumentation
 */
var ApprovedPackagesPolicy_1 = __webpack_require__(73162);
Object.defineProperty(exports, "ApprovedPackagesPolicy", ({ enumerable: true, get: function () { return ApprovedPackagesPolicy_1.ApprovedPackagesPolicy; } }));
var RushConfiguration_1 = __webpack_require__(92905);
Object.defineProperty(exports, "RushConfiguration", ({ enumerable: true, get: function () { return RushConfiguration_1.RushConfiguration; } }));
Object.defineProperty(exports, "PackageManagerOptionsConfigurationBase", ({ enumerable: true, get: function () { return RushConfiguration_1.PackageManagerOptionsConfigurationBase; } }));
Object.defineProperty(exports, "PnpmOptionsConfiguration", ({ enumerable: true, get: function () { return RushConfiguration_1.PnpmOptionsConfiguration; } }));
Object.defineProperty(exports, "NpmOptionsConfiguration", ({ enumerable: true, get: function () { return RushConfiguration_1.NpmOptionsConfiguration; } }));
Object.defineProperty(exports, "YarnOptionsConfiguration", ({ enumerable: true, get: function () { return RushConfiguration_1.YarnOptionsConfiguration; } }));
var PackageManager_1 = __webpack_require__(37421);
Object.defineProperty(exports, "PackageManager", ({ enumerable: true, get: function () { return PackageManager_1.PackageManager; } }));
var RushConfigurationProject_1 = __webpack_require__(90554);
Object.defineProperty(exports, "RushConfigurationProject", ({ enumerable: true, get: function () { return RushConfigurationProject_1.RushConfigurationProject; } }));
var RushGlobalFolder_1 = __webpack_require__(96337);
Object.defineProperty(exports, "_RushGlobalFolder", ({ enumerable: true, get: function () { return RushGlobalFolder_1.RushGlobalFolder; } }));
var ApprovedPackagesConfiguration_1 = __webpack_require__(23838);
Object.defineProperty(exports, "ApprovedPackagesItem", ({ enumerable: true, get: function () { return ApprovedPackagesConfiguration_1.ApprovedPackagesItem; } }));
Object.defineProperty(exports, "ApprovedPackagesConfiguration", ({ enumerable: true, get: function () { return ApprovedPackagesConfiguration_1.ApprovedPackagesConfiguration; } }));
var CommonVersionsConfiguration_1 = __webpack_require__(2465);
Object.defineProperty(exports, "CommonVersionsConfiguration", ({ enumerable: true, get: function () { return CommonVersionsConfiguration_1.CommonVersionsConfiguration; } }));
var PackageJsonEditor_1 = __webpack_require__(32373);
Object.defineProperty(exports, "PackageJsonEditor", ({ enumerable: true, get: function () { return PackageJsonEditor_1.PackageJsonEditor; } }));
Object.defineProperty(exports, "PackageJsonDependency", ({ enumerable: true, get: function () { return PackageJsonEditor_1.PackageJsonDependency; } }));
var RepoStateFile_1 = __webpack_require__(67213);
Object.defineProperty(exports, "RepoStateFile", ({ enumerable: true, get: function () { return RepoStateFile_1.RepoStateFile; } }));
var EventHooks_1 = __webpack_require__(92330);
Object.defineProperty(exports, "EventHooks", ({ enumerable: true, get: function () { return EventHooks_1.EventHooks; } }));
Object.defineProperty(exports, "Event", ({ enumerable: true, get: function () { return EventHooks_1.Event; } }));
var ChangeManager_1 = __webpack_require__(85508);
Object.defineProperty(exports, "ChangeManager", ({ enumerable: true, get: function () { return ChangeManager_1.ChangeManager; } }));
var LastInstallFlag_1 = __webpack_require__(57013);
Object.defineProperty(exports, "_LastInstallFlag", ({ enumerable: true, get: function () { return LastInstallFlag_1.LastInstallFlag; } }));
var VersionPolicy_1 = __webpack_require__(78075);
Object.defineProperty(exports, "VersionPolicyDefinitionName", ({ enumerable: true, get: function () { return VersionPolicy_1.VersionPolicyDefinitionName; } }));
Object.defineProperty(exports, "BumpType", ({ enumerable: true, get: function () { return VersionPolicy_1.BumpType; } }));
Object.defineProperty(exports, "LockStepVersionPolicy", ({ enumerable: true, get: function () { return VersionPolicy_1.LockStepVersionPolicy; } }));
Object.defineProperty(exports, "IndividualVersionPolicy", ({ enumerable: true, get: function () { return VersionPolicy_1.IndividualVersionPolicy; } }));
Object.defineProperty(exports, "VersionPolicy", ({ enumerable: true, get: function () { return VersionPolicy_1.VersionPolicy; } }));
var VersionPolicyConfiguration_1 = __webpack_require__(6375);
Object.defineProperty(exports, "VersionPolicyConfiguration", ({ enumerable: true, get: function () { return VersionPolicyConfiguration_1.VersionPolicyConfiguration; } }));
var Rush_1 = __webpack_require__(4876);
Object.defineProperty(exports, "Rush", ({ enumerable: true, get: function () { return Rush_1.Rush; } }));
var ExperimentsConfiguration_1 = __webpack_require__(94539);
Object.defineProperty(exports, "ExperimentsConfiguration", ({ enumerable: true, get: function () { return ExperimentsConfiguration_1.ExperimentsConfiguration; } }));
var ProjectChangeAnalyzer_1 = __webpack_require__(15504);
Object.defineProperty(exports, "ProjectChangeAnalyzer", ({ enumerable: true, get: function () { return ProjectChangeAnalyzer_1.ProjectChangeAnalyzer; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 78226:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Autoinstaller = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const Utilities_1 = __webpack_require__(89521);
const node_core_library_2 = __webpack_require__(24019);
const PackageJsonEditor_1 = __webpack_require__(32373);
class Autoinstaller {
    constructor(autoinstallerName, rushConfiguration) {
        this._rushConfiguration = rushConfiguration;
        Autoinstaller.validateName(autoinstallerName);
        this.name = autoinstallerName;
    }
    // Example: .../common/autoinstallers/my-task
    get folderFullPath() {
        return path.join(this._rushConfiguration.commonAutoinstallersFolder, this.name);
    }
    // Example: .../common/autoinstallers/my-task/package-lock.yaml
    get shrinkwrapFilePath() {
        return path.join(this._rushConfiguration.commonAutoinstallersFolder, this.name, this._rushConfiguration.shrinkwrapFilename);
    }
    // Example: .../common/autoinstallers/my-task/package.json
    get packageJsonPath() {
        return path.join(this._rushConfiguration.commonAutoinstallersFolder, this.name, 'package.json');
    }
    static validateName(autoinstallerName) {
        const nameOrError = node_core_library_2.PackageName.tryParse(autoinstallerName);
        if (nameOrError.error) {
            throw new Error(`The specified name "${autoinstallerName}" is invalid: ` + nameOrError.error);
        }
        if (nameOrError.scope) {
            throw new Error(`The specified name "${autoinstallerName}" must not contain an NPM scope`);
        }
    }
    update() {
        const autoinstallerPackageJsonPath = path.join(this.folderFullPath, 'package.json');
        if (!node_core_library_1.FileSystem.exists(autoinstallerPackageJsonPath)) {
            throw new Error(`The specified autoinstaller path does not exist: ` + autoinstallerPackageJsonPath);
        }
        console.log(`Updating autoinstaller package: ${autoinstallerPackageJsonPath}`);
        let oldFileContents = '';
        if (node_core_library_1.FileSystem.exists(this.shrinkwrapFilePath)) {
            oldFileContents = node_core_library_1.FileSystem.readFile(this.shrinkwrapFilePath, { convertLineEndings: "\n" /* Lf */ });
            console.log('Deleting ' + this.shrinkwrapFilePath);
            node_core_library_1.FileSystem.deleteFile(this.shrinkwrapFilePath);
        }
        // Detect a common mistake where PNPM prints "Already up-to-date" without creating a shrinkwrap file
        const packageJsonEditor = PackageJsonEditor_1.PackageJsonEditor.load(this.packageJsonPath);
        if (packageJsonEditor.dependencyList.length === 0 && packageJsonEditor.dependencyList.length === 0) {
            throw new Error('You must add at least one dependency to the autoinstaller package' +
                ' before invoking this command:\n' +
                this.packageJsonPath);
        }
        console.log();
        Utilities_1.Utilities.syncNpmrc(this._rushConfiguration.commonRushConfigFolder, this.folderFullPath);
        Utilities_1.Utilities.executeCommand({
            command: this._rushConfiguration.packageManagerToolFilename,
            args: ['install'],
            workingDirectory: this.folderFullPath,
            keepEnvironment: true
        });
        console.log();
        if (this._rushConfiguration.packageManager === 'npm') {
            console.log(safe_1.default.bold('Running "npm shrinkwrap"...'));
            Utilities_1.Utilities.executeCommand({
                command: this._rushConfiguration.packageManagerToolFilename,
                args: ['shrinkwrap'],
                workingDirectory: this.folderFullPath,
                keepEnvironment: true
            });
            console.log('"npm shrinkwrap" completed');
            console.log();
        }
        if (!node_core_library_1.FileSystem.exists(this.shrinkwrapFilePath)) {
            throw new Error('The package manager did not create the expected shrinkwrap file: ' + this.shrinkwrapFilePath);
        }
        const newFileContents = node_core_library_1.FileSystem.readFile(this.shrinkwrapFilePath, {
            convertLineEndings: "\n" /* Lf */
        });
        if (oldFileContents !== newFileContents) {
            console.log(safe_1.default.green('The shrinkwrap file has been updated.') + '  Please commit the updated file:');
            console.log(`\n  ${this.shrinkwrapFilePath}`);
        }
        else {
            console.log(safe_1.default.green('Already up to date.'));
        }
    }
}
exports.Autoinstaller = Autoinstaller;
//# sourceMappingURL=Autoinstaller.js.map

/***/ }),

/***/ 63799:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChangeFiles = void 0;
const path = __importStar(__webpack_require__(85622));
const os_1 = __webpack_require__(12087);
const node_core_library_1 = __webpack_require__(24019);
const Utilities_1 = __webpack_require__(89521);
const glob = node_core_library_1.Import.lazy('glob', require);
/**
 * This class represents the collection of change files existing in the repo and provides operations
 * for those change files.
 */
class ChangeFiles {
    constructor(changesPath) {
        this._changesPath = changesPath;
    }
    /**
     * Validate if the newly added change files match the changed packages.
     */
    static validate(newChangeFilePaths, changedPackages, rushConfiguration) {
        const schema = node_core_library_1.JsonSchema.fromFile(path.resolve(__dirname, '..', 'schemas', 'change-file.schema.json'));
        const projectsWithChangeDescriptions = new Set();
        newChangeFilePaths.forEach((filePath) => {
            console.log(`Found change file: ${filePath}`);
            const changeFile = node_core_library_1.JsonFile.loadAndValidate(filePath, schema);
            if (rushConfiguration.hotfixChangeEnabled) {
                if (changeFile && changeFile.changes) {
                    for (const change of changeFile.changes) {
                        if (change.type !== 'none' && change.type !== 'hotfix') {
                            throw new Error(`Change file ${filePath} specifies a type of '${change.type}' ` +
                                `but only 'hotfix' and 'none' change types may be used in a branch with 'hotfixChangeEnabled'.`);
                        }
                    }
                }
            }
            if (changeFile && changeFile.changes) {
                changeFile.changes.forEach((change) => projectsWithChangeDescriptions.add(change.packageName));
            }
            else {
                throw new Error(`Invalid change file: ${filePath}`);
            }
        });
        const projectsMissingChangeDescriptions = new Set(changedPackages);
        projectsWithChangeDescriptions.forEach((name) => projectsMissingChangeDescriptions.delete(name));
        if (projectsMissingChangeDescriptions.size > 0) {
            const projectsMissingChangeDescriptionsArray = [];
            projectsMissingChangeDescriptions.forEach((name) => projectsMissingChangeDescriptionsArray.push(name));
            throw new Error([
                'The following projects have been changed and require change descriptions, but change descriptions were not ' +
                    'detected for them:',
                ...projectsMissingChangeDescriptionsArray.map((projectName) => `- ${projectName}`),
                'To resolve this error, run "rush change." This will generate change description files that must be ' +
                    'committed to source control.'
            ].join(os_1.EOL));
        }
    }
    static getChangeComments(newChangeFilePaths) {
        const changes = new Map();
        newChangeFilePaths.forEach((filePath) => {
            console.log(`Found change file: ${filePath}`);
            const changeRequest = node_core_library_1.JsonFile.load(filePath);
            if (changeRequest && changeRequest.changes) {
                changeRequest.changes.forEach((change) => {
                    if (!changes.get(change.packageName)) {
                        changes.set(change.packageName, []);
                    }
                    if (change.comment && change.comment.length) {
                        changes.get(change.packageName).push(change.comment);
                    }
                });
            }
            else {
                throw new Error(`Invalid change file: ${filePath}`);
            }
        });
        return changes;
    }
    /**
     * Get the array of absolute paths of change files.
     */
    getFiles() {
        if (!this._files) {
            this._files = glob.sync(`${this._changesPath}/**/*.json`) || [];
        }
        return this._files;
    }
    /**
     * Get the path of changes folder.
     */
    getChangesPath() {
        return this._changesPath;
    }
    /**
     * Delete all change files
     */
    deleteAll(shouldDelete, updatedChangelogs) {
        if (updatedChangelogs) {
            // Skip changes files if the package's change log is not updated.
            const packagesToInclude = new Set();
            updatedChangelogs.forEach((changelog) => {
                packagesToInclude.add(changelog.name);
            });
            const filesToDelete = this.getFiles().filter((filePath) => {
                const changeRequest = node_core_library_1.JsonFile.load(filePath);
                for (const changeInfo of changeRequest.changes) {
                    if (!packagesToInclude.has(changeInfo.packageName)) {
                        return false;
                    }
                }
                return true;
            });
            return this._deleteFiles(filesToDelete, shouldDelete);
        }
        else {
            // Delete all change files.
            return this._deleteFiles(this.getFiles(), shouldDelete);
        }
    }
    _deleteFiles(files, shouldDelete) {
        if (files.length) {
            console.log(`${os_1.EOL}* ${shouldDelete ? 'DELETING:' : 'DRYRUN: Deleting'} ${files.length} change file(s).`);
            for (const filePath of files) {
                console.log(` - ${filePath}`);
                if (shouldDelete) {
                    Utilities_1.Utilities.deleteFile(filePath);
                }
            }
        }
        return files.length;
    }
}
exports.ChangeFiles = ChangeFiles;
//# sourceMappingURL=ChangeFiles.js.map

/***/ }),

/***/ 97562:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChangeManager = void 0;
const PublishUtilities_1 = __webpack_require__(16397);
const ChangeFiles_1 = __webpack_require__(63799);
const PrereleaseToken_1 = __webpack_require__(82397);
const ChangelogGenerator_1 = __webpack_require__(18198);
/**
 * The class manages change files and controls how changes logged by change files
 * can be applied to package.json and change logs.
 */
class ChangeManager {
    constructor(rushConfiguration, lockStepProjectsToExclude) {
        this._rushConfiguration = rushConfiguration;
        this._lockStepProjectsToExclude = lockStepProjectsToExclude;
    }
    /**
     * Load changes from change files
     * @param changesPath - location of change files
     * @param prereleaseToken - prerelease token
     * @param includeCommitDetails - whether commit details need to be included in changes
     */
    load(changesPath, prereleaseToken = new PrereleaseToken_1.PrereleaseToken(), includeCommitDetails = false) {
        this._allPackages = this._rushConfiguration.projectsByName;
        this._prereleaseToken = prereleaseToken;
        this._changeFiles = new ChangeFiles_1.ChangeFiles(changesPath);
        this._allChanges = PublishUtilities_1.PublishUtilities.findChangeRequests(this._allPackages, this._rushConfiguration, this._changeFiles, includeCommitDetails, this._prereleaseToken, this._lockStepProjectsToExclude);
        this._orderedChanges = PublishUtilities_1.PublishUtilities.sortChangeRequests(this._allChanges);
    }
    hasChanges() {
        return this._orderedChanges && this._orderedChanges.length > 0;
    }
    get changes() {
        return this._orderedChanges;
    }
    get allPackages() {
        return this._allPackages;
    }
    validateChanges(versionConfig) {
        Object.keys(this._allChanges).filter((key) => {
            const projectInfo = this._rushConfiguration.getProjectByName(key);
            if (projectInfo) {
                if (projectInfo.versionPolicy) {
                    const changeInfo = this._allChanges[key];
                    projectInfo.versionPolicy.validate(changeInfo.newVersion, key);
                }
            }
        });
    }
    /**
     * Apply changes to package.json
     * @param shouldCommit - If the value is true, package.json will be updated.
     * If the value is false, package.json and change logs will not be updated. It will only do a dry-run.
     */
    apply(shouldCommit) {
        if (!this.hasChanges()) {
            return;
        }
        // Apply all changes to package.json files.
        const updatedPackages = PublishUtilities_1.PublishUtilities.updatePackages(this._allChanges, this._allPackages, this._rushConfiguration, shouldCommit, this._prereleaseToken, this._lockStepProjectsToExclude);
        return updatedPackages;
    }
    updateChangelog(shouldCommit) {
        // Do not update changelog or delete the change files for prerelease.
        // Save them for the official release.
        if (!this._prereleaseToken.hasValue) {
            // Update changelogs.
            const updatedChangelogs = ChangelogGenerator_1.ChangelogGenerator.updateChangelogs(this._allChanges, this._allPackages, this._rushConfiguration, shouldCommit);
            // Remove the change request files only if "-a" was provided.
            this._changeFiles.deleteAll(shouldCommit, updatedChangelogs);
        }
    }
}
exports.ChangeManager = ChangeManager;
//# sourceMappingURL=ChangeManager.js.map

/***/ }),

/***/ 18198:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChangelogGenerator = void 0;
const path = __importStar(__webpack_require__(85622));
const semver = __importStar(__webpack_require__(11383));
const node_core_library_1 = __webpack_require__(24019);
const PublishUtilities_1 = __webpack_require__(16397);
const ChangeManagement_1 = __webpack_require__(6877);
const CHANGELOG_JSON = 'CHANGELOG.json';
const CHANGELOG_MD = 'CHANGELOG.md';
const EOL = '\n';
class ChangelogGenerator {
    /**
     * Updates the appropriate changelogs with the given changes.
     */
    static updateChangelogs(allChanges, allProjects, rushConfiguration, shouldCommit) {
        const updatedChangeLogs = [];
        for (const packageName in allChanges) {
            if (allChanges.hasOwnProperty(packageName)) {
                const project = allProjects.get(packageName);
                if (project && ChangelogGenerator._shouldUpdateChangeLog(project, allChanges)) {
                    const changeLog = ChangelogGenerator.updateIndividualChangelog(allChanges[packageName], project.projectFolder, shouldCommit, rushConfiguration, project.versionPolicy && project.versionPolicy.isLockstepped, project.isMainProject);
                    if (changeLog) {
                        updatedChangeLogs.push(changeLog);
                    }
                }
            }
        }
        return updatedChangeLogs;
    }
    /**
     * Fully regenerate the markdown files based on the current json files.
     */
    static regenerateChangelogs(allProjects, rushConfiguration) {
        allProjects.forEach((project) => {
            const markdownPath = path.resolve(project.projectFolder, CHANGELOG_MD);
            const markdownJSONPath = path.resolve(project.projectFolder, CHANGELOG_JSON);
            if (node_core_library_1.FileSystem.exists(markdownPath)) {
                console.log('Found: ' + markdownPath);
                if (!node_core_library_1.FileSystem.exists(markdownJSONPath)) {
                    throw new Error('A CHANGELOG.md without json: ' + markdownPath);
                }
                const changelog = ChangelogGenerator._getChangelog(project.packageName, project.projectFolder);
                const isLockstepped = !!project.versionPolicy && project.versionPolicy.isLockstepped;
                node_core_library_1.FileSystem.writeFile(path.join(project.projectFolder, CHANGELOG_MD), ChangelogGenerator._translateToMarkdown(changelog, rushConfiguration, isLockstepped));
            }
        });
    }
    /**
     * Updates an individual changelog for a single project.
     */
    static updateIndividualChangelog(change, projectFolder, shouldCommit, rushConfiguration, isLockstepped = false, isMain = true) {
        if (isLockstepped && !isMain) {
            // Early return if the project is lockstepped and does not host change logs
            return undefined;
        }
        const changelog = ChangelogGenerator._getChangelog(change.packageName, projectFolder);
        if (!changelog.entries.some((entry) => entry.version === change.newVersion)) {
            const changelogEntry = {
                version: change.newVersion,
                tag: PublishUtilities_1.PublishUtilities.createTagname(change.packageName, change.newVersion, rushConfiguration.gitTagSeparator),
                date: new Date().toUTCString(),
                comments: {}
            };
            change.changes.forEach((individualChange) => {
                if (individualChange.comment) {
                    // Initialize the comments array only as necessary.
                    const changeTypeString = ChangeManagement_1.ChangeType[individualChange.changeType];
                    changelogEntry.comments[changeTypeString] = changelogEntry.comments[changeTypeString] || [];
                    const comments = changelogEntry.comments[changeTypeString];
                    const changeLogComment = {
                        comment: individualChange.comment
                    };
                    if (individualChange.author) {
                        changeLogComment.author = individualChange.author;
                    }
                    if (individualChange.commit) {
                        changeLogComment.commit = individualChange.commit;
                    }
                    comments.push(changeLogComment);
                }
            });
            // Add the changelog entry to the start of the list.
            changelog.entries.unshift(changelogEntry);
            const changelogFilename = path.join(projectFolder, CHANGELOG_JSON);
            console.log(`${EOL}* ${shouldCommit ? 'APPLYING' : 'DRYRUN'}: ` +
                `Changelog update for "${change.packageName}@${change.newVersion}".`);
            if (shouldCommit) {
                // Write markdown transform.
                node_core_library_1.JsonFile.save(changelog, changelogFilename);
                node_core_library_1.FileSystem.writeFile(path.join(projectFolder, CHANGELOG_MD), ChangelogGenerator._translateToMarkdown(changelog, rushConfiguration, isLockstepped));
            }
            return changelog;
        }
        // change log not updated.
        return undefined;
    }
    /**
     * Loads the changelog json from disk, or creates a new one if there isn't one.
     */
    static _getChangelog(packageName, projectFolder) {
        const changelogFilename = path.join(projectFolder, CHANGELOG_JSON);
        let changelog = undefined;
        // Try to read the existing changelog.
        if (node_core_library_1.FileSystem.exists(changelogFilename)) {
            changelog = node_core_library_1.JsonFile.load(changelogFilename);
        }
        if (!changelog) {
            changelog = {
                name: packageName,
                entries: []
            };
        }
        else {
            // Force the changelog name to be same as package name.
            // In case the package has been renamed but change log name is not updated.
            changelog.name = packageName;
        }
        return changelog;
    }
    /**
     * Translates the given changelog json object into a markdown string.
     */
    static _translateToMarkdown(changelog, rushConfiguration, isLockstepped = false) {
        let markdown = [
            `# Change Log - ${changelog.name}`,
            '',
            `This log was last generated on ${new Date().toUTCString()} and should not be manually modified.`,
            '',
            ''
        ].join(EOL);
        changelog.entries.forEach((entry, index) => {
            markdown += `## ${entry.version}${EOL}`;
            if (entry.date) {
                markdown += `${entry.date}${EOL}`;
            }
            markdown += EOL;
            let comments = '';
            comments += ChangelogGenerator._getChangeComments('Breaking changes', entry.comments.major);
            comments += ChangelogGenerator._getChangeComments('Minor changes', entry.comments.minor);
            comments += ChangelogGenerator._getChangeComments('Patches', entry.comments.patch);
            if (isLockstepped) {
                // In lockstepped projects, all changes are of type ChangeType.none.
                comments += ChangelogGenerator._getChangeComments('Updates', entry.comments.none);
            }
            if (rushConfiguration.hotfixChangeEnabled) {
                comments += ChangelogGenerator._getChangeComments('Hotfixes', entry.comments.hotfix);
            }
            if (!comments) {
                markdown +=
                    (changelog.entries.length === index + 1 ? '_Initial release_' : '_Version update only_') +
                        EOL +
                        EOL;
            }
            else {
                markdown += comments;
            }
        });
        return markdown;
    }
    /**
     * Helper to return the comments string to be appends to the markdown content.
     */
    static _getChangeComments(title, commentsArray) {
        let comments = '';
        if (commentsArray) {
            comments = `### ${title}${EOL + EOL}`;
            commentsArray.forEach((comment) => {
                comments += `- ${comment.comment}${EOL}`;
            });
            comments += EOL;
        }
        return comments;
    }
    /**
     * Changelogs should only be generated for publishable projects.
     * Do not update changelog or delete the change files for prerelease. Save them for the official release.
     * Unless the package is a hotfix, in which case do delete the change files.
     *
     * @param project
     * @param allChanges
     */
    static _shouldUpdateChangeLog(project, allChanges) {
        return (project.shouldPublish &&
            (!semver.prerelease(project.packageJson.version) ||
                allChanges[project.packageName].changeType === ChangeManagement_1.ChangeType.hotfix));
    }
}
exports.ChangelogGenerator = ChangelogGenerator;
//# sourceMappingURL=ChangelogGenerator.js.map

/***/ }),

/***/ 179:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DependencySpecifier = exports.DependencySpecifierType = void 0;
const npmPackageArg = __webpack_require__(32695);
const node_core_library_1 = __webpack_require__(24019);
/**
 * The parsed format of a provided version specifier.
 */
var DependencySpecifierType;
(function (DependencySpecifierType) {
    /**
     * A git repository
     */
    DependencySpecifierType["Git"] = "Git";
    /**
     * A tagged version, e.g. "example@latest"
     */
    DependencySpecifierType["Tag"] = "Tag";
    /**
     * A specific version number, e.g. "example@1.2.3"
     */
    DependencySpecifierType["Version"] = "Version";
    /**
     * A version range, e.g. "example@2.x"
     */
    DependencySpecifierType["Range"] = "Range";
    /**
     * A local .tar.gz, .tar or .tgz file
     */
    DependencySpecifierType["File"] = "File";
    /**
     * A local directory
     */
    DependencySpecifierType["Directory"] = "Directory";
    /**
     * An HTTP url to a .tar.gz, .tar or .tgz file
     */
    DependencySpecifierType["Remote"] = "Remote";
    /**
     * A package alias, e.g. "npm:other-package@^1.2.3"
     */
    DependencySpecifierType["Alias"] = "Alias";
    /**
     * A package specified using workspace protocol, e.g. "workspace:^1.2.3"
     */
    DependencySpecifierType["Workspace"] = "Workspace";
})(DependencySpecifierType = exports.DependencySpecifierType || (exports.DependencySpecifierType = {}));
/**
 * An NPM "version specifier" is a string that can appear as a package.json "dependencies" value.
 * Example version specifiers: `^1.2.3`, `file:./blah.tgz`, `npm:other-package@~1.2.3`, and so forth.
 * A "dependency specifier" is the version specifier information, combined with the dependency package name.
 */
class DependencySpecifier {
    constructor(packageName, versionSpecifier) {
        this.packageName = packageName;
        this.versionSpecifier = versionSpecifier;
        // Workspace ranges are a feature from PNPM and Yarn. Set the version specifier
        // to the trimmed version range.
        if (versionSpecifier.startsWith('workspace:')) {
            this.specifierType = DependencySpecifierType.Workspace;
            this.versionSpecifier = versionSpecifier.slice(this.specifierType.length + 1).trim();
            this.aliasTarget = undefined;
            return;
        }
        const result = npmPackageArg.resolve(packageName, versionSpecifier);
        this.specifierType = DependencySpecifier.getDependencySpecifierType(result.type);
        if (this.specifierType === DependencySpecifierType.Alias) {
            const aliasResult = result;
            if (!aliasResult.subSpec || !aliasResult.subSpec.name) {
                throw new node_core_library_1.InternalError('Unexpected result from npm-package-arg');
            }
            this.aliasTarget = new DependencySpecifier(aliasResult.subSpec.name, aliasResult.subSpec.rawSpec);
        }
        else {
            this.aliasTarget = undefined;
        }
    }
    static getDependencySpecifierType(specifierType) {
        switch (specifierType) {
            case 'git':
                return DependencySpecifierType.Git;
            case 'tag':
                return DependencySpecifierType.Tag;
            case 'version':
                return DependencySpecifierType.Version;
            case 'range':
                return DependencySpecifierType.Range;
            case 'file':
                return DependencySpecifierType.File;
            case 'directory':
                return DependencySpecifierType.Directory;
            case 'remote':
                return DependencySpecifierType.Remote;
            case 'alias':
                return DependencySpecifierType.Alias;
            default:
                throw new node_core_library_1.InternalError(`Unexpected npm-package-arg result type "${specifierType}"`);
        }
    }
}
exports.DependencySpecifier = DependencySpecifier;
//# sourceMappingURL=DependencySpecifier.js.map

/***/ }),

/***/ 96461:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventHooksManager = void 0;
const os = __importStar(__webpack_require__(12087));
const safe_1 = __importDefault(__webpack_require__(41997));
const Utilities_1 = __webpack_require__(89521);
const EventHooks_1 = __webpack_require__(92330);
const Stopwatch_1 = __webpack_require__(80414);
class EventHooksManager {
    constructor(rushConfiguration) {
        this._rushConfiguration = rushConfiguration;
        this._eventHooks = rushConfiguration.eventHooks;
        this._commonTempFolder = rushConfiguration.commonTempFolder;
    }
    handle(event, isDebug, ignoreHooks) {
        if (!this._eventHooks) {
            return;
        }
        const scripts = this._eventHooks.get(event);
        if (scripts.length > 0) {
            if (ignoreHooks) {
                console.log(`Skipping event hooks for ${EventHooks_1.Event[event]} since --ignore-hooks was specified`);
                return;
            }
            const stopwatch = Stopwatch_1.Stopwatch.start();
            console.log(os.EOL + safe_1.default.green(`Executing event hooks for ${EventHooks_1.Event[event]}`));
            scripts.forEach((script) => {
                try {
                    Utilities_1.Utilities.executeLifecycleCommand(script, {
                        rushConfiguration: this._rushConfiguration,
                        workingDirectory: this._rushConfiguration.rushJsonFolder,
                        initCwd: this._commonTempFolder,
                        handleOutput: !isDebug,
                        environmentPathOptions: {
                            includeRepoBin: true
                        }
                    });
                }
                catch (error) {
                    console.error(os.EOL +
                        safe_1.default.yellow(`Event hook "${script}" failed. Run "rush" with --debug` +
                            ` to see detailed error information.`));
                    if (isDebug) {
                        console.error(os.EOL + error.message);
                    }
                }
            });
            stopwatch.stop();
            console.log(os.EOL + safe_1.default.green(`Event hooks finished. (${stopwatch.toString()})`));
        }
    }
}
exports.EventHooksManager = EventHooksManager;
//# sourceMappingURL=EventHooksManager.js.map

/***/ }),

/***/ 58361:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Git = exports.DEFAULT_GIT_TAG_SEPARATOR = void 0;
const gitInfo = __webpack_require__(57640);
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const url = __importStar(__webpack_require__(78835));
const safe_1 = __importDefault(__webpack_require__(41997));
const node_core_library_1 = __webpack_require__(24019);
const Utilities_1 = __webpack_require__(89521);
const GitEmailPolicy_1 = __webpack_require__(8503);
const EnvironmentConfiguration_1 = __webpack_require__(84018);
exports.DEFAULT_GIT_TAG_SEPARATOR = '_';
class Git {
    constructor(rushConfiguration) {
        this._checkedGitPath = false;
        this._checkedGitInfo = false;
        this._gitEmailResult = undefined;
        this._rushConfiguration = rushConfiguration;
    }
    /**
     * Returns the path to the Git binary if found. Otherwise, return undefined.
     */
    get gitPath() {
        if (!this._checkedGitPath) {
            this._gitPath = EnvironmentConfiguration_1.EnvironmentConfiguration.gitBinaryPath || node_core_library_1.Executable.tryResolve('git');
            this._checkedGitPath = true;
        }
        return this._gitPath;
    }
    getGitPathOrThrow() {
        const gitPath = this.gitPath;
        if (!gitPath) {
            throw new Error('Git is not present');
        }
        else {
            return gitPath;
        }
    }
    /**
     * Returns true if the Git binary can be found.
     */
    isGitPresent() {
        return !!this.gitPath;
    }
    /**
     * Returns true if the Git binary was found and the current path is under a Git working tree.
     * @param repoInfo - If provided, do the check based on this Git repo info. If not provided,
     * the result of `this.getGitInfo()` is used.
     */
    isPathUnderGitWorkingTree(repoInfo) {
        if (this.isGitPresent()) {
            // Do we even have a Git binary?
            if (!repoInfo) {
                repoInfo = this.getGitInfo();
            }
            return !!(repoInfo && repoInfo.sha);
        }
        else {
            return false;
        }
    }
    /**
     * If a Git email address is configured and is nonempty, this returns it.
     * Otherwise, undefined is returned.
     */
    tryGetGitEmail() {
        const emailResult = this._tryGetGitEmail();
        if (emailResult.result !== undefined && emailResult.result.length > 0) {
            return emailResult.result;
        }
        return undefined;
    }
    /**
     * If a Git email address is configured and is nonempty, this returns it.
     * Otherwise, configuration instructions are printed to the console,
     * and AlreadyReportedError is thrown.
     */
    getGitEmail() {
        // Determine the user's account
        // Ex: "bob@example.com"
        const emailResult = this._tryGetGitEmail();
        if (emailResult.error) {
            console.log([
                `Error: ${emailResult.error.message}`,
                'Unable to determine your Git configuration using this command:',
                '',
                '    git config user.email',
                ''
            ].join(os.EOL));
            throw new node_core_library_1.AlreadyReportedError();
        }
        if (emailResult.result === undefined || emailResult.result.length === 0) {
            console.log([
                'This operation requires that a Git email be specified.',
                '',
                `If you didn't configure your email yet, try something like this:`,
                '',
                ...GitEmailPolicy_1.GitEmailPolicy.getEmailExampleLines(this._rushConfiguration),
                ''
            ].join(os.EOL));
            throw new node_core_library_1.AlreadyReportedError();
        }
        return emailResult.result;
    }
    /**
     * Get the folder where Git hooks should go for the current working tree.
     * Returns undefined if the current path is not under a Git working tree.
     */
    getHooksFolder() {
        const repoInfo = this.getGitInfo();
        if (repoInfo && repoInfo.worktreeGitDir) {
            return path.join(repoInfo.worktreeGitDir, 'hooks');
        }
        return undefined;
    }
    /**
     * Get information about the current Git working tree.
     * Returns undefined if the current path is not under a Git working tree.
     */
    getGitInfo() {
        if (!this._checkedGitInfo) {
            let repoInfo;
            try {
                // gitInfo() shouldn't usually throw, but wrapping in a try/catch just in case
                repoInfo = gitInfo();
            }
            catch (ex) {
                // if there's an error, assume we're not in a Git working tree
            }
            if (repoInfo && this.isPathUnderGitWorkingTree(repoInfo)) {
                this._gitInfo = repoInfo;
            }
            this._checkedGitInfo = true;
        }
        return this._gitInfo;
    }
    getRepositoryRootPath() {
        const gitPath = this.getGitPathOrThrow();
        const output = node_core_library_1.Executable.spawnSync(gitPath, [
            'rev-parse',
            '--show-toplevel'
        ]);
        if (output.status !== 0) {
            return undefined;
        }
        else {
            return output.stdout.trim();
        }
    }
    getChangedFolders(targetBranch, terminal, shouldFetch = false) {
        if (shouldFetch) {
            this._fetchRemoteBranch(targetBranch, terminal);
        }
        const gitPath = this.getGitPathOrThrow();
        const output = Utilities_1.Utilities.executeCommandAndCaptureOutput(gitPath, ['diff', `${targetBranch}...`, '--dirstat=files,0'], this._rushConfiguration.rushJsonFolder);
        const lines = output.split('\n');
        const result = [];
        for (const line of lines) {
            if (line) {
                const delimiterIndex = line.indexOf('%');
                if (delimiterIndex > 0 && delimiterIndex + 1 < line.length) {
                    result.push(line.substring(delimiterIndex + 1).trim());
                }
            }
        }
        return result;
    }
    /**
     * @param pathPrefix - An optional path prefix "git diff"s should be filtered by.
     * @returns
     * An array of paths of repo-root-relative paths of files that are different from
     * those in the provided {@param targetBranch}. If a {@param pathPrefix} is provided,
     * this function only returns results under the that path.
     */
    getChangedFiles(targetBranch, terminal, skipFetch = false, pathPrefix) {
        if (!skipFetch) {
            this._fetchRemoteBranch(targetBranch, terminal);
        }
        const gitPath = this.getGitPathOrThrow();
        const output = Utilities_1.Utilities.executeCommandAndCaptureOutput(gitPath, ['diff', `${targetBranch}...`, '--name-only', '--no-renames', '--diff-filter=A'], this._rushConfiguration.rushJsonFolder);
        return output
            .split('\n')
            .map((line) => {
            if (line) {
                const trimmedLine = line.trim();
                if (!pathPrefix || node_core_library_1.Path.isUnderOrEqual(trimmedLine, pathPrefix)) {
                    return trimmedLine;
                }
            }
            else {
                return undefined;
            }
        })
            .filter((line) => {
            return line && line.length > 0;
        });
    }
    /**
     * Gets the remote default branch that maps to the provided repository url.
     * This method is used by 'Rush change' to find the default remote branch to compare against.
     * If repository url is not provided or if there is no match, returns the default remote's
     * default branch 'origin/master'.
     * If there are more than one matches, returns the first remote's default branch.
     *
     * @param rushConfiguration - rush configuration
     */
    getRemoteDefaultBranch() {
        const repositoryUrl = this._rushConfiguration.repositoryUrl;
        if (repositoryUrl) {
            const gitPath = this.getGitPathOrThrow();
            const output = Utilities_1.Utilities.executeCommandAndCaptureOutput(gitPath, ['remote'], this._rushConfiguration.rushJsonFolder).trim();
            // Apply toUpperCase() for a case-insensitive comparison
            const normalizedRepositoryUrl = Git.normalizeGitUrlForComparison(repositoryUrl).toUpperCase();
            const matchingRemotes = output.split('\n').filter((remoteName) => {
                if (remoteName) {
                    const remoteUrl = Utilities_1.Utilities.executeCommandAndCaptureOutput(gitPath, ['remote', 'get-url', remoteName], this._rushConfiguration.rushJsonFolder).trim();
                    if (!remoteUrl) {
                        return false;
                    }
                    // Also apply toUpperCase() for a case-insensitive comparison
                    const normalizedRemoteUrl = Git.normalizeGitUrlForComparison(remoteUrl).toUpperCase();
                    if (normalizedRemoteUrl === normalizedRepositoryUrl) {
                        return true;
                    }
                }
                return false;
            });
            if (matchingRemotes.length > 0) {
                if (matchingRemotes.length > 1) {
                    console.log(`More than one git remote matches the repository URL. Using the first remote (${matchingRemotes[0]}).`);
                }
                return `${matchingRemotes[0]}/${this._rushConfiguration.repositoryDefaultBranch}`;
            }
            else {
                console.log(safe_1.default.yellow(`Unable to find a git remote matching the repository URL (${repositoryUrl}). ` +
                    'Detected changes are likely to be incorrect.'));
                return this._rushConfiguration.repositoryDefaultFullyQualifiedRemoteBranch;
            }
        }
        else {
            console.log(safe_1.default.yellow('A git remote URL has not been specified in rush.json. Setting the baseline remote URL is recommended.'));
            return this._rushConfiguration.repositoryDefaultFullyQualifiedRemoteBranch;
        }
    }
    hasUncommittedChanges() {
        return this.getUncommittedChanges().length > 0;
    }
    /**
     * The list of files changed but not committed
     */
    getUncommittedChanges() {
        const changes = [];
        changes.push(...this._getUntrackedChanges());
        changes.push(...this._getDiffOnHEAD());
        return changes.filter((change) => {
            return change.trim().length > 0;
        });
    }
    getTagSeparator() {
        return this._rushConfiguration.gitTagSeparator || exports.DEFAULT_GIT_TAG_SEPARATOR;
    }
    /**
     * Git remotes can use different URL syntaxes; this converts them all to a normalized HTTPS
     * representation for matching purposes.  IF THE INPUT IS NOT ALREADY HTTPS, THE OUTPUT IS
     * NOT NECESSARILY A VALID GIT URL.
     *
     * @example
     * `git@github.com:ExampleOrg/ExampleProject.git` --> `https://github.com/ExampleOrg/ExampleProject`
     */
    static normalizeGitUrlForComparison(gitUrl) {
        // Git URL formats are documented here: https://www.git-scm.com/docs/git-clone#_git_urls
        let result = gitUrl.trim();
        // [user@]host.xz:path/to/repo.git/
        // "This syntax is only recognized if there are no slashes before the first colon. This helps
        // differentiate a local path that contains a colon."
        //
        // Match patterns like this:
        //   user@host.ext:path/to/repo
        //   host.ext:path/to/repo
        //   localhost:/~user/path/to/repo
        //
        // But not:
        //   http://blah
        //   c:/windows/path.txt
        //
        const scpLikeSyntaxRegExp = /^(?:[^@:\/]+\@)?([^:\/]{2,})\:((?!\/\/).+)$/;
        // Example: "user@host.ext:path/to/repo"
        const scpLikeSyntaxMatch = scpLikeSyntaxRegExp.exec(gitUrl);
        if (scpLikeSyntaxMatch) {
            // Example: "host.ext"
            const host = scpLikeSyntaxMatch[1];
            // Example: "path/to/repo"
            const path = scpLikeSyntaxMatch[2];
            if (path.startsWith('/')) {
                result = `https://${host}${path}`;
            }
            else {
                result = `https://${host}/${path}`;
            }
        }
        const parsedUrl = url.parse(result);
        // Only convert recognized schemes
        switch (parsedUrl.protocol) {
            case 'http:':
            case 'https:':
            case 'ssh:':
            case 'ftp:':
            case 'ftps:':
            case 'git:':
            case 'git+http:':
            case 'git+https:':
            case 'git+ssh:':
            case 'git+ftp:':
            case 'git+ftps:':
                // Assemble the parts we want:
                result = `https://${parsedUrl.host}${parsedUrl.pathname}`;
                break;
        }
        // Trim ".git" or ".git/" from the end
        result = result.replace(/.git\/?$/, '');
        return result;
    }
    _tryGetGitEmail() {
        if (this._gitEmailResult === undefined) {
            const gitPath = this.getGitPathOrThrow();
            try {
                this._gitEmailResult = {
                    result: Utilities_1.Utilities.executeCommandAndCaptureOutput(gitPath, ['config', 'user.email'], this._rushConfiguration.rushJsonFolder).trim()
                };
            }
            catch (e) {
                this._gitEmailResult = {
                    error: e
                };
            }
        }
        return this._gitEmailResult;
    }
    _getUntrackedChanges() {
        const gitPath = this.getGitPathOrThrow();
        const output = Utilities_1.Utilities.executeCommandAndCaptureOutput(gitPath, ['ls-files', '--exclude-standard', '--others'], this._rushConfiguration.rushJsonFolder);
        return output.trim().split('\n');
    }
    _getDiffOnHEAD() {
        const gitPath = this.getGitPathOrThrow();
        const output = Utilities_1.Utilities.executeCommandAndCaptureOutput(gitPath, ['diff', 'HEAD', '--name-only'], this._rushConfiguration.rushJsonFolder);
        return output.trim().split('\n');
    }
    _tryFetchRemoteBranch(remoteBranchName) {
        const firstSlashIndex = remoteBranchName.indexOf('/');
        if (firstSlashIndex === -1) {
            throw new Error(`Unexpected git remote branch format: ${remoteBranchName}. ` +
                'Expected branch to be in the <remote>/<branch name> format.');
        }
        const remoteName = remoteBranchName.substr(0, firstSlashIndex);
        const branchName = remoteBranchName.substr(firstSlashIndex + 1);
        const gitPath = this.getGitPathOrThrow();
        const spawnResult = node_core_library_1.Executable.spawnSync(gitPath, ['fetch', remoteName, branchName], {
            stdio: 'ignore'
        });
        return spawnResult.status === 0;
    }
    _fetchRemoteBranch(remoteBranchName, terminal) {
        console.log(`Checking for updates to ${remoteBranchName}...`);
        const fetchResult = this._tryFetchRemoteBranch(remoteBranchName);
        if (!fetchResult) {
            terminal.writeWarningLine(`Error fetching git remote branch ${remoteBranchName}. Detected changed files may be incorrect.`);
        }
    }
}
exports.Git = Git;
//# sourceMappingURL=Git.js.map

/***/ }),

/***/ 66846:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonSchemaUrls = void 0;
/**
 * JSON schema URLs that Rush writes into config files.
 */
class JsonSchemaUrls {
}
exports.JsonSchemaUrls = JsonSchemaUrls;
JsonSchemaUrls.approvedPackages = 'https://developer.microsoft.com/json-schemas/rush/v5/approved-packages.schema.json';
JsonSchemaUrls.commonVersions = 'https://developer.microsoft.com/json-schemas/rush/v5/common-versions.schema.json';
//# sourceMappingURL=JsonSchemaUrls.js.map

/***/ }),

/***/ 83431:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LookupByPath = void 0;
/**
 * This class is used to associate POSIX relative paths, such as those returned by `git` commands,
 * with entities that correspond with ancestor folders, such as Rush Projects.
 *
 * It is optimized for efficiently locating the nearest ancestor path with an associated value.
 *
 * @example
 * ```ts
 * const tree = new LookupByPath([['foo', 1], ['bar', 2], ['foo/bar', 3]]);
 * tree.getNearestAncestor('foo'); // returns 1
 * tree.getNearestAncestor('foo/baz'); // returns 1
 * tree.getNearestAncestor('baz'); // returns undefined
 * tree.getNearestAncestor('foo/bar/baz'); returns 3
 * tree.getNearestAncestor('bar/foo/bar'); returns 2
 * ```
 */
class LookupByPath {
    /**
     * Constructs a new `LookupByPath`
     *
     * @param entries - Initial path-value pairs to populate the tree.
     */
    constructor(entries, delimiter) {
        this._root = {
            value: undefined,
            children: undefined
        };
        this.delimiter = delimiter !== null && delimiter !== void 0 ? delimiter : '/';
        if (entries) {
            for (const [path, item] of entries) {
                this.setItem(path, item);
            }
        }
    }
    /**
     * Iterates over the segments of a serialized path.
     *
     * @example
     *
     * `LookupByPath.iteratePathSegments('foo/bar/baz')` yields 'foo', 'bar', 'baz'
     *
     * `LookupByPath.iteratePathSegments('foo\\bar\\baz', '\\')` yields 'foo', 'bar', 'baz'
     */
    static *iteratePathSegments(serializedPath, delimiter = '/') {
        if (!serializedPath) {
            return;
        }
        let nextIndex = serializedPath.indexOf(delimiter);
        let previousIndex = 0;
        while (nextIndex >= 0) {
            yield serializedPath.slice(previousIndex, nextIndex);
            previousIndex = nextIndex + 1;
            nextIndex = serializedPath.indexOf(delimiter, previousIndex);
        }
        if (previousIndex + 1 < serializedPath.length) {
            yield serializedPath.slice(previousIndex);
        }
    }
    /**
     * Associates the value with the specified serialized path.
     * If a value is already associated, will overwrite.
     *
     * @returns this, for chained calls
     */
    setItem(serializedPath, value) {
        return this.setItemFromSegments(LookupByPath.iteratePathSegments(serializedPath, this.delimiter), value);
    }
    /**
     * Associates the value with the specified path.
     * If a value is already associated, will overwrite.
     *
     * @returns this, for chained calls
     */
    setItemFromSegments(pathSegments, value) {
        let node = this._root;
        for (const segment of pathSegments) {
            if (!node.children) {
                node.children = new Map();
            }
            let child = node.children.get(segment);
            if (!child) {
                node.children.set(segment, (child = {
                    value: undefined,
                    children: undefined
                }));
            }
            node = child;
        }
        node.value = value;
        return this;
    }
    /**
     * Searches for the item associated with `childPath`, or the nearest ancestor of that path that
     * has an associated item.
     *
     * @returns the found item, or `undefined` if no item was found
     *
     * @example
     * ```ts
     * const tree = new LookupByPath([['foo', 1], ['foo/bar', 2]]);
     * tree.findChildPath('foo/baz'); // returns 1
     * tree.findChildPath('foo/bar/baz'); // returns 2
     * ```
     */
    findChildPath(childPath) {
        return this.findChildPathFromSegments(LookupByPath.iteratePathSegments(childPath, this.delimiter));
    }
    /**
     * Searches for the item associated with `childPathSegments`, or the nearest ancestor of that path that
     * has an associated item.
     *
     * @returns the found item, or `undefined` if no item was found
     *
     * @example
     * ```ts
     * const tree = new LookupByPath([['foo', 1], ['foo/bar', 2]]);
     * tree.findChildPathFromSegments(['foo', 'baz']); // returns 1
     * tree.findChildPathFromSegments(['foo','bar', 'baz']); // returns 2
     * ```
     */
    findChildPathFromSegments(childPathSegments) {
        var _a;
        let node = this._root;
        let best = node.value;
        // Trivial cases
        if (node.children) {
            for (const segment of childPathSegments) {
                const child = node.children.get(segment);
                if (!child) {
                    break;
                }
                node = child;
                best = (_a = node.value) !== null && _a !== void 0 ? _a : best;
                if (!node.children) {
                    break;
                }
            }
        }
        return best;
    }
}
exports.LookupByPath = LookupByPath;
//# sourceMappingURL=LookupByPath.js.map

/***/ }),

/***/ 5252:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeJsCompatibility = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const semver = __importStar(__webpack_require__(11383));
/**
 * This constant is the major version of the next LTS node Node.js release. This constant should be updated when
 * a new LTS version is added to Rush's support matrix.
 *
 * LTS schedule: https://nodejs.org/en/about/releases/
 * LTS versions: https://nodejs.org/en/download/releases/
 */
const UPCOMING_NODE_LTS_VERSION = 18;
const nodeVersion = process.versions.node;
const nodeMajorVersion = semver.major(nodeVersion);
/**
 * This class provides useful functions for warning if the current Node.js runtime isn't supported.
 *
 * @internal
 */
class NodeJsCompatibility {
    /**
     * This reports if the Node.js version is known to have serious incompatibilities.  In that situation, the user
     * should downgrade Rush to an older release that supported their Node.js version.
     */
    static reportAncientIncompatibleVersion() {
        // IMPORTANT: If this test fails, the Rush CLI front-end process will terminate with an error.
        // Only increment it when our code base is known to use newer features (e.g. "async"/"await") that
        // have no hope of working with older Node.js.
        if (semver.satisfies(nodeVersion, '< 8.9.0')) {
            console.error(safe_1.default.red(`Your version of Node.js (${nodeVersion}) is very old and incompatible with Rush. ` +
                `Please upgrade to the latest Long-Term Support (LTS) version.\n`));
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Detect whether the Node.js version is "supported" by the Rush maintainers.  We generally
     * only support versions that were "Long Term Support" (LTS) at the time when Rush was published.
     *
     * This is a warning only -- the user is free to ignore it and use Rush anyway.
     */
    static warnAboutCompatibilityIssues(options) {
        // Only show the first warning
        return (NodeJsCompatibility.reportAncientIncompatibleVersion() ||
            NodeJsCompatibility.warnAboutVersionTooNew(options) ||
            NodeJsCompatibility._warnAboutOddNumberedVersion() ||
            NodeJsCompatibility._warnAboutNonLtsVersion(options.rushConfiguration));
    }
    /**
     * Warn about a Node.js version that has not been tested yet with Rush.
     */
    static warnAboutVersionTooNew(options) {
        if (nodeMajorVersion >= UPCOMING_NODE_LTS_VERSION + 1) {
            if (!options.alreadyReportedNodeTooNewError) {
                // We are on a much newer release than we have tested and support
                if (options.isRushLib) {
                    console.warn(safe_1.default.yellow(`Your version of Node.js (${nodeVersion}) has not been tested with this release ` +
                        `of the Rush engine. Please consider upgrading the "rushVersion" setting in rush.json, ` +
                        `or downgrading Node.js.\n`));
                }
                else {
                    console.warn(safe_1.default.yellow(`Your version of Node.js (${nodeVersion}) has not been tested with this release ` +
                        `of Rush. Please consider installing a newer version of the "@microsoft/rush" ` +
                        `package, or downgrading Node.js.\n`));
                }
            }
            return true;
        }
        else {
            return false;
        }
    }
    static _warnAboutNonLtsVersion(rushConfiguration) {
        if (rushConfiguration && !rushConfiguration.suppressNodeLtsWarning && !NodeJsCompatibility.isLtsVersion) {
            console.warn(safe_1.default.yellow(`Your version of Node.js (${nodeVersion}) is not a Long-Term Support (LTS) release. ` +
                'These versions frequently have bugs. Please consider installing a stable release.\n'));
            return true;
        }
        else {
            return false;
        }
    }
    static _warnAboutOddNumberedVersion() {
        if (NodeJsCompatibility.isOddNumberedVersion) {
            console.warn(safe_1.default.yellow(`Your version of Node.js (${nodeVersion}) is an odd-numbered release. ` +
                `These releases frequently have bugs. Please consider installing a Long Term Support (LTS) ` +
                `version instead.\n`));
            return true;
        }
        else {
            return false;
        }
    }
    static get isLtsVersion() {
        return !!process.release.lts;
    }
    static get isOddNumberedVersion() {
        return nodeMajorVersion % 2 !== 0;
    }
}
exports.NodeJsCompatibility = NodeJsCompatibility;
//# sourceMappingURL=NodeJsCompatibility.js.map

/***/ }),

/***/ 82397:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrereleaseToken = void 0;
class PrereleaseToken {
    constructor(prereleaseName, suffixName, partialPrerelease = false) {
        if (prereleaseName && suffixName) {
            throw new Error('Pre-release name and suffix cannot be provided at the same time.');
        }
        this._name = prereleaseName || suffixName;
        this._prereleaseName = prereleaseName;
        this._suffixName = suffixName;
        this._partialPrerelease = partialPrerelease;
    }
    get hasValue() {
        return !!this._prereleaseName || !!this._suffixName;
    }
    get isPrerelease() {
        return !!this._prereleaseName;
    }
    get isSuffix() {
        return !!this._suffixName;
    }
    get isPartialPrerelease() {
        return this.isPrerelease && this._partialPrerelease;
    }
    get name() {
        return this._name;
    }
}
exports.PrereleaseToken = PrereleaseToken;
//# sourceMappingURL=PrereleaseToken.js.map

/***/ }),

/***/ 15504:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProjectChangeAnalyzer = void 0;
const path = __importStar(__webpack_require__(85622));
const crypto = __importStar(__webpack_require__(33373));
const ignore_1 = __importDefault(__webpack_require__(36564));
const package_deps_hash_1 = __webpack_require__(45329);
const node_core_library_1 = __webpack_require__(24019);
const RushProjectConfiguration_1 = __webpack_require__(19847);
const Git_1 = __webpack_require__(58361);
const BaseProjectShrinkwrapFile_1 = __webpack_require__(30052);
const RushConstants_1 = __webpack_require__(63985);
const Utilities_1 = __webpack_require__(89521);
/**
 * @beta
 */
class ProjectChangeAnalyzer {
    constructor(rushConfiguration) {
        /**
         * UNINITIALIZED === we haven't looked
         * undefined === data isn't available (i.e. - git isn't present)
         */
        this._data = Utilities_1.UNINITIALIZED;
        this._filteredData = new Map();
        this._projectStateCache = new Map();
        this._rushConfiguration = rushConfiguration;
        this._git = new Git_1.Git(this._rushConfiguration);
    }
    /**
     * Try to get a list of the specified project's dependencies and their hashes.
     *
     * @remarks
     * If the data can't be generated (i.e. - if Git is not present) this returns undefined.
     *
     * @internal
     */
    async _tryGetProjectDependenciesAsync(projectName, terminal) {
        // Check the cache for any existing data
        const existingData = this._filteredData.get(projectName);
        if (existingData) {
            return existingData;
        }
        if (this._data === Utilities_1.UNINITIALIZED) {
            this._data = await this._getDataAsync(terminal);
        }
        if (this._data === undefined) {
            return undefined;
        }
        const project = this._rushConfiguration.getProjectByName(projectName);
        if (!project) {
            throw new Error(`Project "${projectName}" does not exist in the current Rush configuration.`);
        }
        const unfilteredProjectData = this._data.get(projectName);
        let filteredProjectData;
        const ignoreMatcher = await this._getIgnoreMatcherForProjectAsync(project, terminal);
        if (ignoreMatcher) {
            // At this point, `filePath` is guaranteed to start with `projectRelativeFolder`, so
            // we can safely slice off the first N characters to get the file path relative to the
            // root of the project.
            filteredProjectData = new Map();
            for (const [filePath, fileHash] of unfilteredProjectData) {
                const relativePath = filePath.slice(project.projectRelativeFolder.length + 1);
                if (!ignoreMatcher.ignores(relativePath)) {
                    // Add the file path to the filtered data if it is not ignored
                    filteredProjectData.set(filePath, fileHash);
                }
            }
        }
        else {
            filteredProjectData = unfilteredProjectData;
        }
        this._filteredData.set(projectName, filteredProjectData);
        return filteredProjectData;
    }
    /**
     * The project state hash is calculated in the following way:
     * - Project dependencies are collected (see ProjectChangeAnalyzer.getPackageDeps)
     *   - If project dependencies cannot be collected (i.e. - if Git isn't available),
     *     this function returns `undefined`
     * - The (path separator normalized) repo-root-relative dependencies' file paths are sorted
     * - A SHA1 hash is created and each (sorted) file path is fed into the hash and then its
     *   Git SHA is fed into the hash
     * - A hex digest of the hash is returned
     *
     * @internal
     */
    async _tryGetProjectStateHashAsync(projectName, terminal) {
        let projectState = this._projectStateCache.get(projectName);
        if (!projectState) {
            const packageDeps = await this._tryGetProjectDependenciesAsync(projectName, terminal);
            if (!packageDeps) {
                return undefined;
            }
            else {
                const sortedPackageDepsFiles = Array.from(packageDeps.keys()).sort();
                const hash = crypto.createHash('sha1');
                for (const packageDepsFile of sortedPackageDepsFiles) {
                    hash.update(packageDepsFile);
                    hash.update(RushConstants_1.RushConstants.hashDelimiter);
                    hash.update(packageDeps.get(packageDepsFile));
                    hash.update(RushConstants_1.RushConstants.hashDelimiter);
                }
                projectState = hash.digest('hex');
                this._projectStateCache.set(projectName, projectState);
            }
        }
        return projectState;
    }
    /**
     * Gets a list of projects that have changed in the current state of the repo
     * when compared to the specified branch.
     */
    getChangedProjectsAsync(options) {
        return __asyncGenerator(this, arguments, function* getChangedProjectsAsync_1() {
            const changedFolders = this._git.getChangedFolders(options.targetBranchName, options.terminal, options.shouldFetch);
            if (changedFolders) {
                const repoRootFolder = this._git.getRepositoryRootPath();
                for (const project of this._rushConfiguration.projects) {
                    const projectFolder = repoRootFolder
                        ? path.relative(repoRootFolder, project.projectFolder)
                        : project.projectRelativeFolder;
                    if (this._hasProjectChanged(changedFolders, projectFolder)) {
                        yield yield __await(project);
                    }
                }
            }
        });
    }
    _hasProjectChanged(changedFolders, projectFolder) {
        for (const folder of changedFolders) {
            if (node_core_library_1.Path.isUnderOrEqual(folder, projectFolder)) {
                return true;
            }
        }
        return false;
    }
    async _getDataAsync(terminal) {
        const repoDeps = this._getRepoDeps(terminal);
        if (!repoDeps) {
            return undefined;
        }
        const projectHashDeps = new Map();
        for (const project of this._rushConfiguration.projects) {
            projectHashDeps.set(project.packageName, new Map());
        }
        // Sort each project folder into its own package deps hash
        for (const [filePath, fileHash] of repoDeps) {
            // findProjectForPosixRelativePath uses LookupByPath, for which lookups are O(K)
            // K being the maximum folder depth of any project in rush.json (usually on the order of 3)
            const owningProject = this._rushConfiguration.findProjectForPosixRelativePath(filePath);
            if (owningProject) {
                const owningProjectHashDeps = projectHashDeps.get(owningProject.packageName);
                owningProjectHashDeps.set(filePath, fileHash);
            }
        }
        // Currently, only pnpm handles project shrinkwraps
        if (this._rushConfiguration.packageManager === 'pnpm') {
            const projects = [];
            const projectDependencyManifestPaths = [];
            for (const project of this._rushConfiguration.projects) {
                const projectShrinkwrapFilePath = BaseProjectShrinkwrapFile_1.BaseProjectShrinkwrapFile.getFilePathForProject(project);
                const relativeProjectShrinkwrapFilePath = node_core_library_1.Path.convertToSlashes(path.relative(this._rushConfiguration.rushJsonFolder, projectShrinkwrapFilePath));
                if (!node_core_library_1.FileSystem.exists(projectShrinkwrapFilePath)) {
                    throw new Error(`A project dependency file (${relativeProjectShrinkwrapFilePath}) is missing. You may need to run ` +
                        '"rush install" or "rush update".');
                }
                projects.push(project);
                projectDependencyManifestPaths.push(relativeProjectShrinkwrapFilePath);
            }
            const gitPath = this._git.getGitPathOrThrow();
            const hashes = (0, package_deps_hash_1.getGitHashForFiles)(projectDependencyManifestPaths, this._rushConfiguration.rushJsonFolder, gitPath);
            for (let i = 0; i < projects.length; i++) {
                const project = projects[i];
                const projectDependencyManifestPath = projectDependencyManifestPaths[i];
                if (!hashes.has(projectDependencyManifestPath)) {
                    throw new node_core_library_1.InternalError(`Expected to get a hash for ${projectDependencyManifestPath}`);
                }
                const hash = hashes.get(projectDependencyManifestPath);
                projectHashDeps.get(project.packageName).set(projectDependencyManifestPath, hash);
            }
        }
        else {
            // Determine the current variant from the link JSON.
            const variant = this._rushConfiguration.currentInstalledVariant;
            // Add the shrinkwrap file to every project's dependencies
            const shrinkwrapFile = node_core_library_1.Path.convertToSlashes(path.relative(this._rushConfiguration.rushJsonFolder, this._rushConfiguration.getCommittedShrinkwrapFilename(variant)));
            for (const project of this._rushConfiguration.projects) {
                const shrinkwrapHash = repoDeps.get(shrinkwrapFile);
                if (shrinkwrapHash) {
                    projectHashDeps.get(project.packageName).set(shrinkwrapFile, shrinkwrapHash);
                }
            }
        }
        return projectHashDeps;
    }
    async _getIgnoreMatcherForProjectAsync(project, terminal) {
        const projectConfiguration = await RushProjectConfiguration_1.RushProjectConfiguration.tryLoadForProjectAsync(project, undefined, terminal);
        if (projectConfiguration && projectConfiguration.incrementalBuildIgnoredGlobs) {
            const ignoreMatcher = (0, ignore_1.default)();
            ignoreMatcher.add(projectConfiguration.incrementalBuildIgnoredGlobs);
            return ignoreMatcher;
        }
    }
    _getRepoDeps(terminal) {
        try {
            if (this._git.isPathUnderGitWorkingTree()) {
                // Load the package deps hash for the whole repository
                const gitPath = this._git.getGitPathOrThrow();
                return (0, package_deps_hash_1.getPackageDeps)(this._rushConfiguration.rushJsonFolder, [], gitPath);
            }
            else {
                return undefined;
            }
        }
        catch (e) {
            // If getPackageDeps fails, don't fail the whole build. Treat this case as if we don't know anything about
            // the state of the files in the repo. This can happen if the environment doesn't have Git.
            terminal.writeWarningLine(`Error calculating the state of the repo. (inner error: ${e}). Continuing without diffing files.`);
            return undefined;
        }
    }
}
exports.ProjectChangeAnalyzer = ProjectChangeAnalyzer;
//# sourceMappingURL=ProjectChangeAnalyzer.js.map

/***/ }),

/***/ 85777:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProjectCommandSet = void 0;
/**
 * Parses the "scripts" section from package.json and provides support for executing scripts.
 */
class ProjectCommandSet {
    constructor(packageJson) {
        this.malformedScriptNames = [];
        this.commandNames = [];
        this._scriptsByName = new Map();
        const scripts = packageJson.scripts || {};
        for (const scriptName of Object.keys(scripts)) {
            if (scriptName[0] === '-' || scriptName.length === 0) {
                this.malformedScriptNames.push(scriptName);
            }
            else {
                this.commandNames.push(scriptName);
                this._scriptsByName.set(scriptName, scripts[scriptName]);
            }
        }
        this.commandNames.sort();
    }
    tryGetScriptBody(commandName) {
        return this._scriptsByName.get(commandName);
    }
    getScriptBody(commandName) {
        const result = this.tryGetScriptBody(commandName);
        if (result === undefined) {
            throw new Error(`The command "${commandName}" was not found`);
        }
        return result;
    }
}
exports.ProjectCommandSet = ProjectCommandSet;
//# sourceMappingURL=ProjectCommandSet.js.map

/***/ }),

/***/ 2329:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProjectWatcher = void 0;
const fs = __importStar(__webpack_require__(35747));
const os = __importStar(__webpack_require__(12087));
const events_1 = __webpack_require__(28614);
const node_core_library_1 = __webpack_require__(24019);
const ProjectChangeAnalyzer_1 = __webpack_require__(15504);
/**
 * This class is for incrementally watching a set of projects in the repository for changes.
 *
 * We are manually using fs.watch() instead of `chokidar` because all we want from the file system watcher is a boolean
 * signal indicating that "at least 1 file in a watched project changed". We then defer to ProjectChangeAnalyzer (which
 * is responsible for change detection in all incremental builds) to determine what actually chanaged.
 *
 * Calling `waitForChange()` will return a promise that resolves when the package-deps of one or
 * more projects differ from the value the previous time it was invoked. The first time will always resolve with the full selection.
 */
class ProjectWatcher {
    constructor(options) {
        const { debounceMilliseconds = 1000, rushConfiguration, projectsToWatch, terminal } = options;
        this._debounceMilliseconds = debounceMilliseconds;
        this._rushConfiguration = rushConfiguration;
        this._projectsToWatch = projectsToWatch;
        this._terminal = terminal;
    }
    /**
     * Waits for a change to the package-deps of one or more of the selected projects, since the previous invocation.
     * Will return immediately the first time it is invoked, since no state has been recorded.
     * If no change is currently present, watches the source tree of all selected projects for file changes.
     */
    async waitForChange(onWatchingFiles) {
        const initialChangeResult = await this._computeChanged();
        // Ensure that the new state is recorded so that we don't loop infinitely
        this._commitChanges(initialChangeResult.state);
        if (initialChangeResult.changedProjects.size) {
            return initialChangeResult;
        }
        const previousState = initialChangeResult.state;
        const repoRoot = node_core_library_1.Path.convertToSlashes(this._rushConfiguration.rushJsonFolder);
        const pathsToWatch = new Set();
        // Node 12 supports the "recursive" parameter to fs.watch only on win32 and OSX
        // https://nodejs.org/docs/latest-v12.x/api/fs.html#fs_caveats
        const useNativeRecursiveWatch = os.platform() === 'win32' || os.platform() === 'darwin';
        for (const project of this._projectsToWatch) {
            const projectState = (await previousState._tryGetProjectDependenciesAsync(project.packageName, this._terminal));
            const projectFolder = project.projectRelativeFolder;
            // Watch files in the root of the project, or
            for (const fileName of projectState.keys()) {
                for (const pathToWatch of ProjectWatcher._enumeratePathsToWatch(fileName, projectFolder, useNativeRecursiveWatch)) {
                    pathsToWatch.add(`${repoRoot}/${pathToWatch}`);
                }
            }
        }
        const watchers = new Map();
        const watchedResult = await new Promise((resolve, reject) => {
            let timeout;
            let terminated = false;
            const resolveIfChanged = async () => {
                timeout = undefined;
                if (terminated) {
                    return;
                }
                try {
                    const result = await this._computeChanged();
                    // Need an async tick to allow for more file system events to be handled
                    process.nextTick(() => {
                        if (timeout) {
                            // If another file has changed, wait for another pass.
                            return;
                        }
                        this._commitChanges(result.state);
                        if (result.changedProjects.size) {
                            terminated = true;
                            resolve(result);
                        }
                    });
                }
                catch (err) {
                    // eslint-disable-next-line require-atomic-updates
                    terminated = true;
                    reject(err);
                }
            };
            const onError = (err) => {
                if (terminated) {
                    return;
                }
                terminated = true;
                reject(err);
            };
            const addWatcher = (watchedPath, listener) => {
                const watcher = fs.watch(watchedPath, {
                    encoding: 'utf-8',
                    recursive: useNativeRecursiveWatch
                }, listener);
                watchers.set(watchedPath, watcher);
                watcher.on('error', (err) => {
                    watchers.delete(watchedPath);
                    onError(err);
                });
            };
            const changeListener = (event, fileName) => {
                try {
                    if (terminated) {
                        return;
                    }
                    // Handling for added directories
                    if (!useNativeRecursiveWatch) {
                        const decodedName = fileName && fileName.toString();
                        const normalizedName = decodedName && node_core_library_1.Path.convertToSlashes(decodedName);
                        if (normalizedName && !watchers.has(normalizedName)) {
                            try {
                                const stat = fs.statSync(fileName);
                                if (stat.isDirectory()) {
                                    addWatcher(normalizedName, changeListener);
                                }
                            }
                            catch (err) {
                                const code = err.code;
                                if (code !== 'ENOENT' && code !== 'ENOTDIR') {
                                    throw err;
                                }
                            }
                        }
                    }
                    // Use a timeout to debounce changes, e.g. bulk copying files into the directory while the watcher is running.
                    if (timeout) {
                        clearTimeout(timeout);
                    }
                    timeout = setTimeout(resolveIfChanged, this._debounceMilliseconds);
                }
                catch (err) {
                    terminated = true;
                    reject(err);
                }
            };
            for (const pathToWatch of pathsToWatch) {
                addWatcher(pathToWatch, changeListener);
            }
            if (onWatchingFiles) {
                onWatchingFiles();
            }
        });
        const closePromises = [];
        for (const [watchedPath, watcher] of watchers) {
            closePromises.push((0, events_1.once)(watcher, 'close').then(() => {
                watchers.delete(watchedPath);
            }));
            watcher.close();
        }
        await Promise.all(closePromises);
        return watchedResult;
    }
    /**
     * Determines which, if any, projects (within the selection) have new hashes for files that are not in .gitignore
     */
    async _computeChanged() {
        const state = new ProjectChangeAnalyzer_1.ProjectChangeAnalyzer(this._rushConfiguration);
        const previousState = this._previousState;
        if (!previousState) {
            return {
                changedProjects: this._projectsToWatch,
                state
            };
        }
        const changedProjects = new Set();
        for (const project of this._projectsToWatch) {
            const { packageName } = project;
            if (ProjectWatcher._haveProjectDepsChanged((await previousState._tryGetProjectDependenciesAsync(packageName, this._terminal)), (await state._tryGetProjectDependenciesAsync(packageName, this._terminal)))) {
                // May need to detect if the nature of the change will break the process, e.g. changes to package.json
                changedProjects.add(project);
            }
        }
        return {
            changedProjects,
            state
        };
    }
    _commitChanges(state) {
        this._previousState = state;
        if (!this._initialState) {
            this._initialState = state;
        }
    }
    /**
     * Tests for inequality of the passed Maps. Order invariant.
     *
     * @returns `true` if the maps are different, `false` otherwise
     */
    static _haveProjectDepsChanged(prev, next) {
        if (prev.size !== next.size) {
            return true;
        }
        for (const [key, value] of prev) {
            if (next.get(key) !== value) {
                return true;
            }
        }
        return false;
    }
    static *_enumeratePathsToWatch(path, projectRelativeFolder, useNativeRecursiveWatch) {
        const rootSlashIndex = path.indexOf('/', projectRelativeFolder.length + 2);
        if (rootSlashIndex < 0) {
            yield path;
            return;
        }
        yield path.slice(0, rootSlashIndex);
        if (useNativeRecursiveWatch) {
            // Only need the root folder if fs.watch can be called with recursive: true
            return;
        }
        let slashIndex = path.lastIndexOf('/');
        while (slashIndex > rootSlashIndex) {
            yield path.slice(0, slashIndex);
            slashIndex = path.lastIndexOf('/', slashIndex - 1);
        }
    }
}
exports.ProjectWatcher = ProjectWatcher;
//# sourceMappingURL=ProjectWatcher.js.map

/***/ }),

/***/ 66953:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PublishGit = void 0;
const PublishUtilities_1 = __webpack_require__(16397);
const Utilities_1 = __webpack_require__(89521);
const DUMMY_BRANCH_NAME = '-branch-name-';
class PublishGit {
    constructor(git, targetBranch) {
        this._targetBranch = targetBranch;
        this._gitPath = git.getGitPathOrThrow();
        this._gitTagSeparator = git.getTagSeparator();
    }
    checkout(branchName, createBranch = false) {
        const params = ['checkout'];
        if (createBranch) {
            params.push('-b');
        }
        params.push(branchName || DUMMY_BRANCH_NAME);
        PublishUtilities_1.PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, params);
    }
    merge(branchName, verify = false) {
        PublishUtilities_1.PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, [
            'merge',
            branchName,
            '--no-edit',
            ...(verify ? [] : ['--no-verify'])
        ]);
    }
    deleteBranch(branchName, hasRemote = true, verify = false) {
        if (!branchName) {
            branchName = DUMMY_BRANCH_NAME;
        }
        PublishUtilities_1.PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, ['branch', '-d', branchName]);
        if (hasRemote) {
            PublishUtilities_1.PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, [
                'push',
                'origin',
                '--delete',
                branchName,
                ...(verify ? [] : ['--no-verify'])
            ]);
        }
    }
    pull(verify = false) {
        const params = ['pull', 'origin'];
        if (this._targetBranch) {
            params.push(this._targetBranch);
        }
        if (!verify) {
            params.push('--no-verify');
        }
        PublishUtilities_1.PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, params);
    }
    fetch() {
        PublishUtilities_1.PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, ['fetch', 'origin']);
    }
    addChanges(pathspec, workingDirectory) {
        const files = pathspec ? pathspec : '.';
        PublishUtilities_1.PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, ['add', files], workingDirectory ? workingDirectory : process.cwd());
    }
    addTag(shouldExecute, packageName, packageVersion, commitId) {
        // Tagging only happens if we're publishing to real NPM and committing to git.
        const tagName = PublishUtilities_1.PublishUtilities.createTagname(packageName, packageVersion, this._gitTagSeparator);
        PublishUtilities_1.PublishUtilities.execCommand(!!this._targetBranch && shouldExecute, this._gitPath, [
            'tag',
            '-a',
            tagName,
            '-m',
            `${packageName} v${packageVersion}`,
            ...(commitId ? [commitId] : [])
        ]);
    }
    hasTag(packageConfig) {
        const tagName = PublishUtilities_1.PublishUtilities.createTagname(packageConfig.packageName, packageConfig.packageJson.version, this._gitTagSeparator);
        const tagOutput = Utilities_1.Utilities.executeCommandAndCaptureOutput(this._gitPath, ['tag', '-l', tagName], packageConfig.projectFolder, PublishUtilities_1.PublishUtilities.getEnvArgs(), true).replace(/(\r\n|\n|\r)/gm, '');
        return tagOutput === tagName;
    }
    commit(commitMessage, verify = false) {
        PublishUtilities_1.PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, [
            'commit',
            '-m',
            commitMessage,
            ...(verify ? [] : ['--no-verify'])
        ]);
    }
    push(branchName, verify = false) {
        PublishUtilities_1.PublishUtilities.execCommand(!!this._targetBranch, this._gitPath, 
        // We append "--no-verify" to prevent Git hooks from running.  For example, people may
        // want to invoke "rush change -v" as a pre-push hook.
        [
            'push',
            'origin',
            `HEAD:${branchName || DUMMY_BRANCH_NAME}`,
            '--follow-tags',
            '--verbose',
            ...(verify ? [] : ['--no-verify'])
        ]);
    }
}
exports.PublishGit = PublishGit;
//# sourceMappingURL=PublishGit.js.map

/***/ }),

/***/ 16397:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PublishUtilities = void 0;
/**
 * This file contains a set of helper functions that are unit tested and used with the PublishAction,
 * which itself is a thin wrapper around these helpers.
 */
const os_1 = __webpack_require__(12087);
const path = __importStar(__webpack_require__(85622));
const semver = __importStar(__webpack_require__(11383));
const child_process_1 = __webpack_require__(63129);
const node_core_library_1 = __webpack_require__(24019);
const ChangeManagement_1 = __webpack_require__(6877);
const Utilities_1 = __webpack_require__(89521);
const DependencySpecifier_1 = __webpack_require__(179);
const Git_1 = __webpack_require__(58361);
class PublishUtilities {
    /**
     * Finds change requests in the given folder.
     * @param changesPath Path to the changes folder.
     * @returns Dictionary of all change requests, keyed by package name.
     */
    static findChangeRequests(allPackages, rushConfiguration, changeFiles, includeCommitDetails, prereleaseToken, projectsToExclude) {
        const allChanges = {};
        console.log(`Finding changes in: ${changeFiles.getChangesPath()}`);
        const files = changeFiles.getFiles();
        // Add the minimum changes defined by the change descriptions.
        files.forEach((fullPath) => {
            const changeRequest = node_core_library_1.JsonFile.load(fullPath);
            if (includeCommitDetails) {
                const git = new Git_1.Git(rushConfiguration);
                PublishUtilities._updateCommitDetails(git, fullPath, changeRequest.changes);
            }
            for (const change of changeRequest.changes) {
                PublishUtilities._addChange(change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude);
            }
        });
        // For each requested package change, ensure downstream dependencies are also updated.
        for (const packageName in allChanges) {
            if (allChanges.hasOwnProperty(packageName)) {
                PublishUtilities._updateDownstreamDependencies(allChanges[packageName], allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude);
            }
        }
        // Update orders so that downstreams are marked to come after upstreams.
        for (const packageName in allChanges) {
            if (allChanges.hasOwnProperty(packageName)) {
                const change = allChanges[packageName];
                const project = allPackages.get(packageName);
                const pkg = project.packageJson;
                const deps = project._consumingProjectNames;
                // Write the new version expected for the change.
                const skipVersionBump = PublishUtilities._shouldSkipVersionBump(project, prereleaseToken, projectsToExclude);
                if (skipVersionBump) {
                    change.newVersion = pkg.version;
                }
                else {
                    // For hotfix changes, do not re-write new version
                    change.newVersion =
                        change.changeType >= ChangeManagement_1.ChangeType.patch
                            ? semver.inc(pkg.version, PublishUtilities._getReleaseType(change.changeType))
                            : change.changeType === ChangeManagement_1.ChangeType.hotfix
                                ? change.newVersion
                                : pkg.version;
                }
                if (deps) {
                    for (const depName of deps) {
                        const depChange = allChanges[depName];
                        if (depChange) {
                            depChange.order = Math.max(change.order + 1, depChange.order);
                        }
                    }
                }
            }
        }
        return allChanges;
    }
    /**
     * Given the changes hash, flattens them into a sorted array based on their dependency order.
     * @params allChanges - hash of change requests.
     * @returns Sorted array of change requests.
     */
    static sortChangeRequests(allChanges) {
        return Object.keys(allChanges)
            .map((key) => allChanges[key])
            .sort((a, b) => a.order === b.order ? a.packageName.localeCompare(b.packageName) : a.order < b.order ? -1 : 1);
    }
    /**
     * Given a single change request, updates the package json file with updated versions on disk.
     */
    static updatePackages(allChanges, allPackages, rushConfiguration, shouldCommit, prereleaseToken, projectsToExclude) {
        const updatedPackages = new Map();
        Object.keys(allChanges).forEach((packageName) => {
            const updatedPackage = PublishUtilities._writePackageChanges(allChanges[packageName], allChanges, allPackages, rushConfiguration, shouldCommit, prereleaseToken, projectsToExclude);
            updatedPackages.set(updatedPackage.name, updatedPackage);
        });
        return updatedPackages;
    }
    /**
     * Returns the generated tagname to use for a published commit, given package name and version.
     */
    static createTagname(packageName, version, separator = Git_1.DEFAULT_GIT_TAG_SEPARATOR) {
        return packageName + `${separator}v` + version;
    }
    static isRangeDependency(version) {
        const LOOSE_PKG_REGEX = />=?(?:\d+\.){2}\d+(\-[0-9A-Za-z-.]*)?\s+<(?:\d+\.){2}\d+/;
        return LOOSE_PKG_REGEX.test(version);
    }
    static getEnvArgs() {
        const env = {};
        // Copy existing process.env values (for nodist)
        Object.keys(process.env).forEach((key) => {
            env[key] = process.env[key];
        });
        return env;
    }
    /**
     * @param secretSubstring -- if specified, a substring to be replaced by `<<SECRET>>` to avoid printing secrets
     * on the console
     */
    static execCommand(shouldExecute, command, args = [], workingDirectory = process.cwd(), environment, secretSubstring) {
        let relativeDirectory = path.relative(process.cwd(), workingDirectory);
        if (relativeDirectory) {
            relativeDirectory = `(${relativeDirectory})`;
        }
        let commandArgs = args.join(' ');
        if (secretSubstring && secretSubstring.length > 0) {
            // Avoid printing the NPM publish token on the console when displaying the commandArgs
            commandArgs = node_core_library_1.Text.replaceAll(commandArgs, secretSubstring, '<<SECRET>>');
        }
        console.log(`${os_1.EOL}* ${shouldExecute ? 'EXECUTING' : 'DRYRUN'}: ${command} ${commandArgs} ${relativeDirectory}`);
        if (shouldExecute) {
            Utilities_1.Utilities.executeCommand({
                command,
                args,
                workingDirectory,
                environment,
                suppressOutput: false,
                keepEnvironment: true
            });
        }
    }
    static getNewDependencyVersion(dependencies, dependencyName, newProjectVersion) {
        const currentDependencySpecifier = new DependencySpecifier_1.DependencySpecifier(dependencyName, dependencies[dependencyName]);
        const currentDependencyVersion = currentDependencySpecifier.versionSpecifier;
        let newDependencyVersion;
        if (currentDependencyVersion === '*') {
            newDependencyVersion = '*';
        }
        else if (PublishUtilities.isRangeDependency(currentDependencyVersion)) {
            newDependencyVersion = PublishUtilities._getNewRangeDependency(newProjectVersion);
        }
        else if (currentDependencyVersion.lastIndexOf('~', 0) === 0) {
            newDependencyVersion = '~' + newProjectVersion;
        }
        else if (currentDependencyVersion.lastIndexOf('^', 0) === 0) {
            newDependencyVersion = '^' + newProjectVersion;
        }
        else {
            newDependencyVersion = newProjectVersion;
        }
        return currentDependencySpecifier.specifierType === DependencySpecifier_1.DependencySpecifierType.Workspace
            ? `workspace:${newDependencyVersion}`
            : newDependencyVersion;
    }
    static _getReleaseType(changeType) {
        switch (changeType) {
            case ChangeManagement_1.ChangeType.major:
                return 'major';
            case ChangeManagement_1.ChangeType.minor:
                return 'minor';
            case ChangeManagement_1.ChangeType.patch:
                return 'patch';
            case ChangeManagement_1.ChangeType.hotfix:
                return 'prerelease';
            default:
                throw new Error(`Wrong change type ${changeType}`);
        }
    }
    static _getNewRangeDependency(newVersion) {
        let upperLimit = newVersion;
        if (semver.prerelease(newVersion)) {
            // Remove the prerelease first, then bump major.
            upperLimit = semver.inc(newVersion, 'patch');
        }
        upperLimit = semver.inc(upperLimit, 'major');
        return `>=${newVersion} <${upperLimit}`;
    }
    static _shouldSkipVersionBump(project, prereleaseToken, projectsToExclude) {
        // Suffix does not bump up the version.
        // Excluded projects do not bump up version.
        return ((prereleaseToken && prereleaseToken.isSuffix) ||
            (projectsToExclude && projectsToExclude.has(project.packageName)) ||
            !project.shouldPublish);
    }
    static _updateCommitDetails(git, filename, changes) {
        try {
            const gitPath = git.getGitPathOrThrow();
            const fileLog = (0, child_process_1.execSync)(`${gitPath} log -n 1 ${filename}`, {
                cwd: path.dirname(filename)
            }).toString();
            const author = fileLog.match(/Author: (.*)/)[1];
            const commit = fileLog.match(/commit (.*)/)[1];
            changes.forEach((change) => {
                change.author = author;
                change.commit = commit;
            });
        }
        catch (e) {
            /* no-op, best effort. */
        }
    }
    static _writePackageChanges(change, allChanges, allPackages, rushConfiguration, shouldCommit, prereleaseToken, projectsToExclude) {
        const project = allPackages.get(change.packageName);
        const pkg = project.packageJson;
        const shouldSkipVersionBump = !project.shouldPublish || (!!projectsToExclude && projectsToExclude.has(change.packageName));
        const newVersion = shouldSkipVersionBump
            ? pkg.version
            : PublishUtilities._getChangeInfoNewVersion(change, prereleaseToken);
        if (!shouldSkipVersionBump) {
            console.log(`${os_1.EOL}* ${shouldCommit ? 'APPLYING' : 'DRYRUN'}: ${ChangeManagement_1.ChangeType[change.changeType]} update ` +
                `for ${change.packageName} to ${newVersion}`);
        }
        else {
            console.log(`${os_1.EOL}* ${shouldCommit ? 'APPLYING' : 'DRYRUN'}: update for ${change.packageName} at ${newVersion}`);
        }
        const packagePath = path.join(project.projectFolder, "package.json" /* PackageJson */);
        pkg.version = newVersion;
        // Update the package's dependencies.
        PublishUtilities._updateDependencies(pkg.name, pkg.dependencies, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude);
        // Update the package's dev dependencies.
        PublishUtilities._updateDependencies(pkg.name, pkg.devDependencies, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude);
        // Update the package's peer dependencies.
        PublishUtilities._updateDependencies(pkg.name, pkg.peerDependencies, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude);
        change.changes.forEach((subChange) => {
            if (subChange.comment) {
                console.log(` - [${ChangeManagement_1.ChangeType[subChange.changeType]}] ${subChange.comment}`);
            }
        });
        if (shouldCommit) {
            node_core_library_1.JsonFile.save(pkg, packagePath, { updateExistingFile: true });
        }
        return pkg;
    }
    static _isCyclicDependency(allPackages, packageName, dependencyName) {
        const packageConfig = allPackages.get(packageName);
        return !!packageConfig && packageConfig.cyclicDependencyProjects.has(dependencyName);
    }
    static _updateDependencies(packageName, dependencies, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) {
        if (dependencies) {
            Object.keys(dependencies).forEach((depName) => {
                if (!PublishUtilities._isCyclicDependency(allPackages, packageName, depName)) {
                    const depChange = allChanges[depName];
                    if (!depChange) {
                        return;
                    }
                    const depProject = allPackages.get(depName);
                    if (!depProject.shouldPublish || (projectsToExclude && projectsToExclude.has(depName))) {
                        // No version change.
                        return;
                    }
                    else if (prereleaseToken &&
                        prereleaseToken.hasValue &&
                        prereleaseToken.isPartialPrerelease &&
                        depChange.changeType < ChangeManagement_1.ChangeType.hotfix) {
                        // For partial prereleases, do not version bump dependencies with the `prereleaseToken`
                        // value unless an actual change (hotfix, patch, minor, major) has occurred
                        return;
                    }
                    else if (depChange && prereleaseToken && prereleaseToken.hasValue) {
                        // TODO: treat prerelease version the same as non-prerelease version.
                        // For prerelease, the newVersion needs to be appended with prerelease name.
                        // And dependency should specify the specific prerelease version.
                        const currentSpecifier = new DependencySpecifier_1.DependencySpecifier(depName, dependencies[depName]);
                        const newVersion = PublishUtilities._getChangeInfoNewVersion(depChange, prereleaseToken);
                        dependencies[depName] =
                            currentSpecifier.specifierType === DependencySpecifier_1.DependencySpecifierType.Workspace
                                ? `workspace:${newVersion}`
                                : newVersion;
                    }
                    else if (depChange && depChange.changeType >= ChangeManagement_1.ChangeType.hotfix) {
                        PublishUtilities._updateDependencyVersion(packageName, dependencies, depName, depChange, allChanges, allPackages, rushConfiguration);
                    }
                }
            });
        }
    }
    /**
     * Gets the new version from the ChangeInfo.
     * The value of newVersion in ChangeInfo remains unchanged when the change type is dependency,
     * However, for pre-release build, it won't pick up the updated pre-released dependencies. That is why
     * this function should return a pre-released patch for that case. The exception to this is when we're
     * running a partial pre-release build. In this case, only user-changed packages should update.
     */
    static _getChangeInfoNewVersion(change, prereleaseToken) {
        let newVersion = change.newVersion;
        if (prereleaseToken && prereleaseToken.hasValue) {
            if (prereleaseToken.isPartialPrerelease && change.changeType <= ChangeManagement_1.ChangeType.hotfix) {
                return newVersion;
            }
            if (prereleaseToken.isPrerelease && change.changeType === ChangeManagement_1.ChangeType.dependency) {
                newVersion = semver.inc(newVersion, 'patch');
            }
            return `${newVersion}-${prereleaseToken.name}`;
        }
        else {
            return newVersion;
        }
    }
    /**
     * Adds the given change to the allChanges map.
     *
     * @returns true if the change caused the dependency change type to increase.
     */
    static _addChange(change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) {
        let hasChanged = false;
        const packageName = change.packageName;
        const project = allPackages.get(packageName);
        if (!project) {
            console.log(`The package ${packageName} was requested for publishing but does not exist. Skip this change.`);
            return false;
        }
        const pkg = project.packageJson;
        let currentChange;
        // If the given change does not have a changeType, derive it from the "type" string.
        if (change.changeType === undefined) {
            change.changeType = node_core_library_1.Enum.tryGetValueByKey(ChangeManagement_1.ChangeType, change.type);
        }
        if (!allChanges[packageName]) {
            hasChanged = true;
            currentChange = allChanges[packageName] = {
                packageName,
                changeType: change.changeType,
                order: 0,
                changes: [change]
            };
        }
        else {
            currentChange = allChanges[packageName];
            const oldChangeType = currentChange.changeType;
            if (oldChangeType === ChangeManagement_1.ChangeType.hotfix && change.changeType > oldChangeType) {
                throw new Error(`Cannot apply ${this._getReleaseType(change.changeType)} change after hotfix on same package`);
            }
            if (change.changeType === ChangeManagement_1.ChangeType.hotfix && oldChangeType > change.changeType) {
                throw new Error(`Cannot apply hotfix alongside ${this._getReleaseType(oldChangeType)} change on same package`);
            }
            currentChange.changeType = Math.max(currentChange.changeType, change.changeType);
            currentChange.changes.push(change);
            hasChanged = hasChanged || oldChangeType !== currentChange.changeType;
        }
        const skipVersionBump = PublishUtilities._shouldSkipVersionBump(project, prereleaseToken, projectsToExclude);
        if (skipVersionBump) {
            currentChange.newVersion = pkg.version;
            hasChanged = false;
            currentChange.changeType = ChangeManagement_1.ChangeType.none;
        }
        else {
            if (change.changeType === ChangeManagement_1.ChangeType.hotfix) {
                const prereleaseComponents = semver.prerelease(pkg.version);
                if (!rushConfiguration.hotfixChangeEnabled) {
                    throw new Error(`Cannot add hotfix change; hotfixChangeEnabled is false in configuration.`);
                }
                currentChange.newVersion = pkg.version;
                if (!prereleaseComponents) {
                    currentChange.newVersion += '-hotfix';
                }
                currentChange.newVersion = semver.inc(currentChange.newVersion, 'prerelease');
            }
            else {
                // When there are multiple changes of this package, the final value of new version
                // should not depend on the order of the changes.
                let packageVersion = pkg.version;
                if (currentChange.newVersion && semver.gt(currentChange.newVersion, pkg.version)) {
                    packageVersion = currentChange.newVersion;
                }
                currentChange.newVersion =
                    change.changeType >= ChangeManagement_1.ChangeType.patch
                        ? semver.inc(pkg.version, PublishUtilities._getReleaseType(currentChange.changeType))
                        : packageVersion;
            }
            // If hotfix change, force new range dependency to be the exact new version
            currentChange.newRangeDependency =
                change.changeType === ChangeManagement_1.ChangeType.hotfix
                    ? currentChange.newVersion
                    : PublishUtilities._getNewRangeDependency(currentChange.newVersion);
        }
        return hasChanged;
    }
    static _updateDownstreamDependencies(change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) {
        const packageName = change.packageName;
        const downstream = allPackages.get(packageName).consumingProjects;
        // Iterate through all downstream dependencies for the package.
        if (downstream) {
            if (change.changeType >= ChangeManagement_1.ChangeType.hotfix || (prereleaseToken && prereleaseToken.hasValue)) {
                for (const dependency of downstream) {
                    const pkg = dependency.packageJson;
                    PublishUtilities._updateDownstreamDependency(pkg.name, pkg.dependencies, change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude);
                    PublishUtilities._updateDownstreamDependency(pkg.name, pkg.devDependencies, change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude);
                }
            }
        }
    }
    static _updateDownstreamDependency(parentPackageName, dependencies, change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) {
        if (dependencies &&
            dependencies[change.packageName] &&
            !PublishUtilities._isCyclicDependency(allPackages, parentPackageName, change.packageName)) {
            const requiredVersion = new DependencySpecifier_1.DependencySpecifier(change.packageName, dependencies[change.packageName]);
            const isWorkspaceWildcardVersion = requiredVersion.specifierType === DependencySpecifier_1.DependencySpecifierType.Workspace &&
                requiredVersion.versionSpecifier === '*';
            const alwaysUpdate = (!!prereleaseToken && prereleaseToken.hasValue && !allChanges.hasOwnProperty(parentPackageName)) ||
                isWorkspaceWildcardVersion;
            // If the version range exists and has not yet been updated to this version, update it.
            if (requiredVersion.versionSpecifier !== change.newRangeDependency || alwaysUpdate) {
                let changeType;
                // Propagate hotfix changes to dependencies
                if (change.changeType === ChangeManagement_1.ChangeType.hotfix) {
                    changeType = ChangeManagement_1.ChangeType.hotfix;
                }
                else {
                    // Either it already satisfies the new version, or doesn't.
                    // If not, the downstream dep needs to be republished.
                    // The downstream dep will also need to be republished if using `workspace:*` as this will publish
                    // as the exact version.
                    changeType =
                        semver.satisfies(change.newVersion, requiredVersion.versionSpecifier) &&
                            !isWorkspaceWildcardVersion
                            ? ChangeManagement_1.ChangeType.dependency
                            : ChangeManagement_1.ChangeType.patch;
                }
                const hasChanged = PublishUtilities._addChange({
                    packageName: parentPackageName,
                    changeType
                }, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude);
                if (hasChanged || alwaysUpdate) {
                    // Only re-evaluate downstream dependencies if updating the parent package's dependency
                    // caused a version bump.
                    PublishUtilities._updateDownstreamDependencies(allChanges[parentPackageName], allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude);
                }
            }
        }
    }
    static _updateDependencyVersion(packageName, dependencies, dependencyName, dependencyChange, allChanges, allPackages, rushConfiguration) {
        let currentDependencyVersion = dependencies[dependencyName];
        let newDependencyVersion = PublishUtilities.getNewDependencyVersion(dependencies, dependencyName, dependencyChange.newVersion);
        dependencies[dependencyName] = newDependencyVersion;
        // "*" is a special case for workspace ranges, since it will publish using the exact
        // version of the local dependency, so we need to modify what we write for our change
        // comment
        const currentDependencySpecifier = new DependencySpecifier_1.DependencySpecifier(dependencyName, currentDependencyVersion);
        currentDependencyVersion =
            currentDependencySpecifier.specifierType === DependencySpecifier_1.DependencySpecifierType.Workspace &&
                currentDependencySpecifier.versionSpecifier === '*'
                ? undefined
                : currentDependencySpecifier.versionSpecifier;
        const newDependencySpecifier = new DependencySpecifier_1.DependencySpecifier(dependencyName, newDependencyVersion);
        newDependencyVersion =
            newDependencySpecifier.specifierType === DependencySpecifier_1.DependencySpecifierType.Workspace &&
                newDependencySpecifier.versionSpecifier === '*'
                ? dependencyChange.newVersion
                : newDependencySpecifier.versionSpecifier;
        // Add dependency version update comment.
        PublishUtilities._addChange({
            packageName: packageName,
            changeType: ChangeManagement_1.ChangeType.dependency,
            comment: `Updating dependency "${dependencyName}" ` +
                (currentDependencyVersion ? `from \`${currentDependencyVersion}\` ` : '') +
                `to \`${newDependencyVersion}\``
        }, allChanges, allPackages, rushConfiguration);
    }
}
exports.PublishUtilities = PublishUtilities;
//# sourceMappingURL=PublishUtilities.js.map

/***/ }),

/***/ 28805:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PurgeManager = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const path = __importStar(__webpack_require__(85622));
const AsyncRecycler_1 = __webpack_require__(94191);
const RushConstants_1 = __webpack_require__(63985);
/**
 * This class implements the logic for "rush purge"
 */
class PurgeManager {
    constructor(rushConfiguration, rushGlobalFolder) {
        this._rushConfiguration = rushConfiguration;
        this._rushGlobalFolder = rushGlobalFolder;
        const commonAsyncRecyclerPath = path.join(this._rushConfiguration.commonTempFolder, RushConstants_1.RushConstants.rushRecyclerFolderName);
        this._commonTempFolderRecycler = new AsyncRecycler_1.AsyncRecycler(commonAsyncRecyclerPath);
        const rushUserAsyncRecyclerPath = path.join(this._rushGlobalFolder.path, RushConstants_1.RushConstants.rushRecyclerFolderName);
        this._rushUserFolderRecycler = new AsyncRecycler_1.AsyncRecycler(rushUserAsyncRecyclerPath);
    }
    /**
     * Performs the AsyncRecycler.deleteAll() operation.  This should be called before
     * the PurgeManager instance is disposed.
     */
    deleteAll() {
        this._commonTempFolderRecycler.deleteAll();
        this._rushUserFolderRecycler.deleteAll();
    }
    get commonTempFolderRecycler() {
        return this._commonTempFolderRecycler;
    }
    /**
     * Delete everything from the common/temp folder
     */
    purgeNormal() {
        // Delete everything under common\temp except for the recycler folder itself
        console.log('Purging ' + this._rushConfiguration.commonTempFolder);
        this._commonTempFolderRecycler.moveAllItemsInFolder(this._rushConfiguration.commonTempFolder, this._getMembersToExclude(this._rushConfiguration.commonTempFolder, true));
    }
    /**
     * In addition to performing the purgeNormal() operation, this method also cleans the
     * .rush folder in the user's home directory.
     */
    purgeUnsafe() {
        this.purgeNormal();
        // We will delete everything under ~/.rush/ except for the recycler folder itself
        console.log('Purging ' + this._rushGlobalFolder.path);
        // If Rush itself is running under a folder such as  ~/.rush/node-v4.5.6/rush-1.2.3,
        // we cannot delete that folder.
        // First purge the node-specific folder, e.g. ~/.rush/node-v4.5.6/* except for rush-1.2.3:
        this._rushUserFolderRecycler.moveAllItemsInFolder(this._rushGlobalFolder.nodeSpecificPath, this._getMembersToExclude(this._rushGlobalFolder.nodeSpecificPath, true));
        // Then purge the the global folder, e.g. ~/.rush/* except for node-v4.5.6
        this._rushUserFolderRecycler.moveAllItemsInFolder(this._rushGlobalFolder.path, this._getMembersToExclude(this._rushGlobalFolder.path, false));
        if (this._rushConfiguration.packageManager === 'pnpm' &&
            this._rushConfiguration.pnpmOptions.pnpmStore === 'global' &&
            this._rushConfiguration.pnpmOptions.pnpmStorePath) {
            console.warn(safe_1.default.yellow(`Purging the global pnpm-store`));
            this._rushUserFolderRecycler.moveAllItemsInFolder(this._rushConfiguration.pnpmOptions.pnpmStorePath);
        }
    }
    _getMembersToExclude(folderToRecycle, showWarning) {
        // Don't recycle the recycler
        const membersToExclude = [RushConstants_1.RushConstants.rushRecyclerFolderName];
        // If the current process is running inside one of the folders, don't recycle that either
        // Example: "/home/user/.rush/rush-1.2.3/lib/example.js"
        const currentFolderPath = path.resolve(__dirname);
        // Example:
        // folderToRecycle = "/home/user/.rush/node-v4.5.6"
        // relative =  "rush-1.2.3/lib/example.js"
        const relative = path.relative(folderToRecycle, currentFolderPath);
        // (The result can be an absolute path if the two folders are on different drive letters)
        if (!path.isAbsolute(relative)) {
            // Get the first path segment:
            const firstPart = relative.split(/[\\\/]/)[0];
            if (firstPart.length > 0 && firstPart !== '..') {
                membersToExclude.push(firstPart);
                if (showWarning) {
                    // Warn that we won't dispose this folder
                    console.log(safe_1.default.yellow("The active process's folder will not be deleted: " + path.join(folderToRecycle, firstPart)));
                }
            }
        }
        return membersToExclude;
    }
}
exports.PurgeManager = PurgeManager;
//# sourceMappingURL=PurgeManager.js.map

/***/ }),

/***/ 67213:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RepoStateFile = void 0;
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const PnpmShrinkwrapFile_1 = __webpack_require__(32621);
/**
 * This file is used to track the state of various Rush-related features. It is generated
 * and updated by Rush.
 *
 * @public
 */
class RepoStateFile {
    constructor(repoStateJson, isValid, filePath, variant) {
        this._modified = false;
        this._repoStateFilePath = filePath;
        this._variant = variant;
        this._isValid = isValid;
        if (repoStateJson) {
            this._pnpmShrinkwrapHash = repoStateJson.pnpmShrinkwrapHash;
            this._preferredVersionsHash = repoStateJson.preferredVersionsHash;
        }
    }
    /**
     * Get the absolute file path of the repo-state.json file.
     */
    get filePath() {
        return this._repoStateFilePath;
    }
    /**
     * The hash of the pnpm shrinkwrap file at the end of the last update.
     */
    get pnpmShrinkwrapHash() {
        return this._pnpmShrinkwrapHash;
    }
    /**
     * The hash of all preferred versions at the end of the last update.
     */
    get preferredVersionsHash() {
        return this._preferredVersionsHash;
    }
    /**
     * If false, the repo-state.json file is not valid and its values cannot be relied upon
     */
    get isValid() {
        return this._isValid;
    }
    /**
     * Loads the repo-state.json data from the specified file path.
     * If the file has not been created yet, then an empty object is returned.
     *
     * @param jsonFilename - The path to the repo-state.json file.
     * @param variant - The variant currently being used by Rush.
     */
    static loadFromFile(jsonFilename, variant) {
        let fileContents;
        try {
            fileContents = node_core_library_1.FileSystem.readFile(jsonFilename);
        }
        catch (error) {
            if (!node_core_library_1.FileSystem.isNotExistError(error)) {
                throw error;
            }
        }
        let foundMergeConflictMarker = false;
        let repoStateJson = undefined;
        if (fileContents) {
            try {
                repoStateJson = node_core_library_1.JsonFile.parseString(fileContents);
            }
            catch (error) {
                // Look for a Git merge conflict marker. PNPM gracefully handles merge conflicts in pnpm-lock.yaml,
                // so a user should be able to just run "rush update" if they get conflicts in pnpm-lock.yaml
                // and repo-state.json and have Rush update both.
                for (let nextNewlineIndex = 0; nextNewlineIndex > -1; nextNewlineIndex = fileContents.indexOf('\n', nextNewlineIndex + 1)) {
                    if (fileContents.substr(nextNewlineIndex + 1, 7) === '<<<<<<<') {
                        foundMergeConflictMarker = true;
                        repoStateJson = {
                            preferredVersionsHash: 'INVALID',
                            pnpmShrinkwrapHash: 'INVALID'
                        };
                        break;
                    }
                }
            }
            if (repoStateJson) {
                this._jsonSchema.validateObject(repoStateJson, jsonFilename);
            }
        }
        return new RepoStateFile(repoStateJson, !foundMergeConflictMarker, jsonFilename, variant);
    }
    /**
     * Refresh the data contained in repo-state.json using the current state
     * of the Rush repo, and save the file if changes were made.
     *
     * @param rushConfiguration - The Rush configuration for the repo.
     *
     * @returns true if the file was modified, otherwise false.
     */
    refreshState(rushConfiguration) {
        // Only support saving the pnpm shrinkwrap hash if it was enabled
        const preventShrinkwrapChanges = rushConfiguration.packageManager === 'pnpm' &&
            rushConfiguration.pnpmOptions &&
            rushConfiguration.pnpmOptions.preventManualShrinkwrapChanges;
        if (preventShrinkwrapChanges) {
            const pnpmShrinkwrapFile = PnpmShrinkwrapFile_1.PnpmShrinkwrapFile.loadFromFile(rushConfiguration.getCommittedShrinkwrapFilename(this._variant), rushConfiguration.pnpmOptions);
            if (pnpmShrinkwrapFile) {
                const shrinkwrapFileHash = pnpmShrinkwrapFile.getShrinkwrapHash(rushConfiguration.experimentsConfiguration.configuration);
                if (this._pnpmShrinkwrapHash !== shrinkwrapFileHash) {
                    this._pnpmShrinkwrapHash = shrinkwrapFileHash;
                    this._modified = true;
                }
            }
        }
        else if (this._pnpmShrinkwrapHash !== undefined) {
            this._pnpmShrinkwrapHash = undefined;
            this._modified = true;
        }
        // Currently, only support saving the preferred versions hash if using workspaces
        const useWorkspaces = rushConfiguration.pnpmOptions && rushConfiguration.pnpmOptions.useWorkspaces;
        if (useWorkspaces) {
            const commonVersions = rushConfiguration.getCommonVersions(this._variant);
            const preferredVersionsHash = commonVersions.getPreferredVersionsHash();
            if (this._preferredVersionsHash !== preferredVersionsHash) {
                this._preferredVersionsHash = preferredVersionsHash;
                this._modified = true;
            }
        }
        else if (this._preferredVersionsHash !== undefined) {
            this._preferredVersionsHash = undefined;
            this._modified = true;
        }
        // Now that the file has been refreshed, we know its contents are valid
        this._isValid = true;
        return this._saveIfModified();
    }
    /**
     * Writes the "repo-state.json" file to disk, using the filename that was passed to loadFromFile().
     */
    _saveIfModified() {
        if (this._modified) {
            const content = '// DO NOT MODIFY THIS FILE MANUALLY BUT DO COMMIT IT. It is generated and used by Rush.' +
                `${"\n" /* Lf */}${this._serialize()}`;
            node_core_library_1.FileSystem.writeFile(this._repoStateFilePath, content);
            this._modified = false;
            return true;
        }
        return false;
    }
    _serialize() {
        // We need to set these one-by-one, since JsonFile.stringify does not like undefined values
        const repoStateJson = {};
        if (this._pnpmShrinkwrapHash) {
            repoStateJson.pnpmShrinkwrapHash = this._pnpmShrinkwrapHash;
        }
        if (this._preferredVersionsHash) {
            repoStateJson.preferredVersionsHash = this._preferredVersionsHash;
        }
        return node_core_library_1.JsonFile.stringify(repoStateJson, { newlineConversion: "\n" /* Lf */ });
    }
}
exports.RepoStateFile = RepoStateFile;
RepoStateFile._jsonSchema = node_core_library_1.JsonSchema.fromFile(path.join(__dirname, '../schemas/repo-state.schema.json'));
//# sourceMappingURL=RepoStateFile.js.map

/***/ }),

/***/ 63985:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RushConstants = void 0;
/**
 * Constants used by the Rush tool.
 *
 * @remarks
 *
 * These are NOT part of the public API surface for rush-lib.
 * The rationale is that we don't want people implementing custom parsers for
 * the Rush config files; instead, they should rely on the official APIs from rush-lib.
 */
class RushConstants {
}
exports.RushConstants = RushConstants;
/**
 * The filename ("browser-approved-packages.json") for an optional policy configuration file
 * that stores a list of NPM packages that have been approved for usage by Rush projects.
 * This is part of a pair of config files, one for projects that run in a web browser
 * (e.g. whose approval criteria mostly focuses on licensing and code size), and one for everywhere else
 * (e.g. tooling projects whose approval criteria mostly focuses on avoiding node_modules sprawl).
 */
RushConstants.browserApprovedPackagesFilename = 'browser-approved-packages.json';
/**
 * The folder name ("changes") where change files will be stored.
 */
RushConstants.changeFilesFolderName = 'changes';
/**
 * The filename ("nonbrowser-approved-packages.json") for an optional policy configuration file
 * that stores a list of NPM packages that have been approved for usage by Rush projects.
 * This is part of a pair of config files, one for projects that run in a web browser
 * (e.g. whose approval criteria mostly focuses on licensing and code size), and one for everywhere else
 * (e.g. tooling projects whose approval criteria mostly focuses on avoiding node_modules sprawl).
 */
RushConstants.nonbrowserApprovedPackagesFilename = 'nonbrowser-approved-packages.json';
/**
 * The folder name ("common") where Rush's common data will be stored.
 */
RushConstants.commonFolderName = 'common';
/**
 * The NPM scope ("@rush-temp") that is used for Rush's temporary projects.
 */
RushConstants.rushTempNpmScope = '@rush-temp';
/**
 * The folder name ("temp") under the common folder, or under the .rush folder in each project's directory where
 * temporary files will be stored.
 * Example: `C:\MyRepo\common\temp`
 */
RushConstants.rushTempFolderName = 'temp';
/**
 * The folder name ("projects") where temporary projects will be stored.
 * Example: `C:\MyRepo\common\temp\projects`
 */
RushConstants.rushTempProjectsFolderName = 'projects';
/**
 * The folder name ("variants") under which named variant configurations for
 * alternate dependency sets may be found.
 * Example: "C:\MyRepo\common\config\rush\variants"
 */
RushConstants.rushVariantsFolderName = 'variants';
/**
 * The filename ("npm-shrinkwrap.json") used to store an installation plan for the NPM package manger.
 */
RushConstants.npmShrinkwrapFilename = 'npm-shrinkwrap.json';
/**
 * Number of installation attempts
 */
RushConstants.defaultMaxInstallAttempts = 3;
/**
 * The filename ("pnpm-lock.yaml") used to store an installation plan for the PNPM package manger
 * (PNPM version 3.x and later).
 */
RushConstants.pnpmV3ShrinkwrapFilename = 'pnpm-lock.yaml';
/**
 * The filename ("pnpmfile.js") used to add custom configuration to PNPM (PNPM version 1.x and later).
 */
RushConstants.pnpmfileV1Filename = 'pnpmfile.js';
/**
 * The filename (".pnpmfile.cjs") used to add custom configuration to PNPM (PNPM version 6.x and later).
 */
RushConstants.pnpmfileV6Filename = '.pnpmfile.cjs';
/**
 * The filename ("shrinkwrap.yaml") used to store state for pnpm
 */
RushConstants.yarnShrinkwrapFilename = 'yarn.lock';
/**
 * The folder name ("node_modules") where NPM installs its packages.
 */
RushConstants.nodeModulesFolderName = 'node_modules';
/**
 * The filename ("pinned-versions.json") for an old configuration file that
 * that is no longer supported.
 *
 * @deprecated This feature has been superseded by the "preferredVersions" setting
 * in common-versions.json
 */
// NOTE: Although this is marked as "deprecated", we will probably never retire it,
// since we always want to report the warning when someone upgrades an old repo.
RushConstants.pinnedVersionsFilename = 'pinned-versions.json';
/**
 * The filename ("common-versions.json") for an optional configuration file
 * that stores dependency version information that affects all projects in the repo.
 * This configuration file should go in the "common/config/rush" folder.
 */
RushConstants.commonVersionsFilename = 'common-versions.json';
/**
 * The filename ("repo-state.json") for a file used by Rush to
 * store the state of various features as they stand in the repo.
 */
RushConstants.repoStateFilename = 'repo-state.json';
/**
 * The name of the per-project folder where project-specific Rush files are stored. For example,
 * the package-deps files, which are used by commands to determine if a particular project needs to be rebuilt.
 */
RushConstants.projectRushFolderName = '.rush';
/**
 * Custom command line configuration file, which is used by rush for implementing
 * custom command and options.
 */
RushConstants.commandLineFilename = 'command-line.json';
RushConstants.versionPoliciesFilename = 'version-policies.json';
/**
 * Experiments configuration file.
 */
RushConstants.experimentsFilename = 'experiments.json';
/**
 * The artifactory.json configuration file name.
 */
RushConstants.artifactoryFilename = 'artifactory.json';
/**
 * Build cache configuration file.
 */
RushConstants.buildCacheFilename = 'build-cache.json';
/**
 * Per-project configuration filename.
 */
RushConstants.rushProjectConfigFilename = 'rush-project.json';
/**
 * The URL ("http://rushjs.io") for the Rush web site.
 */
RushConstants.rushWebSiteUrl = 'https://rushjs.io';
/**
 * The name of the NPM package for the Rush tool ("@microsoft/rush").
 */
RushConstants.rushPackageName = '@microsoft/rush';
/**
 * The folder name ("rush-recycler") where Rush moves large folder trees
 * before asynchronously deleting them.
 */
RushConstants.rushRecyclerFolderName = 'rush-recycler';
/**
 * The name of the file to drop in project-folder/.rush/temp/ containing a listing of the project's direct
 * and indirect dependencies. This is used to detect if a project's dependencies have changed since the last build.
 */
RushConstants.projectShrinkwrapFilename = 'shrinkwrap-deps.json';
/**
 * The value of the "commandKind" property for a bulk command in command-line.json
 */
RushConstants.bulkCommandKind = 'bulk';
/**
 * The value of the "commandKind" property for a global command in command-line.json
 */
RushConstants.globalCommandKind = 'global';
/**
 * The value of the "commandKind" property for a phased command in command-line.json
 */
RushConstants.phasedCommandKind = 'phased';
/**
 * The name of the incremental build command.
 */
RushConstants.buildCommandName = 'build';
/**
 * The name of the non-incremental build command.
 */
RushConstants.rebuildCommandName = 'rebuild';
RushConstants.updateCloudCredentialsCommandName = 'update-cloud-credentials';
/**
 * When a hash generated that contains multiple input segments, this character may be used
 * to separate them to avoid issues like
 * crypto.createHash('sha1').update('a').update('bc').digest('hex') === crypto.createHash('sha1').update('ab').update('c').digest('hex')
 */
RushConstants.hashDelimiter = '|';
/**
 * The name of the per-user Rush configuration data folder.
 */
RushConstants.rushUserConfigurationFolderName = '.rush-user';
//# sourceMappingURL=RushConstants.js.map

/***/ }),

/***/ 13857:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Selection = void 0;
/**
 * This namespace contains functions for manipulating sets of projects
 */
class Selection {
    /**
     * Computes the intersection of two or more sets.
     */
    static intersection(first, ...rest) {
        return new Set(generateIntersection(first, ...rest));
    }
    /**
     * Computes the union of two or more sets.
     */
    static union(...sets) {
        return new Set(generateConcatenation(...sets));
    }
    /**
     * Computes a set that contains the input projects and all the direct and indirect dependencies thereof.
     */
    static expandAllDependencies(input) {
        return expandAll(input, expandDependenciesStep);
    }
    /**
     * Computes a set that contains the input projects and all projects that directly or indirectly depend on them.
     */
    static expandAllConsumers(input) {
        return expandAll(input, expandConsumers);
    }
    /**
     * Iterates the direct dependencies of the listed projects. May contain duplicates.
     */
    static *directDependenciesOf(input) {
        for (const item of input) {
            yield* item.dependencyProjects;
        }
    }
    /**
     * Iterates the projects that declare any of the listed projects as a dependency. May contain duplicates.
     */
    static *directConsumersOf(input) {
        for (const item of input) {
            yield* item.consumingProjects;
        }
    }
}
exports.Selection = Selection;
function* generateIntersection(first, ...rest) {
    for (const item of first) {
        if (rest.every((set) => set.has(item))) {
            yield item;
        }
    }
}
function* generateConcatenation(...sets) {
    for (const set of sets) {
        yield* set;
    }
}
/**
 * Adds all dependencies of the specified project to the target set.
 */
function expandDependenciesStep(project, targetSet) {
    for (const dep of project.dependencyProjects) {
        targetSet.add(dep);
    }
}
/**
 * Adds all projects that declare the specified project as a dependency to the target set.
 */
function expandConsumers(project, targetSet) {
    for (const dep of project.consumingProjects) {
        targetSet.add(dep);
    }
}
/**
 * Computes a set derived from the input by cloning it, then iterating over every member of the new set and
 * calling a step function that may add more elements to the set.
 */
function expandAll(input, expandStep) {
    const result = new Set(input);
    for (const item of result) {
        expandStep(item, result);
    }
    return result;
}
//# sourceMappingURL=Selection.js.map

/***/ }),

/***/ 96766:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetupChecks = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const path = __importStar(__webpack_require__(85622));
const semver = __importStar(__webpack_require__(11383));
const node_core_library_1 = __webpack_require__(24019);
const terminal_1 = __webpack_require__(11253);
const RushConstants_1 = __webpack_require__(63985);
// Refuses to run at all if the PNPM version is older than this, because there
// are known bugs or missing features in earlier releases.
const MINIMUM_SUPPORTED_NPM_VERSION = '4.5.0';
// Refuses to run at all if the PNPM version is older than this, because there
// are known bugs or missing features in earlier releases.
const MINIMUM_SUPPORTED_PNPM_VERSION = '5.0.0';
/**
 * Validate that the developer's setup is good.
 *
 * These checks are invoked prior to the following commands:
 * - rush install
 * - rush update
 * - rush build
 * - rush rebuild
 */
class SetupChecks {
    static validate(rushConfiguration) {
        // NOTE: The Node.js version is also checked in rush/src/start.ts
        const errorMessage = SetupChecks._validate(rushConfiguration);
        if (errorMessage) {
            console.error(safe_1.default.red(terminal_1.PrintUtilities.wrapWords(errorMessage)));
            throw new node_core_library_1.AlreadyReportedError();
        }
    }
    static _validate(rushConfiguration) {
        // Check for outdated tools
        if (rushConfiguration.packageManager === 'pnpm') {
            if (semver.lt(rushConfiguration.packageManagerToolVersion, MINIMUM_SUPPORTED_PNPM_VERSION)) {
                return (`The rush.json file requests PNPM version ` +
                    rushConfiguration.packageManagerToolVersion +
                    `, but PNPM ${MINIMUM_SUPPORTED_PNPM_VERSION} is the minimum supported by Rush.`);
            }
        }
        else if (rushConfiguration.packageManager === 'npm') {
            if (semver.lt(rushConfiguration.packageManagerToolVersion, MINIMUM_SUPPORTED_NPM_VERSION)) {
                return (`The rush.json file requests NPM version ` +
                    rushConfiguration.packageManagerToolVersion +
                    `, but NPM ${MINIMUM_SUPPORTED_NPM_VERSION} is the minimum supported by Rush.`);
            }
        }
        SetupChecks._checkForPhantomFolders(rushConfiguration);
    }
    static _checkForPhantomFolders(rushConfiguration) {
        const phantomFolders = [];
        const seenFolders = new Set();
        // Check from the real parent of the common/temp folder
        const commonTempParent = path.dirname(node_core_library_1.FileSystem.getRealPath(rushConfiguration.commonTempFolder));
        SetupChecks._collectPhantomFoldersUpwards(commonTempParent, phantomFolders, seenFolders);
        // Check from the real folder containing rush.json
        const realRushJsonFolder = node_core_library_1.FileSystem.getRealPath(rushConfiguration.rushJsonFolder);
        SetupChecks._collectPhantomFoldersUpwards(realRushJsonFolder, phantomFolders, seenFolders);
        if (phantomFolders.length > 0) {
            if (phantomFolders.length === 1) {
                console.log(safe_1.default.yellow(terminal_1.PrintUtilities.wrapWords('Warning: A phantom "node_modules" folder was found. This defeats Rush\'s protection against' +
                    ' NPM phantom dependencies and may cause confusing build errors. It is recommended to' +
                    ' delete this folder:')));
            }
            else {
                console.log(safe_1.default.yellow(terminal_1.PrintUtilities.wrapWords('Warning: Phantom "node_modules" folders were found. This defeats Rush\'s protection against' +
                    ' NPM phantom dependencies and may cause confusing build errors. It is recommended to' +
                    ' delete these folders:')));
            }
            for (const folder of phantomFolders) {
                console.log(safe_1.default.yellow(`"${folder}"`));
            }
            console.log(); // add a newline
        }
    }
    /**
     * Checks "folder" and each of its parents to see if it contains a node_modules folder.
     * The bad folders will be added to phantomFolders.
     * The seenFolders set is used to avoid duplicates.
     */
    static _collectPhantomFoldersUpwards(folder, phantomFolders, seenFolders) {
        // Stop if we reached a folder that we already analyzed
        while (!seenFolders.has(folder)) {
            seenFolders.add(folder);
            // If there is a node_modules folder under this folder, add it to the list of bad folders
            const nodeModulesFolder = path.join(folder, RushConstants_1.RushConstants.nodeModulesFolderName);
            if (node_core_library_1.FileSystem.exists(nodeModulesFolder)) {
                // Collect the names of files/folders in that node_modules folder
                const filenames = node_core_library_1.FileSystem.readFolder(nodeModulesFolder).filter((x) => !x.startsWith('.'));
                let ignore = false;
                if (filenames.length === 0) {
                    // If the node_modules folder is completely empty, then it's not a concern
                    ignore = true;
                }
                else if (filenames.length === 1 && filenames[0] === 'vso-task-lib') {
                    // Special case:  The Azure DevOps build agent installs the "vso-task-lib" NPM package
                    // in a top-level path such as:
                    //
                    //   /home/vsts/work/node_modules/vso-task-lib
                    //
                    // It is always the only package in that node_modules folder.  The "vso-task-lib" package
                    // is now deprecated, so it is unlikely to be a real dependency of any modern project.
                    // To avoid false alarms, we ignore this specific case.
                    ignore = true;
                }
                if (!ignore) {
                    phantomFolders.push(nodeModulesFolder);
                }
            }
            // Walk upwards
            const parentFolder = path.dirname(folder);
            if (!parentFolder || parentFolder === folder) {
                // If path.dirname() returns its own input, then means we reached the root
                break;
            }
            folder = parentFolder;
        }
    }
}
exports.SetupChecks = SetupChecks;
//# sourceMappingURL=SetupChecks.js.map

/***/ }),

/***/ 94237:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShrinkwrapFileFactory = void 0;
const NpmShrinkwrapFile_1 = __webpack_require__(71068);
const PnpmShrinkwrapFile_1 = __webpack_require__(32621);
const YarnShrinkwrapFile_1 = __webpack_require__(86054);
class ShrinkwrapFileFactory {
    static getShrinkwrapFile(packageManager, packageManagerOptions, shrinkwrapFilename) {
        switch (packageManager) {
            case 'npm':
                return NpmShrinkwrapFile_1.NpmShrinkwrapFile.loadFromFile(shrinkwrapFilename);
            case 'pnpm':
                return PnpmShrinkwrapFile_1.PnpmShrinkwrapFile.loadFromFile(shrinkwrapFilename, packageManagerOptions);
            case 'yarn':
                return YarnShrinkwrapFile_1.YarnShrinkwrapFile.loadFromFile(shrinkwrapFilename);
            default:
                throw new Error(`Invalid package manager: ${packageManager}`);
        }
    }
}
exports.ShrinkwrapFileFactory = ShrinkwrapFileFactory;
//# sourceMappingURL=ShrinkwrapFileFactory.js.map

/***/ }),

/***/ 18821:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StandardScriptUpdater = void 0;
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
/**
 * Checks whether the common/scripts files are up to date, and recopies them if needed.
 * This is used by the "rush install" and "rush update" commands.
 */
class StandardScriptUpdater {
    /**
     * Recopy the scripts if the scripts are out of date.
     * Used by "rush update".
     */
    static update(rushConfiguration) {
        let anyChanges = false;
        for (const scriptName of StandardScriptUpdater._scriptNames) {
            if (StandardScriptUpdater._updateScriptOrThrow(scriptName, rushConfiguration, false)) {
                anyChanges = true;
            }
        }
        if (anyChanges) {
            console.log(); // print a newline after the notices
        }
        return anyChanges;
    }
    /**
     * Throw an exception if the scripts are out of date.
     * Used by "rush install".
     */
    static validate(rushConfiguration) {
        for (const scriptName of StandardScriptUpdater._scriptNames) {
            StandardScriptUpdater._updateScriptOrThrow(scriptName, rushConfiguration, true);
        }
    }
    /**
     * Compares a single script in the common/script folder to see if it needs to be updated.
     * If throwInsteadOfCopy=false, then an outdated or missing script will be recopied;
     * otherwise, an exception is thrown.
     */
    static _updateScriptOrThrow(scriptName, rushConfiguration, throwInsteadOfCopy) {
        const targetFilePath = path.join(rushConfiguration.commonScriptsFolder, scriptName);
        const sourceFilePath = path.resolve(__dirname, '../scripts', scriptName);
        node_core_library_1.FileSystem.ensureFolder(rushConfiguration.commonScriptsFolder);
        // Are the files the same?
        let filesAreSame = false;
        if (node_core_library_1.FileSystem.exists(targetFilePath)) {
            const sourceContent = node_core_library_1.FileSystem.readFile(sourceFilePath);
            const targetContent = node_core_library_1.FileSystem.readFile(targetFilePath);
            const sourceNormalized = StandardScriptUpdater._normalize(sourceContent);
            const targetNormalized = StandardScriptUpdater._normalize(targetContent);
            if (sourceNormalized === targetNormalized) {
                filesAreSame = true;
            }
        }
        if (!filesAreSame) {
            if (throwInsteadOfCopy) {
                throw new Error('The standard files in the "common/scripts" folders need to be updated' +
                    ' for this Rush version.  Please run "rush update" and commit the changes.');
            }
            else {
                console.log(`Script is out of date; updating "${targetFilePath}"`);
                node_core_library_1.FileSystem.copyFile({
                    sourcePath: sourceFilePath,
                    destinationPath: targetFilePath
                });
            }
        }
        return !filesAreSame;
    }
    static _normalize(content) {
        // Ignore newline differences from .gitattributes
        return (node_core_library_1.Text.convertToLf(content)
            // Ignore trailing whitespace
            .split('\n')
            .map((x) => x.trimRight())
            .join('\n'));
    }
}
exports.StandardScriptUpdater = StandardScriptUpdater;
StandardScriptUpdater._scriptNames = [
    'install-run.js',
    'install-run-rush.js',
    'install-run-rushx.js'
];
//# sourceMappingURL=StandardScriptUpdater.js.map

/***/ }),

/***/ 84153:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskSelector = void 0;
const ProjectBuilder_1 = __webpack_require__(57081);
const ProjectChangeAnalyzer_1 = __webpack_require__(15504);
const TaskCollection_1 = __webpack_require__(2683);
/**
 * This class is responsible for:
 *  - based on to/from flags, solving the dependency graph and figuring out which projects need to be run
 *  - creating a ProjectBuilder for each project that needs to be built
 *  - registering the necessary ProjectBuilders with the TaskRunner, which actually orchestrates execution
 */
class TaskSelector {
    constructor(options) {
        this._options = options;
        const { projectChangeAnalyzer = new ProjectChangeAnalyzer_1.ProjectChangeAnalyzer(options.rushConfiguration) } = options;
        this._projectChangeAnalyzer = projectChangeAnalyzer;
    }
    static getScriptToRun(rushProject, commandToRun, customParameterValues) {
        const script = TaskSelector._getScriptCommand(rushProject, commandToRun);
        if (script === undefined) {
            return undefined;
        }
        if (!script) {
            return '';
        }
        else {
            const taskCommand = `${script} ${customParameterValues.join(' ')}`;
            return process.platform === 'win32' ? (0, ProjectBuilder_1.convertSlashesForWindows)(taskCommand) : taskCommand;
        }
    }
    registerTasks() {
        const projects = this._options.selection;
        const taskCollection = new TaskCollection_1.TaskCollection();
        // Register all tasks
        for (const rushProject of projects) {
            this._registerTask(rushProject, taskCollection);
        }
        if (!this._options.ignoreDependencyOrder) {
            const dependencyMap = new Map();
            // Generate the filtered dependency graph for selected projects
            function getDependencyTaskNames(project) {
                const cached = dependencyMap.get(project);
                if (cached) {
                    return cached;
                }
                const dependencyTaskNames = new Set();
                dependencyMap.set(project, dependencyTaskNames);
                for (const dep of project.dependencyProjects) {
                    if (projects.has(dep)) {
                        // Add direct relationships for projects in the set
                        dependencyTaskNames.add(ProjectBuilder_1.ProjectBuilder.getTaskName(dep));
                    }
                    else {
                        // Add indirect relationships for projects not in the set
                        for (const indirectDep of getDependencyTaskNames(dep)) {
                            dependencyTaskNames.add(indirectDep);
                        }
                    }
                }
                return dependencyTaskNames;
            }
            // Add ordering relationships for each dependency
            for (const project of projects) {
                taskCollection.addDependencies(ProjectBuilder_1.ProjectBuilder.getTaskName(project), getDependencyTaskNames(project));
            }
        }
        return taskCollection;
    }
    _registerTask(project, taskCollection) {
        if (!project || taskCollection.hasTask(ProjectBuilder_1.ProjectBuilder.getTaskName(project))) {
            return;
        }
        const commandToRun = TaskSelector.getScriptToRun(project, this._options.commandToRun, this._options.customParameterValues);
        if (commandToRun === undefined && !this._options.ignoreMissingScript) {
            throw new Error(`The project [${project.packageName}] does not define a '${this._options.commandToRun}' command in the 'scripts' section of its package.json`);
        }
        taskCollection.addTask(new ProjectBuilder_1.ProjectBuilder({
            rushProject: project,
            rushConfiguration: this._options.rushConfiguration,
            buildCacheConfiguration: this._options.buildCacheConfiguration,
            commandToRun: commandToRun || '',
            commandName: this._options.commandName,
            isIncrementalBuildAllowed: this._options.isIncrementalBuildAllowed,
            projectChangeAnalyzer: this._projectChangeAnalyzer,
            packageDepsFilename: this._options.packageDepsFilename,
            allowWarningsInSuccessfulBuild: this._options.allowWarningsInSuccessfulBuild
        }));
    }
    static _getScriptCommand(rushProject, script) {
        if (!rushProject.packageJson.scripts) {
            return undefined;
        }
        const rawCommand = rushProject.packageJson.scripts[script];
        if (rawCommand === undefined || rawCommand === null) {
            return undefined;
        }
        return rawCommand;
    }
}
exports.TaskSelector = TaskSelector;
//# sourceMappingURL=TaskSelector.js.map

/***/ }),

/***/ 48375:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Telemetry = void 0;
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const Rush_1 = __webpack_require__(4876);
const lodash = node_core_library_1.Import.lazy('lodash', require);
const MAX_FILE_COUNT = 100;
class Telemetry {
    constructor(rushConfiguration) {
        this._rushConfiguration = rushConfiguration;
        this._enabled = this._rushConfiguration.telemetryEnabled;
        this._store = [];
        const folderName = 'telemetry';
        this._dataFolder = path.join(this._rushConfiguration.commonTempFolder, folderName);
    }
    log(telemetryData) {
        if (!this._enabled) {
            return;
        }
        const data = lodash.cloneDeep(telemetryData);
        data.timestamp = data.timestamp || new Date().getTime();
        data.platform = data.platform || process.platform;
        data.rushVersion = data.rushVersion || Rush_1.Rush.version;
        this._store.push(data);
    }
    flush(writeFile = node_core_library_1.FileSystem.writeFile) {
        if (!this._enabled || this._store.length === 0) {
            return;
        }
        const fullPath = this._getFilePath();
        node_core_library_1.FileSystem.ensureFolder(this._dataFolder);
        writeFile(fullPath, JSON.stringify(this._store));
        this._store = [];
        this._cleanUp();
    }
    get store() {
        return this._store;
    }
    /**
     * When there are too many log files, delete the old ones.
     */
    _cleanUp() {
        if (node_core_library_1.FileSystem.exists(this._dataFolder)) {
            const files = node_core_library_1.FileSystem.readFolder(this._dataFolder);
            if (files.length > MAX_FILE_COUNT) {
                const sortedFiles = files
                    .map((fileName) => {
                    const filePath = path.join(this._dataFolder, fileName);
                    const stats = node_core_library_1.FileSystem.getStatistics(filePath);
                    return {
                        filePath: filePath,
                        modifiedTime: stats.mtime.getTime(),
                        isFile: stats.isFile()
                    };
                })
                    .filter((value) => {
                    // Only delete files
                    return value.isFile;
                })
                    .sort((a, b) => {
                    return a.modifiedTime - b.modifiedTime;
                })
                    .map((s) => {
                    return s.filePath;
                });
                const filesToDelete = sortedFiles.length - MAX_FILE_COUNT;
                for (let i = 0; i < filesToDelete; i++) {
                    node_core_library_1.FileSystem.deleteFile(sortedFiles[i]);
                }
            }
        }
    }
    _getFilePath() {
        let fileName = `telemetry_${new Date().toISOString()}`;
        fileName = fileName.replace(/[\-\:\.]/g, '_') + '.json';
        return path.join(this._dataFolder, fileName);
    }
}
exports.Telemetry = Telemetry;
//# sourceMappingURL=Telemetry.js.map

/***/ }),

/***/ 1984:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnlinkManager = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const Utilities_1 = __webpack_require__(89521);
const BaseProjectShrinkwrapFile_1 = __webpack_require__(30052);
const LastLinkFlag_1 = __webpack_require__(10508);
/**
 * This class implements the logic for "rush unlink"
 */
class UnlinkManager {
    constructor(rushConfiguration) {
        this._rushConfiguration = rushConfiguration;
    }
    /**
     * Delete flag file and all the existing node_modules symlinks and all
     * project/.rush/temp/shrinkwrap-deps.json files
     *
     * Returns true if anything was deleted.
     */
    unlink(force = false) {
        const useWorkspaces = this._rushConfiguration.pnpmOptions && this._rushConfiguration.pnpmOptions.useWorkspaces;
        if (!force && useWorkspaces) {
            console.log(safe_1.default.red('Unlinking is not supported when using workspaces. Run "rush purge" to remove ' +
                'project node_modules folders.'));
            throw new node_core_library_1.AlreadyReportedError();
        }
        LastLinkFlag_1.LastLinkFlagFactory.getCommonTempFlag(this._rushConfiguration).clear();
        return this._deleteProjectFiles();
    }
    /**
     * Delete:
     *  - all the node_modules symlinks of configured Rush projects
     *  - all of the project/.rush/temp/shrinkwrap-deps.json files of configured Rush projects
     *
     * Returns true if anything was deleted
     * */
    _deleteProjectFiles() {
        let didDeleteAnything = false;
        for (const rushProject of this._rushConfiguration.projects) {
            const localModuleFolder = path.join(rushProject.projectFolder, 'node_modules');
            if (node_core_library_1.FileSystem.exists(localModuleFolder)) {
                console.log(`Purging ${localModuleFolder}`);
                Utilities_1.Utilities.dangerouslyDeletePath(localModuleFolder);
                didDeleteAnything = true;
            }
            const projectShrinkwrapFilePath = BaseProjectShrinkwrapFile_1.BaseProjectShrinkwrapFile.getFilePathForProject(rushProject);
            if (node_core_library_1.FileSystem.exists(projectShrinkwrapFilePath)) {
                console.log(`Deleting ${projectShrinkwrapFilePath}`);
                node_core_library_1.FileSystem.deleteFile(projectShrinkwrapFilePath);
                didDeleteAnything = true;
            }
        }
        return didDeleteAnything;
    }
}
exports.UnlinkManager = UnlinkManager;
//# sourceMappingURL=UnlinkManager.js.map

/***/ }),

/***/ 30052:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseProjectShrinkwrapFile = void 0;
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const RushConstants_1 = __webpack_require__(63985);
/**
 * This class handles creating the project/.rush/temp/shrinkwrap-deps.json file
 * which tracks the direct and indirect dependencies that a project consumes. This is used
 * to better determine which projects should be rebuilt when dependencies are updated.
 */
class BaseProjectShrinkwrapFile {
    constructor(shrinkwrapFile, project) {
        this.project = project;
        this.projectShrinkwrapFilePath = BaseProjectShrinkwrapFile.getFilePathForProject(this.project);
        this._shrinkwrapFile = shrinkwrapFile;
    }
    /**
     * Get the fully-qualified path to the <project>/.rush/temp/shrinkwrap-deps.json
     * for the specified project.
     */
    static getFilePathForProject(project) {
        return path.join(project.projectRushTempFolder, RushConstants_1.RushConstants.projectShrinkwrapFilename);
    }
    /**
     * If the <project>/.rush/temp/shrinkwrap-deps.json file exists, delete it. Otherwise, do nothing.
     */
    async deleteIfExistsAsync() {
        await node_core_library_1.FileSystem.deleteFileAsync(this.projectShrinkwrapFilePath, { throwIfNotExists: false });
    }
    /**
     * The shrinkwrap file that the project shrinkwrap file is based off of.
     */
    get shrinkwrapFile() {
        return this._shrinkwrapFile;
    }
}
exports.BaseProjectShrinkwrapFile = BaseProjectShrinkwrapFile;
//# sourceMappingURL=BaseProjectShrinkwrapFile.js.map

/***/ }),

/***/ 74926:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseShrinkwrapFile = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const semver = __importStar(__webpack_require__(11383));
const RushConstants_1 = __webpack_require__(63985);
const DependencySpecifier_1 = __webpack_require__(179);
const PackageNameParsers_1 = __webpack_require__(39458);
/**
 * This class is a parser for both npm's npm-shrinkwrap.json and pnpm's pnpm-lock.yaml file formats.
 */
class BaseShrinkwrapFile {
    constructor() {
        this._alreadyWarnedSpecs = new Set();
    }
    static tryGetValue(dictionary, key) {
        if (dictionary.hasOwnProperty(key)) {
            return dictionary[key];
        }
        return undefined;
    }
    /**
     * Validate the shrinkwrap using the provided policy options.
     *
     * @virtual
     */
    validate(packageManagerOptionsConfig, policyOptions, experimentsConfig) { }
    /**
     * Returns true if the shrinkwrap file includes a top-level package that would satisfy the specified
     * package name and SemVer version range
     *
     * @virtual
     */
    hasCompatibleTopLevelDependency(dependencySpecifier) {
        const shrinkwrapDependency = this.getTopLevelDependencyVersion(dependencySpecifier.packageName);
        if (!shrinkwrapDependency) {
            return false;
        }
        return this._checkDependencyVersion(dependencySpecifier, shrinkwrapDependency);
    }
    /**
     * Returns true if the shrinkwrap file includes a package that would satisfying the specified
     * package name and SemVer version range.  By default, the dependencies are resolved by looking
     * at the root of the node_modules folder described by the shrinkwrap file.  However, if
     * tempProjectName is specified, then the resolution will start in that subfolder.
     *
     * Consider this example:
     *
     * - node_modules\
     *   - temp-project\
     *     - lib-a@1.2.3
     *     - lib-b@1.0.0
     *   - lib-b@2.0.0
     *
     * In this example, hasCompatibleDependency("lib-b", ">= 1.1.0", "temp-project") would fail
     * because it finds lib-b@1.0.0 which does not satisfy the pattern ">= 1.1.0".
     *
     * @virtual
     */
    tryEnsureCompatibleDependency(dependencySpecifier, tempProjectName) {
        const shrinkwrapDependency = this.tryEnsureDependencyVersion(dependencySpecifier, tempProjectName);
        if (!shrinkwrapDependency) {
            return false;
        }
        return this._checkDependencyVersion(dependencySpecifier, shrinkwrapDependency);
    }
    /**
     * Check for projects that exist in the shrinkwrap file, but don't exist
     * in rush.json.  This might occur, e.g. if a project was recently deleted or renamed.
     *
     * @returns a list of orphaned projects.
     */
    findOrphanedProjects(rushConfiguration) {
        const orphanedProjectNames = [];
        // We can recognize temp projects because they are under the "@rush-temp" NPM scope.
        for (const tempProjectName of this.getTempProjectNames()) {
            if (!rushConfiguration.findProjectByTempName(tempProjectName)) {
                orphanedProjectNames.push(tempProjectName);
            }
        }
        return orphanedProjectNames;
    }
    _getTempProjectNames(dependencies) {
        const result = [];
        for (const key of Object.keys(dependencies)) {
            // If it starts with @rush-temp, then include it:
            if (PackageNameParsers_1.PackageNameParsers.permissive.getScope(key) === RushConstants_1.RushConstants.rushTempNpmScope) {
                result.push(key);
            }
        }
        result.sort(); // make the result deterministic
        return result;
    }
    _checkDependencyVersion(projectDependency, shrinkwrapDependency) {
        let normalizedProjectDependency = projectDependency;
        let normalizedShrinkwrapDependency = shrinkwrapDependency;
        // Special handling for NPM package aliases such as this:
        //
        // "dependencies": {
        //   "alias-name": "npm:target-name@^1.2.3"
        // }
        //
        // In this case, the shrinkwrap file will have a key equivalent to "npm:target-name@1.2.5",
        // and so we need to unwrap the target and compare "1.2.5" with "^1.2.3".
        if (projectDependency.specifierType === DependencySpecifier_1.DependencySpecifierType.Alias) {
            // Does the shrinkwrap install it as an alias?
            if (shrinkwrapDependency.specifierType === DependencySpecifier_1.DependencySpecifierType.Alias) {
                // Does the shrinkwrap have the right package name?
                if (projectDependency.packageName === shrinkwrapDependency.packageName) {
                    // Yes, the aliases match, so let's compare their targets in the logic below
                    normalizedProjectDependency = projectDependency.aliasTarget;
                    normalizedShrinkwrapDependency = shrinkwrapDependency.aliasTarget;
                }
                else {
                    // If the names are different, then it's a mismatch
                    return false;
                }
            }
            else {
                // A non-alias cannot satisfy an alias dependency; at least, let's avoid that idea
                return false;
            }
        }
        switch (normalizedProjectDependency.specifierType) {
            case DependencySpecifier_1.DependencySpecifierType.Version:
            case DependencySpecifier_1.DependencySpecifierType.Range:
                return semver.satisfies(normalizedShrinkwrapDependency.versionSpecifier, normalizedProjectDependency.versionSpecifier);
            default:
                // For other version specifier types like "file:./blah.tgz" or "git://github.com/npm/cli.git#v1.0.27"
                // we allow the installation to continue but issue a warning.  The "rush install" checks will not work
                // correctly.
                // Only warn once for each versionSpecifier
                if (!this._alreadyWarnedSpecs.has(projectDependency.versionSpecifier)) {
                    this._alreadyWarnedSpecs.add(projectDependency.versionSpecifier);
                    console.log(safe_1.default.yellow(`WARNING: Not validating ${projectDependency.specifierType}-based` +
                        ` specifier: "${projectDependency.versionSpecifier}"`));
                }
                return true;
        }
    }
}
exports.BaseShrinkwrapFile = BaseShrinkwrapFile;
//# sourceMappingURL=BaseShrinkwrapFile.js.map

/***/ }),

/***/ 97939:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CacheEntryId = void 0;
const OPTIONS_ARGUMENT_NAME = 'options';
const HASH_TOKEN_NAME = 'hash';
const PROJECT_NAME_TOKEN_NAME = 'projectName';
// This regex matches substrings that look like [token]
const TOKEN_REGEX = /\[[^\]]*\]/g;
class CacheEntryId {
    constructor() { }
    static parsePattern(pattern) {
        if (!pattern) {
            return ({ projectStateHash }) => projectStateHash;
        }
        else {
            pattern = pattern.trim();
            if (pattern.startsWith('/')) {
                throw new Error('Cache entry name patterns may not start with a slash.');
            }
            const patternWithoutTokens = pattern.replace(TOKEN_REGEX, '');
            if (patternWithoutTokens.match(/\]/)) {
                throw new Error(`Unexpected "]" character in cache entry name pattern.`);
            }
            if (patternWithoutTokens.match(/\[/)) {
                throw new Error('Unclosed token in cache entry name pattern.');
            }
            if (!patternWithoutTokens.match(/^[A-z0-9-_\/]*$/)) {
                throw new Error('Cache entry name pattern contains an invalid character. ' +
                    'Only alphanumeric characters, slashes, underscores, and hyphens are allowed.');
            }
            let foundHashToken = false;
            const templateString = pattern.trim().replace(TOKEN_REGEX, (token) => {
                token = token.substring(1, token.length - 1);
                let tokenName;
                let tokenAttribute;
                const tokenSplitIndex = token.indexOf(':');
                if (tokenSplitIndex === -1) {
                    tokenName = token;
                }
                else {
                    tokenName = token.substr(0, tokenSplitIndex);
                    tokenAttribute = token.substr(tokenSplitIndex + 1);
                }
                switch (tokenName) {
                    case HASH_TOKEN_NAME: {
                        if (tokenAttribute !== undefined) {
                            throw new Error(`An attribute isn\'t supported for the "${tokenName}" token.`);
                        }
                        foundHashToken = true;
                        return `\${${OPTIONS_ARGUMENT_NAME}.projectStateHash}`;
                    }
                    case PROJECT_NAME_TOKEN_NAME: {
                        switch (tokenAttribute) {
                            case undefined: {
                                return `\${${OPTIONS_ARGUMENT_NAME}.projectName}`;
                            }
                            case 'normalize': {
                                return `\${${OPTIONS_ARGUMENT_NAME}.projectName.replace(/\\+/g, '++').replace(/\\/\/g, '+')}`;
                            }
                            default: {
                                throw new Error(`Unexpected attribute "${tokenAttribute}" for the "${tokenName}" token.`);
                            }
                        }
                    }
                    default: {
                        throw new Error(`Unexpected token name "${tokenName}".`);
                    }
                }
            });
            if (!foundHashToken) {
                throw new Error(`Cache entry name pattern is missing a [${HASH_TOKEN_NAME}] token.`);
            }
            // eslint-disable-next-line no-new-func
            return new Function(OPTIONS_ARGUMENT_NAME, `"use strict"\nreturn \`${templateString}\`;`);
        }
    }
}
exports.CacheEntryId = CacheEntryId;
//# sourceMappingURL=CacheEntryId.js.map

/***/ }),

/***/ 76964:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileSystemBuildCacheProvider = void 0;
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const DEFAULT_BUILD_CACHE_FOLDER_NAME = 'build-cache';
class FileSystemBuildCacheProvider {
    constructor(options) {
        this._cacheFolderPath =
            options.rushUserConfiguration.buildCacheFolder ||
                path.join(options.rushConfiguration.commonTempFolder, DEFAULT_BUILD_CACHE_FOLDER_NAME);
    }
    getCacheEntryPath(cacheId) {
        return path.join(this._cacheFolderPath, cacheId);
    }
    async tryGetCacheEntryPathByIdAsync(terminal, cacheId) {
        const cacheEntryFilePath = this.getCacheEntryPath(cacheId);
        if (await node_core_library_1.FileSystem.existsAsync(cacheEntryFilePath)) {
            return cacheEntryFilePath;
        }
        else {
            return undefined;
        }
    }
    async trySetCacheEntryBufferAsync(terminal, cacheId, entryBuffer) {
        const cacheEntryFilePath = this.getCacheEntryPath(cacheId);
        await node_core_library_1.FileSystem.writeFileAsync(cacheEntryFilePath, entryBuffer, { ensureFolderExists: true });
        terminal.writeVerboseLine(`Wrote cache entry to "${cacheEntryFilePath}".`);
        return cacheEntryFilePath;
    }
}
exports.FileSystemBuildCacheProvider = FileSystemBuildCacheProvider;
//# sourceMappingURL=FileSystemBuildCacheProvider.js.map

/***/ }),

/***/ 71389:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncDelegator = (this && this.__asyncDelegator) || function (o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
};
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProjectBuildCache = void 0;
const path = __importStar(__webpack_require__(85622));
const events_1 = __importDefault(__webpack_require__(28614));
const crypto = __importStar(__webpack_require__(33373));
const tar = __importStar(__webpack_require__(74674));
const node_core_library_1 = __webpack_require__(24019);
const fs = __importStar(__webpack_require__(35747));
const RushConstants_1 = __webpack_require__(63985);
const TarExecutable_1 = __webpack_require__(93246);
const Utilities_1 = __webpack_require__(89521);
class ProjectBuildCache {
    constructor(cacheId, options) {
        this._project = options.projectConfiguration.project;
        this._localBuildCacheProvider = options.buildCacheConfiguration.localCacheProvider;
        this._cloudBuildCacheProvider = options.buildCacheConfiguration.cloudCacheProvider;
        this._buildCacheEnabled = options.buildCacheConfiguration.buildCacheEnabled;
        this._projectOutputFolderNames = options.projectConfiguration.projectOutputFolderNames || [];
        this._cacheId = cacheId;
    }
    static _tryGetTarUtility(terminal) {
        if (ProjectBuildCache._tarUtility === null) {
            ProjectBuildCache._tarUtility = TarExecutable_1.TarExecutable.tryInitialize(terminal);
        }
        return ProjectBuildCache._tarUtility;
    }
    static async tryGetProjectBuildCache(options) {
        const { terminal, projectConfiguration, trackedProjectFiles } = options;
        if (!trackedProjectFiles) {
            return undefined;
        }
        if (!ProjectBuildCache._validateProject(terminal, projectConfiguration, trackedProjectFiles)) {
            return undefined;
        }
        const cacheId = await ProjectBuildCache._getCacheId(options);
        return new ProjectBuildCache(cacheId, options);
    }
    static _validateProject(terminal, projectConfiguration, trackedProjectFiles) {
        const normalizedProjectRelativeFolder = node_core_library_1.Path.convertToSlashes(projectConfiguration.project.projectRelativeFolder);
        const outputFolders = [];
        if (projectConfiguration.projectOutputFolderNames) {
            for (const outputFolderName of projectConfiguration.projectOutputFolderNames) {
                outputFolders.push(`${normalizedProjectRelativeFolder}/${outputFolderName}/`);
            }
        }
        const inputOutputFiles = [];
        for (const file of trackedProjectFiles) {
            for (const outputFolder of outputFolders) {
                if (file.startsWith(outputFolder)) {
                    inputOutputFiles.push(file);
                }
            }
        }
        if (inputOutputFiles.length > 0) {
            terminal.writeWarningLine('Unable to use build cache. The following files are used to calculate project state ' +
                `and are considered project output: ${inputOutputFiles.join(', ')}`);
            return false;
        }
        else {
            return true;
        }
    }
    async tryRestoreFromCacheAsync(terminal) {
        const cacheId = this._cacheId;
        if (!cacheId) {
            terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');
            return false;
        }
        if (!this._buildCacheEnabled) {
            // Skip reading local and cloud build caches, without any noise
            return false;
        }
        let localCacheEntryPath = await this._localBuildCacheProvider.tryGetCacheEntryPathByIdAsync(terminal, cacheId);
        let cacheEntryBuffer;
        let updateLocalCacheSuccess;
        if (!localCacheEntryPath && this._cloudBuildCacheProvider) {
            terminal.writeVerboseLine('This project was not found in the local build cache. Querying the cloud build cache.');
            cacheEntryBuffer = await this._cloudBuildCacheProvider.tryGetCacheEntryBufferByIdAsync(terminal, cacheId);
            if (cacheEntryBuffer) {
                try {
                    localCacheEntryPath = await this._localBuildCacheProvider.trySetCacheEntryBufferAsync(terminal, cacheId, cacheEntryBuffer);
                    updateLocalCacheSuccess = true;
                }
                catch (e) {
                    updateLocalCacheSuccess = false;
                }
            }
        }
        if (!localCacheEntryPath && !cacheEntryBuffer) {
            terminal.writeVerboseLine('This project was not found in the build cache.');
            return false;
        }
        terminal.writeLine('Build cache hit.');
        const projectFolderPath = this._project.projectFolder;
        // Purge output folders
        terminal.writeVerboseLine(`Clearing cached folders: ${this._projectOutputFolderNames.join(', ')}`);
        await Promise.all(this._projectOutputFolderNames.map((outputFolderName) => node_core_library_1.FileSystem.deleteFolderAsync(`${projectFolderPath}/${outputFolderName}`)));
        const tarUtility = ProjectBuildCache._tryGetTarUtility(terminal);
        let restoreSuccess = false;
        if (tarUtility && localCacheEntryPath) {
            const logFilePath = this._getTarLogFilePath();
            const tarExitCode = await tarUtility.tryUntarAsync({
                archivePath: localCacheEntryPath,
                outputFolderPath: projectFolderPath,
                logFilePath
            });
            if (tarExitCode === 0) {
                restoreSuccess = true;
            }
            else {
                terminal.writeWarningLine(`"tar" exited with code ${tarExitCode} while attempting to restore cache entry. ` +
                    'Rush will attempt to extract from the cache entry with a JavaScript implementation of tar. ' +
                    `See "${logFilePath}" for logs from the tar process.`);
            }
        }
        if (!restoreSuccess) {
            if (!cacheEntryBuffer && localCacheEntryPath) {
                cacheEntryBuffer = await node_core_library_1.FileSystem.readFileToBufferAsync(localCacheEntryPath);
            }
            if (!cacheEntryBuffer) {
                throw new Error('Expected the cache entry buffer to be set.');
            }
            // If we don't have tar on the PATH, if we failed to update the local cache entry,
            // or if the tar binary failed, untar in-memory
            const tarStream = tar.extract({
                cwd: projectFolderPath,
                // Set to true to omit writing mtime value for extracted entries.
                m: true
            });
            try {
                const tarPromise = events_1.default.once(tarStream, 'drain');
                tarStream.write(cacheEntryBuffer);
                await tarPromise;
                restoreSuccess = true;
            }
            catch (e) {
                restoreSuccess = false;
            }
        }
        if (restoreSuccess) {
            terminal.writeLine('Successfully restored output from the build cache.');
        }
        else {
            terminal.writeWarningLine('Unable to restore output from the build cache.');
        }
        if (updateLocalCacheSuccess === false) {
            terminal.writeWarningLine('Unable to update the local build cache with data from the cloud cache.');
        }
        return restoreSuccess;
    }
    async trySetCacheEntryAsync(terminal) {
        var _a, _b;
        const cacheId = this._cacheId;
        if (!cacheId) {
            terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');
            return false;
        }
        if (!this._buildCacheEnabled) {
            // Skip writing local and cloud build caches, without any noise
            return false;
        }
        const projectFolderPath = this._project.projectFolder;
        const filesToCache = await this._tryCollectPathsToCacheAsync(terminal);
        if (!filesToCache) {
            return false;
        }
        terminal.writeVerboseLine(`Caching build output folders: ${filesToCache.filteredOutputFolderNames.join(', ')}`);
        let localCacheEntryPath;
        const tarUtility = ProjectBuildCache._tryGetTarUtility(terminal);
        if (tarUtility) {
            const tempLocalCacheEntryPath = this._localBuildCacheProvider.getCacheEntryPath(cacheId);
            const logFilePath = this._getTarLogFilePath();
            const tarExitCode = await tarUtility.tryCreateArchiveFromProjectPathsAsync({
                archivePath: tempLocalCacheEntryPath,
                paths: filesToCache.outputFilePaths,
                project: this._project,
                logFilePath
            });
            if (tarExitCode === 0) {
                localCacheEntryPath = tempLocalCacheEntryPath;
            }
            else {
                terminal.writeWarningLine(`"tar" exited with code ${tarExitCode} while attempting to create the cache entry. ` +
                    'Rush will attempt to create the cache entry with a JavaScript implementation of tar. ' +
                    `See "${logFilePath}" for logs from the tar process.`);
            }
        }
        let cacheEntryBuffer;
        let setLocalCacheEntryPromise;
        if (!localCacheEntryPath) {
            // If we weren't able to create the cache entry with tar, try to do it with the "tar" NPM package
            const tarStream = tar.create({
                gzip: true,
                portable: true,
                strict: true,
                cwd: projectFolderPath
            }, filesToCache.outputFilePaths);
            cacheEntryBuffer = await Utilities_1.Utilities.readStreamToBufferAsync(tarStream);
            setLocalCacheEntryPromise = this._localBuildCacheProvider.trySetCacheEntryBufferAsync(terminal, cacheId, cacheEntryBuffer);
        }
        else {
            setLocalCacheEntryPromise = Promise.resolve(localCacheEntryPath);
        }
        let setCloudCacheEntryPromise;
        // Note that "writeAllowed" settings (whether in config or environment) always apply to
        // the configured CLOUD cache. If the cache is enabled, rush is always allowed to read from and
        // write to the local build cache.
        if ((_a = this._cloudBuildCacheProvider) === null || _a === void 0 ? void 0 : _a.isCacheWriteAllowed) {
            if (!cacheEntryBuffer) {
                if (localCacheEntryPath) {
                    cacheEntryBuffer = await node_core_library_1.FileSystem.readFileToBufferAsync(localCacheEntryPath);
                }
                else {
                    throw new Error('Expected the local cache entry path to be set.');
                }
            }
            setCloudCacheEntryPromise = (_b = this._cloudBuildCacheProvider) === null || _b === void 0 ? void 0 : _b.trySetCacheEntryBufferAsync(terminal, cacheId, cacheEntryBuffer);
        }
        let localCachePath;
        let updateCloudCacheSuccess;
        if (setCloudCacheEntryPromise) {
            [updateCloudCacheSuccess, localCachePath] = await Promise.all([
                setCloudCacheEntryPromise,
                setLocalCacheEntryPromise
            ]);
        }
        else {
            updateCloudCacheSuccess = true;
            localCachePath = await setLocalCacheEntryPromise;
        }
        const success = updateCloudCacheSuccess && !!localCachePath;
        if (success) {
            terminal.writeLine('Successfully set cache entry.');
        }
        else if (!localCachePath && updateCloudCacheSuccess) {
            terminal.writeWarningLine('Unable to set local cache entry.');
        }
        else if (localCachePath && !updateCloudCacheSuccess) {
            terminal.writeWarningLine('Unable to set cloud cache entry.');
        }
        else {
            terminal.writeWarningLine('Unable to set both cloud and local cache entries.');
        }
        return success;
    }
    async _tryCollectPathsToCacheAsync(terminal) {
        var e_1, _a;
        const projectFolderPath = this._project.projectFolder;
        const outputFolderNamesThatExist = await Promise.all(this._projectOutputFolderNames.map((outputFolderName) => node_core_library_1.FileSystem.existsAsync(`${projectFolderPath}/${outputFolderName}`)));
        const filteredOutputFolderNames = [];
        for (let i = 0; i < outputFolderNamesThatExist.length; i++) {
            if (outputFolderNamesThatExist[i]) {
                filteredOutputFolderNames.push(this._projectOutputFolderNames[i]);
            }
        }
        let encounteredEnumerationIssue = false;
        function symbolicLinkPathCallback(entryPath) {
            terminal.writeError(`Unable to include "${entryPath}" in build cache. It is a symbolic link.`);
            encounteredEnumerationIssue = true;
        }
        const outputFilePaths = [];
        for (const filteredOutputFolderName of filteredOutputFolderNames) {
            if (encounteredEnumerationIssue) {
                return undefined;
            }
            const outputFilePathsForFolder = this._getPathsInFolder(terminal, symbolicLinkPathCallback, filteredOutputFolderName, `${projectFolderPath}/${filteredOutputFolderName}`);
            try {
                for (var outputFilePathsForFolder_1 = (e_1 = void 0, __asyncValues(outputFilePathsForFolder)), outputFilePathsForFolder_1_1; outputFilePathsForFolder_1_1 = await outputFilePathsForFolder_1.next(), !outputFilePathsForFolder_1_1.done;) {
                    const outputFilePath = outputFilePathsForFolder_1_1.value;
                    outputFilePaths.push(outputFilePath);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (outputFilePathsForFolder_1_1 && !outputFilePathsForFolder_1_1.done && (_a = outputFilePathsForFolder_1.return)) await _a.call(outputFilePathsForFolder_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        if (encounteredEnumerationIssue) {
            return undefined;
        }
        return {
            filteredOutputFolderNames,
            outputFilePaths
        };
    }
    _getPathsInFolder(terminal, symbolicLinkPathCallback, posixPrefix, folderPath) {
        return __asyncGenerator(this, arguments, function* _getPathsInFolder_1() {
            const folderEntries = yield __await(node_core_library_1.LegacyAdapters.convertCallbackToPromise(fs.readdir, folderPath, {
                withFileTypes: true
            }));
            for (const folderEntry of folderEntries) {
                const entryPath = `${posixPrefix}/${folderEntry.name}`;
                if (folderEntry.isSymbolicLink()) {
                    symbolicLinkPathCallback(entryPath);
                }
                else if (folderEntry.isDirectory()) {
                    yield __await(yield* __asyncDelegator(__asyncValues(this._getPathsInFolder(terminal, symbolicLinkPathCallback, entryPath, `${folderPath}/${folderEntry.name}`))));
                }
                else {
                    yield yield __await(entryPath);
                }
            }
        });
    }
    _getTarLogFilePath() {
        return path.join(this._project.projectRushTempFolder, 'build-cache-tar.log');
    }
    static async _getCacheId(options) {
        // The project state hash is calculated in the following method:
        // - The current project's hash (see ProjectChangeAnalyzer.getProjectStateHash) is
        //   calculated and appended to an array
        // - The current project's recursive dependency projects' hashes are calculated
        //   and appended to the array
        // - A SHA1 hash is created and the following data is fed into it, in order:
        //   1. The JSON-serialized list of output folder names for this
        //      project (see ProjectBuildCache._projectOutputFolderNames)
        //   2. The command that will be run in the project
        //   3. Each dependency project hash (from the array constructed in previous steps),
        //      in sorted alphanumerical-sorted order
        // - A hex digest of the hash is returned
        const projectChangeAnalyzer = options.projectChangeAnalyzer;
        const projectStates = [];
        const projectsThatHaveBeenProcessed = new Set();
        let projectsToProcess = new Set();
        projectsToProcess.add(options.projectConfiguration.project);
        while (projectsToProcess.size > 0) {
            const newProjectsToProcess = new Set();
            for (const projectToProcess of projectsToProcess) {
                projectsThatHaveBeenProcessed.add(projectToProcess);
                const projectState = await projectChangeAnalyzer._tryGetProjectStateHashAsync(projectToProcess.packageName, options.terminal);
                if (!projectState) {
                    // If we hit any projects with unknown state, return unknown cache ID
                    return undefined;
                }
                else {
                    projectStates.push(projectState);
                    for (const dependency of projectToProcess.dependencyProjects) {
                        if (!projectsThatHaveBeenProcessed.has(dependency)) {
                            newProjectsToProcess.add(dependency);
                        }
                    }
                }
            }
            projectsToProcess = newProjectsToProcess;
        }
        const sortedProjectStates = projectStates.sort();
        const hash = crypto.createHash('sha1');
        const serializedOutputFolders = JSON.stringify(options.projectConfiguration.projectOutputFolderNames);
        hash.update(serializedOutputFolders);
        hash.update(RushConstants_1.RushConstants.hashDelimiter);
        hash.update(options.command);
        hash.update(RushConstants_1.RushConstants.hashDelimiter);
        for (const projectHash of sortedProjectStates) {
            hash.update(projectHash);
            hash.update(RushConstants_1.RushConstants.hashDelimiter);
        }
        const projectStateHash = hash.digest('hex');
        return options.buildCacheConfiguration.getCacheEntryId({
            projectName: options.projectConfiguration.project.packageName,
            projectStateHash
        });
    }
}
exports.ProjectBuildCache = ProjectBuildCache;
/**
 * null === we haven't tried to initialize yet
 * undefined === unable to initialize
 */
ProjectBuildCache._tarUtility = null;
//# sourceMappingURL=ProjectBuildCache.js.map

/***/ }),

/***/ 90893:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeployScenarioConfiguration = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
class DeployScenarioConfiguration {
    constructor(json, projectJsonsByName) {
        this.json = json;
        this.projectJsonsByName = projectJsonsByName;
    }
    /**
     * Validates that the input string conforms to the naming rules for a "rush deploy" scenario name.
     */
    static validateScenarioName(scenarioName) {
        if (!scenarioName) {
            throw new Error('The scenario name cannot be an empty string');
        }
        if (!this._scenarioNameRegExp.test(scenarioName)) {
            throw new Error(`"${scenarioName}" is not a valid scenario name. The name must be comprised of` +
                ' lowercase letters and numbers, separated by single hyphens. Example: "my-scenario"');
        }
    }
    /**
     * Given the --scenarioName value, return the full path of the filename.
     *
     * Example: "ftp-site" --> "...common/config/rush/deploy-ftp-site.json"
     * Example: undefined --> "...common/config/rush/deploy.json"
     */
    static getConfigFilePath(scenarioName, rushConfiguration) {
        let scenarioFileName;
        if (scenarioName) {
            DeployScenarioConfiguration.validateScenarioName(scenarioName);
            scenarioFileName = `deploy-${scenarioName}.json`;
        }
        else {
            scenarioFileName = `deploy.json`;
        }
        return path.join(rushConfiguration.commonRushConfigFolder, scenarioFileName);
    }
    static loadFromFile(scenarioFilePath, rushConfiguration) {
        if (!node_core_library_1.FileSystem.exists(scenarioFilePath)) {
            throw new Error('The scenario config file was not found: ' + scenarioFilePath);
        }
        console.log(safe_1.default.cyan('Loading deployment scenario: ') + scenarioFilePath);
        const deployScenarioJson = node_core_library_1.JsonFile.loadAndValidate(scenarioFilePath, DeployScenarioConfiguration._jsonSchema);
        // Apply the defaults
        if (!deployScenarioJson.linkCreation) {
            deployScenarioJson.linkCreation = 'default';
        }
        const deployScenarioProjectJsonsByName = new Map();
        for (const projectSetting of deployScenarioJson.projectSettings || []) {
            // Validate projectSetting.projectName
            if (!rushConfiguration.getProjectByName(projectSetting.projectName)) {
                throw new Error(`The "projectSettings" section refers to the project name "${projectSetting.projectName}"` +
                    ` which was not found in rush.json`);
            }
            for (const additionalProjectsToInclude of projectSetting.additionalProjectsToInclude || []) {
                if (!rushConfiguration.getProjectByName(projectSetting.projectName)) {
                    throw new Error(`The "additionalProjectsToInclude" setting refers to the` +
                        ` project name "${additionalProjectsToInclude}" which was not found in rush.json`);
                }
            }
            deployScenarioProjectJsonsByName.set(projectSetting.projectName, projectSetting);
        }
        return new DeployScenarioConfiguration(deployScenarioJson, deployScenarioProjectJsonsByName);
    }
}
exports.DeployScenarioConfiguration = DeployScenarioConfiguration;
// Used by validateScenarioName()
// Matches lowercase words separated by dashes.
// Example: "deploy-the-thing123"
DeployScenarioConfiguration._scenarioNameRegExp = /^[a-z0-9]+(-[a-z0-9]+)*$/;
DeployScenarioConfiguration._jsonSchema = node_core_library_1.JsonSchema.fromFile(path.join(__dirname, '../../schemas/deploy-scenario.schema.json'));
//# sourceMappingURL=DeployScenarioConfiguration.js.map

/***/ }),

/***/ 54939:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InstallHelpers = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const LastInstallFlag_1 = __webpack_require__(57013);
const Utilities_1 = __webpack_require__(89521);
class InstallHelpers {
    static generateCommonPackageJson(rushConfiguration, dependencies = new Map()) {
        const commonPackageJson = {
            dependencies: {},
            description: 'Temporary file generated by the Rush tool',
            name: 'rush-common',
            private: true,
            version: '0.0.0'
        };
        // Add any preferred versions to the top of the commonPackageJson
        // do this in alphabetical order for simpler debugging
        for (const dependency of Array.from(dependencies.keys()).sort()) {
            commonPackageJson.dependencies[dependency] = dependencies.get(dependency);
        }
        // Example: "C:\MyRepo\common\temp\package.json"
        const commonPackageJsonFilename = path.join(rushConfiguration.commonTempFolder, "package.json" /* PackageJson */);
        // Don't update the file timestamp unless the content has changed, since "rush install"
        // will consider this timestamp
        node_core_library_1.JsonFile.save(commonPackageJson, commonPackageJsonFilename, { onlyIfChanged: true });
    }
    static getPackageManagerEnvironment(rushConfiguration, options = {}) {
        let configurationEnvironment = undefined;
        if (rushConfiguration.packageManager === 'npm') {
            if (rushConfiguration.npmOptions && rushConfiguration.npmOptions.environmentVariables) {
                configurationEnvironment = rushConfiguration.npmOptions.environmentVariables;
            }
        }
        else if (rushConfiguration.packageManager === 'pnpm') {
            if (rushConfiguration.pnpmOptions && rushConfiguration.pnpmOptions.environmentVariables) {
                configurationEnvironment = rushConfiguration.pnpmOptions.environmentVariables;
            }
        }
        else if (rushConfiguration.packageManager === 'yarn') {
            if (rushConfiguration.yarnOptions && rushConfiguration.yarnOptions.environmentVariables) {
                configurationEnvironment = rushConfiguration.yarnOptions.environmentVariables;
            }
        }
        return InstallHelpers._mergeEnvironmentVariables(process.env, configurationEnvironment, options);
    }
    /**
     * If the "(p)npm-local" symlink hasn't been set up yet, this creates it, installing the
     * specified (P)npm version in the user's home directory if needed.
     */
    static async ensureLocalPackageManager(rushConfiguration, rushGlobalFolder, maxInstallAttempts) {
        // Example: "C:\Users\YourName\.rush"
        const rushUserFolder = rushGlobalFolder.nodeSpecificPath;
        if (!node_core_library_1.FileSystem.exists(rushUserFolder)) {
            console.log('Creating ' + rushUserFolder);
            node_core_library_1.FileSystem.ensureFolder(rushUserFolder);
        }
        const packageManager = rushConfiguration.packageManager;
        const packageManagerVersion = rushConfiguration.packageManagerToolVersion;
        const packageManagerAndVersion = `${packageManager}-${packageManagerVersion}`;
        // Example: "C:\Users\YourName\.rush\pnpm-1.2.3"
        const packageManagerToolFolder = path.join(rushUserFolder, packageManagerAndVersion);
        const packageManagerMarker = new LastInstallFlag_1.LastInstallFlag(packageManagerToolFolder, {
            node: process.versions.node
        });
        console.log(`Trying to acquire lock for ${packageManagerAndVersion}`);
        const lock = await node_core_library_1.LockFile.acquire(rushUserFolder, packageManagerAndVersion);
        console.log(`Acquired lock for ${packageManagerAndVersion}`);
        if (!packageManagerMarker.isValid() || lock.dirtyWhenAcquired) {
            console.log(safe_1.default.bold(`Installing ${packageManager} version ${packageManagerVersion}${os.EOL}`));
            // note that this will remove the last-install flag from the directory
            Utilities_1.Utilities.installPackageInDirectory({
                directory: packageManagerToolFolder,
                packageName: packageManager,
                version: rushConfiguration.packageManagerToolVersion,
                tempPackageTitle: `${packageManager}-local-install`,
                maxInstallAttempts: maxInstallAttempts,
                // This is using a local configuration to install a package in a shared global location.
                // Generally that's a bad practice, but in this case if we can successfully install
                // the package at all, we can reasonably assume it's good for all the repositories.
                // In particular, we'll assume that two different NPM registries cannot have two
                // different implementations of the same version of the same package.
                // This was needed for: https://github.com/microsoft/rushstack/issues/691
                commonRushConfigFolder: rushConfiguration.commonRushConfigFolder
            });
            console.log(`Successfully installed ${packageManager} version ${packageManagerVersion}`);
        }
        else {
            console.log(`Found ${packageManager} version ${packageManagerVersion} in ${packageManagerToolFolder}`);
        }
        packageManagerMarker.create();
        // Example: "C:\MyRepo\common\temp"
        node_core_library_1.FileSystem.ensureFolder(rushConfiguration.commonTempFolder);
        // Example: "C:\MyRepo\common\temp\pnpm-local"
        const localPackageManagerToolFolder = path.join(rushConfiguration.commonTempFolder, `${packageManager}-local`);
        console.log(os.EOL + `Symlinking "${localPackageManagerToolFolder}"`);
        console.log(`  --> "${packageManagerToolFolder}"`);
        // We cannot use FileSystem.exists() to test the existence of a symlink, because it will
        // return false for broken symlinks.  There is no way to test without catching an exception.
        try {
            node_core_library_1.FileSystem.deleteFolder(localPackageManagerToolFolder);
        }
        catch (error) {
            if (error.code !== 'ENOENT') {
                throw error;
            }
        }
        node_core_library_1.FileSystem.createSymbolicLinkJunction({
            linkTargetPath: packageManagerToolFolder,
            newLinkPath: localPackageManagerToolFolder
        });
        lock.release();
    }
    // Helper for getPackageManagerEnvironment
    static _mergeEnvironmentVariables(baseEnv, environmentVariables, options = {}) {
        const packageManagerEnv = baseEnv;
        if (environmentVariables) {
            // eslint-disable-next-line guard-for-in
            for (const envVar in environmentVariables) {
                let setEnvironmentVariable = true;
                console.log(`\nProcessing definition for environment variable: ${envVar}`);
                if (baseEnv.hasOwnProperty(envVar)) {
                    setEnvironmentVariable = false;
                    console.log(`Environment variable already defined:`);
                    console.log(`  Name: ${envVar}`);
                    console.log(`  Existing value: ${baseEnv[envVar]}`);
                    console.log(`  Value set in rush.json: ${environmentVariables[envVar].value}`);
                    if (environmentVariables[envVar].override) {
                        setEnvironmentVariable = true;
                        console.log(`Overriding the environment variable with the value set in rush.json.`);
                    }
                    else {
                        console.log(safe_1.default.yellow(`WARNING: Not overriding the value of the environment variable.`));
                    }
                }
                if (setEnvironmentVariable) {
                    if (options.debug) {
                        console.log(`Setting environment variable for package manager.`);
                        console.log(`  Name: ${envVar}`);
                        console.log(`  Value: ${environmentVariables[envVar].value}`);
                    }
                    packageManagerEnv[envVar] = environmentVariables[envVar].value;
                }
            }
        }
        return packageManagerEnv;
    }
}
exports.InstallHelpers = InstallHelpers;
//# sourceMappingURL=InstallHelpers.js.map

/***/ }),

/***/ 71068:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NpmShrinkwrapFile = void 0;
const os = __importStar(__webpack_require__(12087));
const node_core_library_1 = __webpack_require__(24019);
const BaseShrinkwrapFile_1 = __webpack_require__(74926);
const DependencySpecifier_1 = __webpack_require__(179);
class NpmShrinkwrapFile extends BaseShrinkwrapFile_1.BaseShrinkwrapFile {
    constructor(shrinkwrapJson) {
        super();
        this._shrinkwrapJson = shrinkwrapJson;
        // Normalize the data
        if (!this._shrinkwrapJson.version) {
            this._shrinkwrapJson.version = '';
        }
        if (!this._shrinkwrapJson.name) {
            this._shrinkwrapJson.name = '';
        }
        if (!this._shrinkwrapJson.dependencies) {
            this._shrinkwrapJson.dependencies = {};
        }
        // Workspaces not supported in NPM
        this.isWorkspaceCompatible = false;
    }
    static loadFromFile(shrinkwrapJsonFilename) {
        let data = undefined;
        try {
            if (!node_core_library_1.FileSystem.exists(shrinkwrapJsonFilename)) {
                return undefined; // file does not exist
            }
            // We don't use JsonFile/jju here because shrinkwrap.json is a special NPM file format
            // and typically very large, so we want to load it the same way that NPM does.
            data = node_core_library_1.FileSystem.readFile(shrinkwrapJsonFilename);
            if (data.charCodeAt(0) === 0xfeff) {
                // strip BOM
                data = data.slice(1);
            }
            return new NpmShrinkwrapFile(JSON.parse(data));
        }
        catch (error) {
            throw new Error(`Error reading "${shrinkwrapJsonFilename}":` + os.EOL + `  ${error.message}`);
        }
    }
    /** @override */
    getTempProjectNames() {
        return this._getTempProjectNames(this._shrinkwrapJson.dependencies);
    }
    /** @override */
    serialize() {
        return node_core_library_1.JsonFile.stringify(this._shrinkwrapJson);
    }
    /** @override */
    getTopLevelDependencyVersion(dependencyName) {
        // First, check under tempProjectName, as this is the first place we look during linking.
        const dependencyJson = NpmShrinkwrapFile.tryGetValue(this._shrinkwrapJson.dependencies, dependencyName);
        if (!dependencyJson) {
            return undefined;
        }
        return new DependencySpecifier_1.DependencySpecifier(dependencyName, dependencyJson.version);
    }
    /**
     * @param dependencyName the name of the dependency to get a version for
     * @param tempProjectName the name of the temp project to check for this dependency
     * @param versionRange Not used, just exists to satisfy abstract API contract
     * @override
     */
    tryEnsureDependencyVersion(dependencySpecifier, tempProjectName) {
        // First, check under tempProjectName, as this is the first place we look during linking.
        let dependencyJson = undefined;
        const tempDependency = NpmShrinkwrapFile.tryGetValue(this._shrinkwrapJson.dependencies, tempProjectName);
        if (tempDependency && tempDependency.dependencies) {
            dependencyJson = NpmShrinkwrapFile.tryGetValue(tempDependency.dependencies, dependencySpecifier.packageName);
        }
        // Otherwise look at the root of the shrinkwrap file
        if (!dependencyJson) {
            return this.getTopLevelDependencyVersion(dependencySpecifier.packageName);
        }
        return new DependencySpecifier_1.DependencySpecifier(dependencySpecifier.packageName, dependencyJson.version);
    }
    /** @override */
    getProjectShrinkwrap(project) {
        return undefined;
    }
    /** @override */
    isWorkspaceProjectModified(project, variant) {
        throw new node_core_library_1.InternalError('Not implemented');
    }
}
exports.NpmShrinkwrapFile = NpmShrinkwrapFile;
//# sourceMappingURL=NpmShrinkwrapFile.js.map

/***/ }),

/***/ 74605:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PnpmProjectShrinkwrapFile = void 0;
const crypto = __importStar(__webpack_require__(33373));
const node_core_library_1 = __webpack_require__(24019);
const BaseProjectShrinkwrapFile_1 = __webpack_require__(30052);
const RushConstants_1 = __webpack_require__(63985);
/**
 *
 */
class PnpmProjectShrinkwrapFile extends BaseProjectShrinkwrapFile_1.BaseProjectShrinkwrapFile {
    /**
     * Generate and write the project shrinkwrap file to <project>/.rush/temp/shrinkwrap-deps.json.
     * @returns True if the project shrinkwrap was created or updated, false otherwise.
     */
    async updateProjectShrinkwrapAsync() {
        const projectShrinkwrapMap = this.shrinkwrapFile.isWorkspaceCompatible
            ? this.generateWorkspaceProjectShrinkwrapMap()
            : this.generateLegacyProjectShrinkwrapMap();
        return projectShrinkwrapMap ? this.saveAsync(projectShrinkwrapMap) : this.deleteIfExistsAsync();
    }
    generateWorkspaceProjectShrinkwrapMap() {
        // Obtain the workspace importer from the shrinkwrap, which lists resolved dependencies
        const importerKey = this.shrinkwrapFile.getImporterKeyByPath(this.project.rushConfiguration.commonTempFolder, this.project.projectFolder);
        const importer = this.shrinkwrapFile.getImporter(importerKey);
        if (!importer) {
            // It's not in here. This is possible when perfoming filtered installs
            return undefined;
        }
        // Only select the importer dependencies that are non-local since we already handle local
        // project changes
        const externalDependencies = [
            ...Object.entries(importer.dependencies || {}),
            ...Object.entries(importer.devDependencies || {}),
            ...Object.entries(importer.optionalDependencies || {})
        ].filter((d) => d[1].indexOf('link:') === -1);
        const projectShrinkwrapMap = new Map();
        for (const [name, version] of externalDependencies) {
            // Add to the manifest and provide all the parent dependencies
            this._addDependencyRecursive(projectShrinkwrapMap, name, version, {
                dependencies: Object.assign(Object.assign({}, importer.dependencies), importer.devDependencies),
                optionalDependencies: Object.assign({}, importer.optionalDependencies)
            });
        }
        return projectShrinkwrapMap;
    }
    generateLegacyProjectShrinkwrapMap() {
        const tempProjectDependencyKey = this.shrinkwrapFile.getTempProjectDependencyKey(this.project.tempProjectName);
        if (!tempProjectDependencyKey) {
            throw new Error(`Cannot get dependency key for temp project: ${this.project.tempProjectName}`);
        }
        const parentShrinkwrapEntry = this.shrinkwrapFile.getShrinkwrapEntryFromTempProjectDependencyKey(tempProjectDependencyKey);
        // Only select the shrinkwrap dependencies that are non-local since we already handle local
        // project changes
        const externalDependencies = [
            ...Object.entries(parentShrinkwrapEntry.dependencies || {}),
            ...Object.entries(parentShrinkwrapEntry.optionalDependencies || {})
        ].filter((d) => d[0].indexOf('@rush-temp/') === -1);
        const projectShrinkwrapMap = new Map();
        for (const [name, version] of externalDependencies) {
            this._addDependencyRecursive(projectShrinkwrapMap, name, version, parentShrinkwrapEntry);
        }
        // Since peer dependencies within on external packages may be hoisted up to the top-level package,
        // we need to resolve and add these dependencies directly
        this._resolveAndAddPeerDependencies(projectShrinkwrapMap, parentShrinkwrapEntry);
        return projectShrinkwrapMap;
    }
    _addDependencyRecursive(projectShrinkwrapMap, name, version, parentShrinkwrapEntry, throwIfShrinkwrapEntryMissing = true) {
        var _a;
        const shrinkwrapEntry = this.shrinkwrapFile.getShrinkwrapEntry(name, version);
        if (!shrinkwrapEntry) {
            if (throwIfShrinkwrapEntryMissing) {
                throw new node_core_library_1.InternalError(`Unable to find dependency ${name} with version ${version} in shrinkwrap.`);
            }
            return;
        }
        const specifier = `${name}@${version}`;
        let integrity = (_a = shrinkwrapEntry === null || shrinkwrapEntry === void 0 ? void 0 : shrinkwrapEntry.resolution) === null || _a === void 0 ? void 0 : _a.integrity;
        if (!integrity) {
            // git dependency specifiers do not have an integrity entry. Instead, they specify the tarball field.
            // So instead, we will hash the contents of the dependency entry and use that as the integrity hash.
            // Ex:
            // github.com/chfritz/node-xmlrpc/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38:
            //   ...
            //   resolution:
            //     tarball: 'https://codeload.github.com/chfritz/node-xmlrpc/tar.gz/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38'
            const sha256Digest = crypto
                .createHash('sha256')
                .update(JSON.stringify(shrinkwrapEntry))
                .digest('hex');
            integrity = `${name}@${version}:${sha256Digest}:`;
        }
        const existingSpecifier = projectShrinkwrapMap.get(specifier);
        if (existingSpecifier) {
            if (existingSpecifier !== integrity) {
                throw new Error(`Collision: ${specifier} already exists in with a different integrity`);
            }
            return;
        }
        // Add the current dependency
        projectShrinkwrapMap.set(specifier, integrity);
        // Add the dependencies of the dependency
        for (const [name, version] of Object.entries(shrinkwrapEntry.dependencies || {})) {
            this._addDependencyRecursive(projectShrinkwrapMap, name, version, shrinkwrapEntry);
        }
        // Add the optional dependencies of the dependency, and don't blow up if they don't exist
        for (const [name, version] of Object.entries(shrinkwrapEntry.optionalDependencies || {})) {
            this._addDependencyRecursive(projectShrinkwrapMap, name, version, shrinkwrapEntry, 
            /* throwIfShrinkwrapEntryMissing */ false);
        }
        // When using workspaces, hoisting of peer dependencies to a singular top-level project is not possible.
        // Therefore, all packages that are consumed should be specified in the dependency tree. Given this, there
        // is no need to look for peer dependencies, since it is simply a constraint to be validated by the
        // package manager.
        if (!this.shrinkwrapFile.isWorkspaceCompatible) {
            this._resolveAndAddPeerDependencies(projectShrinkwrapMap, shrinkwrapEntry, parentShrinkwrapEntry);
        }
    }
    _resolveAndAddPeerDependencies(projectShrinkwrapMap, shrinkwrapEntry, parentShrinkwrapEntry) {
        var _a, _b, _c;
        for (const peerDependencyName of Object.keys(shrinkwrapEntry.peerDependencies || {})) {
            // Skip peer dependency resolution of local package peer dependencies
            if (peerDependencyName.indexOf(RushConstants_1.RushConstants.rushTempNpmScope) !== -1) {
                continue;
            }
            // Check to see if the peer dependency is satisfied with the current shrinkwrap
            // entry. If not, check the parent shrinkwrap entry. Finally, if neither have
            // the specified dependency, check that the parent mentions the dependency in
            // it's own peer dependencies. If it is, we can rely on the package manager and
            // make the assumption that we've already found it further up the stack.
            if (((_a = shrinkwrapEntry.dependencies) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(peerDependencyName)) ||
                ((_b = parentShrinkwrapEntry === null || parentShrinkwrapEntry === void 0 ? void 0 : parentShrinkwrapEntry.dependencies) === null || _b === void 0 ? void 0 : _b.hasOwnProperty(peerDependencyName)) ||
                ((_c = parentShrinkwrapEntry === null || parentShrinkwrapEntry === void 0 ? void 0 : parentShrinkwrapEntry.peerDependencies) === null || _c === void 0 ? void 0 : _c.hasOwnProperty(peerDependencyName))) {
                continue;
            }
            // As a last attempt, check if it's been hoisted up as a top-level dependency. If
            // we can't find it, we can assume that it's already been provided somewhere up the
            // dependency tree.
            const topLevelDependencySpecifier = this.shrinkwrapFile.getTopLevelDependencyVersion(peerDependencyName);
            if (topLevelDependencySpecifier) {
                this._addDependencyRecursive(projectShrinkwrapMap, peerDependencyName, this.shrinkwrapFile.getTopLevelDependencyKey(peerDependencyName), shrinkwrapEntry);
            }
        }
    }
    /**
     * Save the current state of the object to project/.rush/temp/shrinkwrap-deps.json
     */
    async saveAsync(projectShrinkwrapMap) {
        const file = {};
        const keys = Array.from(projectShrinkwrapMap.keys()).sort();
        for (const key of keys) {
            file[key] = projectShrinkwrapMap.get(key);
        }
        await node_core_library_1.JsonFile.saveAsync(file, this.projectShrinkwrapFilePath, { ensureFolderExists: true });
    }
    /**
     * @override
     */
    get shrinkwrapFile() {
        return super.shrinkwrapFile;
    }
}
exports.PnpmProjectShrinkwrapFile = PnpmProjectShrinkwrapFile;
//# sourceMappingURL=PnpmProjectShrinkwrapFile.js.map

/***/ }),

/***/ 32621:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PnpmShrinkwrapFile = exports.parsePnpmDependencyKey = void 0;
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const semver = __importStar(__webpack_require__(11383));
const crypto_1 = __importDefault(__webpack_require__(33373));
const safe_1 = __importDefault(__webpack_require__(41997));
const node_core_library_1 = __webpack_require__(24019);
const BaseShrinkwrapFile_1 = __webpack_require__(74926);
const DependencySpecifier_1 = __webpack_require__(179);
const RushConfiguration_1 = __webpack_require__(92905);
const PnpmYamlCommon_1 = __webpack_require__(16864);
const RushConstants_1 = __webpack_require__(63985);
const PackageJsonEditor_1 = __webpack_require__(32373);
const PnpmfileConfiguration_1 = __webpack_require__(75857);
const PnpmProjectShrinkwrapFile_1 = __webpack_require__(74605);
const yamlModule = node_core_library_1.Import.lazy('js-yaml', require);
/**
 * Given an encoded "dependency key" from the PNPM shrinkwrap file, this parses it into an equivalent
 * DependencySpecifier.
 *
 * @returns a SemVer string, or undefined if the version specifier cannot be parsed
 */
function parsePnpmDependencyKey(dependencyName, dependencyKey) {
    if (!dependencyKey) {
        return undefined;
    }
    if (/^\w+:/.test(dependencyKey)) {
        // If it starts with an NPM scheme such as "file:projects/my-app.tgz", we don't support that
        return undefined;
    }
    // The package name parsed from the dependency key, or dependencyName if it was omitted.
    // Example: "@scope/depame"
    let parsedPackageName;
    // The trailing portion of the dependency key that includes the version and optional peer dependency path.
    // Example: "2.8.0/chai@3.5.0+sinon@1.17.7"
    let parsedInstallPath;
    // Example: "path.pkgs.visualstudio.com/@scope/depame/1.4.0"  --> 0="@scope/depame" 1="1.4.0"
    // Example: "/isarray/2.0.1"                                  --> 0="isarray"       1="2.0.1"
    // Example: "/sinon-chai/2.8.0/chai@3.5.0+sinon@1.17.7"       --> 0="sinon-chai"    1="2.8.0/chai@3.5.0+sinon@1.17.7"
    const packageNameMatch = /^[^\/]*\/((?:@[^\/]+\/)?[^\/]+)\/(.*)$/.exec(dependencyKey);
    if (packageNameMatch) {
        parsedPackageName = packageNameMatch[1];
        parsedInstallPath = packageNameMatch[2];
    }
    else {
        parsedPackageName = dependencyName;
        // Example: "23.6.0_babel-core@6.26.3"
        // Example: "23.6.0"
        parsedInstallPath = dependencyKey;
    }
    // The SemVer value
    // Example: "2.8.0"
    let parsedVersionPart;
    // Example: "23.6.0_babel-core@6.26.3" --> "23.6.0"
    // Example: "2.8.0/chai@3.5.0+sinon@1.17.7" --> "2.8.0"
    const versionMatch = /^([^\/_]+)[\/_]/.exec(parsedInstallPath);
    if (versionMatch) {
        parsedVersionPart = versionMatch[1];
    }
    else {
        // Example: "2.8.0"
        parsedVersionPart = parsedInstallPath;
    }
    // By this point, we expect parsedVersionPart to be a valid SemVer range
    if (!parsedVersionPart) {
        return undefined;
    }
    if (!semver.valid(parsedVersionPart)) {
        const urlRegex = /^(@?)([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}\/([^\/\\]+\/?)*([^\/\\]+)$/i;
        // Test for urls:
        // Examples:
        //     @github.com/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2
        //     github.com/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2
        //     github.com.au/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2
        //     bitbucket.com/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2
        //     bitbucket.co.in/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2
        if (urlRegex.test(dependencyKey)) {
            const dependencySpecifier = new DependencySpecifier_1.DependencySpecifier(dependencyName, dependencyKey);
            return dependencySpecifier;
        }
        else {
            return undefined;
        }
    }
    // Is it an alias for a different package?
    if (parsedPackageName === dependencyName) {
        // No, it's a regular dependency
        return new DependencySpecifier_1.DependencySpecifier(parsedPackageName, parsedVersionPart);
    }
    else {
        // If the parsed package name is different from the dependencyName, then this is an NPM package alias
        return new DependencySpecifier_1.DependencySpecifier(dependencyName, `npm:${parsedPackageName}@${parsedVersionPart}`);
    }
}
exports.parsePnpmDependencyKey = parsePnpmDependencyKey;
class PnpmShrinkwrapFile extends BaseShrinkwrapFile_1.BaseShrinkwrapFile {
    constructor(shrinkwrapJson, shrinkwrapFilename) {
        super();
        this.shrinkwrapFilename = shrinkwrapFilename;
        this._shrinkwrapJson = shrinkwrapJson;
        // Normalize the data
        this.registry = shrinkwrapJson.registry || '';
        this.dependencies = new Map(Object.entries(shrinkwrapJson.dependencies || {}));
        this.importers = new Map(Object.entries(shrinkwrapJson.importers || {}));
        this.specifiers = new Map(Object.entries(shrinkwrapJson.specifiers || {}));
        this.packages = new Map(Object.entries(shrinkwrapJson.packages || {}));
        // Importers only exist in workspaces
        this.isWorkspaceCompatible = this.importers.size > 0;
    }
    static loadFromFile(shrinkwrapYamlFilename, pnpmOptions) {
        try {
            if (!node_core_library_1.FileSystem.exists(shrinkwrapYamlFilename)) {
                return undefined; // file does not exist
            }
            const shrinkwrapContent = node_core_library_1.FileSystem.readFile(shrinkwrapYamlFilename);
            const parsedData = yamlModule.safeLoad(shrinkwrapContent);
            return new PnpmShrinkwrapFile(parsedData, shrinkwrapYamlFilename);
        }
        catch (error) {
            throw new Error(`Error reading "${shrinkwrapYamlFilename}":${os.EOL}  ${error.message}`);
        }
    }
    getShrinkwrapHash(experimentsConfig) {
        // The 'omitImportersFromPreventManualShrinkwrapChanges' experiment skips the 'importers' section
        // when computing the hash, since the main concern is changes to the overall external dependency footprint
        const { omitImportersFromPreventManualShrinkwrapChanges } = experimentsConfig || {};
        const shrinkwrapContent = this._serializeInternal(omitImportersFromPreventManualShrinkwrapChanges);
        return crypto_1.default.createHash('sha1').update(shrinkwrapContent).digest('hex');
    }
    /** @override */
    validate(packageManagerOptionsConfig, policyOptions, experimentsConfig) {
        super.validate(packageManagerOptionsConfig, policyOptions);
        if (!(packageManagerOptionsConfig instanceof RushConfiguration_1.PnpmOptionsConfiguration)) {
            throw new Error('The provided package manager options are not valid for PNPM shrinkwrap files.');
        }
        if (!policyOptions.allowShrinkwrapUpdates) {
            if (!policyOptions.repoState.isValid) {
                console.log(safe_1.default.red(`The ${RushConstants_1.RushConstants.repoStateFilename} file is invalid. There may be a merge conflict marker ` +
                    'in the file. You may need to run "rush update" to refresh its contents.') + os.EOL);
                throw new node_core_library_1.AlreadyReportedError();
            }
            // Only check the hash if allowShrinkwrapUpdates is false. If true, the shrinkwrap file
            // may have changed and the hash could be invalid.
            if (packageManagerOptionsConfig.preventManualShrinkwrapChanges) {
                if (!policyOptions.repoState.pnpmShrinkwrapHash) {
                    console.log(safe_1.default.red('The existing shrinkwrap file hash could not be found. You may need to run "rush update" to ' +
                        'populate the hash. See the "preventManualShrinkwrapChanges" setting documentation for details.') + os.EOL);
                    throw new node_core_library_1.AlreadyReportedError();
                }
                if (this.getShrinkwrapHash(experimentsConfig) !== policyOptions.repoState.pnpmShrinkwrapHash) {
                    console.log(safe_1.default.red('The shrinkwrap file hash does not match the expected hash. Please run "rush update" to ensure the ' +
                        'shrinkwrap file is up to date. See the "preventManualShrinkwrapChanges" setting documentation for ' +
                        'details.') + os.EOL);
                    throw new node_core_library_1.AlreadyReportedError();
                }
            }
        }
    }
    /** @override */
    getTempProjectNames() {
        return this._getTempProjectNames(this._shrinkwrapJson.dependencies || {});
    }
    /**
     * Gets the path to the tarball file if the package is a tarball.
     * Returns undefined if the package entry doesn't exist or the package isn't a tarball.
     * Example of return value: file:projects/build-tools.tgz
     */
    getTarballPath(packageName) {
        var _a;
        const dependency = this.packages.get(packageName);
        return (_a = dependency === null || dependency === void 0 ? void 0 : dependency.resolution) === null || _a === void 0 ? void 0 : _a.tarball;
    }
    getTopLevelDependencyKey(dependencyName) {
        return this.dependencies.get(dependencyName);
    }
    /**
     * Gets the version number from the list of top-level dependencies in the "dependencies" section
     * of the shrinkwrap file. Sample return values:
     *   '2.1.113'
     *   '1.9.0-dev.27'
     *   'file:projects/empty-webpart-project.tgz'
     *   undefined
     *
     * @override
     */
    getTopLevelDependencyVersion(dependencyName) {
        var _a;
        let value = this.dependencies.get(dependencyName);
        if (value) {
            // Getting the top level dependency version from a PNPM lockfile version 5.1
            // --------------------------------------------------------------------------
            //
            // 1) Top-level tarball dependency entries in pnpm-lock.yaml look like:
            //    '@rush-temp/sp-filepicker': 'file:projects/sp-filepicker.tgz_0ec79d3b08edd81ebf49cd19ca50b3f5'
            //    Then, it would be defined below:
            //    'file:projects/sp-filepicker.tgz_0ec79d3b08edd81ebf49cd19ca50b3f5':
            //      dependencies:
            //       '@microsoft/load-themed-styles': 1.10.7
            //       ...
            //      resolution:
            //       integrity: sha512-guuoFIc**==
            //       tarball: 'file:projects/sp-filepicker.tgz'
            //    Here, we are interested in the part 'file:projects/sp-filepicker.tgz'. Splitting by underscores is not the
            //    best way to get this because file names could have underscores in them. Instead, we could use the tarball
            //    field in the resolution section.
            // 2) Top-level non-tarball dependency entries in pnpm-lock.yaml would look like:
            //    '@rushstack/set-webpack-public-path-plugin': 2.1.133
            //    @microsoft/sp-build-node': 1.9.0-dev.27_typescript@2.9.2
            //    Here, we could just split by underscores and take the first part.
            // The below code is also compatible with lockfile versions < 5.1
            const dependency = this.packages.get(value);
            if (((_a = dependency === null || dependency === void 0 ? void 0 : dependency.resolution) === null || _a === void 0 ? void 0 : _a.tarball) && value.startsWith(dependency.resolution.tarball)) {
                return new DependencySpecifier_1.DependencySpecifier(dependencyName, dependency.resolution.tarball);
            }
            else {
                const underscoreIndex = value.indexOf('_');
                if (underscoreIndex >= 0) {
                    value = value.substr(0, underscoreIndex);
                }
            }
            return new DependencySpecifier_1.DependencySpecifier(dependencyName, value);
        }
        return undefined;
    }
    /**
     * The PNPM shrinkwrap file has top-level dependencies on the temp projects like this:
     *
     * ```
     * dependencies:
     *   '@rush-temp/my-app': 'file:projects/my-app.tgz_25c559a5921686293a001a397be4dce0'
     * packages:
     *   /@types/node/10.14.15:
     *     dev: false
     *   'file:projects/my-app.tgz_25c559a5921686293a001a397be4dce0':
     *     dev: false
     *     name: '@rush-temp/my-app'
     *     version: 0.0.0
     * ```
     *
     * We refer to 'file:projects/my-app.tgz_25c559a5921686293a001a397be4dce0' as the temp project dependency key
     * of the temp project '@rush-temp/my-app'.
     */
    getTempProjectDependencyKey(tempProjectName) {
        const tempProjectDependencyKey = this.dependencies.get(tempProjectName);
        return tempProjectDependencyKey ? tempProjectDependencyKey : undefined;
    }
    getShrinkwrapEntryFromTempProjectDependencyKey(tempProjectDependencyKey) {
        return this.packages.get(tempProjectDependencyKey);
    }
    getShrinkwrapEntry(name, version) {
        // Version can sometimes be in the form of a path that's already in the /name/version format.
        const packageId = version.indexOf('/') !== -1 ? version : `/${name}/${version}`;
        return this.packages.get(packageId);
    }
    /**
     * Serializes the PNPM Shrinkwrap file
     *
     * @override
     */
    serialize() {
        return this._serializeInternal(false);
    }
    /**
     * Gets the resolved version number of a dependency for a specific temp project.
     * For PNPM, we can reuse the version that another project is using.
     * Note that this function modifies the shrinkwrap data if tryReusingPackageVersionsFromShrinkwrap is set to true.
     *
     * @override
     */
    tryEnsureDependencyVersion(dependencySpecifier, tempProjectName) {
        // PNPM doesn't have the same advantage of NPM, where we can skip generate as long as the
        // shrinkwrap file puts our dependency in either the top of the node_modules folder
        // or underneath the package we are looking at.
        // This is because the PNPM shrinkwrap file describes the exact links that need to be created
        // to recreate the graph..
        // Because of this, we actually need to check for a version that this package is directly
        // linked to.
        const packageName = dependencySpecifier.packageName;
        const tempProjectDependencyKey = this.getTempProjectDependencyKey(tempProjectName);
        if (!tempProjectDependencyKey) {
            return undefined;
        }
        const packageDescription = this._getPackageDescription(tempProjectDependencyKey);
        if (!packageDescription ||
            !packageDescription.dependencies ||
            !packageDescription.dependencies.hasOwnProperty(packageName)) {
            return undefined;
        }
        const dependencyKey = packageDescription.dependencies[packageName];
        return this._parsePnpmDependencyKey(packageName, dependencyKey);
    }
    /** @override */
    findOrphanedProjects(rushConfiguration) {
        // The base shrinkwrap handles orphaned projects the same across all package managers,
        // but this is only valid for non-workspace installs
        if (!this.isWorkspaceCompatible) {
            return super.findOrphanedProjects(rushConfiguration);
        }
        const orphanedProjectPaths = [];
        for (const importerKey of this.getImporterKeys()) {
            // PNPM importer keys are relative paths from the workspace root, which is the common temp folder
            const rushProjectPath = path.resolve(rushConfiguration.commonTempFolder, importerKey);
            if (!rushConfiguration.tryGetProjectForPath(rushProjectPath)) {
                orphanedProjectPaths.push(rushProjectPath);
            }
        }
        return orphanedProjectPaths;
    }
    /** @override */
    getProjectShrinkwrap(project) {
        return new PnpmProjectShrinkwrapFile_1.PnpmProjectShrinkwrapFile(this, project);
    }
    getImporterKeys() {
        // Filter out the root importer used for the generated package.json in the root
        // of the install, since we do not use this.
        return [...this.importers.keys()].filter((k) => k !== '.');
    }
    getImporterKeyByPath(workspaceRoot, projectFolder) {
        return node_core_library_1.Path.convertToSlashes(path.relative(workspaceRoot, projectFolder));
    }
    getImporter(importerKey) {
        return this.importers.get(importerKey);
    }
    /** @override */
    isWorkspaceProjectModified(project, variant) {
        const importerKey = this.getImporterKeyByPath(project.rushConfiguration.commonTempFolder, project.projectFolder);
        const importer = this.getImporter(importerKey);
        if (!importer) {
            return true;
        }
        // First, let's transform the package.json using the pnpmfile
        const packageJson = project.packageJsonEditor.saveToObject();
        // Initialize the pnpmfile if it doesn't exist
        if (!this._pnpmfileConfiguration) {
            this._pnpmfileConfiguration = new PnpmfileConfiguration_1.PnpmfileConfiguration(project.rushConfiguration, { variant });
        }
        // Use a new PackageJsonEditor since it will classify each dependency type, making tracking the
        // found versions much simpler.
        const { dependencyList, devDependencyList } = PackageJsonEditor_1.PackageJsonEditor.fromObject(this._pnpmfileConfiguration.transform(packageJson), project.packageJsonEditor.filePath);
        // Then get the unique package names and map them to package versions.
        const dependencyVersions = new Map();
        for (const packageDependency of [...dependencyList, ...devDependencyList]) {
            // We will also filter out peer dependencies since these are not installed at development time.
            if (packageDependency.dependencyType === "peerDependencies" /* Peer */) {
                continue;
            }
            const foundDependency = dependencyVersions.get(packageDependency.name);
            if (!foundDependency) {
                dependencyVersions.set(packageDependency.name, packageDependency);
            }
            else {
                // Shrinkwrap will prioritize optional dependencies, followed by regular dependencies, with dev being
                // the least prioritized. We will only keep the most prioritized option.
                // See: https://github.com/pnpm/pnpm/blob/main/packages/lockfile-utils/src/satisfiesPackageManifest.ts
                switch (foundDependency.dependencyType) {
                    case "optionalDependencies" /* Optional */:
                        break;
                    case "dependencies" /* Regular */:
                        if (packageDependency.dependencyType === "optionalDependencies" /* Optional */) {
                            dependencyVersions.set(packageDependency.name, packageDependency);
                        }
                        break;
                    case "devDependencies" /* Dev */:
                        dependencyVersions.set(packageDependency.name, packageDependency);
                        break;
                }
            }
        }
        // Then validate that the dependency fields are as expected in the shrinkwrap to avoid false-negatives
        // when moving a package from one field to the other.
        for (const dependencyVersion of dependencyVersions.values()) {
            switch (dependencyVersion.dependencyType) {
                case "optionalDependencies" /* Optional */:
                    if (!importer.optionalDependencies || !importer.optionalDependencies[dependencyVersion.name])
                        return true;
                    break;
                case "dependencies" /* Regular */:
                    if (!importer.dependencies || !importer.dependencies[dependencyVersion.name])
                        return true;
                    break;
                case "devDependencies" /* Dev */:
                    if (!importer.devDependencies || !importer.devDependencies[dependencyVersion.name])
                        return true;
                    break;
            }
        }
        // Then validate the length matches between the importer and the dependency list, since duplicates are
        // a valid use-case. Importers will only take one of these values, so no need to do more work here.
        if (dependencyVersions.size !== Object.keys(importer.specifiers).length) {
            return true;
        }
        // Finally, validate that all values in the importer are also present in the dependency list.
        for (const [importerPackageName, importerVersionSpecifier] of Object.entries(importer.specifiers)) {
            const foundDependency = dependencyVersions.get(importerPackageName);
            if (!foundDependency || foundDependency.version !== importerVersionSpecifier) {
                return true;
            }
        }
        return false;
    }
    /**
     * Gets the package description for a tempProject from the shrinkwrap file.
     */
    _getPackageDescription(tempProjectDependencyKey) {
        const packageDescription = this.packages.get(tempProjectDependencyKey);
        return packageDescription && packageDescription.dependencies ? packageDescription : undefined;
    }
    _parsePnpmDependencyKey(dependencyName, pnpmDependencyKey) {
        if (pnpmDependencyKey) {
            const result = parsePnpmDependencyKey(dependencyName, pnpmDependencyKey);
            if (!result) {
                throw new Error(`Cannot parse PNPM shrinkwrap version specifier: "${pnpmDependencyKey}"` +
                    ` for "${dependencyName}"`);
            }
            return result;
        }
        else {
            return undefined;
        }
    }
    _serializeInternal(omitImporters = false) {
        // Ensure that if any of the top-level properties are provided but empty are removed. We populate the object
        // properties when we read the shrinkwrap but PNPM does not set these top-level properties unless they are present.
        const shrinkwrapToSerialize = {};
        for (const [key, value] of Object.entries(this._shrinkwrapJson)) {
            if (omitImporters && key === 'importers') {
                continue;
            }
            if (!value || typeof value !== 'object' || Object.keys(value).length > 0) {
                shrinkwrapToSerialize[key] = value;
            }
        }
        return yamlModule.safeDump(shrinkwrapToSerialize, PnpmYamlCommon_1.PNPM_SHRINKWRAP_YAML_FORMAT);
    }
}
exports.PnpmShrinkwrapFile = PnpmShrinkwrapFile;
//# sourceMappingURL=PnpmShrinkwrapFile.js.map

/***/ }),

/***/ 16864:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PNPM_SHRINKWRAP_YAML_FORMAT = void 0;
// This is based on PNPM's own configuration:
// https://github.com/pnpm/pnpm-shrinkwrap/blob/master/src/write.ts
exports.PNPM_SHRINKWRAP_YAML_FORMAT = {
    lineWidth: 1000,
    noCompatMode: true,
    noRefs: true,
    sortKeys: true
};
//# sourceMappingURL=PnpmYamlCommon.js.map

/***/ }),

/***/ 75857:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PnpmfileConfiguration = void 0;
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const pnpmfile = __importStar(__webpack_require__(86514));
/**
 * Loads PNPM's pnpmfile.js configuration, and invokes it to preprocess package.json files,
 * optionally utilizing a pnpmfile shim to inject preferred versions.
 */
class PnpmfileConfiguration {
    constructor(rushConfiguration, pnpmfileShimOptions) {
        if (rushConfiguration.packageManager !== 'pnpm') {
            throw new Error(`PnpmfileConfiguration cannot be used with package manager "${rushConfiguration.packageManager}"`);
        }
        // Set the context to swallow log output and store our settings
        this._context = {
            log: (message) => { },
            pnpmfileShimSettings: PnpmfileConfiguration._getPnpmfileShimSettings(rushConfiguration, pnpmfileShimOptions)
        };
    }
    static async writeCommonTempPnpmfileShimAsync(rushConfiguration, options) {
        if (rushConfiguration.packageManager !== 'pnpm') {
            throw new Error(`PnpmfileConfiguration cannot be used with package manager "${rushConfiguration.packageManager}"`);
        }
        const targetDir = rushConfiguration.commonTempFolder;
        const pnpmfilePath = path.join(targetDir, rushConfiguration.packageManagerWrapper.pnpmfileFilename);
        // Write the shim itself
        await node_core_library_1.FileSystem.copyFileAsync({
            sourcePath: path.join(__dirname, 'PnpmfileShim.js'),
            destinationPath: pnpmfilePath
        });
        const pnpmfileShimSettings = PnpmfileConfiguration._getPnpmfileShimSettings(rushConfiguration, options);
        // Write the settings file used by the shim
        await node_core_library_1.JsonFile.saveAsync(pnpmfileShimSettings, path.join(targetDir, 'pnpmfileSettings.json'), {
            ensureFolderExists: true
        });
    }
    static _getPnpmfileShimSettings(rushConfiguration, options) {
        let allPreferredVersions = {};
        let allowedAlternativeVersions = {};
        // Only workspaces shims in the common versions using pnpmfile
        if (rushConfiguration.packageManagerOptions.useWorkspaces) {
            const commonVersionsConfiguration = rushConfiguration.getCommonVersions();
            const preferredVersions = new Map();
            node_core_library_1.MapExtensions.mergeFromMap(preferredVersions, commonVersionsConfiguration.getAllPreferredVersions());
            node_core_library_1.MapExtensions.mergeFromMap(preferredVersions, rushConfiguration.getImplicitlyPreferredVersions());
            allPreferredVersions = node_core_library_1.MapExtensions.toObject(preferredVersions);
            allowedAlternativeVersions = node_core_library_1.MapExtensions.toObject(commonVersionsConfiguration.allowedAlternativeVersions);
        }
        const settings = {
            allPreferredVersions,
            allowedAlternativeVersions,
            semverPath: __webpack_require__.ab + "index1.js"
        };
        // Use the provided path if available. Otherwise, use the default path.
        const userPnpmfilePath = rushConfiguration.getPnpmfilePath(options === null || options === void 0 ? void 0 : options.variant);
        if (userPnpmfilePath && node_core_library_1.FileSystem.exists(userPnpmfilePath)) {
            settings.userPnpmfilePath = userPnpmfilePath;
        }
        return settings;
    }
    /**
     * Transform a package.json file using the pnpmfile.js hook.
     * @returns the tranformed object, or the original input if pnpmfile.js was not found.
     */
    transform(packageJson) {
        var _a;
        if (!((_a = pnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.readPackage) || !this._context) {
            return packageJson;
        }
        else {
            return pnpmfile.hooks.readPackage(packageJson, this._context);
        }
    }
}
exports.PnpmfileConfiguration = PnpmfileConfiguration;
//# sourceMappingURL=PnpmfileConfiguration.js.map

/***/ }),

/***/ 86514:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
let settings;
let allPreferredVersions;
let allowedAlternativeVersions;
let userPnpmfile;
let semver;
// Initialize all external aspects of the pnpmfile shim. When using the shim, settings
// are always expected to be available. Init must be called before running any hook that
// depends on a resource obtained from or related to the settings, and will require modules
// once so they aren't repeatedly required in the hook functions.
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function init(context) {
    // Sometimes PNPM may provide us a context arg that doesn't fit spec, ex.:
    // https://github.com/pnpm/pnpm/blob/97c64bae4d14a8c8f05803f1d94075ee29c2df2f/packages/get-context/src/index.ts#L134
    // So we need to normalize the context format before we move on
    if (typeof context !== 'object' || Array.isArray(context)) {
        context = {
            log: (message) => { },
            originalContext: context
        };
    }
    if (!settings) {
        // Initialize the settings from file
        if (!context.pnpmfileShimSettings) {
            context.pnpmfileShimSettings = __webpack_require__(53223);
        }
        settings = context.pnpmfileShimSettings;
    }
    else if (!context.pnpmfileShimSettings) {
        // Reuse the already initialized settings
        context.pnpmfileShimSettings = settings;
    }
    if (!allPreferredVersions && settings.allPreferredVersions) {
        allPreferredVersions = new Map(Object.entries(settings.allPreferredVersions));
    }
    if (!allowedAlternativeVersions && settings.allowedAlternativeVersions) {
        allowedAlternativeVersions = new Map(Object.entries(settings.allowedAlternativeVersions).map(([packageName, versions]) => {
            return [packageName, new Set(versions)];
        }));
    }
    // If a userPnpmfilePath is provided, we expect it to exist
    if (!userPnpmfile && settings.userPnpmfilePath) {
        userPnpmfile = require(settings.userPnpmfilePath);
    }
    // If a semverPath is provided, we expect it to exist
    if (!semver && settings.semverPath) {
        semver = require(settings.semverPath);
    }
    // Return the normalized context
    return context;
}
// Set the preferred versions on the dependency map. If the version on the map is an allowedAlternativeVersion
// then skip it. Otherwise, check to ensure that the common version is a subset of the specified version. If
// it is, then replace the specified version with the preferredVersion
function setPreferredVersions(dependencies) {
    var _a;
    for (const [name, version] of Object.entries(dependencies || {})) {
        const preferredVersion = allPreferredVersions === null || allPreferredVersions === void 0 ? void 0 : allPreferredVersions.get(name);
        if (preferredVersion && !((_a = allowedAlternativeVersions === null || allowedAlternativeVersions === void 0 ? void 0 : allowedAlternativeVersions.get(name)) === null || _a === void 0 ? void 0 : _a.has(version))) {
            let preferredVersionRange;
            let versionRange;
            try {
                preferredVersionRange = new semver.Range(preferredVersion);
                versionRange = new semver.Range(version);
            }
            catch (_b) {
                // Swallow invalid range errors
            }
            if (preferredVersionRange &&
                versionRange &&
                semver.subset(preferredVersionRange, versionRange, { includePrerelease: true })) {
                dependencies[name] = preferredVersion;
            }
        }
    }
}
const pnpmfileShim = {
    hooks: {
        // Call the original pnpmfile (if it exists)
        afterAllResolved: (lockfile, context) => {
            var _a;
            context = init(context);
            return ((_a = userPnpmfile === null || userPnpmfile === void 0 ? void 0 : userPnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.afterAllResolved)
                ? userPnpmfile.hooks.afterAllResolved(lockfile, context)
                : lockfile;
        },
        // Set the preferred versions in the package, then call the original pnpmfile (if it exists)
        readPackage: (pkg, context) => {
            var _a;
            context = init(context);
            setPreferredVersions(pkg.dependencies);
            setPreferredVersions(pkg.devDependencies);
            setPreferredVersions(pkg.optionalDependencies);
            return ((_a = userPnpmfile === null || userPnpmfile === void 0 ? void 0 : userPnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.readPackage) ? userPnpmfile.hooks.readPackage(pkg, context) : pkg;
        }
    }
};
module.exports = pnpmfileShim;
//# sourceMappingURL=PnpmfileShim.js.map

/***/ }),

/***/ 8503:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GitEmailPolicy = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const os = __importStar(__webpack_require__(12087));
const node_core_library_1 = __webpack_require__(24019);
const Utilities_1 = __webpack_require__(89521);
const Git_1 = __webpack_require__(58361);
class GitEmailPolicy {
    static validate(rushConfiguration) {
        const git = new Git_1.Git(rushConfiguration);
        if (!git.isGitPresent()) {
            // If Git isn't installed, or this Rush project is not under a Git working folder,
            // then we don't care about the Git email
            console.log(safe_1.default.cyan('Ignoring Git validation because the Git binary was not found in the shell path.') +
                os.EOL);
            return;
        }
        if (!git.isPathUnderGitWorkingTree()) {
            // If Git isn't installed, or this Rush project is not under a Git working folder,
            // then we don't care about the Git email
            console.log(safe_1.default.cyan('Ignoring Git validation because this is not a Git working folder.' + os.EOL));
            return;
        }
        // If there isn't a Git policy, then we don't care whether the person configured
        // a Git email address at all.  This helps people who don't
        if (rushConfiguration.gitAllowedEmailRegExps.length === 0) {
            if (git.tryGetGitEmail() === undefined) {
                return;
            }
            // Otherwise, if an email *is* configured at all, then we still perform the basic
            // sanity checks (e.g. no spaces in the address).
        }
        let userEmail;
        try {
            userEmail = git.getGitEmail();
            // sanity check; a valid email should not contain any whitespace
            // if this fails, then we have another issue to report
            if (!userEmail.match(/^\S+$/g)) {
                console.log([
                    safe_1.default.red('Your Git email address is invalid: ' + JSON.stringify(userEmail)),
                    '',
                    `To configure your Git email address, try something like this:`,
                    '',
                    ...GitEmailPolicy.getEmailExampleLines(rushConfiguration),
                    ''
                ].join(os.EOL));
                throw new node_core_library_1.AlreadyReportedError();
            }
        }
        catch (e) {
            if (e instanceof node_core_library_1.AlreadyReportedError) {
                console.log(safe_1.default.red('Aborting, so you can go fix your settings.  (Or use --bypass-policy to skip.)'));
                throw e;
            }
            else {
                throw e;
            }
        }
        if (rushConfiguration.gitAllowedEmailRegExps.length === 0) {
            // If there is no policy, then we're good
            return;
        }
        console.log('Checking Git policy for this repository.' + os.EOL);
        // If there is a policy, at least one of the RegExp's must match
        for (const pattern of rushConfiguration.gitAllowedEmailRegExps) {
            const regex = new RegExp(`^${pattern}$`, 'i');
            if (userEmail.match(regex)) {
                return;
            }
        }
        // Show the user's name as well.
        // Ex. "Mr. Example <mr@example.com>"
        let fancyEmail = safe_1.default.cyan(userEmail);
        try {
            const userName = Utilities_1.Utilities.executeCommandAndCaptureOutput(git.gitPath, ['config', 'user.name'], '.').trim();
            if (userName) {
                fancyEmail = `${userName} <${fancyEmail}>`;
            }
        }
        catch (e) {
            // but if it fails, this isn't critical, so don't bother them about it
        }
        console.log([
            'Hey there!  To keep things tidy, this repo asks you to submit your Git commits using an email like ' +
                (rushConfiguration.gitAllowedEmailRegExps.length > 1 ? 'one of these patterns:' : 'this pattern:'),
            '',
            ...rushConfiguration.gitAllowedEmailRegExps.map((pattern) => '    ' + safe_1.default.cyan(pattern)),
            '',
            '...but yours is configured like this:',
            '',
            `    ${fancyEmail}`,
            '',
            'To fix it, you can use commands like this:',
            '',
            ...GitEmailPolicy.getEmailExampleLines(rushConfiguration),
            ''
        ].join(os.EOL));
        console.log(safe_1.default.red('Aborting, so you can go fix your settings.  (Or use --bypass-policy to skip.)'));
        throw new node_core_library_1.AlreadyReportedError();
    }
    static getEmailExampleLines(rushConfiguration) {
        return [
            safe_1.default.cyan('    git config --local user.name "Mr. Example"'),
            safe_1.default.cyan(`    git config --local user.email "${rushConfiguration.gitSampleEmail || 'example@contoso.com'}"`)
        ];
    }
}
exports.GitEmailPolicy = GitEmailPolicy;
//# sourceMappingURL=GitEmailPolicy.js.map

/***/ }),

/***/ 40499:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PolicyValidator = void 0;
const GitEmailPolicy_1 = __webpack_require__(8503);
const ShrinkwrapFilePolicy_1 = __webpack_require__(35098);
class PolicyValidator {
    static validatePolicy(rushConfiguration, options) {
        if (options.bypassPolicy) {
            return;
        }
        GitEmailPolicy_1.GitEmailPolicy.validate(rushConfiguration);
        if (!options.allowShrinkwrapUpdates) {
            // Don't validate the shrinkwrap if updates are allowed, as it's likely to change
            // It also may have merge conflict markers, which PNPM can gracefully handle, but the validator cannot
            ShrinkwrapFilePolicy_1.ShrinkwrapFilePolicy.validate(rushConfiguration, options);
        }
    }
}
exports.PolicyValidator = PolicyValidator;
//# sourceMappingURL=PolicyValidator.js.map

/***/ }),

/***/ 35098:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShrinkwrapFilePolicy = void 0;
const os = __importStar(__webpack_require__(12087));
const ShrinkwrapFileFactory_1 = __webpack_require__(94237);
/**
 *  A policy that validates shrinkwrap files used by package managers.
 */
class ShrinkwrapFilePolicy {
    static validate(rushConfiguration, options) {
        console.log('Validating package manager shrinkwrap file.' + os.EOL);
        const shrinkwrapFile = ShrinkwrapFileFactory_1.ShrinkwrapFileFactory.getShrinkwrapFile(rushConfiguration.packageManager, rushConfiguration.packageManagerOptions, rushConfiguration.getCommittedShrinkwrapFilename(options.shrinkwrapVariant));
        if (!shrinkwrapFile) {
            console.log('Shrinkwrap file could not be found, skipping validation.' + os.EOL);
            return;
        }
        // Run shrinkwrap-specific validation
        shrinkwrapFile.validate(rushConfiguration.packageManagerOptions, Object.assign(Object.assign({}, options), { repoState: rushConfiguration.getRepoState(options.shrinkwrapVariant) }), rushConfiguration.experimentsConfiguration.configuration);
    }
}
exports.ShrinkwrapFilePolicy = ShrinkwrapFilePolicy;
//# sourceMappingURL=ShrinkwrapFilePolicy.js.map

/***/ }),

/***/ 61009:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArtifactoryConfiguration = void 0;
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
/**
 * Use this class to load the "common/config/rush/artifactory.json" config file.
 * It configures the "rush setup" command.
 */
class ArtifactoryConfiguration {
    /**
     * @internal
     */
    constructor(jsonFileName) {
        this._jsonFileName = jsonFileName;
        this._setupJson = {
            packageRegistry: {
                enabled: false,
                registryUrl: '',
                artifactoryWebsiteUrl: ''
            }
        };
        if (node_core_library_1.FileSystem.exists(this._jsonFileName)) {
            this._setupJson = node_core_library_1.JsonFile.loadAndValidate(this._jsonFileName, ArtifactoryConfiguration._jsonSchema);
        }
    }
    /**
     * Get the experiments configuration.
     */
    get configuration() {
        return this._setupJson;
    }
}
exports.ArtifactoryConfiguration = ArtifactoryConfiguration;
ArtifactoryConfiguration._jsonSchema = node_core_library_1.JsonSchema.fromFile(path.resolve(__dirname, '..', '..', 'schemas', 'artifactory.schema.json'));
//# sourceMappingURL=ArtifactoryConfiguration.js.map

/***/ }),

/***/ 19886:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeyboardLoop = void 0;
const readline = __importStar(__webpack_require__(51058));
const process = __importStar(__webpack_require__(61765));
const node_core_library_1 = __webpack_require__(24019);
// TODO: Integrate these into the AnsiEscape API in @rushstack/node-core-library
// As part of that work we should generalize the "Colors" API to support more general
// terminal escapes, and simplify the interface for that API.
const ANSI_ESCAPE_SHOW_CURSOR = '\u001B[?25l';
const ANSI_ESCAPE_HIDE_CURSOR = '\u001B[?25h';
class KeyboardLoop {
    constructor() {
        this._cursorHidden = false;
        this._onKeypress = (character, key) => {
            if (key.name === 'c' && key.ctrl && !key.meta && !key.shift) {
                // Intercept CTRL+C
                process.kill(process.pid, 'SIGINT');
                return;
            }
            try {
                this.onKeypress(character, key);
            }
            catch (error) {
                throw new node_core_library_1.InternalError('Uncaught exception in Prompter.onKeypress(): ' + error.toString());
            }
        };
        this.stdin = process.stdin;
        this.stderr = process.stderr;
    }
    get capturedInput() {
        return this._readlineInterface !== undefined;
    }
    _captureInput() {
        if (this._readlineInterface) {
            return;
        }
        this._readlineInterface = readline.createInterface({ input: this.stdin });
        readline.emitKeypressEvents(process.stdin);
        this.stdin.setRawMode(true);
        this.stdin.addListener('keypress', this._onKeypress);
    }
    _uncaptureInput() {
        if (!this._readlineInterface) {
            return;
        }
        this.stdin.removeListener('keypress', this._onKeypress);
        this.stdin.setRawMode(false);
        this._readlineInterface.close();
        this._readlineInterface = undefined;
    }
    hideCursor() {
        if (this._cursorHidden) {
            return;
        }
        this._cursorHidden = true;
        this.stderr.write(ANSI_ESCAPE_SHOW_CURSOR);
    }
    unhideCursor() {
        if (!this._cursorHidden) {
            return;
        }
        this._cursorHidden = false;
        this.stderr.write(ANSI_ESCAPE_HIDE_CURSOR);
    }
    async startAsync() {
        try {
            this._captureInput();
            this.onStart();
            await new Promise((resolve, reject) => {
                this._resolvePromise = resolve;
                this._rejectPromise = reject;
            });
        }
        finally {
            this._uncaptureInput();
            this.unhideCursor();
        }
    }
    resolveAsync() {
        if (!this._resolvePromise) {
            return;
        }
        this._resolvePromise();
        this._resolvePromise = undefined;
        this._rejectPromise = undefined;
    }
    rejectAsync(error) {
        if (!this._rejectPromise) {
            return;
        }
        this._rejectPromise(error);
        this._resolvePromise = undefined;
        this._rejectPromise = undefined;
    }
    /** @virtual */
    onStart() { }
    /** @virtual */
    onKeypress(character, key) { }
}
exports.KeyboardLoop = KeyboardLoop;
//# sourceMappingURL=KeyboardLoop.js.map

/***/ }),

/***/ 61295:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetupPackageRegistry = void 0;
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const terminal_1 = __webpack_require__(11253);
const Utilities_1 = __webpack_require__(89521);
const ArtifactoryConfiguration_1 = __webpack_require__(61009);
const WebClient_1 = __webpack_require__(80168);
const TerminalInput_1 = __webpack_require__(65823);
const defaultMessages = {
    introduction: 'This monorepo consumes packages from an Artifactory private NPM registry.',
    obtainAnAccount: 'Please contact the repository maintainers for help with setting up an Artifactory user account.',
    visitWebsite: 'Please open this URL in your web browser:',
    locateUserName: 'Your user name appears in the upper-right corner of the JFrog website.',
    locateApiKey: 'Click "Edit Profile" on the JFrog website.  Click the "Generate API Key"' +
        " button if you haven't already done so previously."
};
class SetupPackageRegistry {
    constructor(options) {
        this._options = options;
        this.rushConfiguration = options.rushConfiguration;
        this._terminal = new node_core_library_1.Terminal(new node_core_library_1.ConsoleTerminalProvider({
            verboseEnabled: options.isDebug
        }));
        this._artifactoryConfiguration = new ArtifactoryConfiguration_1.ArtifactoryConfiguration(path.join(this.rushConfiguration.commonRushConfigFolder, 'artifactory.json'));
        this._messages = Object.assign(Object.assign({}, defaultMessages), this._artifactoryConfiguration.configuration.packageRegistry.messageOverrides);
    }
    _writeInstructionBlock(message) {
        if (message === '') {
            return;
        }
        this._terminal.writeLine(terminal_1.PrintUtilities.wrapWords(message));
        this._terminal.writeLine();
    }
    /**
     * Test whether the NPM token is valid.
     *
     * @returns - `true` if valid, `false` if not valid
     */
    async checkOnly() {
        var _a;
        const packageRegistry = this._artifactoryConfiguration.configuration.packageRegistry;
        if (!packageRegistry.enabled) {
            this._terminal.writeVerbose('Skipping package registry setup because packageRegistry.enabled=false');
            return true;
        }
        const registryUrl = ((packageRegistry === null || packageRegistry === void 0 ? void 0 : packageRegistry.registryUrl) || '').trim();
        if (registryUrl.length === 0) {
            throw new Error('The "registryUrl" setting in artifactory.json is missing or empty');
        }
        if (!this._options.syncNpmrcAlreadyCalled) {
            Utilities_1.Utilities.syncNpmrc(this.rushConfiguration.commonRushConfigFolder, this.rushConfiguration.commonTempFolder);
        }
        // Artifactory does not implement the "npm ping" protocol or any equivalent REST API.
        // But if we query a package that is known not to exist, Artifactory will only return
        // a 404 error if it is successfully authenticated.  We can use this negative query
        // to validate the credentials.
        const npmArgs = [
            'view',
            '@rushstack/nonexistent-package',
            '--json',
            '--registry=' + packageRegistry.registryUrl
        ];
        this._terminal.writeLine('Testing access to private NPM registry: ' + packageRegistry.registryUrl);
        const result = node_core_library_1.Executable.spawnSync('npm', npmArgs, {
            currentWorkingDirectory: this.rushConfiguration.commonTempFolder,
            stdio: ['ignore', 'pipe', 'pipe'],
            // Wait at most 10 seconds for "npm view" to succeed
            timeoutMs: 10 * 1000
        });
        this._terminal.writeLine();
        // (This is not exactly correct, for example Node.js puts a string in error.errno instead of a string.)
        const error = result.error;
        if (error) {
            if (error.code === 'ETIMEDOUT') {
                // For example, an incorrect "https-proxy" setting can hang for a long time
                throw new Error('The "npm view" command timed out; check your .npmrc file for an incorrect setting');
            }
            throw new Error('Error invoking "npm view": ' + result.error);
        }
        if (result.status === 0) {
            throw new node_core_library_1.InternalError('"npm view" unexpectedly succeeded');
        }
        // NPM 6.x writes to stdout
        let jsonContent = SetupPackageRegistry._tryFindJson(result.stdout);
        if (jsonContent === undefined) {
            // NPM 7.x writes dirty output to stderr; see https://github.com/npm/cli/issues/2740
            jsonContent = SetupPackageRegistry._tryFindJson(result.stderr);
        }
        if (jsonContent === undefined) {
            throw new node_core_library_1.InternalError('The "npm view" command did not return a JSON structure');
        }
        let jsonOutput;
        try {
            jsonOutput = JSON.parse(jsonContent);
        }
        catch (error) {
            this._terminal.writeVerboseLine('NPM response:\n\n--------\n' + jsonContent + '\n--------\n\n');
            throw new node_core_library_1.InternalError('The "npm view" command returned an invalid JSON structure');
        }
        const errorCode = (_a = jsonOutput === null || jsonOutput === void 0 ? void 0 : jsonOutput.error) === null || _a === void 0 ? void 0 : _a.code;
        if (typeof errorCode !== 'string') {
            this._terminal.writeVerboseLine('NPM response:\n' + JSON.stringify(jsonOutput, undefined, 2) + '\n\n');
            throw new node_core_library_1.InternalError('The "npm view" command returned unexpected output');
        }
        switch (errorCode) {
            case 'E404':
                this._terminal.writeLine('NPM credentials are working');
                this._terminal.writeLine();
                return true;
            case 'E401':
            case 'E403':
                this._terminal.writeVerboseLine('NPM response:\n' + JSON.stringify(jsonOutput, undefined, 2) + '\n\n');
                // Credentials are missing or expired
                return false;
            default:
                this._terminal.writeVerboseLine('NPM response:\n' + JSON.stringify(jsonOutput, undefined, 2) + '\n\n');
                throw new Error(`The "npm view" command returned an unexpected error code "${errorCode}"`);
        }
    }
    /**
     * Test whether the NPM token is valid.  If not, prompt to update it.
     */
    async checkAndSetup() {
        if (await this.checkOnly()) {
            return;
        }
        this._terminal.writeWarningLine('NPM credentials are missing or expired');
        this._terminal.writeLine();
        const packageRegistry = this._artifactoryConfiguration.configuration.packageRegistry;
        const fixThisProblem = await TerminalInput_1.TerminalInput.promptYesNo({
            message: 'Fix this problem now?',
            defaultValue: false
        });
        this._terminal.writeLine();
        if (!fixThisProblem) {
            return;
        }
        this._writeInstructionBlock(this._messages.introduction);
        const hasArtifactoryAccount = await TerminalInput_1.TerminalInput.promptYesNo({
            message: 'Do you already have an Artifactory user account?'
        });
        this._terminal.writeLine();
        if (!hasArtifactoryAccount) {
            this._writeInstructionBlock(this._messages.obtainAnAccount);
            throw new node_core_library_1.AlreadyReportedError();
        }
        if (this._messages.visitWebsite) {
            this._writeInstructionBlock(this._messages.visitWebsite);
            const artifactoryWebsiteUrl = this._artifactoryConfiguration.configuration.packageRegistry.artifactoryWebsiteUrl;
            if (artifactoryWebsiteUrl) {
                this._terminal.writeLine('  ', node_core_library_1.Colors.cyan(artifactoryWebsiteUrl));
                this._terminal.writeLine();
            }
        }
        this._writeInstructionBlock(this._messages.locateUserName);
        let artifactoryUser = await TerminalInput_1.TerminalInput.promptLine({
            message: 'What is your Artifactory user name?'
        });
        this._terminal.writeLine();
        artifactoryUser = artifactoryUser.trim();
        if (artifactoryUser.length === 0) {
            this._terminal.writeLine(node_core_library_1.Colors.red('Operation aborted because the input was empty'));
            this._terminal.writeLine();
            throw new node_core_library_1.AlreadyReportedError();
        }
        this._writeInstructionBlock(this._messages.locateApiKey);
        let artifactoryKey = await TerminalInput_1.TerminalInput.promptPasswordLine({
            message: 'What is your Artifactory API key?'
        });
        this._terminal.writeLine();
        artifactoryKey = artifactoryKey.trim();
        if (artifactoryKey.length === 0) {
            this._terminal.writeLine(node_core_library_1.Colors.red('Operation aborted because the input was empty'));
            this._terminal.writeLine();
            throw new node_core_library_1.AlreadyReportedError();
        }
        await this._fetchTokenAndUpdateNpmrc(artifactoryUser, artifactoryKey, packageRegistry);
    }
    /**
     * Fetch a valid NPM token from the Artifactory service and add it to the `~/.npmrc` file,
     * preserving other settings in that file.
     */
    async _fetchTokenAndUpdateNpmrc(artifactoryUser, artifactoryKey, packageRegistry) {
        this._terminal.writeLine('\nFetching an NPM token from the Artifactory service...');
        const webClient = new WebClient_1.WebClient();
        webClient.addBasicAuthHeader(artifactoryUser, artifactoryKey);
        let queryUrl = packageRegistry.registryUrl;
        if (!queryUrl.endsWith('/')) {
            queryUrl += '/';
        }
        // There doesn't seem to be a way to invoke the "/auth" REST endpoint without a resource name.
        // Artifactory's NPM folders always seem to contain a ".npm" folder, so we can use that to obtain
        // our token.
        queryUrl += `auth/.npm`;
        let response;
        try {
            response = await webClient.fetchAsync(queryUrl);
        }
        catch (e) {
            console.log(e.toString());
            return;
        }
        if (!response.ok) {
            if (response.status === 401) {
                throw new Error('Authorization failed; the Artifactory user name or API key may be incorrect.');
            }
            throw new Error(`The Artifactory request failed:\n  (${response.status}) ${response.statusText}`);
        }
        // We expect a response like this:
        //
        //   @.npm:registry=https://your-company.jfrog.io/your-artifacts/api/npm/npm-private/
        //   //your-company.jfrog.io/your-artifacts/api/npm/npm-private/:_password=dGhlIHRva2VuIGdvZXMgaGVyZQ==
        //   //your-company.jfrog.io/your-artifacts/api/npm/npm-private/:username=your.name@your-company.com
        //   //your-company.jfrog.io/your-artifacts/api/npm/npm-private/:email=your.name@your-company.com
        //   //your-company.jfrog.io/your-artifacts/api/npm/npm-private/:always-auth=true
        const responseText = await response.text();
        const responseLines = node_core_library_1.Text.convertToLf(responseText).trim().split('\n');
        if (responseLines.length < 2 || !responseLines[0].startsWith('@.npm:')) {
            throw new Error('Unexpected response from Artifactory');
        }
        responseLines.shift(); // Remove the @.npm line
        // These are the lines to be injected in ~/.npmrc
        const linesToAdd = [];
        // Start with userNpmrcLinesToAdd...
        if (packageRegistry.userNpmrcLinesToAdd) {
            linesToAdd.push(...packageRegistry.userNpmrcLinesToAdd);
        }
        // ...then append the stuff we got from the REST API, but discard any junk that isn't a proper key/value
        linesToAdd.push(...responseLines.filter((x) => SetupPackageRegistry._getNpmrcKey(x) !== undefined));
        const npmrcPath = path.join(Utilities_1.Utilities.getHomeFolder(), '.npmrc');
        this._mergeLinesIntoNpmrc(npmrcPath, linesToAdd);
    }
    /**
     * Update the `~/.npmrc` file by adding `linesToAdd` to it.
     * @remarks
     *
     * If the `.npmrc` file has existing content, it gets merged as follows:
     * - If `linesToAdd` contains key/value pairs and the key already appears in .npmrc,
     *   that line will be overwritten in place
     * - If `linesToAdd` contains non-key lines (e.g. a comment) and it exactly matches a
     *   line in .npmrc, then that line will be kept where it is
     * - The remaining `linesToAdd` that weren't handled by one of the two rules above
     *   are simply appended to the end of the file
     * - Under no circumstances is a duplicate key/value added to the file; in the case of
     *   duplicates, the earliest line in `linesToAdd` takes precedence
     */
    _mergeLinesIntoNpmrc(npmrcPath, linesToAdd) {
        // We'll replace entries with "undefined" if they get discarded
        const workingLinesToAdd = [...linesToAdd];
        // Now build a table of .npmrc keys that can be replaced if they already exist in the file.
        // For example, if we are adding "always-auth=false" then we should delete an existing line
        // that says "always-auth=true".
        const keysToReplace = new Map(); // key --> linesToAdd index
        for (let index = 0; index < workingLinesToAdd.length; ++index) {
            const lineToAdd = workingLinesToAdd[index];
            const key = SetupPackageRegistry._getNpmrcKey(lineToAdd);
            if (key !== undefined) {
                // If there are duplicate keys, the first one takes precedence.
                // In particular this means "userNpmrcLinesToAdd" takes precedence over the REST API response
                if (keysToReplace.has(key)) {
                    // Discard the duplicate key
                    workingLinesToAdd[index] = undefined;
                }
                else {
                    keysToReplace.set(key, index);
                }
            }
        }
        this._terminal.writeLine();
        this._terminal.writeLine(node_core_library_1.Colors.green('Adding Artifactory token to: '), npmrcPath);
        const npmrcLines = [];
        if (node_core_library_1.FileSystem.exists(npmrcPath)) {
            const npmrcContent = node_core_library_1.FileSystem.readFile(npmrcPath, { convertLineEndings: "\n" /* Lf */ });
            npmrcLines.push(...npmrcContent.trimRight().split('\n'));
        }
        if (npmrcLines.length === 1 && npmrcLines[0] === '') {
            // Edge case where split() adds a blank line to the start of the file
            npmrcLines.length = 0;
        }
        // Make a set of existing .npmrc lines that are not key/value pairs.
        const npmrcNonKeyLinesSet = new Set();
        for (const npmrcLine of npmrcLines) {
            const trimmed = npmrcLine.trim();
            if (trimmed.length > 0) {
                if (SetupPackageRegistry._getNpmrcKey(trimmed) === undefined) {
                    npmrcNonKeyLinesSet.add(trimmed);
                }
            }
        }
        // Overwrite any existing lines that match a key from "linesToAdd"
        for (let index = 0; index < npmrcLines.length; ++index) {
            const line = npmrcLines[index];
            const key = SetupPackageRegistry._getNpmrcKey(line);
            if (key) {
                const linesToAddIndex = keysToReplace.get(key);
                if (linesToAddIndex !== undefined) {
                    npmrcLines[index] = workingLinesToAdd[linesToAddIndex] || '';
                    // Delete it since it's been replaced
                    keysToReplace.delete(key);
                    // Also remove it from "linesToAdd"
                    workingLinesToAdd[linesToAddIndex] = undefined;
                }
            }
        }
        if (npmrcLines.length > 0 && npmrcLines[npmrcLines.length - 1] !== '') {
            // Append a blank line
            npmrcLines.push('');
        }
        // Add any remaining values that weren't matched above
        for (const lineToAdd of workingLinesToAdd) {
            // If a line is undefined, that means we already used it to replace an existing line above
            if (lineToAdd !== undefined) {
                // If a line belongs to npmrcNonKeyLinesSet, then we should not add it because it's
                // already in the .npmrc file
                if (!npmrcNonKeyLinesSet.has(lineToAdd.trim())) {
                    npmrcLines.push(lineToAdd);
                }
            }
        }
        // Save the result
        node_core_library_1.FileSystem.writeFile(npmrcPath, npmrcLines.join('\n').trimRight() + '\n');
    }
    static _getNpmrcKey(npmrcLine) {
        if (SetupPackageRegistry._isCommentLine(npmrcLine)) {
            return undefined;
        }
        const delimiterIndex = npmrcLine.indexOf('=');
        if (delimiterIndex < 1) {
            return undefined;
        }
        const key = npmrcLine.substring(0, delimiterIndex + 1);
        return key.trim();
    }
    static _isCommentLine(npmrcLine) {
        return /^\s*#/.test(npmrcLine);
    }
    /**
     * This is a workaround for https://github.com/npm/cli/issues/2740 where the NPM tool sometimes
     * mixes together JSON and terminal messages in a single STDERR stream.
     *
     * @remarks
     * Given an input like this:
     * ```
     * npm ERR! 404 Note that you can also install from a
     * npm ERR! 404 tarball, folder, http url, or git url.
     * {
     *   "error": {
     *     "code": "E404",
     *     "summary": "Not Found - GET https://registry.npmjs.org/@rushstack%2fnonexistent-package - Not found"
     *   }
     * }
     * npm ERR! A complete log of this run can be found in:
     * ```
     *
     * @returns the JSON section, or `undefined` if a JSON object could not be detected
     */
    static _tryFindJson(dirtyOutput) {
        const lines = dirtyOutput.split(/\r?\n/g);
        let startIndex;
        let endIndex;
        // Find the first line that starts with "{"
        for (let i = 0; i < lines.length; ++i) {
            const line = lines[i];
            if (/^\s*\{/.test(line)) {
                startIndex = i;
                break;
            }
        }
        if (startIndex === undefined) {
            return undefined;
        }
        // Find the last line that ends with "}"
        for (let i = lines.length - 1; i >= startIndex; --i) {
            const line = lines[i];
            if (/\}\s*$/.test(line)) {
                endIndex = i;
                break;
            }
        }
        if (endIndex === undefined) {
            return undefined;
        }
        return lines.slice(startIndex, endIndex + 1).join('\n');
    }
}
exports.SetupPackageRegistry = SetupPackageRegistry;
//# sourceMappingURL=SetupPackageRegistry.js.map

/***/ }),

/***/ 65823:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TerminalInput = void 0;
const readline = __importStar(__webpack_require__(51058));
const process = __importStar(__webpack_require__(61765));
const safe_1 = __importDefault(__webpack_require__(41997));
const node_core_library_1 = __webpack_require__(24019);
const KeyboardLoop_1 = __webpack_require__(19886);
class YesNoKeyboardLoop extends KeyboardLoop_1.KeyboardLoop {
    constructor(options) {
        super();
        this.result = undefined;
        this.options = options;
    }
    onStart() {
        this.stderr.write(safe_1.default.green('==>') + ' ');
        this.stderr.write(safe_1.default.bold(this.options.message));
        let optionSuffix = '';
        switch (this.options.defaultValue) {
            case true:
                optionSuffix = '(Y/n)';
                break;
            case false:
                optionSuffix = '(y/N)';
                break;
            default:
                optionSuffix = '(y/n)';
                break;
        }
        this.stderr.write(' ' + safe_1.default.bold(optionSuffix) + ' ');
    }
    onKeypress(character, key) {
        if (this.result !== undefined) {
            return;
        }
        switch (key.name) {
            case 'y':
                this.result = true;
                break;
            case 'n':
                this.result = false;
                break;
            case 'enter':
            case 'return':
                if (this.options.defaultValue !== undefined) {
                    this.result = this.options.defaultValue;
                }
                break;
        }
        if (this.result !== undefined) {
            this.stderr.write(this.result ? 'Yes\n' : 'No\n');
            this.resolveAsync();
            return;
        }
    }
}
class PasswordKeyboardLoop extends KeyboardLoop_1.KeyboardLoop {
    constructor(options) {
        super();
        this._startX = 0;
        this._printedY = 0;
        this._lastPrintedLength = 0;
        this.result = '';
        this._options = options;
        this._passwordCharacter =
            this._options.passwordCharacter === undefined ? '*' : this._options.passwordCharacter.substr(0, 1);
    }
    _getLineWrapWidth() {
        return this.stderr.columns ? this.stderr.columns : 80;
    }
    onStart() {
        this.result = '';
        readline.cursorTo(this.stderr, 0);
        readline.clearLine(this.stderr, 1);
        const prefix = safe_1.default.green('==>') + ' ' + safe_1.default.bold(this._options.message) + ' ';
        this.stderr.write(prefix);
        let lineStartIndex = prefix.lastIndexOf('\n');
        if (lineStartIndex < 0) {
            lineStartIndex = 0;
        }
        const line = prefix.substring(lineStartIndex);
        this._startX = node_core_library_1.AnsiEscape.removeCodes(line).length % this._getLineWrapWidth();
    }
    onKeypress(character, key) {
        switch (key.name) {
            case 'enter':
            case 'return':
                if (this._passwordCharacter !== '') {
                    // To avoid disclosing the length of the password, after the user presses ENTER,
                    // replace the "*********" sequence with exactly three stars ("***").
                    this._render(this._passwordCharacter.repeat(3));
                }
                this.stderr.write('\n');
                this.resolveAsync();
                return;
            case 'backspace':
                this.result = this.result.substring(0, this.result.length - 1);
                this._render(this.result);
                break;
            default:
                let printable = true;
                if (character === '') {
                    printable = false;
                }
                else if (key.name && key.name.length !== 1 && key.name !== 'space') {
                    printable = false;
                }
                else if (!key.name && !key.sequence) {
                    printable = false;
                }
                if (printable) {
                    this.result += character;
                    this._render(this.result);
                }
        }
    }
    _render(text) {
        // Optimize rendering when we don't need to erase anything
        const needsClear = text.length < this._lastPrintedLength;
        this._lastPrintedLength = text.length;
        this.hideCursor();
        // Restore Y
        while (this._printedY > 0) {
            readline.cursorTo(this.stderr, 0);
            if (needsClear) {
                readline.clearLine(this.stderr, 1);
            }
            readline.moveCursor(this.stderr, 0, -1);
            --this._printedY;
        }
        // Restore X
        readline.cursorTo(this.stderr, this._startX);
        let i = 0;
        let column = this._startX;
        this._printedY = 0;
        let buffer = '';
        while (i < text.length) {
            if (this._passwordCharacter === '') {
                buffer += text.substr(i, 1);
            }
            else {
                buffer += this._passwordCharacter;
            }
            ++i;
            ++column;
            // -1 to avoid weird TTY behavior in final column
            if (column >= this._getLineWrapWidth() - 1) {
                column = 0;
                ++this._printedY;
                buffer += '\n';
            }
        }
        this.stderr.write(buffer);
        if (needsClear) {
            readline.clearLine(this.stderr, 1);
        }
        this.unhideCursor();
    }
}
class TerminalInput {
    static async _readLine() {
        const readlineInterface = readline.createInterface({ input: process.stdin });
        try {
            return await new Promise((resolve, reject) => {
                readlineInterface.question('', (answer) => {
                    resolve(answer);
                });
            });
        }
        finally {
            readlineInterface.close();
        }
    }
    static async promptYesNo(options) {
        const keyboardLoop = new YesNoKeyboardLoop(options);
        await keyboardLoop.startAsync();
        return keyboardLoop.result;
    }
    static async promptLine(options) {
        const stderr = process.stderr;
        stderr.write(safe_1.default.green('==>') + ' ');
        stderr.write(safe_1.default.bold(options.message));
        stderr.write(' ');
        return await TerminalInput._readLine();
    }
    static async promptPasswordLine(options) {
        const keyboardLoop = new PasswordKeyboardLoop(options);
        await keyboardLoop.startAsync();
        return keyboardLoop.result;
    }
}
exports.TerminalInput = TerminalInput;
//# sourceMappingURL=TerminalInput.js.map

/***/ }),

/***/ 73489:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseBuilder = void 0;
/**
 * The `Task` class is a node in the dependency graph of work that needs to be scheduled by the `TaskRunner`.
 * Each `Task` has a `BaseBuilder` member, whose subclass manages the actual operations for building a single
 * project.
 */
class BaseBuilder {
}
exports.BaseBuilder = BaseBuilder;
//# sourceMappingURL=BaseBuilder.js.map

/***/ }),

/***/ 57081:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertSlashesForWindows = exports.ProjectBuilder = void 0;
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const terminal_1 = __webpack_require__(11253);
const stream_collator_1 = __webpack_require__(59486);
const Utilities_1 = __webpack_require__(89521);
const TaskStatus_1 = __webpack_require__(9116);
const TaskError_1 = __webpack_require__(22654);
const BaseBuilder_1 = __webpack_require__(73489);
const ProjectLogWritable_1 = __webpack_require__(48092);
const ProjectBuildCache_1 = __webpack_require__(71389);
const RushProjectConfiguration_1 = __webpack_require__(19847);
const CollatedTerminalProvider_1 = __webpack_require__(86944);
const RushConstants_1 = __webpack_require__(63985);
function _areShallowEqual(object1, object2) {
    for (const n in object1) {
        if (!(n in object2) || object1[n] !== object2[n]) {
            return false;
        }
    }
    for (const n in object2) {
        if (!(n in object1)) {
            return false;
        }
    }
    return true;
}
/**
 * A `BaseBuilder` subclass that builds a Rush project and updates its package-deps-hash
 * incremental state.
 */
class ProjectBuilder extends BaseBuilder_1.BaseBuilder {
    constructor(options) {
        super();
        this.hadEmptyScript = false;
        /**
         * UNINITIALIZED === we haven't tried to initialize yet
         * undefined === we didn't create one because the feature is not enabled
         */
        this._projectBuildCache = Utilities_1.UNINITIALIZED;
        this._rushProject = options.rushProject;
        this._rushConfiguration = options.rushConfiguration;
        this._buildCacheConfiguration = options.buildCacheConfiguration;
        this._commandName = options.commandName;
        this._commandToRun = options.commandToRun;
        this._isCacheReadAllowed = options.isIncrementalBuildAllowed;
        this.isSkipAllowed = options.isIncrementalBuildAllowed;
        this._projectChangeAnalyzer = options.projectChangeAnalyzer;
        this._packageDepsFilename = options.packageDepsFilename;
        this._allowWarningsInSuccessfulBuild = options.allowWarningsInSuccessfulBuild || false;
    }
    get name() {
        return ProjectBuilder.getTaskName(this._rushProject);
    }
    /**
     * A helper method to determine the task name of a ProjectBuilder. Used when the task
     * name is required before a task is created.
     */
    static getTaskName(rushProject) {
        return rushProject.packageName;
    }
    async executeAsync(context) {
        try {
            if (!this._commandToRun) {
                this.hadEmptyScript = true;
            }
            return await this._executeTaskAsync(context);
        }
        catch (error) {
            throw new TaskError_1.TaskError('executing', error.message);
        }
    }
    async tryWriteCacheEntryAsync(terminal, trackedFilePaths, repoCommandLineConfiguration) {
        const projectBuildCache = await this._getProjectBuildCacheAsync(terminal, trackedFilePaths, repoCommandLineConfiguration);
        return projectBuildCache === null || projectBuildCache === void 0 ? void 0 : projectBuildCache.trySetCacheEntryAsync(terminal);
    }
    async _executeTaskAsync(context) {
        // TERMINAL PIPELINE:
        //
        //                             +--> quietModeTransform? --> collatedWriter
        //                             |
        // normalizeNewlineTransform --1--> stderrLineTransform --2--> removeColorsTransform --> projectLogWritable
        //                                                        |
        //                                                        +--> stdioSummarizer
        const projectLogWritable = new ProjectLogWritable_1.ProjectLogWritable(this._rushProject, context.collatedWriter.terminal);
        try {
            const removeColorsTransform = new terminal_1.TextRewriterTransform({
                destination: projectLogWritable,
                removeColors: true,
                normalizeNewlines: "os" /* OsDefault */
            });
            const splitterTransform2 = new terminal_1.SplitterTransform({
                destinations: [removeColorsTransform, context.stdioSummarizer]
            });
            const stderrLineTransform = new terminal_1.StderrLineTransform({
                destination: splitterTransform2,
                newlineKind: "\n" /* Lf */ // for StdioSummarizer
            });
            const discardTransform = new terminal_1.DiscardStdoutTransform({
                destination: context.collatedWriter
            });
            const splitterTransform1 = new terminal_1.SplitterTransform({
                destinations: [context.quietMode ? discardTransform : context.collatedWriter, stderrLineTransform]
            });
            const normalizeNewlineTransform = new terminal_1.TextRewriterTransform({
                destination: splitterTransform1,
                normalizeNewlines: "\n" /* Lf */,
                ensureNewlineAtEnd: true
            });
            const collatedTerminal = new stream_collator_1.CollatedTerminal(normalizeNewlineTransform);
            const terminalProvider = new CollatedTerminalProvider_1.CollatedTerminalProvider(collatedTerminal, {
                debugEnabled: context.debugMode
            });
            const terminal = new node_core_library_1.Terminal(terminalProvider);
            let hasWarningOrError = false;
            const projectFolder = this._rushProject.projectFolder;
            let lastProjectBuildDeps = undefined;
            const currentDepsPath = path.join(this._rushProject.projectRushTempFolder, this._packageDepsFilename);
            if (node_core_library_1.FileSystem.exists(currentDepsPath)) {
                try {
                    lastProjectBuildDeps = node_core_library_1.JsonFile.load(currentDepsPath);
                }
                catch (e) {
                    // Warn and ignore - treat failing to load the file as the project being not built.
                    terminal.writeWarningLine(`Warning: error parsing ${this._packageDepsFilename}: ${e}. Ignoring and ` +
                        `treating the command "${this._commandToRun}" as not run.`);
                }
            }
            let projectBuildDeps;
            let trackedFiles;
            try {
                const fileHashes = await this._projectChangeAnalyzer._tryGetProjectDependenciesAsync(this._rushProject.packageName, terminal);
                if (fileHashes) {
                    const files = {};
                    trackedFiles = [];
                    for (const [filePath, fileHash] of fileHashes) {
                        files[filePath] = fileHash;
                        trackedFiles.push(filePath);
                    }
                    projectBuildDeps = {
                        files,
                        arguments: this._commandToRun
                    };
                }
                else if (this.isSkipAllowed) {
                    // To test this code path:
                    // Remove the `.git` folder then run "rush build --verbose"
                    terminal.writeLine({
                        text: terminal_1.PrintUtilities.wrapWords('This workspace does not appear to be tracked by Git. ' +
                            'Rush will proceed without incremental build, caching, and change detection.'),
                        foregroundColor: node_core_library_1.ColorValue.Cyan
                    });
                }
            }
            catch (error) {
                // To test this code path:
                // Delete a project's ".rush/temp/shrinkwrap-deps.json" then run "rush build --verbose"
                terminal.writeLine('Unable to calculate incremental build state: ' + error.toString());
                terminal.writeLine({
                    text: 'Rush will proceed without incremental build, caching, and change detection.',
                    foregroundColor: node_core_library_1.ColorValue.Cyan
                });
            }
            // If possible, we want to skip this build -- either by restoring it from the
            // build cache, if build caching is enabled, or determining that the project
            // is unchanged (using the older incremental build logic). These two approaches,
            // "caching" and "skipping", are incompatible, so only one applies.
            //
            // Note that "build caching" and "build skipping" take two different approaches
            // to tracking dependents:
            //
            //   - For build caching, "isCacheReadAllowed" is set if a project supports
            //     incremental builds, and determining whether this project or a dependent
            //     has changed happens inside the hashing logic.
            //
            //   - For build skipping, "isSkipAllowed" is set to true initially, and during
            //     the process of building dependents, it will be changed by TaskRunner to
            //     false if a dependency wasn't able to be skipped.
            //
            let buildCacheReadAttempted = false;
            if (this._isCacheReadAllowed) {
                const projectBuildCache = await this._getProjectBuildCacheAsync(terminal, trackedFiles, context.repoCommandLineConfiguration);
                buildCacheReadAttempted = !!projectBuildCache;
                const restoreFromCacheSuccess = await (projectBuildCache === null || projectBuildCache === void 0 ? void 0 : projectBuildCache.tryRestoreFromCacheAsync(terminal));
                if (restoreFromCacheSuccess) {
                    return TaskStatus_1.TaskStatus.FromCache;
                }
            }
            if (this.isSkipAllowed && !buildCacheReadAttempted) {
                const isPackageUnchanged = !!(lastProjectBuildDeps &&
                    projectBuildDeps &&
                    projectBuildDeps.arguments === lastProjectBuildDeps.arguments &&
                    _areShallowEqual(projectBuildDeps.files, lastProjectBuildDeps.files));
                if (isPackageUnchanged) {
                    return TaskStatus_1.TaskStatus.Skipped;
                }
            }
            // If the deps file exists, remove it before starting a build.
            node_core_library_1.FileSystem.deleteFile(currentDepsPath);
            // TODO: Remove legacyDepsPath with the next major release of Rush
            const legacyDepsPath = path.join(this._rushProject.projectFolder, 'package-deps.json');
            // Delete the legacy package-deps.json
            node_core_library_1.FileSystem.deleteFile(legacyDepsPath);
            if (!this._commandToRun) {
                // Write deps on success.
                if (projectBuildDeps) {
                    node_core_library_1.JsonFile.save(projectBuildDeps, currentDepsPath, {
                        ensureFolderExists: true
                    });
                }
                return TaskStatus_1.TaskStatus.Success;
            }
            // Run the task
            terminal.writeLine('Invoking: ' + this._commandToRun);
            const task = Utilities_1.Utilities.executeLifecycleCommandAsync(this._commandToRun, {
                rushConfiguration: this._rushConfiguration,
                workingDirectory: projectFolder,
                initCwd: this._rushConfiguration.commonTempFolder,
                handleOutput: true,
                environmentPathOptions: {
                    includeProjectBin: true
                }
            });
            // Hook into events, in order to get live streaming of build log
            if (task.stdout !== null) {
                task.stdout.on('data', (data) => {
                    const text = data.toString();
                    collatedTerminal.writeChunk({ text, kind: "O" /* Stdout */ });
                });
            }
            if (task.stderr !== null) {
                task.stderr.on('data', (data) => {
                    const text = data.toString();
                    collatedTerminal.writeChunk({ text, kind: "E" /* Stderr */ });
                    hasWarningOrError = true;
                });
            }
            let status = await new Promise((resolve, reject) => {
                task.on('close', (code) => {
                    try {
                        if (code !== 0) {
                            reject(new TaskError_1.TaskError('error', `Returned error code: ${code}`));
                        }
                        else if (hasWarningOrError) {
                            resolve(TaskStatus_1.TaskStatus.SuccessWithWarning);
                        }
                        else {
                            resolve(TaskStatus_1.TaskStatus.Success);
                        }
                    }
                    catch (error) {
                        reject(error);
                    }
                });
            });
            const taskIsSuccessful = status === TaskStatus_1.TaskStatus.Success ||
                (status === TaskStatus_1.TaskStatus.SuccessWithWarning &&
                    this._allowWarningsInSuccessfulBuild &&
                    !!this._rushConfiguration.experimentsConfiguration.configuration
                        .buildCacheWithAllowWarningsInSuccessfulBuild);
            if (taskIsSuccessful && projectBuildDeps) {
                // Write deps on success.
                const writeProjectStatePromise = node_core_library_1.JsonFile.saveAsync(projectBuildDeps, currentDepsPath, {
                    ensureFolderExists: true
                });
                // If the command is successful and we can calculate project hash, we will write a
                // new cache entry even if incremental builds are not allowed.
                const setCacheEntryPromise = this.tryWriteCacheEntryAsync(terminal, trackedFiles, context.repoCommandLineConfiguration);
                const [, cacheWriteSuccess] = await Promise.all([writeProjectStatePromise, setCacheEntryPromise]);
                if (terminalProvider.hasErrors) {
                    status = TaskStatus_1.TaskStatus.Failure;
                }
                else if (cacheWriteSuccess === false) {
                    status = TaskStatus_1.TaskStatus.SuccessWithWarning;
                }
            }
            normalizeNewlineTransform.close();
            // If the pipeline is wired up correctly, then closing normalizeNewlineTransform should
            // have closed projectLogWritable.
            if (projectLogWritable.isOpen) {
                throw new node_core_library_1.InternalError('The output file handle was not closed');
            }
            return status;
        }
        finally {
            projectLogWritable.close();
        }
    }
    async _getProjectBuildCacheAsync(terminal, trackedProjectFiles, commandLineConfiguration) {
        var _a;
        if (this._projectBuildCache === Utilities_1.UNINITIALIZED) {
            this._projectBuildCache = undefined;
            if (this._buildCacheConfiguration && this._buildCacheConfiguration.buildCacheEnabled) {
                const projectConfiguration = await RushProjectConfiguration_1.RushProjectConfiguration.tryLoadForProjectAsync(this._rushProject, commandLineConfiguration, terminal);
                if (projectConfiguration) {
                    if ((_a = projectConfiguration.cacheOptions) === null || _a === void 0 ? void 0 : _a.disableBuildCache) {
                        terminal.writeVerboseLine('Caching has been disabled for this project.');
                    }
                    else {
                        const commandOptions = projectConfiguration.cacheOptions.optionsForCommandsByName.get(this._commandName);
                        if (commandOptions === null || commandOptions === void 0 ? void 0 : commandOptions.disableBuildCache) {
                            terminal.writeVerboseLine(`Caching has been disabled for this project's "${this._commandName}" command.`);
                        }
                        else {
                            this._projectBuildCache = await ProjectBuildCache_1.ProjectBuildCache.tryGetProjectBuildCache({
                                projectConfiguration,
                                buildCacheConfiguration: this._buildCacheConfiguration,
                                terminal,
                                command: this._commandToRun,
                                trackedProjectFiles: trackedProjectFiles,
                                projectChangeAnalyzer: this._projectChangeAnalyzer
                            });
                        }
                    }
                }
                else {
                    terminal.writeVerboseLine(`Project does not have a ${RushConstants_1.RushConstants.rushProjectConfigFilename} configuration file, ` +
                        'or one provided by a rig, so it does not support caching.');
                }
            }
        }
        return this._projectBuildCache;
    }
}
exports.ProjectBuilder = ProjectBuilder;
/**
 * When running a command from the "scripts" block in package.json, if the command
 * contains Unix-style path slashes and the OS is Windows, the package managers will
 * convert slashes to backslashes.  This is a complicated undertaking.  For example, they
 * need to convert "node_modules/bin/this && ./scripts/that --name keep/this"
 * to "node_modules\bin\this && .\scripts\that --name keep/this", and they don't want to
 * convert ANY of the slashes in "cmd.exe /c echo a/b".  NPM and PNPM use npm-lifecycle for this,
 * but it unfortunately has a dependency on the entire node-gyp kitchen sink.  Yarn has a
 * simplified implementation in fix-cmd-win-slashes.js, but it's not exposed as a library.
 *
 * Fundamentally NPM's whole feature seems misguided:  They start by inviting people to write
 * shell scripts that will be executed by wildly different shell languages (e.g. cmd.exe and Bash).
 * It's very tricky for a developer to guess what's safe to do without testing every OS.
 * Even simple path separators are not portable, so NPM added heuristics to figure out which
 * slashes are part of a path or not, and convert them.  These workarounds end up having tons
 * of special cases.  They probably could have implemented their own entire minimal cross-platform
 * shell language with less code and less confusion than npm-lifecycle's approach.
 *
 * We've deprecated shell operators inside package.json.  Instead, we advise people to move their
 * scripts into conventional script files, and put only a file path in package.json.  So, for
 * Rush's workaround here, we really only care about supporting the small set of cases seen in the
 * unit tests.  For anything that doesn't fit those patterns, we leave the string untouched
 * (i.e. err on the side of not breaking anything).  We could revisit this later if someone
 * complains about it, but so far nobody has.  :-)
 */
function convertSlashesForWindows(command) {
    // The first group will match everything up to the first space, "&", "|", "<", ">", or quote.
    // The second group matches the remainder.
    const commandRegExp = /^([^\s&|<>"]+)(.*)$/;
    const match = commandRegExp.exec(command);
    if (match) {
        // Example input: "bin/blarg --path ./config/blah.json && a/b"
        // commandPart="bin/blarg"
        // remainder=" --path ./config/blah.json && a/b"
        const commandPart = match[1];
        const remainder = match[2];
        // If the command part already contains a backslash, then leave it alone
        if (commandPart.indexOf('\\') < 0) {
            // Replace all the slashes with backslashes, e.g. to produce:
            // "bin\blarg --path ./config/blah.json && a/b"
            //
            // NOTE: we don't attempt to process the path parameter or stuff after "&&"
            return node_core_library_1.Text.replaceAll(commandPart, '/', '\\') + remainder;
        }
    }
    // Don't change anything
    return command;
}
exports.convertSlashesForWindows = convertSlashesForWindows;
//# sourceMappingURL=ProjectBuilder.js.map

/***/ }),

/***/ 48092:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProjectLogWritable = void 0;
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const terminal_1 = __webpack_require__(11253);
const PackageNameParsers_1 = __webpack_require__(39458);
class ProjectLogWritable extends terminal_1.TerminalWritable {
    constructor(project, terminal) {
        super();
        this._buildLogWriter = undefined;
        this._errorLogWriter = undefined;
        this._project = project;
        this._terminal = terminal;
        const unscopedProjectName = PackageNameParsers_1.PackageNameParsers.permissive.getUnscopedName(this._project.packageName);
        this._buildLogPath = path.join(this._project.projectFolder, `${unscopedProjectName}.build.log`);
        this._errorLogPath = path.join(this._project.projectFolder, `${unscopedProjectName}.build.error.log`);
        node_core_library_1.FileSystem.deleteFile(this._buildLogPath);
        node_core_library_1.FileSystem.deleteFile(this._errorLogPath);
        this._buildLogWriter = node_core_library_1.FileWriter.open(this._buildLogPath);
    }
    onWriteChunk(chunk) {
        if (!this._buildLogWriter) {
            throw new node_core_library_1.InternalError('Output file was closed');
        }
        // Both stderr and stdout get written to *.build.log
        this._buildLogWriter.write(chunk.text);
        if (chunk.kind === "E" /* Stderr */) {
            // Only stderr gets written to *.build.error.log
            if (!this._errorLogWriter) {
                this._errorLogWriter = node_core_library_1.FileWriter.open(this._errorLogPath);
            }
            this._errorLogWriter.write(chunk.text);
        }
    }
    onClose() {
        if (this._buildLogWriter) {
            try {
                this._buildLogWriter.close();
            }
            catch (error) {
                this._terminal.writeStderrLine('Failed to close file handle for ' + this._buildLogWriter.filePath);
            }
            this._buildLogWriter = undefined;
        }
        if (this._errorLogWriter) {
            try {
                this._errorLogWriter.close();
            }
            catch (error) {
                this._terminal.writeStderrLine('Failed to close file handle for ' + this._errorLogWriter.filePath);
            }
            this._errorLogWriter = undefined;
        }
    }
}
exports.ProjectLogWritable = ProjectLogWritable;
//# sourceMappingURL=ProjectLogWritable.js.map

/***/ }),

/***/ 58213:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Task = void 0;
/**
 * The `Task` class is a node in the dependency graph of work that needs to be scheduled by the `TaskRunner`.
 * Each `Task` has a `BaseBuilder` member, whose subclass manages the actual operations for building a single
 * project.
 */
class Task {
    constructor(builder, initialStatus) {
        /**
         * A set of all dependencies which must be executed before this task is complete.
         * When dependencies finish execution, they are removed from this list.
         */
        this.dependencies = new Set();
        /**
         * The inverse of dependencies, lists all projects which are directly dependent on this one.
         */
        this.dependents = new Set();
        this.builder = builder;
        this.status = initialStatus;
    }
    get name() {
        return this.builder.name;
    }
}
exports.Task = Task;
//# sourceMappingURL=Task.js.map

/***/ }),

/***/ 2683:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskCollection = void 0;
const node_core_library_1 = __webpack_require__(24019);
const Task_1 = __webpack_require__(58213);
const TaskStatus_1 = __webpack_require__(9116);
/**
 * This class represents a set of tasks with interdependencies.  Any class of task definition
 * may be registered, and dependencies between tasks are easily specified. There is a check for
 * cyclic dependencies and tasks are ordered based on critical path.
 */
class TaskCollection {
    constructor() {
        this._tasks = new Map();
    }
    /**
     * Registers a task definition to the map of defined tasks
     */
    addTask(builder) {
        if (this._tasks.has(builder.name)) {
            throw new Error('A task with that name has already been registered.');
        }
        const task = new Task_1.Task(builder, TaskStatus_1.TaskStatus.Ready);
        task.criticalPathLength = undefined;
        this._tasks.set(task.name, task);
    }
    /**
     * Returns true if a task with that name has been registered
     */
    hasTask(taskName) {
        return this._tasks.has(taskName);
    }
    /**
     * Defines the list of dependencies for an individual task.
     * @param taskName - the string name of the task for which we are defining dependencies. A task with this
     * name must already have been registered.
     */
    addDependencies(taskName, taskDependencies) {
        const task = this._tasks.get(taskName);
        if (!task) {
            throw new Error(`The task '${taskName}' has not been registered`);
        }
        if (!taskDependencies) {
            throw new Error('The list of dependencies must be defined');
        }
        for (const dependencyName of taskDependencies) {
            if (!this._tasks.has(dependencyName)) {
                throw new Error(`The project '${dependencyName}' has not been registered.`);
            }
            const dependency = this._tasks.get(dependencyName);
            task.dependencies.add(dependency);
            dependency.dependents.add(task);
        }
    }
    /**
     * Returns the tasks registered with the collection ordered by the critical path.
     * It also makes sure there are no cyclic dependencies in the tasks.
     */
    getOrderedTasks() {
        this._checkForCyclicDependencies(this._tasks.values(), [], new Set());
        // Precalculate the number of dependent packages
        this._tasks.forEach((task) => {
            this._calculateCriticalPaths(task);
        });
        const buildQueue = [];
        // Add everything to the buildQueue
        this._tasks.forEach((task) => {
            buildQueue.push(task);
        });
        // Sort the queue in descending order, nothing will mess with the order
        node_core_library_1.Sort.sortBy(buildQueue, (task) => -task.criticalPathLength);
        return buildQueue;
    }
    /**
     * Checks for projects that indirectly depend on themselves.
     */
    _checkForCyclicDependencies(tasks, dependencyChain, alreadyCheckedProjects) {
        for (const task of tasks) {
            if (dependencyChain.indexOf(task.name) >= 0) {
                throw new Error('A cyclic dependency was encountered:\n' +
                    '  ' +
                    [...dependencyChain, task.name].reverse().join('\n  -> ') +
                    '\nConsider using the cyclicDependencyProjects option for rush.json.');
            }
            if (!alreadyCheckedProjects.has(task.name)) {
                alreadyCheckedProjects.add(task.name);
                dependencyChain.push(task.name);
                this._checkForCyclicDependencies(task.dependents, dependencyChain, alreadyCheckedProjects);
                dependencyChain.pop();
            }
        }
    }
    /**
     * Calculate the number of packages which must be built before we reach
     * the furthest away "root" node
     */
    _calculateCriticalPaths(task) {
        // Return the memoized value
        if (task.criticalPathLength !== undefined) {
            return task.criticalPathLength;
        }
        // If no dependents, we are in a "root"
        if (task.dependents.size === 0) {
            task.criticalPathLength = 0;
            return task.criticalPathLength;
        }
        else {
            // Otherwise we are as long as the longest package + 1
            const depsLengths = [];
            task.dependents.forEach((dep) => depsLengths.push(this._calculateCriticalPaths(dep)));
            task.criticalPathLength = Math.max(...depsLengths) + 1;
            return task.criticalPathLength;
        }
    }
}
exports.TaskCollection = TaskCollection;
//# sourceMappingURL=TaskCollection.js.map

/***/ }),

/***/ 22654:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BuildTaskError = exports.TaskError = void 0;
/**
 * Encapsulates information about an error
 */
class TaskError extends Error {
    constructor(type, message) {
        super(message);
        this._type = type;
    }
    get message() {
        return `[${this._type}] '${super.message}'`;
    }
    toString() {
        return this.message;
    }
}
exports.TaskError = TaskError;
/**
 * TestTaskError extends TaskError
 */
class BuildTaskError extends TaskError {
    constructor(type, message, file, line, offset) {
        super(type, message);
        this._file = file;
        this._line = line;
        this._offset = offset;
    }
    get message() {
        // Example: "C:\Project\Blah.ts(123,1): [tslint] error no-any: 'any' is not allowed"
        return `${this._file}(${this._line},${this._offset}): ${super.message}`;
    }
    toString() {
        return this.message;
    }
}
exports.BuildTaskError = BuildTaskError;
//# sourceMappingURL=TaskError.js.map

/***/ }),

/***/ 58883:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskRunner = void 0;
const os = __importStar(__webpack_require__(12087));
const safe_1 = __importDefault(__webpack_require__(41997));
const terminal_1 = __webpack_require__(11253);
const stream_collator_1 = __webpack_require__(59486);
const node_core_library_1 = __webpack_require__(24019);
const Stopwatch_1 = __webpack_require__(80414);
const TaskStatus_1 = __webpack_require__(9116);
/**
 * A class which manages the execution of a set of tasks with interdependencies.
 * Initially, and at the end of each task execution, all unblocked tasks
 * are added to a ready queue which is then executed. This is done continually until all
 * tasks are complete, or prematurely fails if any of the tasks fail.
 */
class TaskRunner {
    constructor(orderedTasks, options) {
        this._streamCollator_onWriterActive = (writer) => {
            if (writer) {
                this._completedTasks++;
                // Format a header like this
                //
                // ==[ @rushstack/the-long-thing ]=================[ 1 of 1000 ]==
                // leftPart: "==[ @rushstack/the-long-thing "
                const leftPart = safe_1.default.gray('==[') + ' ' + safe_1.default.cyan(writer.taskName) + ' ';
                const leftPartLength = 4 + writer.taskName.length + 1;
                // rightPart: " 1 of 1000 ]=="
                const completedOfTotal = `${this._completedTasks} of ${this._totalTasks}`;
                const rightPart = ' ' + safe_1.default.white(completedOfTotal) + ' ' + safe_1.default.gray(']==');
                const rightPartLength = 1 + completedOfTotal.length + 4;
                // middlePart: "]=================["
                const twoBracketsLength = 2;
                const middlePartLengthMinusTwoBrackets = Math.max(TaskRunner._ASCII_HEADER_WIDTH - (leftPartLength + rightPartLength + twoBracketsLength), 0);
                const middlePart = safe_1.default.gray(']' + '='.repeat(middlePartLengthMinusTwoBrackets) + '[');
                this._terminal.writeStdoutLine('\n' + leftPart + middlePart + rightPart);
                if (!this._quietMode) {
                    this._terminal.writeStdoutLine('');
                }
            }
        };
        const { quietMode, debugMode, parallelism, changedProjectsOnly, allowWarningsInSuccessfulBuild, repoCommandLineConfiguration } = options;
        this._tasks = orderedTasks;
        this._buildQueue = orderedTasks.slice(0);
        this._quietMode = quietMode;
        this._debugMode = debugMode;
        this._hasAnyFailures = false;
        this._hasAnyWarnings = false;
        this._changedProjectsOnly = changedProjectsOnly;
        this._allowWarningsInSuccessfulBuild = allowWarningsInSuccessfulBuild;
        this._repoCommandLineConfiguration = repoCommandLineConfiguration;
        // TERMINAL PIPELINE:
        //
        // streamCollator --> colorsNewlinesTransform --> StdioWritable
        //
        this._outputWritable = options.destination ? options.destination : terminal_1.StdioWritable.instance;
        this._colorsNewlinesTransform = new terminal_1.TextRewriterTransform({
            destination: this._outputWritable,
            normalizeNewlines: "os" /* OsDefault */,
            removeColors: !safe_1.default.enabled
        });
        this._streamCollator = new stream_collator_1.StreamCollator({
            destination: this._colorsNewlinesTransform,
            onWriterActive: this._streamCollator_onWriterActive
        });
        this._terminal = this._streamCollator.terminal;
        const numberOfCores = os.cpus().length;
        if (parallelism) {
            if (parallelism === 'max') {
                this._parallelism = numberOfCores;
            }
            else {
                const parallelismInt = parseInt(parallelism, 10);
                if (isNaN(parallelismInt)) {
                    throw new Error(`Invalid parallelism value of '${parallelism}', expected a number or 'max'`);
                }
                this._parallelism = parallelismInt;
            }
        }
        else {
            // If an explicit parallelism number wasn't provided, then choose a sensible
            // default.
            if (os.platform() === 'win32') {
                // On desktop Windows, some people have complained that their system becomes
                // sluggish if Rush is using all the CPU cores.  Leave one thread for
                // other operations. For CI environments, you can use the "max" argument to use all available cores.
                this._parallelism = Math.max(numberOfCores - 1, 1);
            }
            else {
                // Unix-like operating systems have more balanced scheduling, so default
                // to the number of CPU cores
                this._parallelism = numberOfCores;
            }
        }
    }
    /**
     * Executes all tasks which have been registered, returning a promise which is resolved when all the
     * tasks are completed successfully, or rejects when any task fails.
     */
    async executeAsync() {
        this._currentActiveTasks = 0;
        this._completedTasks = 0;
        this._totalTasks = this._tasks.length;
        if (!this._quietMode) {
            const plural = this._tasks.length === 1 ? '' : 's';
            this._terminal.writeStdoutLine(`Selected ${this._tasks.length} project${plural}:`);
            this._terminal.writeStdoutLine(this._tasks
                .map((x) => `  ${x.name}`)
                .sort()
                .join('\n'));
            this._terminal.writeStdoutLine('');
        }
        this._terminal.writeStdoutLine(`Executing a maximum of ${this._parallelism} simultaneous processes...`);
        await this._startAvailableTasksAsync();
        this._printTaskStatus();
        if (this._hasAnyFailures) {
            this._terminal.writeStderrLine(safe_1.default.red('Projects failed to build.') + '\n');
            throw new node_core_library_1.AlreadyReportedError();
        }
        else if (this._hasAnyWarnings && !this._allowWarningsInSuccessfulBuild) {
            this._terminal.writeStderrLine(safe_1.default.yellow('Projects succeeded with warnings.') + '\n');
            throw new node_core_library_1.AlreadyReportedError();
        }
    }
    /**
     * Pulls the next task with no dependencies off the build queue
     * Removes any non-ready tasks from the build queue (this should only be blocked tasks)
     */
    _getNextTask() {
        for (let i = 0; i < this._buildQueue.length; i++) {
            const task = this._buildQueue[i];
            if (task.status !== TaskStatus_1.TaskStatus.Ready) {
                // It shouldn't be on the queue, remove it
                this._buildQueue.splice(i, 1);
                // Decrement since we modified the array
                i--;
            }
            else if (task.dependencies.size === 0 && task.status === TaskStatus_1.TaskStatus.Ready) {
                // this is a task which is ready to go. remove it and return it
                return this._buildQueue.splice(i, 1)[0];
            }
            // Otherwise task is still waiting
        }
        return undefined; // There are no tasks ready to go at this time
    }
    /**
     * Helper function which finds any tasks which are available to run and begins executing them.
     * It calls the complete callback when all tasks are completed, or rejects if any task fails.
     */
    async _startAvailableTasksAsync() {
        const taskPromises = [];
        let ctask;
        while (this._currentActiveTasks < this._parallelism && (ctask = this._getNextTask())) {
            this._currentActiveTasks++;
            const task = ctask;
            task.status = TaskStatus_1.TaskStatus.Executing;
            task.stopwatch = Stopwatch_1.Stopwatch.start();
            task.collatedWriter = this._streamCollator.registerTask(task.name);
            task.stdioSummarizer = new terminal_1.StdioSummarizer();
            taskPromises.push(this._executeTaskAndChainAsync(task));
        }
        await Promise.all(taskPromises);
    }
    async _executeTaskAndChainAsync(task) {
        const context = {
            repoCommandLineConfiguration: this._repoCommandLineConfiguration,
            stdioSummarizer: task.stdioSummarizer,
            collatedWriter: task.collatedWriter,
            quietMode: this._quietMode,
            debugMode: this._debugMode
        };
        try {
            const result = await task.builder.executeAsync(context);
            task.stopwatch.stop();
            task.stdioSummarizer.close();
            this._currentActiveTasks--;
            switch (result) {
                case TaskStatus_1.TaskStatus.Success:
                    this._markTaskAsSuccess(task);
                    break;
                case TaskStatus_1.TaskStatus.SuccessWithWarning:
                    this._hasAnyWarnings = true;
                    this._markTaskAsSuccessWithWarning(task);
                    break;
                case TaskStatus_1.TaskStatus.FromCache:
                    this._markTaskAsFromCache(task);
                    break;
                case TaskStatus_1.TaskStatus.Skipped:
                    this._markTaskAsSkipped(task);
                    break;
                case TaskStatus_1.TaskStatus.Failure:
                    this._hasAnyFailures = true;
                    this._markTaskAsFailed(task);
                    break;
            }
        }
        catch (error) {
            task.stdioSummarizer.close();
            this._currentActiveTasks--;
            this._hasAnyFailures = true;
            // eslint-disable-next-line require-atomic-updates
            task.error = error;
            this._markTaskAsFailed(task);
        }
        task.collatedWriter.close();
        await this._startAvailableTasksAsync();
    }
    /**
     * Marks a task as having failed and marks each of its dependents as blocked
     */
    _markTaskAsFailed(task) {
        if (task.error) {
            task.collatedWriter.terminal.writeStderrLine(task.error.message);
        }
        task.collatedWriter.terminal.writeStderrLine(safe_1.default.red(`"${task.name}" failed to build.`));
        task.status = TaskStatus_1.TaskStatus.Failure;
        task.dependents.forEach((dependent) => {
            this._markTaskAsBlocked(dependent, task);
        });
    }
    /**
     * Marks a task and all its dependents as blocked
     */
    _markTaskAsBlocked(blockedTask, failedTask) {
        if (blockedTask.status === TaskStatus_1.TaskStatus.Ready) {
            this._completedTasks++;
            // Note: We cannot write to task.collatedWriter because "blockedTask" will be skipped
            failedTask.collatedWriter.terminal.writeStdoutLine(`"${blockedTask.name}" is blocked by "${failedTask.name}".`);
            blockedTask.status = TaskStatus_1.TaskStatus.Blocked;
            blockedTask.dependents.forEach((dependent) => {
                this._markTaskAsBlocked(dependent, failedTask);
            });
        }
    }
    /**
     * Marks a task as being completed, and removes it from the dependencies list of all its dependents
     */
    _markTaskAsSuccess(task) {
        if (task.builder.hadEmptyScript) {
            task.collatedWriter.terminal.writeStdoutLine(safe_1.default.green(`"${task.name}" had an empty script.`));
        }
        else {
            task.collatedWriter.terminal.writeStdoutLine(safe_1.default.green(`"${task.name}" completed successfully in ${task.stopwatch.toString()}.`));
        }
        task.status = TaskStatus_1.TaskStatus.Success;
        task.dependents.forEach((dependent) => {
            if (!this._changedProjectsOnly) {
                dependent.builder.isSkipAllowed = false;
            }
            dependent.dependencies.delete(task);
        });
    }
    /**
     * Marks a task as being completed, but with warnings written to stderr, and removes it from the dependencies
     * list of all its dependents
     */
    _markTaskAsSuccessWithWarning(task) {
        task.collatedWriter.terminal.writeStderrLine(safe_1.default.yellow(`"${task.name}" completed with warnings in ${task.stopwatch.toString()}.`));
        task.status = TaskStatus_1.TaskStatus.SuccessWithWarning;
        task.dependents.forEach((dependent) => {
            if (!this._changedProjectsOnly) {
                dependent.builder.isSkipAllowed = false;
            }
            dependent.dependencies.delete(task);
        });
    }
    /**
     * Marks a task as skipped.
     */
    _markTaskAsSkipped(task) {
        task.collatedWriter.terminal.writeStdoutLine(safe_1.default.green(`${task.name} was skipped.`));
        task.status = TaskStatus_1.TaskStatus.Skipped;
        task.dependents.forEach((dependent) => {
            dependent.dependencies.delete(task);
        });
    }
    /**
     * Marks a task as provided by cache.
     */
    _markTaskAsFromCache(task) {
        task.collatedWriter.terminal.writeStdoutLine(safe_1.default.green(`${task.name} was restored from the build cache.`));
        task.status = TaskStatus_1.TaskStatus.FromCache;
        task.dependents.forEach((dependent) => {
            dependent.dependencies.delete(task);
        });
    }
    /**
     * Prints out a report of the status of each project
     */
    _printTaskStatus() {
        const tasksByStatus = {};
        for (const task of this._tasks) {
            switch (task.status) {
                // These are the sections that we will report below
                case TaskStatus_1.TaskStatus.Skipped:
                case TaskStatus_1.TaskStatus.FromCache:
                case TaskStatus_1.TaskStatus.Success:
                case TaskStatus_1.TaskStatus.SuccessWithWarning:
                case TaskStatus_1.TaskStatus.Blocked:
                case TaskStatus_1.TaskStatus.Failure:
                    break;
                default:
                    // This should never happen
                    throw new node_core_library_1.InternalError('Unexpected task status: ' + task.status);
            }
            if (tasksByStatus[task.status]) {
                tasksByStatus[task.status].push(task);
            }
            else {
                tasksByStatus[task.status] = [task];
            }
        }
        // Skip a few lines before we start the summary
        this._terminal.writeStdoutLine('');
        this._terminal.writeStdoutLine('');
        this._terminal.writeStdoutLine('');
        // These are ordered so that the most interesting statuses appear last:
        this._writeCondensedSummary(TaskStatus_1.TaskStatus.Skipped, tasksByStatus, safe_1.default.green, 'These projects were already up to date:');
        this._writeCondensedSummary(TaskStatus_1.TaskStatus.FromCache, tasksByStatus, safe_1.default.green, 'These projects were restored from the build cache:');
        this._writeCondensedSummary(TaskStatus_1.TaskStatus.Success, tasksByStatus, safe_1.default.green, 'These projects completed successfully:');
        this._writeDetailedSummary(TaskStatus_1.TaskStatus.SuccessWithWarning, tasksByStatus, safe_1.default.yellow, 'WARNING');
        this._writeCondensedSummary(TaskStatus_1.TaskStatus.Blocked, tasksByStatus, safe_1.default.white, 'These projects were blocked by dependencies that failed:');
        this._writeDetailedSummary(TaskStatus_1.TaskStatus.Failure, tasksByStatus, safe_1.default.red);
        this._terminal.writeStdoutLine('');
    }
    _writeCondensedSummary(status, tasksByStatus, headingColor, preamble) {
        // Example:
        //
        // ==[ BLOCKED: 4 projects ]==============================================================
        //
        // These projects were blocked by dependencies that failed:
        //   @scope/name
        //   e
        //   k
        const tasks = tasksByStatus[status];
        if (!tasks || tasks.length === 0) {
            return;
        }
        node_core_library_1.Sort.sortBy(tasks, (x) => x.name);
        this._writeSummaryHeader(status, tasks, headingColor);
        this._terminal.writeStdoutLine(preamble);
        const longestTaskName = Math.max(...tasks.map((x) => x.name.length));
        for (const task of tasks) {
            if (task.stopwatch && !task.builder.hadEmptyScript && task.status !== TaskStatus_1.TaskStatus.Skipped) {
                const time = task.stopwatch.toString();
                const padding = ' '.repeat(longestTaskName - task.name.length);
                this._terminal.writeStdoutLine(`  ${task.name}${padding}    ${time}`);
            }
            else {
                this._terminal.writeStdoutLine(`  ${task.name}`);
            }
        }
        this._terminal.writeStdoutLine('');
    }
    _writeDetailedSummary(status, tasksByStatus, headingColor, shortStatusName) {
        // Example:
        //
        // ==[ SUCCESS WITH WARNINGS: 2 projects ]================================
        //
        // --[ WARNINGS: f ]------------------------------------[ 5.07 seconds ]--
        //
        // [eslint] Warning: src/logic/taskRunner/TaskRunner.ts:393:3 ...
        const tasks = tasksByStatus[status];
        if (!tasks || tasks.length === 0) {
            return;
        }
        this._writeSummaryHeader(status, tasks, headingColor);
        if (shortStatusName === undefined) {
            shortStatusName = status;
        }
        for (const task of tasks) {
            // Format a header like this
            //
            // --[ WARNINGS: f ]------------------------------------[ 5.07 seconds ]--
            // leftPart: "--[ WARNINGS: f "
            const subheadingText = `${shortStatusName}: ${task.name}`;
            const leftPart = safe_1.default.gray('--[') + ' ' + headingColor(subheadingText) + ' ';
            const leftPartLength = 4 + subheadingText.length + 1;
            // rightPart: " 5.07 seconds ]--"
            const time = task.stopwatch.toString();
            const rightPart = ' ' + safe_1.default.white(time) + ' ' + safe_1.default.gray(']--');
            const rightPartLength = 1 + time.length + 1 + 3;
            // middlePart: "]----------------------["
            const twoBracketsLength = 2;
            const middlePartLengthMinusTwoBrackets = Math.max(TaskRunner._ASCII_HEADER_WIDTH - (leftPartLength + rightPartLength + twoBracketsLength), 0);
            const middlePart = safe_1.default.gray(']' + '-'.repeat(middlePartLengthMinusTwoBrackets) + '[');
            this._terminal.writeStdoutLine(leftPart + middlePart + rightPart + '\n');
            const details = task.stdioSummarizer.getReport();
            if (details) {
                // Don't write a newline, because the report will always end with a newline
                this._terminal.writeChunk({ text: details, kind: "O" /* Stdout */ });
            }
            this._terminal.writeStdoutLine('');
        }
    }
    _writeSummaryHeader(status, tasks, headingColor) {
        // Format a header like this
        //
        // ==[ FAILED: 2 projects ]================================================
        // "2 projects"
        const projectsText = tasks.length.toString() + (tasks.length === 1 ? ' project' : ' projects');
        const headingText = `${status}: ${projectsText}`;
        // leftPart: "==[ FAILED: 2 projects "
        const leftPart = safe_1.default.gray('==[') + ' ' + headingColor(headingText) + ' ';
        const leftPartLength = 3 + 1 + headingText.length + 1;
        const rightPartLengthMinusBracket = Math.max(TaskRunner._ASCII_HEADER_WIDTH - (leftPartLength + 1), 0);
        // rightPart: "]======================"
        const rightPart = safe_1.default.gray(']' + '='.repeat(rightPartLengthMinusBracket));
        this._terminal.writeStdoutLine(leftPart + rightPart);
        this._terminal.writeStdoutLine('');
    }
}
exports.TaskRunner = TaskRunner;
// Format "======" lines for a shell window with classic 80 columns
TaskRunner._ASCII_HEADER_WIDTH = 79;
//# sourceMappingURL=TaskRunner.js.map

/***/ }),

/***/ 9116:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskStatus = void 0;
/**
 * Enumeration defining potential states of a task: not started, executing, or completed
 */
var TaskStatus;
(function (TaskStatus) {
    TaskStatus["Ready"] = "READY";
    TaskStatus["Executing"] = "EXECUTING";
    TaskStatus["Success"] = "SUCCESS";
    TaskStatus["SuccessWithWarning"] = "SUCCESS WITH WARNINGS";
    TaskStatus["Skipped"] = "SKIPPED";
    TaskStatus["FromCache"] = "FROM CACHE";
    TaskStatus["Failure"] = "FAILURE";
    TaskStatus["Blocked"] = "BLOCKED";
})(TaskStatus = exports.TaskStatus || (exports.TaskStatus = {}));
//# sourceMappingURL=TaskStatus.js.map

/***/ }),

/***/ 81372:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VersionMismatchFinder = void 0;
const safe_1 = __importDefault(__webpack_require__(41997));
const node_core_library_1 = __webpack_require__(24019);
const VersionMismatchFinderProject_1 = __webpack_require__(10256);
const VersionMismatchFinderCommonVersions_1 = __webpack_require__(89333);
class VersionMismatchFinder {
    constructor(projects, allowedAlternativeVersions) {
        this._projects = projects;
        this._mismatches = new Map();
        this._allowedAlternativeVersion = allowedAlternativeVersions || new Map();
        this._analyze();
    }
    static rushCheck(rushConfiguration, options = {}) {
        VersionMismatchFinder._checkForInconsistentVersions(rushConfiguration, Object.assign(Object.assign({}, options), { isRushCheckCommand: true }));
    }
    static ensureConsistentVersions(rushConfiguration, options = {}) {
        VersionMismatchFinder._checkForInconsistentVersions(rushConfiguration, Object.assign(Object.assign({}, options), { isRushCheckCommand: false }));
    }
    /**
     * Populates a version mismatch finder object given a Rush Configuration.
     * Intentionally considers preferred versions.
     */
    static getMismatches(rushConfiguration, options = {}) {
        const commonVersions = rushConfiguration.getCommonVersions(options.variant);
        const projects = rushConfiguration.projects.map((project) => {
            return new VersionMismatchFinderProject_1.VersionMismatchFinderProject(project);
        });
        // Create an object for the purposes of reporting conflicts with preferredVersions
        // or xstitchPreferredVersions from common-versions.json
        projects.push(new VersionMismatchFinderCommonVersions_1.VersionMismatchFinderCommonVersions(commonVersions));
        return new VersionMismatchFinder(projects, commonVersions.allowedAlternativeVersions);
    }
    static _checkForInconsistentVersions(rushConfiguration, options) {
        if (rushConfiguration.ensureConsistentVersions || options.isRushCheckCommand) {
            const mismatchFinder = VersionMismatchFinder.getMismatches(rushConfiguration, options);
            if (options.printAsJson) {
                mismatchFinder.printAsJson();
            }
            else {
                mismatchFinder.print();
                if (mismatchFinder.numberOfMismatches > 0) {
                    console.log(safe_1.default.red(`Found ${mismatchFinder.numberOfMismatches} mis-matching dependencies!`));
                    throw new node_core_library_1.AlreadyReportedError();
                }
                else {
                    if (options.isRushCheckCommand) {
                        console.log(safe_1.default.green(`Found no mis-matching dependencies!`));
                    }
                }
            }
        }
    }
    get numberOfMismatches() {
        return this._mismatches.size;
    }
    getMismatches() {
        return this._getKeys(this._mismatches);
    }
    getVersionsOfMismatch(mismatch) {
        return this._mismatches.has(mismatch) ? this._getKeys(this._mismatches.get(mismatch)) : undefined;
    }
    getConsumersOfMismatch(mismatch, version) {
        const mismatchedPackage = this._mismatches.get(mismatch);
        if (!mismatchedPackage) {
            return undefined;
        }
        const mismatchedVersion = mismatchedPackage.get(version);
        return mismatchedVersion;
    }
    printAsJson() {
        const mismatchDependencies = [];
        this.getMismatches().forEach((dependency) => {
            const mismatchDependencyVersionArray = [];
            this.getVersionsOfMismatch(dependency).forEach((version) => {
                const projects = [];
                this.getConsumersOfMismatch(dependency, version).forEach((project) => {
                    projects.push(project.friendlyName);
                });
                const mismatchDependencyVersion = {
                    version: version,
                    projects: projects
                };
                mismatchDependencyVersionArray.push(mismatchDependencyVersion);
            });
            const mismatchDependency = {
                dependencyName: dependency,
                versions: mismatchDependencyVersionArray
            };
            mismatchDependencies.push(mismatchDependency);
        });
        const output = {
            mismatchedVersions: mismatchDependencies
        };
        console.log(JSON.stringify(output, undefined, 2));
    }
    print() {
        // Iterate over the list. For any dependency with mismatching versions, print the projects
        this.getMismatches().forEach((dependency) => {
            console.log(safe_1.default.yellow(dependency));
            this.getVersionsOfMismatch(dependency).forEach((version) => {
                console.log(`  ${version}`);
                this.getConsumersOfMismatch(dependency, version).forEach((project) => {
                    console.log(`   - ${project.friendlyName}`);
                });
            });
            console.log();
        });
    }
    _analyze() {
        this._projects.forEach((project) => {
            if (!project.skipRushCheck) {
                // NOTE: We do not consider peer dependencies here.  The purpose of "rush check" is
                // mainly to avoid side-by-side duplicates in the node_modules folder, whereas
                // peer dependencies are just a compatibility statement that will be satisfied by a
                // regular dependency.  (It might be useful for Rush to help people keep their peer dependency
                // patterns consistent, but on the other hand different projects may have different
                // levels of compatibility -- we should wait for someone to actually request this feature
                // before we get into that.)
                project.allDependencies.forEach((dependency) => {
                    if (dependency.dependencyType !== "peerDependencies" /* Peer */) {
                        const version = dependency.version;
                        const isCyclic = project.cyclicDependencyProjects.has(dependency.name);
                        if (this._isVersionAllowedAlternative(dependency.name, version)) {
                            return;
                        }
                        const name = dependency.name + (isCyclic ? ' (cyclic)' : '');
                        if (!this._mismatches.has(name)) {
                            this._mismatches.set(name, new Map());
                        }
                        const dependencyVersions = this._mismatches.get(name);
                        if (!dependencyVersions.has(version)) {
                            dependencyVersions.set(version, []);
                        }
                        dependencyVersions.get(version).push(project);
                    }
                });
            }
        });
        this._mismatches.forEach((mismatches, project) => {
            if (mismatches.size <= 1) {
                this._mismatches.delete(project);
            }
        });
    }
    _isVersionAllowedAlternative(dependency, version) {
        const allowedAlternatives = this._allowedAlternativeVersion.get(dependency);
        return Boolean(allowedAlternatives && allowedAlternatives.indexOf(version) > -1);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _getKeys(iterable) {
        const keys = [];
        if (iterable) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            iterable.forEach((value, key) => {
                keys.push(key);
            });
        }
        return keys;
    }
}
exports.VersionMismatchFinder = VersionMismatchFinder;
//# sourceMappingURL=VersionMismatchFinder.js.map

/***/ }),

/***/ 89333:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VersionMismatchFinderCommonVersions = void 0;
const RushConstants_1 = __webpack_require__(63985);
const PackageJsonEditor_1 = __webpack_require__(32373);
const VersionMismatchFinderEntity_1 = __webpack_require__(64260);
class VersionMismatchFinderCommonVersions extends VersionMismatchFinderEntity_1.VersionMismatchFinderEntity {
    constructor(commonVersionsConfiguration) {
        super({
            friendlyName: `preferred versions from ${RushConstants_1.RushConstants.commonVersionsFilename}`,
            cyclicDependencyProjects: new Set()
        });
        this._fileManager = commonVersionsConfiguration;
    }
    get filePath() {
        return this._fileManager.filePath;
    }
    get allDependencies() {
        const dependencies = [];
        this._fileManager.getAllPreferredVersions().forEach((version, dependencyName) => {
            dependencies.push(this._getPackageJsonDependency(dependencyName, version));
        });
        return dependencies;
    }
    tryGetDependency(packageName) {
        const version = this._fileManager.getAllPreferredVersions().get(packageName);
        if (!version) {
            return undefined;
        }
        else {
            return this._getPackageJsonDependency(packageName, version);
        }
    }
    tryGetDevDependency(packageName) {
        return undefined; // common-versions.json doesn't have a distinction between dev and non-dev dependencies
    }
    addOrUpdateDependency(packageName, newVersion, dependencyType) {
        if (dependencyType !== "dependencies" /* Regular */) {
            throw new Error(`${RushConstants_1.RushConstants.commonVersionsFilename} only accepts "${"dependencies" /* Regular */}" dependencies`);
        }
        if (this._fileManager.xstitchPreferredVersions.has(packageName)) {
            this._fileManager.xstitchPreferredVersions.set(packageName, newVersion);
        }
        else {
            this._fileManager.preferredVersions.set(packageName, newVersion);
        }
    }
    saveIfModified() {
        return this._fileManager.save();
    }
    _getPackageJsonDependency(dependencyName, version) {
        return new PackageJsonEditor_1.PackageJsonDependency(dependencyName, version, "dependencies" /* Regular */, () => this.addOrUpdateDependency(dependencyName, version, "dependencies" /* Regular */));
    }
}
exports.VersionMismatchFinderCommonVersions = VersionMismatchFinderCommonVersions;
//# sourceMappingURL=VersionMismatchFinderCommonVersions.js.map

/***/ }),

/***/ 64260:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VersionMismatchFinderEntity = void 0;
class VersionMismatchFinderEntity {
    constructor(options) {
        this.friendlyName = options.friendlyName;
        this.cyclicDependencyProjects = options.cyclicDependencyProjects;
        this.skipRushCheck = options.skipRushCheck;
    }
}
exports.VersionMismatchFinderEntity = VersionMismatchFinderEntity;
//# sourceMappingURL=VersionMismatchFinderEntity.js.map

/***/ }),

/***/ 10256:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VersionMismatchFinderProject = void 0;
const VersionMismatchFinderEntity_1 = __webpack_require__(64260);
class VersionMismatchFinderProject extends VersionMismatchFinderEntity_1.VersionMismatchFinderEntity {
    constructor(project) {
        super({
            friendlyName: project.packageName,
            cyclicDependencyProjects: project.cyclicDependencyProjects,
            skipRushCheck: project.skipRushCheck
        });
        this._fileManager = project.packageJsonEditor;
        this.packageName = project.packageName;
    }
    get filePath() {
        return this._fileManager.filePath;
    }
    get allDependencies() {
        return [...this._fileManager.dependencyList, ...this._fileManager.devDependencyList];
    }
    tryGetDependency(packageName) {
        return this._fileManager.tryGetDependency(packageName);
    }
    tryGetDevDependency(packageName) {
        return this._fileManager.tryGetDevDependency(packageName);
    }
    addOrUpdateDependency(packageName, newVersion, dependencyType) {
        return this._fileManager.addOrUpdateDependency(packageName, newVersion, dependencyType);
    }
    saveIfModified() {
        return this._fileManager.saveIfModified();
    }
}
exports.VersionMismatchFinderProject = VersionMismatchFinderProject;
//# sourceMappingURL=VersionMismatchFinderProject.js.map

/***/ }),

/***/ 86054:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.YarnShrinkwrapFile = void 0;
const os = __importStar(__webpack_require__(12087));
const BaseShrinkwrapFile_1 = __webpack_require__(74926);
const node_core_library_1 = __webpack_require__(24019);
const RushConstants_1 = __webpack_require__(63985);
const PackageNameParsers_1 = __webpack_require__(39458);
const lockfileModule = node_core_library_1.Import.lazy('@yarnpkg/lockfile', require);
/**
 * Support for consuming the "yarn.lock" file.
 *
 * Yarn refers to its shrinkwrap file as a "lock file", even though it has nothing to do
 * with file locking.  Apparently this was based on a convention of the Ruby bundler.
 * Since Rush has to work interchangeably with 3 different package managers, here we refer
 * generically to yarn.lock as a "shrinkwrap file".
 *
 * If Rush's Yarn support gains popularity, we will try to improve the wording of
 * logging messages to use terminology more consistent with Yarn's own documentation.
 */
class YarnShrinkwrapFile extends BaseShrinkwrapFile_1.BaseShrinkwrapFile {
    constructor(shrinkwrapJson) {
        super();
        this._shrinkwrapJson = shrinkwrapJson;
        this._tempProjectNames = [];
        const seenEntries = new Set();
        for (const key of Object.keys(this._shrinkwrapJson)) {
            // Example key:
            const packageNameAndSemVer = YarnShrinkwrapFile._decodePackageNameAndSemVer(key);
            // If it starts with @rush-temp, then include it:
            if (PackageNameParsers_1.PackageNameParsers.permissive.getScope(packageNameAndSemVer.packageName) ===
                RushConstants_1.RushConstants.rushTempNpmScope) {
                if (!/^file:/i.test(packageNameAndSemVer.semVerRange)) {
                    // Sanity check to make sure this is a real package.
                    // (Nobody should ever have an actual dependency on an "@rush-temp/" package.
                    throw new Error('Unexpected package/semver expression found in the Yarn shrinkwrap file (yarn.lock): ' +
                        JSON.stringify(key));
                }
                if (!seenEntries.add(packageNameAndSemVer.packageName)) {
                    // Sanity check -- this should never happen
                    throw new Error('Duplicate @rush-temp package found in the Yarn shrinkwrap file (yarn.lock): ' +
                        JSON.stringify(key));
                }
                this._tempProjectNames.push(packageNameAndSemVer.packageName);
                const entry = this._shrinkwrapJson[key];
                // Yarn fails installation if the integrity hash does not match a "file://" reference to a tarball.
                // This is incorrect:  Normally a mismatched integrity hash does indicate a corrupted download,
                // since an NPM registry normally guarantees that a specific version number cannot be republished
                // with different content.  But this is NOT true for a "file://" reference, and there are valid
                // reasons why someone would update the file.  (PNPM handles this correctly, by simply reinstalling
                // the tarball if its hash has changed.)
                //
                // As a workaround, we can simply remove the hashes from the shrinkwrap file.  We will convert this:
                //   "file:./projects/my-project.tgz#80cefe05fd715e65219d1ed481209dc4023408aa"
                // ..to this:
                //   "file:./projects/my-project.tgz"
                const indexOfHash = entry.resolved.indexOf('#');
                if (indexOfHash >= 0) {
                    entry.resolved = entry.resolved.substring(0, indexOfHash);
                }
            }
        }
        this._tempProjectNames.sort(); // make the result deterministic
        // We don't support Yarn workspaces yet
        this.isWorkspaceCompatible = false;
    }
    static loadFromFile(shrinkwrapFilename) {
        let shrinkwrapString;
        let shrinkwrapJson;
        try {
            if (!node_core_library_1.FileSystem.exists(shrinkwrapFilename)) {
                return undefined; // file does not exist
            }
            shrinkwrapString = node_core_library_1.FileSystem.readFile(shrinkwrapFilename);
            shrinkwrapJson = lockfileModule.parse(shrinkwrapString);
        }
        catch (error) {
            throw new Error(`Error reading "${shrinkwrapFilename}":` + os.EOL + `  ${error.message}`);
        }
        return new YarnShrinkwrapFile(shrinkwrapJson.object);
    }
    /**
     * The `@yarnpkg/lockfile` API only partially deserializes its data, and expects the caller
     * to parse the yarn.lock lookup keys (sometimes called a "pattern").
     *
     * Example input:  "js-tokens@^3.0.0 || ^4.0.0"
     * Example output: { packageName: "js-tokens", semVerRange: "^3.0.0 || ^4.0.0" }
     */
    static _decodePackageNameAndSemVer(packageNameAndSemVer) {
        const result = YarnShrinkwrapFile._packageNameAndSemVerRegExp.exec(packageNameAndSemVer);
        if (!result) {
            // Sanity check -- this should never happen
            throw new Error('Unable to parse package/semver expression in the Yarn shrinkwrap file (yarn.lock): ' +
                JSON.stringify(packageNameAndSemVer));
        }
        const packageName = result[1] || '';
        const parsedPackageName = PackageNameParsers_1.PackageNameParsers.permissive.tryParse(packageName);
        if (parsedPackageName.error) {
            // Sanity check -- this should never happen
            throw new Error('Invalid package name the Yarn shrinkwrap file (yarn.lock): ' +
                JSON.stringify(packageNameAndSemVer) +
                '\n' +
                parsedPackageName.error);
        }
        return {
            packageName,
            semVerRange: result[2] || ''
        };
    }
    /**
     * This is the inverse of _decodePackageNameAndSemVer():
     * Given an IPackageNameAndSemVer object, recreate the yarn.lock lookup key
     * (sometimes called a "pattern").
     */
    static _encodePackageNameAndSemVer(packageNameAndSemVer) {
        return packageNameAndSemVer.packageName + '@' + packageNameAndSemVer.semVerRange;
    }
    /** @override */
    getTempProjectNames() {
        return this._tempProjectNames;
    }
    /** @override */
    hasCompatibleTopLevelDependency(dependencySpecifier) {
        // It seems like we should normalize the key somehow, but Yarn apparently does not
        // do any normalization.
        const key = YarnShrinkwrapFile._encodePackageNameAndSemVer({
            packageName: dependencySpecifier.packageName,
            semVerRange: dependencySpecifier.versionSpecifier
        });
        // Check whether this exact key appears in the shrinkwrap file
        return Object.hasOwnProperty.call(this._shrinkwrapJson, key);
    }
    /** @override */
    tryEnsureCompatibleDependency(dependencySpecifier, tempProjectName) {
        return this.hasCompatibleTopLevelDependency(dependencySpecifier);
    }
    /** @override */
    serialize() {
        return lockfileModule.stringify(this._shrinkwrapJson);
    }
    /** @override */
    getTopLevelDependencyVersion(dependencyName) {
        throw new node_core_library_1.InternalError('Not implemented');
    }
    /** @override */
    tryEnsureDependencyVersion(dependencySpecifier, tempProjectName) {
        throw new node_core_library_1.InternalError('Not implemented');
    }
    /** @override */
    getProjectShrinkwrap(project) {
        return undefined;
    }
    /** @override */
    isWorkspaceProjectModified(project, variant) {
        throw new node_core_library_1.InternalError('Not implemented');
    }
}
exports.YarnShrinkwrapFile = YarnShrinkwrapFile;
// Example inputs:
// "js-tokens@^3.0.0 || ^4.0.0"
// "@rush-temp/api-extractor-test-03@file:./projects/api-extractor-test-03.tgz"
YarnShrinkwrapFile._packageNameAndSemVerRegExp = /^(@?[^@\s]+)(?:@(.*))?$/;
//# sourceMappingURL=YarnShrinkwrapFile.js.map

/***/ }),

/***/ 94191:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AsyncRecycler = void 0;
const child_process = __importStar(__webpack_require__(63129));
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const Utilities_1 = __webpack_require__(89521);
/**
 * For deleting large folders, AsyncRecycler is significantly faster than Utilities.dangerouslyDeletePath().
 * It works by moving one or more folders into a temporary "recycler" folder, and then launches a separate
 * background process to recursively delete that folder.
 */
class AsyncRecycler {
    constructor(recyclerFolder) {
        this._recyclerFolder = path.resolve(recyclerFolder);
        this._movedFolderCount = 0;
        this._deleting = false;
    }
    /**
     * The full path of the recycler folder.
     * Example: `C:\MyRepo\common\rush-recycler`
     */
    get recyclerFolder() {
        return this._recyclerFolder;
    }
    /**
     * Synchronously moves the specified folder into the recycler folder.  If the specified folder
     * does not exist, then no operation is performed.  After calling this function one or more times,
     * deleteAll() must be called to actually delete the contents of the recycler folder.
     */
    moveFolder(folderPath) {
        if (this._deleting) {
            throw new Error('AsyncRecycler.moveFolder() must not be called after deleteAll() has started');
        }
        if (node_core_library_1.Path.isUnder(this.recyclerFolder, folderPath)) {
            throw new Error('AsyncRecycler.moveFolder() cannot be called on a parent of the recycler folder');
        }
        if (!node_core_library_1.FileSystem.exists(folderPath)) {
            return;
        }
        ++this._movedFolderCount;
        // We need to do a simple "FileSystem.move" here, however if the folder we're trying to rename
        // has a lock, or if its destination container doesn't exist yet,
        // then there seems to be some OS process (virus scanner?) that holds
        // a lock on the folder for a split second, which causes renameSync to
        // fail. To workaround that, retry for up to 7 seconds before giving up.
        const maxWaitTimeMs = 7 * 1000;
        const oldFolderName = path.basename(folderPath);
        const newFolderPath = path.join(this.recyclerFolder, `${oldFolderName}_${new Date().getTime()}`);
        if (!node_core_library_1.FileSystem.exists(this.recyclerFolder)) {
            Utilities_1.Utilities.createFolderWithRetry(this.recyclerFolder);
        }
        Utilities_1.Utilities.retryUntilTimeout(() => node_core_library_1.FileSystem.move({ sourcePath: folderPath, destinationPath: newFolderPath }), maxWaitTimeMs, (e) => new Error(`Error: ${e}${os.EOL}Often this is caused by a file lock ` +
            'from a process like the virus scanner.'), 'recycleFolder');
    }
    /**
     * This deletes all items under the specified folder, except for the items in the membersToExclude.
     * To be conservative, a case-insensitive comparison is used for membersToExclude.
     * The membersToExclude must be file/folder names that would match readdir() results.
     */
    moveAllItemsInFolder(folderPath, membersToExclude) {
        const resolvedFolderPath = path.resolve(folderPath);
        const excludeSet = new Set((membersToExclude || []).map((x) => x.toUpperCase()));
        for (const memberPath of node_core_library_1.FileSystem.readFolder(resolvedFolderPath, { absolutePaths: true })) {
            const normalizedMemberName = path.basename(memberPath).toUpperCase();
            if (!excludeSet.has(normalizedMemberName)) {
                let shouldMove = false;
                try {
                    const stats = node_core_library_1.FileSystem.getLinkStatistics(memberPath);
                    shouldMove = stats.isDirectory();
                }
                catch (error) {
                    // If we fail to access the item, assume it's not a folder
                }
                if (shouldMove) {
                    this.moveFolder(memberPath);
                }
                else {
                    node_core_library_1.FileSystem.deleteFolder(memberPath);
                }
            }
        }
    }
    /**
     * Starts an asynchronous process to delete the recycler folder.  Deleting will continue
     * even if the current Node.js process is killed.
     *
     * NOTE: To avoid spawning multiple instances of the same command, moveFolder()
     * MUST NOT be called again after deleteAll() has started.
     */
    deleteAll() {
        if (this._deleting) {
            throw new Error('AsyncRecycler.deleteAll() must not be called more than once');
        }
        this._deleting = true;
        if (this._movedFolderCount === 0) {
            // Nothing to do
            return;
        }
        // Asynchronously delete the folder contents.
        let command;
        let args;
        const options = {
            detached: true,
            // The child won't stay alive unless we detach its stdio
            stdio: 'ignore'
        };
        if (os.platform() === 'win32') {
            // PowerShell.exe doesn't work with a detached console, so we need cmd.exe to create
            // the new console for us.
            command = 'cmd.exe';
            // In PowerShell single-quote literals, single quotes are escaped by doubling them
            const escapedRecyclerFolder = node_core_library_1.Text.replaceAll(this.recyclerFolder, "'", "''");
            // As of PowerShell 3.0, the "\\?" prefix can be used for paths that exceed MAX_PATH.
            // (This prefix does not seem to work for cmd.exe's "rd" command.)
            args = [
                '/c',
                '"' +
                    'PowerShell.exe -Version 3.0 -NoLogo -NonInteractive -WindowStyle Hidden -Command' +
                    ` Get-ChildItem -Force '${escapedRecyclerFolder}'` +
                    // The "^|" here prevents cmd.exe from interpreting the "|" symbol
                    ` ^| ForEach ($_) { Remove-Item -ErrorAction Ignore -Force -Recurse "\\\\?\\$($_.FullName)" }` +
                    '"'
            ];
            options.windowsVerbatimArguments = true;
        }
        else {
            command = 'rm';
            args = ['-rf'];
            let pathCount = 0;
            // child_process.spawn() doesn't expand wildcards.  To be safe, we will do it manually
            // rather than rely on an unknown shell.
            for (const filename of node_core_library_1.FileSystem.readFolder(this.recyclerFolder)) {
                // The "." and ".." are supposed to be excluded, but let's be safe
                if (filename !== '.' && filename !== '..') {
                    args.push(path.join(this.recyclerFolder, filename));
                    ++pathCount;
                }
            }
            if (pathCount === 0) {
                // Nothing to do
                return;
            }
        }
        const process = child_process.spawn(command, args, options);
        // The child won't stay alive unless we unlink it from the parent process
        process.unref();
    }
}
exports.AsyncRecycler = AsyncRecycler;
//# sourceMappingURL=AsyncRecycler.js.map

/***/ }),

/***/ 86944:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CollatedTerminalProvider = void 0;
const node_core_library_1 = __webpack_require__(24019);
class CollatedTerminalProvider {
    constructor(collatedTerminal, options) {
        this._hasErrors = false;
        this._hasWarnings = false;
        this._debugEnabled = false;
        this.supportsColor = true;
        this.eolCharacter = '\n';
        this._collatedTerminal = collatedTerminal;
        this._debugEnabled = !!(options === null || options === void 0 ? void 0 : options.debugEnabled);
    }
    get hasErrors() {
        return this._hasErrors;
    }
    get hasWarnings() {
        return this._hasWarnings;
    }
    write(data, severity) {
        switch (severity) {
            case node_core_library_1.TerminalProviderSeverity.log:
            case node_core_library_1.TerminalProviderSeverity.verbose: {
                // Unlike the basic ConsoleTerminalProvider, verbose messages are always passed
                // to stdout -- by convention the user-controlled build script output is sent
                // to verbose, and will be routed to a variety of other providers in the ProjectBuilder.
                this._collatedTerminal.writeStdoutLine(data);
                break;
            }
            case node_core_library_1.TerminalProviderSeverity.debug: {
                // Similar to the basic ConsoleTerminalProvider, debug messages are discarded
                // unless they are explicitly enabled.
                if (this._debugEnabled) {
                    this._collatedTerminal.writeStdoutLine(data);
                }
                break;
            }
            case node_core_library_1.TerminalProviderSeverity.error: {
                this._collatedTerminal.writeStderrLine(data);
                this._hasErrors = true;
                break;
            }
            case node_core_library_1.TerminalProviderSeverity.warning: {
                this._collatedTerminal.writeStderrLine(data);
                this._hasWarnings = true;
                break;
            }
            default: {
                throw new Error(`Unexpected severity: ${severity}`);
            }
        }
    }
}
exports.CollatedTerminalProvider = CollatedTerminalProvider;
//# sourceMappingURL=CollatedTerminalProvider.js.map

/***/ }),

/***/ 39482:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Npm = void 0;
const Utilities_1 = __webpack_require__(89521);
const semver = __importStar(__webpack_require__(11383));
class Npm {
    static publishedVersions(packageName, cwd, env, extraArgs = []) {
        const versions = [];
        try {
            const packageTime = Utilities_1.Utilities.executeCommandAndCaptureOutput('npm', ['view', packageName, 'time', '--json', ...extraArgs], cwd, env, true);
            if (packageTime && packageTime !== '') {
                Object.keys(JSON.parse(packageTime)).forEach((v) => {
                    if (semver.valid(v)) {
                        versions.push(v);
                    }
                });
            }
            else {
                console.log(`Package ${packageName} time value does not exist. Fall back to versions.`);
                // time property does not exist. It happens sometimes. Fall back to versions.
                const packageVersions = Utilities_1.Utilities.executeCommandAndCaptureOutput('npm', ['view', packageName, 'versions', '--json', ...extraArgs], cwd, env, true);
                if (packageVersions && packageVersions.length > 0) {
                    const parsedPackageVersions = JSON.parse(packageVersions);
                    // NPM <= 6 always returns an array, NPM >= 7 returns a string if the package has only one version available
                    (Array.isArray(parsedPackageVersions) ? parsedPackageVersions : [parsedPackageVersions]).forEach((version) => {
                        versions.push(version);
                    });
                }
                else {
                    console.log(`No version is found for ${packageName}`);
                }
            }
        }
        catch (error) {
            if (error.message.indexOf('npm ERR! 404') >= 0) {
                console.log(`Package ${packageName} does not exist in the registry.`);
            }
            else {
                console.log(`Failed to get NPM information about ${packageName}.`);
                throw error;
            }
        }
        return versions;
    }
}
exports.Npm = Npm;
//# sourceMappingURL=Npm.js.map

/***/ }),

/***/ 48892:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OverlappingPathAnalyzer = void 0;
/**
 * This is a tool for determining if a set of paths overlap. For example 'lib' and 'lib/x' overlap,
 * 'lib/x' and 'lib/y' do not.
 */
class OverlappingPathAnalyzer {
    constructor() {
        this._root = {
            encounteredLabels: new Set(),
            paths: {}
        };
    }
    addPathAndGetFirstEncounteredLabels(path, label) {
        const pathParts = path.split('/');
        let currentNode = this._root;
        let currentNodeIsNew = false;
        let labelWasAlreadyPresentInCurrentNode = false;
        for (const pathPart of pathParts) {
            if (pathPart === '') {
                continue;
            }
            if (currentNode.label) {
                return [currentNode.label];
            }
            if (!currentNode.paths[pathPart]) {
                currentNodeIsNew = true;
                currentNode = currentNode.paths[pathPart] = {
                    encounteredLabels: new Set(),
                    paths: {}
                };
            }
            else {
                currentNodeIsNew = false;
                currentNode = currentNode.paths[pathPart];
            }
            labelWasAlreadyPresentInCurrentNode = currentNode.encounteredLabels.has(label);
            if (!labelWasAlreadyPresentInCurrentNode) {
                currentNode.encounteredLabels.add(label);
            }
        }
        if (currentNodeIsNew) {
            currentNode.label = label;
            return undefined;
        }
        else if (labelWasAlreadyPresentInCurrentNode) {
            return Array.from(currentNode.encounteredLabels);
        }
        else {
            const clonedEncounteredLabels = new Set(currentNode.encounteredLabels);
            clonedEncounteredLabels.delete(label);
            return Array.from(clonedEncounteredLabels);
        }
    }
}
exports.OverlappingPathAnalyzer = OverlappingPathAnalyzer;
//# sourceMappingURL=OverlappingPathAnalyzer.js.map

/***/ }),

/***/ 80414:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Stopwatch = exports.StopwatchState = void 0;
const Utilities_1 = __webpack_require__(89521);
/**
 * Used with the Stopwatch class.
 */
var StopwatchState;
(function (StopwatchState) {
    StopwatchState[StopwatchState["Stopped"] = 1] = "Stopped";
    StopwatchState[StopwatchState["Started"] = 2] = "Started";
})(StopwatchState = exports.StopwatchState || (exports.StopwatchState = {}));
/**
 * Represents a typical timer/stopwatch which keeps track
 * of elapsed time in between two events.
 */
class Stopwatch {
    constructor(getTime = Utilities_1.Utilities.getTimeInMs) {
        this._startTime = undefined;
        this._endTime = undefined;
        this._getTime = getTime;
        this._state = StopwatchState.Stopped;
    }
    /**
     * Static helper function which creates a stopwatch which is immediately started
     */
    static start() {
        return new Stopwatch().start();
    }
    get state() {
        return this._state;
    }
    /**
     * Starts the stopwatch. Note that if end() has been called,
     * reset() should be called before calling start() again.
     */
    start() {
        if (this._startTime !== undefined) {
            throw new Error('Call reset() before starting the Stopwatch');
        }
        this._startTime = this._getTime();
        this._endTime = undefined;
        this._state = StopwatchState.Started;
        return this;
    }
    /**
     * Stops executing the stopwatch and saves the current timestamp
     */
    stop() {
        this._endTime = this._startTime !== undefined ? this._getTime() : undefined;
        this._state = StopwatchState.Stopped;
        return this;
    }
    /**
     * Resets all values of the stopwatch back to the original
     */
    reset() {
        this._endTime = this._startTime = undefined;
        this._state = StopwatchState.Stopped;
        return this;
    }
    /**
     * Displays how long the stopwatch has been executing in a human readable format.
     */
    toString() {
        if (this._state === StopwatchState.Stopped && this._startTime === undefined) {
            return '0.00 seconds (stopped)';
        }
        const totalSeconds = this.duration;
        if (totalSeconds > 60) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60.0;
            return `${minutes.toFixed(0)} minute${minutes === 1 ? '' : 's'} ${seconds.toFixed(1)} seconds`;
        }
        else {
            return `${totalSeconds.toFixed(2)} seconds`;
        }
    }
    /**
     * Get the duration in seconds.
     */
    get duration() {
        if (this._startTime === undefined) {
            return 0;
        }
        const curTime = this._endTime !== undefined ? this._endTime : this._getTime();
        return (curTime - this._startTime) / 1000.0;
    }
}
exports.Stopwatch = Stopwatch;
//# sourceMappingURL=Stopwatch.js.map

/***/ }),

/***/ 93246:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TarExecutable = void 0;
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const events_1 = __importDefault(__webpack_require__(28614));
const EnvironmentConfiguration_1 = __webpack_require__(84018);
class TarExecutable {
    constructor(tarExecutablePath) {
        this._tarExecutablePath = tarExecutablePath;
    }
    static tryInitialize(terminal) {
        terminal.writeVerboseLine('Trying to find "tar" binary');
        const tarExecutablePath = EnvironmentConfiguration_1.EnvironmentConfiguration.tarBinaryPath || node_core_library_1.Executable.tryResolve('tar');
        if (!tarExecutablePath) {
            terminal.writeVerboseLine('"tar" was not found on the PATH');
            return undefined;
        }
        return new TarExecutable(tarExecutablePath);
    }
    /**
     * @returns
     * The "tar" exit code
     */
    async tryUntarAsync(options) {
        return await this._spawnTarWithLoggingAsync(
        // These parameters are chosen for compatibility with the very primitive bsdtar 3.3.2 shipped with Windows 10.
        [
            // [Windows bsdtar 3.3.2] Extract: tar -x [options] [<patterns>]
            '-x',
            // [Windows bsdtar 3.3.2] -m    Don't restore modification times
            '-m',
            // [Windows bsdtar 3.3.2] -f <filename>  Location of archive (default \\.\tape0)
            '-f',
            options.archivePath
        ], options.outputFolderPath, options.logFilePath);
    }
    /**
     * @returns
     * The "tar" exit code
     */
    async tryCreateArchiveFromProjectPathsAsync(options) {
        const { project, archivePath, paths, logFilePath } = options;
        const pathsListFilePath = `${project.projectRushTempFolder}/tarPaths_${Date.now()}`;
        await node_core_library_1.FileSystem.writeFileAsync(pathsListFilePath, paths.join('\n'));
        // On Windows, tar.exe will report a "Failed to clean up compressor" error if the target folder
        // does not exist (GitHub #2622)
        await node_core_library_1.FileSystem.ensureFolderAsync(path.dirname(archivePath));
        const projectFolderPath = project.projectFolder;
        const tarExitCode = await this._spawnTarWithLoggingAsync(
        // These parameters are chosen for compatibility with the very primitive bsdtar 3.3.2 shipped with Windows 10.
        [
            // [Windows bsdtar 3.3.2] -c Create
            '-c',
            // [Windows bsdtar 3.3.2] -f <filename>  Location of archive (default \\.\tape0)
            '-f',
            archivePath,
            // [Windows bsdtar 3.3.2] -z, -j, -J, --lzma  Compress archive with gzip/bzip2/xz/lzma
            '-z',
            // [Windows bsdtar 3.3.2] -C <dir>  Change to <dir> before processing remaining files
            '-C',
            projectFolderPath,
            // [GNU tar 1.33] -T, --files-from=FILE      get names to extract or create from FILE
            //
            // Windows bsdtar does not document this parameter, but seems to accept it.
            '--files-from',
            pathsListFilePath
        ], projectFolderPath, logFilePath);
        await node_core_library_1.FileSystem.deleteFileAsync(pathsListFilePath);
        return tarExitCode;
    }
    async _spawnTarWithLoggingAsync(args, currentWorkingDirectory, logFilePath) {
        // Runs "tar" with the specified args and logs its output to the specified location.
        // The log file looks like this:
        //
        // Windows:
        // Start time: Mon Apr 19 2021 13:06:40 GMT-0700 (Pacific Daylight Time)
        // Invoking "C:\WINDOWS\system32\tar.exe -x -f E:\rush-cache\d18105f7f83eb610b468be4e2421681f4a52e44d"
        //
        // ======= BEGIN PROCESS OUTPUT =======
        // [stdout] <tar stdout output>
        // [stderr] <tar stderr output>
        // ======== END PROCESS OUTPUT ========
        //
        // Exited with code "0"
        //
        // Linux:
        // Start time: Mon Apr 19 2021 13:06:40 GMT-0700 (Pacific Daylight Time)
        // Invoking "/bin/tar -x -f /home/username/rush-cache/d18105f7f83eb610b468be4e2421681f4a52e44d"
        //
        // ======= BEGIN PROCESS OUTPUT =======
        // [stdout] <tar stdout output>
        // [stderr] <tar stderr output>
        // ======== END PROCESS OUTPUT ========
        //
        // Exited with code "0"
        var _a, _b;
        await node_core_library_1.FileSystem.ensureFolderAsync(path.dirname(logFilePath));
        const fileWriter = node_core_library_1.FileWriter.open(logFilePath);
        fileWriter.write([
            `Start time: ${new Date().toString()}`,
            `Invoking "${this._tarExecutablePath} ${args.join(' ')}"`,
            '',
            '======= BEGIN PROCESS OUTPUT =======',
            ''
        ].join('\n'));
        const childProcess = node_core_library_1.Executable.spawn(this._tarExecutablePath, args, {
            currentWorkingDirectory: currentWorkingDirectory
        });
        (_a = childProcess.stdout) === null || _a === void 0 ? void 0 : _a.on('data', (chunk) => fileWriter.write(`[stdout] ${chunk}`));
        (_b = childProcess.stderr) === null || _b === void 0 ? void 0 : _b.on('data', (chunk) => fileWriter.write(`[stderr] ${chunk}`));
        const [tarExitCode] = await events_1.default.once(childProcess, 'exit');
        fileWriter.write(['======== END PROCESS OUTPUT ========', '', `Exited with code "${tarExitCode}"`].join('\n'));
        fileWriter.close();
        return tarExitCode;
    }
}
exports.TarExecutable = TarExecutable;
//# sourceMappingURL=TarExecutable.js.map

/***/ }),

/***/ 89521:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Utilities = exports.UNINITIALIZED = void 0;
const child_process = __importStar(__webpack_require__(63129));
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(24019);
const ts_command_line_1 = __webpack_require__(36972);
exports.UNINITIALIZED = 'UNINITIALIZED';
class Utilities {
    /**
     * Get the user's home directory. On windows this looks something like "C:\users\username\" and on UNIX
     * this looks something like "/home/username/"
     */
    static getHomeFolder() {
        const unresolvedUserFolder = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];
        const dirError = "Unable to determine the current user's home directory";
        if (unresolvedUserFolder === undefined) {
            throw new Error(dirError);
        }
        const homeFolder = path.resolve(unresolvedUserFolder);
        if (!node_core_library_1.FileSystem.exists(homeFolder)) {
            throw new Error(dirError);
        }
        return homeFolder;
    }
    /**
     * Node.js equivalent of performance.now().
     */
    static getTimeInMs() {
        const [seconds, nanoseconds] = process.hrtime();
        return seconds * 1000 + nanoseconds / 1000000;
    }
    /**
     * Returns the values from a Set<T>
     */
    static getSetAsArray(set) {
        // When ES6 is supported, we can use Array.from() instead.
        const result = [];
        set.forEach((value) => {
            result.push(value);
        });
        return result;
    }
    /**
     * Retries a function until a timeout is reached. The function is expected to throw if it failed and
     *  should be retried.
     */
    static retryUntilTimeout(fn, maxWaitTimeMs, getTimeoutError, fnName) {
        const startTime = Utilities.getTimeInMs();
        let looped = false;
        let result;
        for (;;) {
            try {
                result = fn();
                break;
            }
            catch (e) {
                looped = true;
                const currentTime = Utilities.getTimeInMs();
                if (currentTime - startTime > maxWaitTimeMs) {
                    throw getTimeoutError(e);
                }
            }
        }
        if (looped) {
            const currentTime = Utilities.getTimeInMs();
            const totalSeconds = ((currentTime - startTime) / 1000.0).toFixed(2);
            // This logging statement isn't meaningful to the end-user. `fnName` should be updated
            // to something like `operationDescription`
            console.log(`${fnName}() stalled for ${totalSeconds} seconds`);
        }
        return result;
    }
    /**
     * Creates the specified folder by calling FileSystem.ensureFolder(), but using a
     * retry loop to recover from temporary locks that may be held by other processes.
     * If the folder already exists, no error occurs.
     */
    static createFolderWithRetry(folderName) {
        // Note: If a file exists with the same name, then we fall through and report
        // an error.
        if (Utilities.directoryExists(folderName)) {
            return;
        }
        // We need to do a simple "FileSystem.ensureFolder(localModulesFolder)" here,
        // however if the folder we deleted above happened to contain any files,
        // then there seems to be some OS process (virus scanner?) that holds
        // a lock on the folder for a split second, which causes mkdirSync to
        // fail.  To workaround that, retry for up to 7 seconds before giving up.
        const maxWaitTimeMs = 7 * 1000;
        return Utilities.retryUntilTimeout(() => node_core_library_1.FileSystem.ensureFolder(folderName), maxWaitTimeMs, (e) => new Error(`Error: ${e}${os.EOL}Often this is caused by a file lock ` +
            'from a process such as your text editor, command prompt, ' +
            'or a filesystem watcher.'), 'createFolderWithRetry');
    }
    /**
     * Determines if the path points to a file and that it exists.
     */
    static fileExists(filePath) {
        let exists = false;
        try {
            const lstat = node_core_library_1.FileSystem.getLinkStatistics(filePath);
            exists = lstat.isFile();
        }
        catch (e) {
            /* no-op */
        }
        return exists;
    }
    /**
     * Determines if a path points to a directory and that it exists.
     */
    static directoryExists(directoryPath) {
        let exists = false;
        try {
            const lstat = node_core_library_1.FileSystem.getLinkStatistics(directoryPath);
            exists = lstat.isDirectory();
        }
        catch (e) {
            /* no-op */
        }
        return exists;
    }
    /**
     * BE VERY CAREFUL CALLING THIS FUNCTION!
     * If you specify the wrong folderPath (e.g. "/"), it could potentially delete your entire
     * hard disk.
     */
    static dangerouslyDeletePath(folderPath) {
        try {
            node_core_library_1.FileSystem.deleteFolder(folderPath);
        }
        catch (e) {
            throw new Error(`${e.message}${os.EOL}Often this is caused by a file lock from a process ` +
                'such as your text editor, command prompt, or a filesystem watcher');
        }
    }
    /**
     * Attempts to delete a file. If it does not exist, or the path is not a file, it no-ops.
     */
    static deleteFile(filePath) {
        if (Utilities.fileExists(filePath)) {
            console.log(`Deleting: ${filePath}`);
            node_core_library_1.FileSystem.deleteFile(filePath);
        }
    }
    /*
     * Returns true if dateToCompare is more recent than all of the inputFilenames, which
     * would imply that we don't need to rebuild it. Returns false if any of the files
     * does not exist.
     * NOTE: The filenames can also be paths for directories, in which case the directory
     * timestamp is compared.
     */
    static isFileTimestampCurrent(dateToCompare, inputFilenames) {
        for (const inputFilename of inputFilenames) {
            if (!node_core_library_1.FileSystem.exists(inputFilename)) {
                return false;
            }
            const inputStats = node_core_library_1.FileSystem.getStatistics(inputFilename);
            if (dateToCompare < inputStats.mtime) {
                return false;
            }
        }
        return true;
    }
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     */
    static executeCommand(options) {
        Utilities._executeCommandInternal(options.command, options.args, options.workingDirectory, options.suppressOutput ? undefined : [0, 1, 2], options.environment, options.keepEnvironment);
    }
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     */
    static executeCommandAndCaptureOutput(command, args, workingDirectory, environment, keepEnvironment = false) {
        const result = Utilities._executeCommandInternal(command, args, workingDirectory, ['pipe', 'pipe', 'pipe'], environment, keepEnvironment);
        return result.stdout.toString();
    }
    /**
     * Attempts to run Utilities.executeCommand() up to maxAttempts times before giving up.
     */
    static executeCommandWithRetry(options, maxAttempts, retryCallback) {
        if (maxAttempts < 1) {
            throw new Error('The maxAttempts parameter cannot be less than 1');
        }
        let attemptNumber = 1;
        for (;;) {
            try {
                Utilities.executeCommand(options);
            }
            catch (error) {
                console.log(os.EOL + 'The command failed:');
                console.log(` ${options.command} ` + options.args.join(' '));
                console.log(`ERROR: ${error.toString()}`);
                if (attemptNumber < maxAttempts) {
                    ++attemptNumber;
                    console.log(`Trying again (attempt #${attemptNumber})...` + os.EOL);
                    if (retryCallback) {
                        retryCallback();
                    }
                    continue;
                }
                else {
                    console.error(`Giving up after ${attemptNumber} attempts` + os.EOL);
                    throw error;
                }
            }
            break;
        }
    }
    /**
     * Executes the command using cmd if running on windows, or using sh if running on a non-windows OS.
     * @param command - the command to run on shell
     * @param options - options for how the command should be run
     */
    static executeLifecycleCommand(command, options) {
        const result = Utilities._executeLifecycleCommandInternal(command, child_process.spawnSync, options);
        if (options.handleOutput) {
            Utilities._processResult(result);
        }
        if (result.status !== null) {
            return result.status;
        }
        else {
            throw result.error || new Error('An unknown error occurred.');
        }
    }
    /**
     * Executes the command using cmd if running on windows, or using sh if running on a non-windows OS.
     * @param command - the command to run on shell
     * @param options - options for how the command should be run
     */
    static executeLifecycleCommandAsync(command, options) {
        return Utilities._executeLifecycleCommandInternal(command, child_process.spawn, options);
    }
    /**
     * Utility to determine if the app should restrict writing to the console.
     */
    static shouldRestrictConsoleOutput() {
        return (ts_command_line_1.CommandLineHelper.isTabCompletionActionRequest(process.argv) || process.argv.indexOf('--json') !== -1);
    }
    /**
     * For strings passed to a shell command, this adds appropriate escaping
     * to avoid misinterpretation of spaces or special characters.
     *
     * Example: 'hello there' --> '"hello there"'
     */
    static escapeShellParameter(parameter) {
        // This approach is based on what NPM 7 now does:
        // https://github.com/npm/run-script/blob/47a4d539fb07220e7215cc0e482683b76407ef9b/lib/run-script-pkg.js#L34
        return JSON.stringify(parameter);
    }
    /**
     * Installs a package by name and version in the specified directory.
     */
    static installPackageInDirectory(options) {
        const directory = path.resolve(options.directory);
        if (node_core_library_1.FileSystem.exists(directory)) {
            console.log('Deleting old files from ' + directory);
        }
        node_core_library_1.FileSystem.ensureEmptyFolder(directory);
        const npmPackageJson = {
            dependencies: {
                [options.packageName]: options.version
            },
            description: 'Temporary file generated by the Rush tool',
            name: options.tempPackageTitle,
            private: true,
            version: '0.0.0'
        };
        node_core_library_1.JsonFile.save(npmPackageJson, path.join(directory, "package.json" /* PackageJson */));
        if (options.commonRushConfigFolder) {
            Utilities.syncNpmrc(options.commonRushConfigFolder, directory);
        }
        console.log(os.EOL + 'Running "npm install" in ' + directory);
        // NOTE: Here we use whatever version of NPM we happen to find in the PATH
        Utilities.executeCommandWithRetry({
            command: 'npm',
            args: ['install'],
            workingDirectory: directory,
            environment: Utilities._createEnvironmentForRushCommand({}),
            suppressOutput: options.suppressOutput
        }, options.maxInstallAttempts);
    }
    /**
     * As a workaround, copyAndTrimNpmrcFile() copies the .npmrc file to the target folder, and also trims
     * unusable lines from the .npmrc file.
     *
     * Why are we trimming the .npmrc lines?  NPM allows environment variables to be specified in
     * the .npmrc file to provide different authentication tokens for different registry.
     * However, if the environment variable is undefined, it expands to an empty string, which
     * produces a valid-looking mapping with an invalid URL that causes an error.  Instead,
     * we'd prefer to skip that line and continue looking in other places such as the user's
     * home directory.
     *
     * IMPORTANT: THIS CODE SHOULD BE KEPT UP TO DATE WITH _copyAndTrimNpmrcFile() FROM scripts/install-run.ts
     */
    static copyAndTrimNpmrcFile(sourceNpmrcPath, targetNpmrcPath) {
        console.log(`Transforming ${sourceNpmrcPath}`); // Verbose
        console.log(`  --> "${targetNpmrcPath}"`);
        let npmrcFileLines = node_core_library_1.FileSystem.readFile(sourceNpmrcPath).split('\n');
        npmrcFileLines = npmrcFileLines.map((line) => (line || '').trim());
        const resultLines = [];
        // This finds environment variable tokens that look like "${VAR_NAME}"
        const expansionRegExp = /\$\{([^\}]+)\}/g;
        // Comment lines start with "#" or ";"
        const commentRegExp = /^\s*[#;]/;
        // Trim out lines that reference environment variables that aren't defined
        for (const line of npmrcFileLines) {
            let lineShouldBeTrimmed = false;
            // Ignore comment lines
            if (!commentRegExp.test(line)) {
                const environmentVariables = line.match(expansionRegExp);
                if (environmentVariables) {
                    for (const token of environmentVariables) {
                        // Remove the leading "${" and the trailing "}" from the token
                        const environmentVariableName = token.substring(2, token.length - 1);
                        // Is the environment variable defined?
                        if (!process.env[environmentVariableName]) {
                            // No, so trim this line
                            lineShouldBeTrimmed = true;
                            break;
                        }
                    }
                }
            }
            if (lineShouldBeTrimmed) {
                // Example output:
                // "; MISSING ENVIRONMENT VARIABLE: //my-registry.com/npm/:_authToken=${MY_AUTH_TOKEN}"
                resultLines.push('; MISSING ENVIRONMENT VARIABLE: ' + line);
            }
            else {
                resultLines.push(line);
            }
        }
        node_core_library_1.FileSystem.writeFile(targetNpmrcPath, resultLines.join(os.EOL));
    }
    /**
     * Copies the file "sourcePath" to "destinationPath", overwriting the target file location.
     * If the source file does not exist, then the target file is deleted.
     */
    static syncFile(sourcePath, destinationPath) {
        if (node_core_library_1.FileSystem.exists(sourcePath)) {
            console.log(`Copying "${sourcePath}"`);
            console.log(`  --> "${destinationPath}"`);
            node_core_library_1.FileSystem.copyFile({ sourcePath, destinationPath });
        }
        else {
            if (node_core_library_1.FileSystem.exists(destinationPath)) {
                // If the source file doesn't exist and there is one in the target, delete the one in the target
                console.log(`Deleting ${destinationPath}`);
                node_core_library_1.FileSystem.deleteFile(destinationPath);
            }
        }
    }
    /**
     * syncNpmrc() copies the .npmrc file to the target folder, and also trims unusable lines from the .npmrc file.
     * If the source .npmrc file not exist, then syncNpmrc() will delete an .npmrc that is found in the target folder.
     *
     * IMPORTANT: THIS CODE SHOULD BE KEPT UP TO DATE WITH _syncNpmrc() FROM scripts/install-run.ts
     */
    static syncNpmrc(sourceNpmrcFolder, targetNpmrcFolder, useNpmrcPublish) {
        const sourceNpmrcPath = path.join(sourceNpmrcFolder, !useNpmrcPublish ? '.npmrc' : '.npmrc-publish');
        const targetNpmrcPath = path.join(targetNpmrcFolder, '.npmrc');
        try {
            if (node_core_library_1.FileSystem.exists(sourceNpmrcPath)) {
                Utilities.copyAndTrimNpmrcFile(sourceNpmrcPath, targetNpmrcPath);
            }
            else if (node_core_library_1.FileSystem.exists(targetNpmrcPath)) {
                // If the source .npmrc doesn't exist and there is one in the target, delete the one in the target
                console.log(`Deleting ${targetNpmrcPath}`); // Verbose
                node_core_library_1.FileSystem.deleteFile(targetNpmrcPath);
            }
        }
        catch (e) {
            throw new Error(`Error syncing .npmrc file: ${e}`);
        }
    }
    static getRushConfigNotFoundError() {
        return new Error('Unable to find rush.json configuration file');
    }
    static getPackageDepsFilenameForCommand(command) {
        return `package-deps_${command}.json`;
    }
    static async usingAsync(getDisposableAsync, doActionAsync) {
        let disposable;
        try {
            disposable = (await getDisposableAsync());
            await doActionAsync(disposable);
        }
        finally {
            disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
        }
    }
    static async readStreamToBufferAsync(stream) {
        return await new Promise((resolve, reject) => {
            const parts = [];
            stream.on('data', (chunk) => parts.push(chunk));
            stream.on('error', (error) => reject(error));
            stream.on('end', () => {
                const result = Buffer.concat(parts);
                resolve(result);
            });
        });
    }
    static _executeLifecycleCommandInternal(command, spawnFunction, options) {
        let shellCommand = process.env.comspec || 'cmd';
        let commandFlags = '/d /s /c';
        let useShell = true;
        if (process.platform !== 'win32') {
            shellCommand = 'sh';
            commandFlags = '-c';
            useShell = false;
        }
        const environment = Utilities._createEnvironmentForRushCommand({
            initCwd: options.initCwd,
            pathOptions: Object.assign(Object.assign({}, options.environmentPathOptions), { projectRoot: options.workingDirectory, commonTempFolder: options.rushConfiguration ? options.rushConfiguration.commonTempFolder : undefined })
        });
        return spawnFunction(shellCommand, [commandFlags, command], {
            cwd: options.workingDirectory,
            shell: useShell,
            env: environment,
            stdio: options.handleOutput ? ['pipe', 'pipe', 'pipe'] : [0, 1, 2]
        });
    }
    /**
     * Returns a process.env environment suitable for executing lifecycle scripts.
     * @param initialEnvironment - an existing environment to copy instead of process.env
     *
     * @remarks
     * Rush._assignRushInvokedFolder() assigns the `RUSH_INVOKED_FOLDER` variable globally
     * via the parent process's environment.
     */
    static _createEnvironmentForRushCommand(options) {
        if (options.initialEnvironment === undefined) {
            options.initialEnvironment = process.env;
        }
        const environment = {};
        for (const key of Object.getOwnPropertyNames(options.initialEnvironment)) {
            const normalizedKey = os.platform() === 'win32' ? key.toUpperCase() : key;
            // If Rush itself was invoked inside a lifecycle script, this may be set and would interfere
            // with Rush's installations.  If we actually want it, we will set it explicitly below.
            if (normalizedKey === 'INIT_CWD') {
                continue;
            }
            // When NPM invokes a lifecycle event, it copies its entire configuration into environment
            // variables.  Rush is supposed to be a deterministic controlled environment, so don't bring
            // this along.
            //
            // NOTE: Longer term we should clean out the entire environment and use rush.json to bring
            // back specific environment variables that the repo maintainer has determined to be safe.
            if (normalizedKey.match(/^NPM_CONFIG_/)) {
                continue;
            }
            // Use the uppercased environment variable name on Windows because environment variable names
            // are case-insensitive on Windows
            environment[normalizedKey] = options.initialEnvironment[key];
        }
        // When NPM invokes a lifecycle script, it sets an environment variable INIT_CWD that remembers
        // the directory that NPM started in.  This allows naive scripts to change their current working directory
        // and invoke NPM operations, while still be able to find a local .npmrc file.  Although Rush recommends
        // for toolchain scripts to be professionally written (versus brittle stuff like
        // "cd ./lib && npm run tsc && cd .."), we support INIT_CWD for compatibility.
        //
        // More about this feature: https://github.com/npm/npm/pull/12356
        if (options.initCwd) {
            environment['INIT_CWD'] = options.initCwd; // eslint-disable-line dot-notation
        }
        if (options.pathOptions) {
            if (options.pathOptions.includeRepoBin && options.pathOptions.commonTempFolder) {
                environment.PATH = Utilities._prependNodeModulesBinToPath(environment.PATH, options.pathOptions.commonTempFolder);
            }
            if (options.pathOptions.includeProjectBin && options.pathOptions.projectRoot) {
                environment.PATH = Utilities._prependNodeModulesBinToPath(environment.PATH, options.pathOptions.projectRoot);
            }
            if (options.pathOptions.additionalPathFolders) {
                environment.PATH = [...options.pathOptions.additionalPathFolders, environment.PATH].join(path.delimiter);
            }
        }
        return environment;
    }
    /**
     * Prepend the node_modules/.bin folder under the specified folder to the specified PATH variable. For example,
     * if `rootDirectory` is "/foobar" and `existingPath` is "/bin", this function will return
     * "/foobar/node_modules/.bin:/bin"
     */
    static _prependNodeModulesBinToPath(existingPath, rootDirectory) {
        const binPath = path.resolve(rootDirectory, 'node_modules', '.bin');
        if (existingPath) {
            return `${binPath}${path.delimiter}${existingPath}`;
        }
        else {
            return binPath;
        }
    }
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     */
    static _executeCommandInternal(command, args, workingDirectory, stdio, environment, keepEnvironment = false) {
        const options = {
            cwd: workingDirectory,
            shell: true,
            stdio: stdio,
            env: keepEnvironment
                ? environment
                : Utilities._createEnvironmentForRushCommand({ initialEnvironment: environment })
        };
        // This is needed since we specify shell=true below.
        // NOTE: On Windows if we escape "NPM", the spawnSync() function runs something like this:
        //   [ 'C:\\Windows\\system32\\cmd.exe', '/s', '/c', '""NPM" "install""' ]
        //
        // Due to a bug with Windows cmd.exe, the npm.cmd batch file's "%~dp0" variable will
        // return the current working directory instead of the batch file's directory.
        // The workaround is to not escape, npm, i.e. do this instead:
        //   [ 'C:\\Windows\\system32\\cmd.exe', '/s', '/c', '"npm "install""' ]
        //
        // We will come up with a better solution for this when we promote executeCommand()
        // into node-core-library, but for now this hack will unblock people:
        // Only escape the command if it actually contains spaces:
        const escapedCommand = command.indexOf(' ') < 0 ? command : Utilities.escapeShellParameter(command);
        const escapedArgs = args.map((x) => Utilities.escapeShellParameter(x));
        let result = child_process.spawnSync(escapedCommand, escapedArgs, options);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (result.error && result.error.errno === 'ENOENT') {
            // This is a workaround for GitHub issue #25330
            // https://github.com/nodejs/node-v0.x-archive/issues/25330
            //
            // TODO: The fully worked out solution for this problem is now provided by the "Executable" API
            // from @rushstack/node-core-library
            result = child_process.spawnSync(command + '.cmd', args, options);
        }
        Utilities._processResult(result);
        return result;
    }
    static _processResult(result) {
        if (result.error) {
            result.error.message += os.EOL + (result.stderr ? result.stderr.toString() + os.EOL : '');
            throw result.error;
        }
        if (result.status) {
            throw new Error('The command failed with exit code ' +
                result.status +
                os.EOL +
                (result.stderr ? result.stderr.toString() : ''));
        }
    }
}
exports.Utilities = Utilities;
//# sourceMappingURL=Utilities.js.map

/***/ }),

/***/ 80168:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebClient = exports.WebClientProxy = void 0;
const os = __importStar(__webpack_require__(12087));
const process = __importStar(__webpack_require__(61765));
const fetch = __importStar(__webpack_require__(48941));
const node_core_library_1 = __webpack_require__(24019);
const createHttpsProxyAgent = node_core_library_1.Import.lazy('https-proxy-agent', require);
var WebClientProxy;
(function (WebClientProxy) {
    WebClientProxy[WebClientProxy["None"] = 0] = "None";
    WebClientProxy[WebClientProxy["Detect"] = 1] = "Detect";
    WebClientProxy[WebClientProxy["Fiddler"] = 2] = "Fiddler";
})(WebClientProxy = exports.WebClientProxy || (exports.WebClientProxy = {}));
class WebClient {
    constructor() {
        this.standardHeaders = new fetch.Headers();
        this.accept = '*/*';
        this.userAgent = `rush node/${process.version} ${os.platform()} ${os.arch()}`;
        this.proxy = WebClientProxy.Detect;
    }
    static mergeHeaders(target, source) {
        source.forEach((value, name) => {
            target.set(name, value);
        });
    }
    addBasicAuthHeader(userName, password) {
        this.standardHeaders.set('Authorization', 'Basic ' + Buffer.from(userName + ':' + password).toString('base64'));
    }
    async fetchAsync(url, options) {
        const headers = new fetch.Headers();
        WebClient.mergeHeaders(headers, this.standardHeaders);
        if (options === null || options === void 0 ? void 0 : options.headers) {
            WebClient.mergeHeaders(headers, options.headers);
        }
        if (this.userAgent) {
            headers.set('user-agent', this.userAgent);
        }
        if (this.accept) {
            headers.set('accept', this.accept);
        }
        let proxyUrl = '';
        switch (this.proxy) {
            case WebClientProxy.Detect:
                if (process.env.HTTPS_PROXY) {
                    proxyUrl = process.env.HTTPS_PROXY;
                }
                else if (process.env.HTTP_PROXY) {
                    proxyUrl = process.env.HTTP_PROXY;
                }
                break;
            case WebClientProxy.Fiddler:
                // For debugging, disable cert validation
                // eslint-disable-next-line
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                proxyUrl = 'http://localhost:8888/';
                break;
        }
        let agent = undefined;
        if (proxyUrl) {
            agent = createHttpsProxyAgent(proxyUrl);
        }
        const timeoutMs = (options === null || options === void 0 ? void 0 : options.timeoutMs) !== undefined ? options.timeoutMs : 15 * 1000; // 15 seconds
        const requestInit = {
            method: options === null || options === void 0 ? void 0 : options.verb,
            headers: headers,
            agent: agent,
            timeout: timeoutMs
        };
        const putOptions = options;
        if (putOptions === null || putOptions === void 0 ? void 0 : putOptions.body) {
            requestInit.body = putOptions.body;
        }
        return await fetch.default(url, requestInit);
    }
}
exports.WebClient = WebClient;
//# sourceMappingURL=WebClient.js.map

/***/ }),

/***/ 26807:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AlreadyReportedError = void 0;
const TypeUuid_1 = __webpack_require__(21131);
const uuidAlreadyReportedError = 'f26b0640-a49b-49d1-9ead-1a516d5920c7';
/**
 * This exception can be thrown to indicate that an operation failed and an error message has already
 * been reported appropriately. Thus, the catch handler does not have responsibility for reporting
 * the error.
 *
 * @remarks
 * For example, suppose a tool writes interactive output to `console.log()`.  When an exception is thrown,
 * the `catch` handler will typically provide simplistic reporting such as this:
 *
 * ```ts
 * catch (error) {
 *   console.log("ERROR: " + error.message);
 * }
 * ```
 *
 * Suppose that the code performing the operation normally prints rich output to the console.  It may be able to
 * present an error message more nicely (for example, as part of a table, or structured log format).  Throwing
 * `AlreadyReportedError` provides a way to use exception handling to abort the operation, but instruct the `catch`
 * handler not to print an error a second time:
 *
 * ```ts
 * catch (error) {
 *   if (error instanceof AlreadyReportedError) {
 *     return;
 *   }
 *   console.log("ERROR: " + error.message);
 * }
 * ```
 *
 * @public
 */
class AlreadyReportedError extends Error {
    constructor() {
        super('An error occurred.');
        // Manually set the prototype, as we can no longer extend built-in classes like Error, Array, Map, etc
        // [https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work](https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work)
        //
        // Note: the prototype must also be set on any classes which extend this one
        this.__proto__ = AlreadyReportedError.prototype; // eslint-disable-line @typescript-eslint/no-explicit-any
    }
    static [Symbol.hasInstance](instance) {
        return TypeUuid_1.TypeUuid.isInstanceOf(instance, uuidAlreadyReportedError);
    }
}
exports.AlreadyReportedError = AlreadyReportedError;
TypeUuid_1.TypeUuid.registerClass(AlreadyReportedError, uuidAlreadyReportedError);
//# sourceMappingURL=AlreadyReportedError.js.map

/***/ }),

/***/ 45822:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Async = void 0;
/**
 * Utilities for parallel asynchronous operations, for use with the system `Promise` APIs.
 *
 * @beta
 */
class Async {
    /**
     * Given an input array and a `callback` function, invoke the callback to start a
     * promise for each element in the array.  Returns an array containing the results.
     *
     * @remarks
     * This API is similar to the system `Array#map`, except that the loop is asynchronous,
     * and the maximum number of concurrent promises can be throttled
     * using {@link IAsyncParallelismOptions.concurrency}.
     *
     * If `callback` throws a synchronous exception, or if it returns a promise that rejects,
     * then the loop stops immediately.  Any remaining array items will be skipped, and
     * overall operation will reject with the first error that was encountered.
     *
     * @param iterable - the array of inputs for the callback function
     * @param callback - a function that starts an asynchronous promise for an element
     *   from the array
     * @param options - options for customizing the control flow
     * @returns an array containing the result for each callback, in the same order
     *   as the original input `array`
     */
    static async mapAsync(iterable, callback, options) {
        const result = [];
        await Async.forEachAsync(iterable, async (item, arrayIndex) => {
            result[arrayIndex] = await callback(item, arrayIndex);
        }, options);
        return result;
    }
    /**
     * Given an input array and a `callback` function, invoke the callback to start a
     * promise for each element in the array.
     *
     * @remarks
     * This API is similar to the system `Array#forEach`, except that the loop is asynchronous,
     * and the maximum number of concurrent promises can be throttled
     * using {@link IAsyncParallelismOptions.concurrency}.
     *
     * If `callback` throws a synchronous exception, or if it returns a promise that rejects,
     * then the loop stops immediately.  Any remaining array items will be skipped, and
     * overall operation will reject with the first error that was encountered.
     *
     * @param iterable - the array of inputs for the callback function
     * @param callback - a function that starts an asynchronous promise for an element
     *   from the array
     * @param options - options for customizing the control flow
     */
    static async forEachAsync(iterable, callback, options) {
        await new Promise((resolve, reject) => {
            const concurrency = (options === null || options === void 0 ? void 0 : options.concurrency) && options.concurrency > 0 ? options.concurrency : Infinity;
            let operationsInProgress = 0;
            const iterator = (iterable[Symbol.iterator] ||
                iterable[Symbol.asyncIterator]).call(iterable);
            let arrayIndex = 0;
            let iteratorIsComplete = false;
            let promiseHasResolvedOrRejected = false;
            async function queueOperationsAsync() {
                while (operationsInProgress < concurrency && !iteratorIsComplete && !promiseHasResolvedOrRejected) {
                    const currentIteratorResult = await iterator.next();
                    // eslint-disable-next-line require-atomic-updates
                    iteratorIsComplete = !!currentIteratorResult.done;
                    if (!iteratorIsComplete) {
                        operationsInProgress++;
                        Promise.resolve(callback(currentIteratorResult.value, arrayIndex++))
                            .then(async () => {
                            operationsInProgress--;
                            await onOperationCompletionAsync();
                        })
                            .catch((error) => {
                            promiseHasResolvedOrRejected = true;
                            reject(error);
                        });
                    }
                }
                if (iteratorIsComplete) {
                    await onOperationCompletionAsync();
                }
            }
            async function onOperationCompletionAsync() {
                if (!promiseHasResolvedOrRejected) {
                    if (operationsInProgress === 0 && iteratorIsComplete) {
                        promiseHasResolvedOrRejected = true;
                        resolve();
                    }
                    else if (!iteratorIsComplete) {
                        await queueOperationsAsync();
                    }
                }
            }
            queueOperationsAsync().catch((error) => {
                promiseHasResolvedOrRejected = true;
                reject(error);
            });
        });
    }
    /**
     * Return a promise that resolves after the specified number of milliseconds.
     */
    static async sleep(ms) {
        await new Promise((resolve) => {
            setTimeout(resolve, ms);
        });
    }
}
exports.Async = Async;
//# sourceMappingURL=Async.js.map

/***/ }),

/***/ 46997:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Enum = void 0;
/**
 * A helper for looking up TypeScript `enum` keys/values.
 *
 * @remarks
 * TypeScript enums implement a lookup table for mapping between their keys and values:
 *
 * ```ts
 * enum Colors {
 *   Red = 1
 * }
 *
 * // Prints "Red"
 * console.log(Colors[1]);
 *
 * // Prints "1"
 * console.log(Colors["Red]);
 * ```
 *
 * However the compiler's "noImplicitAny" validation has trouble with these mappings, because
 * there are so many possible types for the map elements:
 *
 * ```ts
 * function f(s: string): Colors | undefined {
 *   // (TS 7015) Element implicitly has an 'any' type because
 *   // index expression is not of type 'number'.
 *   return Colors[s];
 * }
 * ```
 *
 * The `Enum` helper provides a more specific, strongly typed way to access members:
 *
 * ```ts
 * function f(s: string): Colors | undefined {
 *   return Enum.tryGetValueByKey(Colors, s);
 * }
 * ```
 *
 * @public
 */
class Enum {
    constructor() { }
    /**
     * Returns an enum value, given its key. Returns `undefined` if no matching key is found.
     *
     * @example
     *
     * Example usage:
     * ```ts
     * enum Colors {
     *   Red = 1
     * }
     *
     * // Prints "1"
     * console.log(Enum.tryGetValueByKey(Colors, "Red"));
     *
     * // Prints "undefined"
     * console.log(Enum.tryGetValueByKey(Colors, "Black"));
     * ```
     */
    static tryGetValueByKey(enumObject, key) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return enumObject[key];
    }
    /**
     * This API is similar to {@link Enum.tryGetValueByKey}, except that it throws an exception
     * if the key is undefined.
     */
    static getValueByKey(enumObject, key) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const result = enumObject[key];
        if (result === undefined) {
            throw new Error(`The lookup key ${JSON.stringify(key)} is not defined`);
        }
        return result;
    }
    /**
     * Returns an enum string key, given its numeric value.  Returns `undefined` if no matching value
     * is found.
     *
     * @remarks
     * The TypeScript compiler only creates a reverse mapping for enum members whose value is numeric.
     * For example:
     *
     * ```ts
     * enum E {
     *   A = 1,
     *   B = 'c'
     * }
     *
     * // Prints "A"
     * console.log(E[1]);
     *
     * // Prints "undefined"
     * console.log(E["c"]);
     * ```
     *
     * @example
     *
     * Example usage:
     * ```ts
     * enum Colors {
     *   Red = 1,
     *   Blue = 'blue'
     * }
     *
     * // Prints "Red"
     * console.log(Enum.tryGetKeyByNumber(Colors, 1));
     *
     * // Prints "undefined"
     * console.log(Enum.tryGetKeyByNumber(Colors, -1));
     * ```
     */
    static tryGetKeyByNumber(enumObject, value) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return enumObject[value];
    }
    /**
     * This API is similar to {@link Enum.tryGetKeyByNumber}, except that it throws an exception
     * if the key is undefined.
     */
    static getKeyByNumber(enumObject, value) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const result = enumObject[value];
        if (result === undefined) {
            throw new Error(`The value ${value} does not exist in the mapping`);
        }
        return result;
    }
}
exports.Enum = Enum;
//# sourceMappingURL=Enum.js.map

/***/ }),

/***/ 90205:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnvironmentMap = void 0;
const process_1 = __importDefault(__webpack_require__(61765));
const InternalError_1 = __webpack_require__(73710);
/**
 * A map data structure that stores process environment variables.  On Windows
 * operating system, the variable names are case-insensitive.
 * @public
 */
class EnvironmentMap {
    constructor(environmentObject = {}) {
        this._map = new Map();
        // This property helps catch a mistake where an instance of `EnvironmentMap` is accidentally passed to
        // a function that expects a `Record<string, string>` (as would be used with the `process.env` API).
        // The property getter will throw an exception if that function tries to enumerate the object values.
        Object.defineProperty(this, '_sanityCheck', {
            enumerable: true,
            get: function () {
                throw new InternalError_1.InternalError('Attempt to read EnvironmentMap class as an object');
            }
        });
        this.caseSensitive = process_1.default.platform !== 'win32';
        this.mergeFromObject(environmentObject);
    }
    /**
     * Clears all entries, resulting in an empty map.
     */
    clear() {
        this._map.clear();
    }
    /**
     * Assigns the variable to the specified value.  A previous value will be overwritten.
     *
     * @remarks
     * The value can be an empty string.  To completely remove the entry, use
     * {@link EnvironmentMap.unset} instead.
     */
    set(name, value) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        this._map.set(key, { name: name, value });
    }
    /**
     * Removes the key from the map, if present.
     */
    unset(name) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        this._map.delete(key);
    }
    /**
     * Returns the value of the specified variable, or `undefined` if the map does not contain that name.
     */
    get(name) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        const entry = this._map.get(key);
        if (entry === undefined) {
            return undefined;
        }
        return entry.value;
    }
    /**
     * Returns the map keys, which are environment variable names.
     */
    names() {
        return this._map.keys();
    }
    /**
     * Returns the map entries.
     */
    entries() {
        return this._map.values();
    }
    /**
     * Adds each entry from `environmentMap` to this map.
     */
    mergeFrom(environmentMap) {
        for (const entry of environmentMap.entries()) {
            this.set(entry.name, entry.value);
        }
    }
    /**
     * Merges entries from a plain JavaScript object, such as would be used with the `process.env` API.
     */
    mergeFromObject(environmentObject = {}) {
        for (const [name, value] of Object.entries(environmentObject)) {
            if (value !== undefined) {
                this.set(name, value);
            }
        }
    }
    /**
     * Returns the keys as a plain JavaScript object similar to the object returned by the `process.env` API.
     */
    toObject() {
        const result = {};
        for (const entry of this.entries()) {
            result[entry.name] = entry.value;
        }
        return result;
    }
}
exports.EnvironmentMap = EnvironmentMap;
//# sourceMappingURL=EnvironmentMap.js.map

/***/ }),

/***/ 55210:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Executable = void 0;
const child_process = __importStar(__webpack_require__(63129));
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const EnvironmentMap_1 = __webpack_require__(90205);
const FileSystem_1 = __webpack_require__(76952);
/**
 * The Executable class provides a safe, portable, recommended solution for tools that need
 * to launch child processes.
 *
 * @remarks
 * The NodeJS child_process API provides a solution for launching child processes, however
 * its design encourages reliance on the operating system shell for certain features.
 * Invoking the OS shell is not safe, not portable, and generally not recommended:
 *
 * - Different shells have different behavior and command-line syntax, and which shell you
 *   will get with NodeJS is unpredictable.  There is no universal shell guaranteed to be
 *   available on all platforms.
 *
 * - If a command parameter contains symbol characters, a shell may interpret them, which
 *   can introduce a security vulnerability
 *
 * - Each shell has different rules for escaping these symbols.  On Windows, the default
 *   shell is incapable of escaping certain character sequences.
 *
 * The Executable API provides a pure JavaScript implementation of primitive shell-like
 * functionality for searching the default PATH, appending default file extensions on Windows,
 * and executing a file that may contain a POSIX shebang.  This primitive functionality
 * is sufficient (and recommended) for most tooling scenarios.
 *
 * If you need additional shell features such as wildcard globbing, environment variable
 * expansion, piping, or built-in commands, then we recommend to use the `@microsoft/rushell`
 * library instead.  Rushell is a pure JavaScript shell with a standard syntax that is
 * guaranteed to work consistently across all platforms.
 *
 * @public
 */
class Executable {
    /**
     * Synchronously create a child process and optionally capture its output.
     *
     * @remarks
     * This function is similar to child_process.spawnSync().  The main differences are:
     *
     * - It does not invoke the OS shell unless the executable file is a shell script.
     * - Command-line arguments containing special characters are more accurately passed
     *   through to the child process.
     * - If the filename is missing a path, then the shell's default PATH will be searched.
     * - If the filename is missing a file extension, then Windows default file extensions
     *   will be searched.
     *
     * @param filename - The name of the executable file.  This string must not contain any
     * command-line arguments.  If the name contains any path delimiters, then the shell's
     * default PATH will not be searched.
     * @param args - The command-line arguments to be passed to the process.
     * @param options - Additional options
     * @returns the same data type as returned by the NodeJS child_process.spawnSync() API
     *
     * @privateRemarks
     *
     * NOTE: The NodeJS spawnSync() returns SpawnSyncReturns<string> or SpawnSyncReturns<Buffer>
     * polymorphically based on the options.encoding parameter value.  This is a fairly confusing
     * design.  In most cases, developers want string with the default encoding.  If/when someone
     * wants binary output or a non-default text encoding, we will introduce a separate API function
     * with a name like "spawnWithBufferSync".
     */
    static spawnSync(filename, args, options) {
        if (!options) {
            options = {};
        }
        const context = Executable._getExecutableContext(options);
        const resolvedPath = Executable._tryResolve(filename, options, context);
        if (!resolvedPath) {
            throw new Error(`The executable file was not found: "${filename}"`);
        }
        const spawnOptions = {
            cwd: context.currentWorkingDirectory,
            env: context.environmentMap.toObject(),
            input: options.input,
            stdio: options.stdio,
            timeout: options.timeoutMs,
            maxBuffer: options.maxBuffer,
            // Contrary to what the NodeJS typings imply, we must explicitly specify "utf8" here
            // if we want the result to be SpawnSyncReturns<string> instead of SpawnSyncReturns<Buffer>.
            encoding: 'utf8',
            // NOTE: This is always false, because Rushell will be recommended instead of relying on the OS shell.
            shell: false
        };
        const normalizedCommandLine = Executable._buildCommandLineFixup(resolvedPath, args, context);
        return child_process.spawnSync(normalizedCommandLine.path, normalizedCommandLine.args, spawnOptions);
    }
    /**
     * Start a child process.
     *
     * @remarks
     * This function is similar to child_process.spawn().  The main differences are:
     *
     * - It does not invoke the OS shell unless the executable file is a shell script.
     * - Command-line arguments containing special characters are more accurately passed
     *   through to the child process.
     * - If the filename is missing a path, then the shell's default PATH will be searched.
     * - If the filename is missing a file extension, then Windows default file extensions
     *   will be searched.
     *
     * This command is asynchronous, but it does not return a `Promise`.  Instead it returns
     * a Node.js `ChildProcess` supporting event notifications.
     *
     * @param filename - The name of the executable file.  This string must not contain any
     * command-line arguments.  If the name contains any path delimiters, then the shell's
     * default PATH will not be searched.
     * @param args - The command-line arguments to be passed to the process.
     * @param options - Additional options
     * @returns the same data type as returned by the NodeJS child_process.spawnSync() API
     */
    static spawn(filename, args, options) {
        if (!options) {
            options = {};
        }
        const context = Executable._getExecutableContext(options);
        const resolvedPath = Executable._tryResolve(filename, options, context);
        if (!resolvedPath) {
            throw new Error(`The executable file was not found: "${filename}"`);
        }
        const spawnOptions = {
            cwd: context.currentWorkingDirectory,
            env: context.environmentMap.toObject(),
            stdio: options.stdio,
            // NOTE: This is always false, because Rushell will be recommended instead of relying on the OS shell.
            shell: false
        };
        const normalizedCommandLine = Executable._buildCommandLineFixup(resolvedPath, args, context);
        return child_process.spawn(normalizedCommandLine.path, normalizedCommandLine.args, spawnOptions);
    }
    // PROBLEM: Given an "args" array of strings that may contain special characters (e.g. spaces,
    // backslashes, quotes), ensure that these strings pass through to the child process's ARGV array
    // without anything getting corrupted along the way.
    //
    // On Unix you just pass the array to spawnSync().  But on Windows, this is a very complex problem:
    // - The Win32 CreateProcess() API expects the args to be encoded as a single text string
    // - The decoding of this string is up to the application (not the OS), and there are 3 different
    //   algorithms in common usage:  the cmd.exe shell, the Microsoft CRT library init code, and
    //   the Win32 CommandLineToArgvW()
    // - The encodings are counterintuitive and have lots of special cases
    // - NodeJS spawnSync() tries do the encoding without knowing which decoder will be used
    //
    // See these articles for a full analysis:
    // http://www.windowsinspired.com/understanding-the-command-line-string-and-arguments-received-by-a-windows-program/
    // http://www.windowsinspired.com/how-a-windows-programs-splits-its-command-line-into-individual-arguments/
    static _buildCommandLineFixup(resolvedPath, args, context) {
        const fileExtension = path.extname(resolvedPath);
        if (os.platform() === 'win32') {
            // Do we need a custom handler for this file type?
            switch (fileExtension.toUpperCase()) {
                case '.EXE':
                case '.COM':
                    // okay to execute directly
                    break;
                case '.BAT':
                case '.CMD': {
                    Executable._validateArgsForWindowsShell(args);
                    // These file types must be invoked via the Windows shell
                    let shellPath = context.environmentMap.get('COMSPEC');
                    if (!shellPath || !Executable._canExecute(shellPath, context)) {
                        shellPath = Executable.tryResolve('cmd.exe');
                    }
                    if (!shellPath) {
                        throw new Error(`Unable to execute "${path.basename(resolvedPath)}" ` +
                            `because CMD.exe was not found in the PATH`);
                    }
                    const shellArgs = [];
                    // /D: Disable execution of AutoRun commands when starting the new shell context
                    shellArgs.push('/d');
                    // /S: Disable Cmd.exe's parsing of double-quote characters inside the command-line
                    shellArgs.push('/s');
                    // /C: Execute the following command and then exit immediately
                    shellArgs.push('/c');
                    // If the path contains special charactrers (e.g. spaces), escape them so that
                    // they don't get interpreted by the shell
                    shellArgs.push(Executable._getEscapedForWindowsShell(resolvedPath));
                    shellArgs.push(...args);
                    return { path: shellPath, args: shellArgs };
                }
                default:
                    throw new Error(`Cannot execute "${path.basename(resolvedPath)}" because the file type is not supported`);
            }
        }
        return {
            path: resolvedPath,
            args: args
        };
    }
    /**
     * Given a filename, this determines the absolute path of the executable file that would
     * be executed by a shell:
     *
     * - If the filename is missing a path, then the shell's default PATH will be searched.
     * - If the filename is missing a file extension, then Windows default file extensions
     *   will be searched.
     *
     * @remarks
     *
     * @param filename - The name of the executable file.  This string must not contain any
     * command-line arguments.  If the name contains any path delimiters, then the shell's
     * default PATH will not be searched.
     * @param options - optional other parameters
     * @returns the absolute path of the executable, or undefined if it was not found
     */
    static tryResolve(filename, options) {
        return Executable._tryResolve(filename, options || {}, Executable._getExecutableContext(options));
    }
    static _tryResolve(filename, options, context) {
        // NOTE: Since "filename" cannot contain command-line arguments, the "/" here
        // must be interpreted as a path delimiter
        const hasPathSeparators = filename.indexOf('/') >= 0 || (os.platform() === 'win32' && filename.indexOf('\\') >= 0);
        // Are there any path separators?
        if (hasPathSeparators) {
            // If so, then don't search the PATH.  Just resolve relative to the current working directory
            const resolvedPath = path.resolve(context.currentWorkingDirectory, filename);
            return Executable._tryResolveFileExtension(resolvedPath, context);
        }
        else {
            // Otherwise if it's a bare name, then try everything in the shell PATH
            const pathsToSearch = Executable._getSearchFolders(context);
            for (const pathToSearch of pathsToSearch) {
                const resolvedPath = path.join(pathToSearch, filename);
                const result = Executable._tryResolveFileExtension(resolvedPath, context);
                if (result) {
                    return result;
                }
            }
            // No match was found
            return undefined;
        }
    }
    static _tryResolveFileExtension(resolvedPath, context) {
        if (Executable._canExecute(resolvedPath, context)) {
            return resolvedPath;
        }
        // Try the default file extensions
        for (const shellExtension of context.windowsExecutableExtensions) {
            const resolvedNameWithExtension = resolvedPath + shellExtension;
            if (Executable._canExecute(resolvedNameWithExtension, context)) {
                return resolvedNameWithExtension;
            }
        }
        return undefined;
    }
    static _buildEnvironmentMap(options) {
        const environmentMap = new EnvironmentMap_1.EnvironmentMap();
        if (options.environment !== undefined && options.environmentMap !== undefined) {
            throw new Error('IExecutableResolveOptions.environment and IExecutableResolveOptions.environmentMap' +
                ' cannot both be specified');
        }
        if (options.environment !== undefined) {
            environmentMap.mergeFromObject(options.environment);
        }
        else if (options.environmentMap !== undefined) {
            environmentMap.mergeFrom(options.environmentMap);
        }
        else {
            environmentMap.mergeFromObject(process.env);
        }
        return environmentMap;
    }
    /**
     * This is used when searching the shell PATH for an executable, to determine
     * whether a match should be skipped or not.  If it returns true, this does not
     * guarantee that the file can be successfully executed.
     */
    static _canExecute(filePath, context) {
        if (!FileSystem_1.FileSystem.exists(filePath)) {
            return false;
        }
        if (os.platform() === 'win32') {
            // NOTE: For Windows, we don't validate that the file extension appears in PATHEXT.
            // That environment variable determines which extensions can be appended if the
            // extension is missing, but it does not affect whether a file may be executed or not.
            // Windows does have a (seldom used) ACL that can be used to deny execution permissions
            // for a file, but NodeJS doesn't expose that API, so we don't bother checking it.
            // However, Windows *does* require that the file has some kind of file extension
            if (path.extname(filePath) === '') {
                return false;
            }
        }
        else {
            // For Unix, check whether any of the POSIX execute bits are set
            try {
                // eslint-disable-next-line no-bitwise
                if ((FileSystem_1.FileSystem.getPosixModeBits(filePath) & 73 /* AllExecute */) === 0) {
                    return false; // not executable
                }
            }
            catch (error) {
                // If we have trouble accessing the file, ignore the error and consider it "not executable"
                // since that's what a shell would do
            }
        }
        return true;
    }
    /**
     * Returns the list of folders where we will search for an executable,
     * based on the PATH environment variable.
     */
    static _getSearchFolders(context) {
        const pathList = context.environmentMap.get('PATH') || '';
        const folders = [];
        // Avoid processing duplicates
        const seenPaths = new Set();
        // NOTE: Cmd.exe on Windows always searches the current working directory first.
        // PowerShell and Unix shells do NOT do that, because it's a security concern.
        // We follow their behavior.
        for (const splitPath of pathList.split(path.delimiter)) {
            const trimmedPath = splitPath.trim();
            if (trimmedPath !== '') {
                if (!seenPaths.has(trimmedPath)) {
                    // Fun fact: If you put relative paths in your PATH environment variable,
                    // all shells will dynamically match them against the current working directory.
                    // This is a terrible design, and in practice nobody does that, but it is supported...
                    // so we allow it here.
                    const resolvedPath = path.resolve(context.currentWorkingDirectory, trimmedPath);
                    if (!seenPaths.has(resolvedPath)) {
                        if (FileSystem_1.FileSystem.exists(resolvedPath)) {
                            folders.push(resolvedPath);
                        }
                        seenPaths.add(resolvedPath);
                    }
                    seenPaths.add(trimmedPath);
                }
            }
        }
        return folders;
    }
    static _getExecutableContext(options) {
        if (!options) {
            options = {};
        }
        const environment = Executable._buildEnvironmentMap(options);
        let currentWorkingDirectory;
        if (options.currentWorkingDirectory) {
            currentWorkingDirectory = path.resolve(options.currentWorkingDirectory);
        }
        else {
            currentWorkingDirectory = process.cwd();
        }
        const windowsExecutableExtensions = [];
        if (os.platform() === 'win32') {
            const pathExtVariable = environment.get('PATHEXT') || '';
            for (const splitValue of pathExtVariable.split(';')) {
                const trimmed = splitValue.trim().toLowerCase();
                // Ignore malformed extensions
                if (/^\.[a-z0-9\.]*[a-z0-9]$/i.test(trimmed)) {
                    // Don't add the same extension twice
                    if (windowsExecutableExtensions.indexOf(trimmed) < 0) {
                        windowsExecutableExtensions.push(trimmed);
                    }
                }
            }
        }
        return {
            environmentMap: environment,
            currentWorkingDirectory,
            windowsExecutableExtensions
        };
    }
    /**
     * Given an input string containing special symbol characters, this inserts the "^" escape
     * character to ensure the symbols are interpreted literally by the Windows shell.
     */
    static _getEscapedForWindowsShell(text) {
        const escapableCharRegExp = /[%\^&|<> ]/g;
        return text.replace(escapableCharRegExp, (value) => '^' + value);
    }
    /**
     * Checks for characters that are unsafe to pass to a Windows batch file
     * due to the way that cmd.exe implements escaping.
     */
    static _validateArgsForWindowsShell(args) {
        const specialCharRegExp = /[%\^&|<>\r\n]/g;
        for (const arg of args) {
            const match = arg.match(specialCharRegExp);
            if (match) {
                // NOTE: It is possible to escape some of these characters by prefixing them
                // with a caret (^), which allows these characters to be successfully passed
                // through to the batch file %1 variables.  But they will be expanded again
                // whenever they are used.  For example, NPM's binary wrapper batch files
                // use "%*" to pass their arguments to Node.exe, which causes them to be expanded
                // again.  Unfortunately the Cmd.exe batch language provides native escaping
                // function (that could be used to insert the carets again).
                //
                // We could work around that by adding double carets, but in general there
                // is no way to predict how many times the variable will get expanded.
                // Thus, there is no generally reliable way to pass these characters.
                throw new Error(`The command line argument ${JSON.stringify(arg)} contains a` +
                    ` special character ${JSON.stringify(match[0])} that cannot be escaped for the Windows shell`);
            }
        }
    }
}
exports.Executable = Executable;
//# sourceMappingURL=Executable.js.map

/***/ }),

/***/ 76952:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileSystem = void 0;
const nodeJsPath = __importStar(__webpack_require__(85622));
const fs = __importStar(__webpack_require__(35747));
const fsx = __importStar(__webpack_require__(5630));
const Text_1 = __webpack_require__(963);
const MOVE_DEFAULT_OPTIONS = {
    overwrite: true,
    ensureFolderExists: false
};
const READ_FOLDER_DEFAULT_OPTIONS = {
    absolutePaths: false
};
const WRITE_FILE_DEFAULT_OPTIONS = {
    ensureFolderExists: false,
    convertLineEndings: undefined,
    encoding: "utf8" /* Utf8 */
};
const APPEND_TO_FILE_DEFAULT_OPTIONS = Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS);
const READ_FILE_DEFAULT_OPTIONS = {
    encoding: "utf8" /* Utf8 */,
    convertLineEndings: undefined
};
const COPY_FILE_DEFAULT_OPTIONS = {
    alreadyExistsBehavior: "overwrite" /* Overwrite */
};
const COPY_FILES_DEFAULT_OPTIONS = {
    alreadyExistsBehavior: "overwrite" /* Overwrite */
};
const DELETE_FILE_DEFAULT_OPTIONS = {
    throwIfNotExists: false
};
/**
 * The FileSystem API provides a complete set of recommended operations for interacting with the file system.
 *
 * @remarks
 * We recommend to use this instead of the native `fs` API, because `fs` is a minimal set of low-level
 * primitives that must be mapped for each supported operating system. The FileSystem API takes a
 * philosophical approach of providing "one obvious way" to do each operation. We also prefer synchronous
 * operations except in cases where there would be a clear performance benefit for using async, since synchronous
 * code is much easier to read and debug. Also, indiscriminate parallelism has been seen to actually worsen
 * performance, versus improving it.
 *
 * Note that in the documentation, we refer to "filesystem objects", this can be a
 * file, folder, symbolic link, hard link, directory junction, etc.
 *
 * @public
 */
class FileSystem {
    // ===============
    // COMMON OPERATIONS
    // ===============
    /**
     * Returns true if the path exists on disk.
     * Behind the scenes it uses `fs.existsSync()`.
     * @remarks
     * There is a debate about the fact that after `fs.existsSync()` returns true,
     * the file might be deleted before fs.readSync() is called, which would imply that everybody
     * should catch a `readSync()` exception, and nobody should ever use `fs.existsSync()`.
     * We find this to be unpersuasive, since "unexceptional exceptions" really hinder the
     * break-on-exception debugging experience. Also, throwing/catching is generally slow.
     * @param path - The absolute or relative path to the filesystem object.
     */
    static exists(path) {
        return FileSystem._wrapException(() => {
            return fsx.existsSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.exists}.
     */
    static async existsAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return new Promise((resolve) => {
                fsx.exists(path, resolve);
            });
        });
    }
    /**
     * Gets the statistics for a particular filesystem object.
     * If the path is a link, this function follows the link and returns statistics about the link target.
     * Behind the scenes it uses `fs.statSync()`.
     * @param path - The absolute or relative path to the filesystem object.
     */
    static getStatistics(path) {
        return FileSystem._wrapException(() => {
            return fsx.statSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.getStatistics}.
     */
    static async getStatisticsAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.stat(path);
        });
    }
    /**
     * Updates the accessed and modified timestamps of the filesystem object referenced by path.
     * Behind the scenes it uses `fs.utimesSync()`.
     * The caller should specify both times in the `times` parameter.
     * @param path - The path of the file that should be modified.
     * @param times - The times that the object should be updated to reflect.
     */
    static updateTimes(path, times) {
        return FileSystem._wrapException(() => {
            fsx.utimesSync(path, times.accessedTime, times.modifiedTime);
        });
    }
    /**
     * An async version of {@link FileSystem.updateTimes}.
     */
    static async updateTimesAsync(path, times) {
        await FileSystem._wrapExceptionAsync(() => {
            // This cast is needed because the fs-extra typings require both parameters
            // to have the same type (number or Date), whereas Node.js does not require that.
            return fsx.utimes(path, times.accessedTime, times.modifiedTime);
        });
    }
    /**
     * Changes the permissions (i.e. file mode bits) for a filesystem object.
     * Behind the scenes it uses `fs.chmodSync()`.
     * @param path - The absolute or relative path to the object that should be updated.
     * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum
     */
    static changePosixModeBits(path, mode) {
        FileSystem._wrapException(() => {
            fs.chmodSync(path, mode);
        });
    }
    /**
     * An async version of {@link FileSystem.changePosixModeBits}.
     */
    static async changePosixModeBitsAsync(path, mode) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.chmod(path, mode);
        });
    }
    /**
     * Retrieves the permissions (i.e. file mode bits) for a filesystem object.
     * Behind the scenes it uses `fs.chmodSync()`.
     * @param path - The absolute or relative path to the object that should be updated.
     *
     * @remarks
     * This calls {@link FileSystem.getStatistics} to get the POSIX mode bits.
     * If statistics in addition to the mode bits are needed, it is more efficient
     * to call {@link FileSystem.getStatistics} directly instead.
     */
    static getPosixModeBits(path) {
        return FileSystem._wrapException(() => {
            return FileSystem.getStatistics(path).mode;
        });
    }
    /**
     * An async version of {@link FileSystem.getPosixModeBits}.
     */
    static async getPosixModeBitsAsync(path) {
        return await FileSystem._wrapExceptionAsync(async () => {
            return (await FileSystem.getStatisticsAsync(path)).mode;
        });
    }
    /**
     * Returns a 10-character string representation of a PosixModeBits value similar to what
     * would be displayed by a command such as "ls -l" on a POSIX-like operating system.
     * @remarks
     * For example, `PosixModeBits.AllRead | PosixModeBits.AllWrite` would be formatted as "-rw-rw-rw-".
     * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum
     */
    static formatPosixModeBits(modeBits) {
        let result = '-'; // (later we may add support for additional states such as S_IFDIR or S_ISUID)
        result += modeBits & 256 /* UserRead */ ? 'r' : '-';
        result += modeBits & 128 /* UserWrite */ ? 'w' : '-';
        result += modeBits & 64 /* UserExecute */ ? 'x' : '-';
        result += modeBits & 32 /* GroupRead */ ? 'r' : '-';
        result += modeBits & 16 /* GroupWrite */ ? 'w' : '-';
        result += modeBits & 8 /* GroupExecute */ ? 'x' : '-';
        result += modeBits & 4 /* OthersRead */ ? 'r' : '-';
        result += modeBits & 2 /* OthersWrite */ ? 'w' : '-';
        result += modeBits & 1 /* OthersExecute */ ? 'x' : '-';
        return result;
    }
    /**
     * Moves a file. The folder must exist, unless the `ensureFolderExists` option is provided.
     * Behind the scenes it uses `fs-extra.moveSync()`
     */
    static move(options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, MOVE_DEFAULT_OPTIONS), options);
            try {
                fsx.moveSync(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(options.destinationPath);
                    FileSystem.ensureFolder(folderPath);
                    fsx.moveSync(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.move}.
     */
    static async moveAsync(options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, MOVE_DEFAULT_OPTIONS), options);
            try {
                await fsx.move(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(options.destinationPath);
                    await FileSystem.ensureFolderAsync(nodeJsPath.dirname(folderPath));
                    await fsx.move(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
                }
                else {
                    throw error;
                }
            }
        });
    }
    // ===============
    // FOLDER OPERATIONS
    // ===============
    /**
     * Recursively creates a folder at a given path.
     * Behind the scenes is uses `fs-extra.ensureDirSync()`.
     * @remarks
     * Throws an exception if anything in the folderPath is not a folder.
     * @param folderPath - The absolute or relative path of the folder which should be created.
     */
    static ensureFolder(folderPath) {
        FileSystem._wrapException(() => {
            fsx.ensureDirSync(folderPath);
        });
    }
    /**
     * An async version of {@link FileSystem.ensureFolder}.
     */
    static async ensureFolderAsync(folderPath) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.ensureDir(folderPath);
        });
    }
    /**
     * Reads the contents of the folder, not including "." or "..".
     * Behind the scenes it uses `fs.readdirSync()`.
     * @param folderPath - The absolute or relative path to the folder which should be read.
     * @param options - Optional settings that can change the behavior. Type: `IReadFolderOptions`
     */
    static readFolder(folderPath, options) {
        return FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, READ_FOLDER_DEFAULT_OPTIONS), options);
            // @todo: Update this to use Node 10's `withFileTypes: true` option when we drop support for Node 8
            const fileNames = fsx.readdirSync(folderPath);
            if (options.absolutePaths) {
                return fileNames.map((fileName) => nodeJsPath.resolve(folderPath, fileName));
            }
            else {
                return fileNames;
            }
        });
    }
    /**
     * An async version of {@link FileSystem.readFolder}.
     */
    static async readFolderAsync(folderPath, options) {
        return await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, READ_FOLDER_DEFAULT_OPTIONS), options);
            // @todo: Update this to use Node 10's `withFileTypes: true` option when we drop support for Node 8
            const fileNames = await fsx.readdir(folderPath);
            if (options.absolutePaths) {
                return fileNames.map((fileName) => nodeJsPath.resolve(folderPath, fileName));
            }
            else {
                return fileNames;
            }
        });
    }
    /**
     * Deletes a folder, including all of its contents.
     * Behind the scenes is uses `fs-extra.removeSync()`.
     * @remarks
     * Does not throw if the folderPath does not exist.
     * @param folderPath - The absolute or relative path to the folder which should be deleted.
     */
    static deleteFolder(folderPath) {
        FileSystem._wrapException(() => {
            fsx.removeSync(folderPath);
        });
    }
    /**
     * An async version of {@link FileSystem.deleteFolder}.
     */
    static async deleteFolderAsync(folderPath) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.remove(folderPath);
        });
    }
    /**
     * Deletes the content of a folder, but not the folder itself. Also ensures the folder exists.
     * Behind the scenes it uses `fs-extra.emptyDirSync()`.
     * @remarks
     * This is a workaround for a common race condition, where the virus scanner holds a lock on the folder
     * for a brief period after it was deleted, causing EBUSY errors for any code that tries to recreate the folder.
     * @param folderPath - The absolute or relative path to the folder which should have its contents deleted.
     */
    static ensureEmptyFolder(folderPath) {
        FileSystem._wrapException(() => {
            fsx.emptyDirSync(folderPath);
        });
    }
    /**
     * An async version of {@link FileSystem.ensureEmptyFolder}.
     */
    static async ensureEmptyFolderAsync(folderPath) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.emptyDir(folderPath);
        });
    }
    // ===============
    // FILE OPERATIONS
    // ===============
    /**
     * Writes a text string to a file on disk, overwriting the file if it already exists.
     * Behind the scenes it uses `fs.writeFileSync()`.
     * @remarks
     * Throws an error if the folder doesn't exist, unless ensureFolder=true.
     * @param filePath - The absolute or relative path of the file.
     * @param contents - The text that should be written to the file.
     * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`
     */
    static writeFile(filePath, contents, options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                fsx.writeFileSync(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    FileSystem.ensureFolder(folderPath);
                    fsx.writeFileSync(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.writeFile}.
     */
    static async writeFileAsync(filePath, contents, options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                await fsx.writeFile(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    await FileSystem.ensureFolderAsync(folderPath);
                    await fsx.writeFile(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * Writes a text string to a file on disk, appending to the file if it already exists.
     * Behind the scenes it uses `fs.appendFileSync()`.
     * @remarks
     * Throws an error if the folder doesn't exist, unless ensureFolder=true.
     * @param filePath - The absolute or relative path of the file.
     * @param contents - The text that should be written to the file.
     * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`
     */
    static appendToFile(filePath, contents, options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, APPEND_TO_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                fsx.appendFileSync(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    FileSystem.ensureFolder(folderPath);
                    fsx.appendFileSync(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.appendToFile}.
     */
    static async appendToFileAsync(filePath, contents, options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, APPEND_TO_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                await fsx.appendFile(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    await FileSystem.ensureFolderAsync(folderPath);
                    await fsx.appendFile(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * Reads the contents of a file into a string.
     * Behind the scenes it uses `fs.readFileSync()`.
     * @param filePath - The relative or absolute path to the file whose contents should be read.
     * @param options - Optional settings that can change the behavior. Type: `IReadFileOptions`
     */
    static readFile(filePath, options) {
        return FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, READ_FILE_DEFAULT_OPTIONS), options);
            let contents = FileSystem.readFileToBuffer(filePath).toString(options.encoding);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents, options.convertLineEndings);
            }
            return contents;
        });
    }
    /**
     * An async version of {@link FileSystem.readFile}.
     */
    static async readFileAsync(filePath, options) {
        return await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, READ_FILE_DEFAULT_OPTIONS), options);
            let contents = (await FileSystem.readFileToBufferAsync(filePath)).toString(options.encoding);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents, options.convertLineEndings);
            }
            return contents;
        });
    }
    /**
     * Reads the contents of a file into a buffer.
     * Behind the scenes is uses `fs.readFileSync()`.
     * @param filePath - The relative or absolute path to the file whose contents should be read.
     */
    static readFileToBuffer(filePath) {
        return FileSystem._wrapException(() => {
            return fsx.readFileSync(filePath);
        });
    }
    /**
     * An async version of {@link FileSystem.readFileToBuffer}.
     */
    static async readFileToBufferAsync(filePath) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.readFile(filePath);
        });
    }
    /**
     * Copies a single file from one location to another.
     * By default, destinationPath is overwritten if it already exists.
     *
     * @remarks
     * The `copyFile()` API cannot be used to copy folders.  It copies at most one file.
     * Use {@link FileSystem.copyFiles} if you need to recursively copy a tree of folders.
     *
     * The implementation is based on `copySync()` from the `fs-extra` package.
     */
    static copyFile(options) {
        options = Object.assign(Object.assign({}, COPY_FILE_DEFAULT_OPTIONS), options);
        if (FileSystem.getStatistics(options.sourcePath).isDirectory()) {
            throw new Error('The specified path refers to a folder; this operation expects a file object:\n' + options.sourcePath);
        }
        FileSystem._wrapException(() => {
            fsx.copySync(options.sourcePath, options.destinationPath, {
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */
            });
        });
    }
    /**
     * An async version of {@link FileSystem.copyFile}.
     */
    static async copyFileAsync(options) {
        options = Object.assign(Object.assign({}, COPY_FILE_DEFAULT_OPTIONS), options);
        if (FileSystem.getStatistics(options.sourcePath).isDirectory()) {
            throw new Error('The specified path refers to a folder; this operation expects a file object:\n' + options.sourcePath);
        }
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.copy(options.sourcePath, options.destinationPath, {
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */
            });
        });
    }
    /**
     * Copies a file or folder from one location to another, recursively copying any folder contents.
     * By default, destinationPath is overwritten if it already exists.
     *
     * @remarks
     * If you only intend to copy a single file, it is recommended to use {@link FileSystem.copyFile}
     * instead to more clearly communicate the intended operation.
     *
     * The implementation is based on `copySync()` from the `fs-extra` package.
     */
    static copyFiles(options) {
        options = Object.assign(Object.assign({}, COPY_FILES_DEFAULT_OPTIONS), options);
        FileSystem._wrapException(() => {
            fsx.copySync(options.sourcePath, options.destinationPath, {
                dereference: !!options.dereferenceSymlinks,
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */,
                preserveTimestamps: !!options.preserveTimestamps,
                filter: options.filter
            });
        });
    }
    /**
     * An async version of {@link FileSystem.copyFiles}.
     */
    static async copyFilesAsync(options) {
        options = Object.assign(Object.assign({}, COPY_FILES_DEFAULT_OPTIONS), options);
        await FileSystem._wrapExceptionAsync(async () => {
            fsx.copySync(options.sourcePath, options.destinationPath, {
                dereference: !!options.dereferenceSymlinks,
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */,
                preserveTimestamps: !!options.preserveTimestamps,
                filter: options.filter
            });
        });
    }
    /**
     * Deletes a file. Can optionally throw if the file doesn't exist.
     * Behind the scenes it uses `fs.unlinkSync()`.
     * @param filePath - The absolute or relative path to the file that should be deleted.
     * @param options - Optional settings that can change the behavior. Type: `IDeleteFileOptions`
     */
    static deleteFile(filePath, options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, DELETE_FILE_DEFAULT_OPTIONS), options);
            try {
                fsx.unlinkSync(filePath);
            }
            catch (error) {
                if (options.throwIfNotExists || !FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.deleteFile}.
     */
    static async deleteFileAsync(filePath, options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, DELETE_FILE_DEFAULT_OPTIONS), options);
            try {
                await fsx.unlink(filePath);
            }
            catch (error) {
                if (options.throwIfNotExists || !FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        });
    }
    // ===============
    // LINK OPERATIONS
    // ===============
    /**
     * Gets the statistics of a filesystem object. Does NOT follow the link to its target.
     * Behind the scenes it uses `fs.lstatSync()`.
     * @param path - The absolute or relative path to the filesystem object.
     */
    static getLinkStatistics(path) {
        return FileSystem._wrapException(() => {
            return fsx.lstatSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.getLinkStatistics}.
     */
    static async getLinkStatisticsAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.lstat(path);
        });
    }
    /**
     * If `path` refers to a symbolic link, this returns the path of the link target, which may be
     * an absolute or relative path.
     *
     * @remarks
     * If `path` refers to a filesystem object that is not a symbolic link, then an `ErrnoException` is thrown
     * with code 'UNKNOWN'.  If `path` does not exist, then an `ErrnoException` is thrown with code `ENOENT`.
     *
     * @param path - The absolute or relative path to the symbolic link.
     * @returns the path of the link target
     */
    static readLink(path) {
        return FileSystem._wrapException(() => {
            return fsx.readlinkSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.readLink}.
     */
    static async readLinkAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.readlink(path);
        });
    }
    /**
     * Creates an NTFS "directory junction" on Windows operating systems; for other operating systems, it
     * creates a regular symbolic link.  The link target must be a folder, not a file.
     * Behind the scenes it uses `fs.symlinkSync()`.
     *
     * @remarks
     * For security reasons, Windows operating systems by default require administrator elevation to create
     * symbolic links.  As a result, on Windows it's generally recommended for Node.js tools to use hard links
     * (for files) or NTFS directory junctions (for folders), since regular users are allowed to create them.
     * Hard links and junctions are less vulnerable to symlink attacks because they cannot reference a network share,
     * and their target must exist at the time of link creation.  Non-Windows operating systems generally don't
     * restrict symlink creation, and as such are more vulnerable to symlink attacks.  Note that Windows can be
     * configured to permit regular users to create symlinks, for example by enabling Windows 10 "developer mode."
     *
     * A directory junction requires the link source and target to both be located on local disk volumes;
     * if not, use a symbolic link instead.
     */
    static createSymbolicLinkJunction(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                // For directories, we use a Windows "junction".  On POSIX operating systems, this produces a regular symlink.
                return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'junction');
            }, options);
        });
    }
    /**
     * An async version of {@link FileSystem.createSymbolicLinkJunction}.
     */
    static async createSymbolicLinkJunctionAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                // For directories, we use a Windows "junction".  On POSIX operating systems, this produces a regular symlink.
                return fsx.symlink(options.linkTargetPath, options.newLinkPath, 'junction');
            }, options);
        });
    }
    /**
     * Creates a symbolic link to a file.  On Windows operating systems, this may require administrator elevation.
     * Behind the scenes it uses `fs.symlinkSync()`.
     *
     * @remarks
     * To avoid administrator elevation on Windows, use {@link FileSystem.createHardLink} instead.
     *
     * On Windows operating systems, the NTFS file system distinguishes file symlinks versus directory symlinks:
     * If the target is not the correct type, the symlink will be created successfully, but will fail to resolve.
     * Other operating systems do not make this distinction, in which case {@link FileSystem.createSymbolicLinkFile}
     * and {@link FileSystem.createSymbolicLinkFolder} can be used interchangeably, but doing so will make your
     * tool incompatible with Windows.
     */
    static createSymbolicLinkFile(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'file');
            }, options);
        });
    }
    /**
     * An async version of {@link FileSystem.createSymbolicLinkFile}.
     */
    static async createSymbolicLinkFileAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                return fsx.symlink(options.linkTargetPath, options.newLinkPath, 'file');
            }, options);
        });
    }
    /**
     * Creates a symbolic link to a folder.  On Windows operating systems, this may require administrator elevation.
     * Behind the scenes it uses `fs.symlinkSync()`.
     *
     * @remarks
     * To avoid administrator elevation on Windows, use {@link FileSystem.createSymbolicLinkJunction} instead.
     *
     * On Windows operating systems, the NTFS file system distinguishes file symlinks versus directory symlinks:
     * If the target is not the correct type, the symlink will be created successfully, but will fail to resolve.
     * Other operating systems do not make this distinction, in which case {@link FileSystem.createSymbolicLinkFile}
     * and {@link FileSystem.createSymbolicLinkFolder} can be used interchangeably, but doing so will make your
     * tool incompatible with Windows.
     */
    static createSymbolicLinkFolder(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'dir');
            }, options);
        });
    }
    /**
     * An async version of {@link FileSystem.createSymbolicLinkFolder}.
     */
    static async createSymbolicLinkFolderAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                return fsx.symlink(options.linkTargetPath, options.newLinkPath, 'dir');
            }, options);
        });
    }
    /**
     * Creates a hard link.  The link target must be a file, not a folder.
     * Behind the scenes it uses `fs.linkSync()`.
     *
     * @remarks
     * For security reasons, Windows operating systems by default require administrator elevation to create
     * symbolic links.  As a result, on Windows it's generally recommended for Node.js tools to use hard links
     * (for files) or NTFS directory junctions (for folders), since regular users are allowed to create them.
     * Hard links and junctions are less vulnerable to symlink attacks because they cannot reference a network share,
     * and their target must exist at the time of link creation.  Non-Windows operating systems generally don't
     * restrict symlink creation, and as such are more vulnerable to symlink attacks.  Note that Windows can be
     * configured to permit regular users to create symlinks, for example by enabling Windows 10 "developer mode."
     *
     * A hard link requires the link source and target to both be located on same disk volume;
     * if not, use a symbolic link instead.
     */
    static createHardLink(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                return fsx.linkSync(options.linkTargetPath, options.newLinkPath);
            }, Object.assign(Object.assign({}, options), { linkTargetMustExist: true }));
        });
    }
    /**
     * An async version of {@link FileSystem.createHardLink}.
     */
    static async createHardLinkAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                return fsx.link(options.linkTargetPath, options.newLinkPath);
            }, Object.assign(Object.assign({}, options), { linkTargetMustExist: true }));
        });
    }
    /**
     * Follows a link to its destination and returns the absolute path to the final target of the link.
     * Behind the scenes it uses `fs.realpathSync()`.
     * @param linkPath - The path to the link.
     */
    static getRealPath(linkPath) {
        return FileSystem._wrapException(() => {
            return fsx.realpathSync(linkPath);
        });
    }
    /**
     * An async version of {@link FileSystem.getRealPath}.
     */
    static async getRealPathAsync(linkPath) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.realpath(linkPath);
        });
    }
    // ===============
    // UTILITY FUNCTIONS
    // ===============
    /**
     * Returns true if the error object indicates the file or folder already exists (`EEXIST`).
     */
    static isExistError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'EEXIST';
    }
    /**
     * Returns true if the error object indicates the file or folder does not exist (`ENOENT` or `ENOTDIR`)
     */
    static isNotExistError(error) {
        return FileSystem.isFileDoesNotExistError(error) || FileSystem.isFolderDoesNotExistError(error);
    }
    /**
     * Returns true if the error object indicates the file does not exist (`ENOENT`).
     */
    static isFileDoesNotExistError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'ENOENT';
    }
    /**
     * Returns true if the error object indicates the folder does not exist (`ENOTDIR`).
     */
    static isFolderDoesNotExistError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'ENOTDIR';
    }
    /**
     * Returns true if the error object indicates that the `unlink` system call failed
     * due to a permissions issue (`EPERM`).
     */
    static isUnlinkNotPermittedError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'EPERM' && error.syscall === 'unlink';
    }
    /**
     * Detects if the provided error object is a `NodeJS.ErrnoException`
     */
    static isErrnoException(error) {
        const typedError = error;
        return (typeof typedError.code === 'string' &&
            typeof typedError.errno === 'number' &&
            typeof typedError.path === 'string' &&
            typeof typedError.syscall === 'string');
    }
    static _handleLink(linkFn, options) {
        try {
            linkFn();
        }
        catch (error) {
            if (FileSystem.isExistError(error)) {
                // Link exists, handle it
                switch (options.alreadyExistsBehavior) {
                    case "ignore" /* Ignore */:
                        break;
                    case "overwrite" /* Overwrite */:
                        // fsx.linkSync does not allow overwriting so we must manually delete. If it's
                        // a folder, it will throw an error.
                        this.deleteFile(options.newLinkPath);
                        linkFn();
                        break;
                    case "error" /* Error */:
                    default:
                        throw error;
                }
            }
            else {
                // When attempting to create a link in a directory that does not exist, an ENOENT
                // or ENOTDIR error is thrown, so we should ensure the directory exists before
                // retrying. There are also cases where the target file must exist, so validate in
                // those cases to avoid confusing the missing directory with the missing target file.
                if (FileSystem.isNotExistError(error) &&
                    (!options.linkTargetMustExist || FileSystem.exists(options.linkTargetPath))) {
                    this.ensureFolder(nodeJsPath.dirname(options.newLinkPath));
                    linkFn();
                }
                else {
                    throw error;
                }
            }
        }
    }
    static async _handleLinkAsync(linkFn, options) {
        try {
            await linkFn();
        }
        catch (error) {
            if (FileSystem.isExistError(error)) {
                // Link exists, handle it
                switch (options.alreadyExistsBehavior) {
                    case "ignore" /* Ignore */:
                        break;
                    case "overwrite" /* Overwrite */:
                        // fsx.linkSync does not allow overwriting so we must manually delete. If it's
                        // a folder, it will throw an error.
                        await this.deleteFileAsync(options.newLinkPath);
                        await linkFn();
                        break;
                    case "error" /* Error */:
                    default:
                        throw error;
                }
            }
            else {
                // When attempting to create a link in a directory that does not exist, an ENOENT
                // or ENOTDIR error is thrown, so we should ensure the directory exists before
                // retrying. There are also cases where the target file must exist, so validate in
                // those cases to avoid confusing the missing directory with the missing target file.
                if (FileSystem.isNotExistError(error) &&
                    (!options.linkTargetMustExist || (await FileSystem.existsAsync(options.linkTargetPath)))) {
                    await this.ensureFolderAsync(nodeJsPath.dirname(options.newLinkPath));
                    await linkFn();
                }
                else {
                    throw error;
                }
            }
        }
    }
    static _wrapException(fn) {
        try {
            return fn();
        }
        catch (error) {
            FileSystem._updateErrorMessage(error);
            throw error;
        }
    }
    static async _wrapExceptionAsync(fn) {
        try {
            return await fn();
        }
        catch (error) {
            FileSystem._updateErrorMessage(error);
            throw error;
        }
    }
    static _updateErrorMessage(error) {
        if (FileSystem.isErrnoException(error)) {
            if (FileSystem.isFileDoesNotExistError(error)) {
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `File does not exist: ${error.path}\n${error.message}`;
            }
            else if (FileSystem.isFolderDoesNotExistError(error)) {
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `Folder does not exist: ${error.path}\n${error.message}`;
            }
            else if (FileSystem.isExistError(error)) {
                // Oddly, the typing does not include the `dest` property even though the documentation
                // indicates it is there: https://nodejs.org/docs/latest-v10.x/api/errors.html#errors_error_dest
                const extendedError = error;
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `File or folder already exists: ${extendedError.dest}\n${error.message}`;
            }
            else if (FileSystem.isUnlinkNotPermittedError(error)) {
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `File or folder could not be deleted: ${error.path}\n${error.message}`;
            }
        }
    }
}
exports.FileSystem = FileSystem;
//# sourceMappingURL=FileSystem.js.map

/***/ }),

/***/ 78439:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileWriter = void 0;
const Import_1 = __webpack_require__(38489);
const fsx = Import_1.Import.lazy('fs-extra', require);
/**
 * API for interacting with file handles.
 * @public
 */
class FileWriter {
    constructor(fileDescriptor, filePath) {
        this._fileDescriptor = fileDescriptor;
        this.filePath = filePath;
    }
    /**
     * Opens a new file handle to the file at the specified path and given mode.
     * Behind the scenes it uses `fs.openSync()`.
     * The behaviour of this function is platform specific.
     * See: https://nodejs.org/docs/latest-v8.x/api/fs.html#fs_fs_open_path_flags_mode_callback
     * @param filePath - The absolute or relative path to the file handle that should be opened.
     * @param flags - The flags for opening the handle
     */
    static open(filePath, flags) {
        return new FileWriter(fsx.openSync(filePath, FileWriter._convertFlagsForNode(flags)), filePath);
    }
    /**
     * Helper function to convert the file writer array to a Node.js style string (e.g. "wx" or "a").
     * @param flags - The flags that should be converted.
     */
    static _convertFlagsForNode(flags) {
        flags = Object.assign({ append: false, exclusive: false }, flags);
        return [flags.append ? 'a' : 'w', flags.exclusive ? 'x' : ''].join('');
    }
    /**
     * Writes some text to the given file handle. Throws if the file handle has been closed.
     * Behind the scenes it uses `fs.writeSync()`.
     * @param text - The text to write to the file.
     */
    write(text) {
        if (!this._fileDescriptor) {
            throw new Error(`Cannot write to file, file descriptor has already been released.`);
        }
        fsx.writeSync(this._fileDescriptor, text);
    }
    /**
     * Closes the file handle permanently. No operations can be made on this file handle after calling this.
     * Behind the scenes it uses `fs.closeSync()` and releases the file descriptor to be re-used.
     *
     * @remarks
     * The `close()` method can be called more than once; additional calls are ignored.
     */
    close() {
        const fd = this._fileDescriptor;
        if (fd) {
            this._fileDescriptor = undefined;
            fsx.closeSync(fd);
        }
    }
}
exports.FileWriter = FileWriter;
//# sourceMappingURL=FileWriter.js.map

/***/ }),

/***/ 38489:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Import = void 0;
const path = __importStar(__webpack_require__(85622));
const importLazy = __webpack_require__(41239);
const Resolve = __importStar(__webpack_require__(61118));
const nodeModule = __webpack_require__(32282);
const PackageJsonLookup_1 = __webpack_require__(52453);
const FileSystem_1 = __webpack_require__(76952);
/**
 * Helpers for resolving and importing Node.js modules.
 * @public
 */
class Import {
    static get _builtInModules() {
        if (!Import.__builtInModules) {
            Import.__builtInModules = new Set(nodeModule.builtinModules);
        }
        return Import.__builtInModules;
    }
    /**
     * Provides a way to improve process startup times by lazy-loading imported modules.
     *
     * @remarks
     * This is a more structured wrapper for the {@link https://www.npmjs.com/package/import-lazy|import-lazy}
     * package.  It enables you to replace an import like this:
     *
     * ```ts
     * import * as example from 'example'; // <-- 100ms load time
     *
     * if (condition) {
     *   example.doSomething();
     * }
     * ```
     *
     * ...with a pattern like this:
     *
     * ```ts
     * const example: typeof import('example') = Import.lazy('example', require);
     *
     * if (condition) {
     *   example.doSomething(); // <-- 100ms load time occurs here, only if needed
     * }
     * ```
     *
     * The implementation relies on JavaScript's `Proxy` feature to intercept access to object members.  Thus
     * it will only work correctly with certain types of module exports.  If a particular export isn't well behaved,
     * you may need to find (or introduce) some other module in your dependency graph to apply the optimization to.
     *
     * Usage guidelines:
     *
     * - Always specify types using `typeof` as shown above.
     *
     * - Never apply lazy-loading in a way that would convert the module's type to `any`. Losing type safety
     *   seriously impacts the maintainability of the code base.
     *
     * - In cases where the non-runtime types are needed, import them separately using the `Types` suffix:
     *
     * ```ts
     * const example: typeof import('example') = Import.lazy('example', require);
     * import type * as exampleTypes from 'example';
     * ```
     *
     * - If the imported module confusingly has the same name as its export, then use the Module suffix:
     *
     * ```ts
     * const exampleModule: typeof import('../../logic/Example') = Import.lazy(
     *   '../../logic/Example', require);
     * import type * as exampleTypes from '../../logic/Example';
     * ```
     *
     * - If the exports cause a lot of awkwardness (e.g. too many expressions need to have `exampleModule.` inserted
     *   into them), or if some exports cannot be proxied (e.g. `Import.lazy('example', require)` returns a function
     *   signature), then do not lazy-load that module.  Instead, apply lazy-loading to some other module which is
     *   better behaved.
     *
     * - It's recommended to sort imports in a standard ordering:
     *
     * ```ts
     * // 1. external imports
     * import * as path from 'path';
     * import { Import, JsonFile, JsonObject } from '@rushstack/node-core-library';
     *
     * // 2. local imports
     * import { LocalFile } from './path/LocalFile';
     *
     * // 3. lazy-imports (which are technically variables, not imports)
     * const semver: typeof import('semver') = Import.lazy('semver', require);
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static lazy(moduleName, require) {
        const importLazyLocal = importLazy(require);
        return importLazyLocal(moduleName);
    }
    /**
     * This resolves a module path using similar logic as the Node.js `require.resolve()` API,
     * but supporting extra features such as specifying the base folder.
     *
     * @remarks
     * A module path is a text string that might appear in a statement such as
     * `import { X } from "____";` or `const x = require("___");`.  The implementation is based
     * on the popular `resolve` NPM package.
     *
     * Suppose `example` is an NPM package whose entry point is `lib/index.js`:
     * ```ts
     * // Returns "/path/to/project/node_modules/example/lib/index.js"
     * Import.resolveModule({ modulePath: 'example' });
     *
     * // Returns "/path/to/project/node_modules/example/lib/other.js"
     * Import.resolveModule({ modulePath: 'example/lib/other' });
     * ```
     * If you need to determine the containing package folder
     * (`/path/to/project/node_modules/example`), use {@link Import.resolvePackage} instead.
     *
     * @returns the absolute path of the resolved module.
     * If {@link IImportResolveOptions.includeSystemModules} is specified
     * and a system module is found, then its name is returned without any file path.
     */
    static resolveModule(options) {
        const { modulePath } = options;
        if (path.isAbsolute(modulePath)) {
            return modulePath;
        }
        const normalizedRootPath = FileSystem_1.FileSystem.getRealPath(options.baseFolderPath);
        if (modulePath.startsWith('.')) {
            // This looks like a conventional relative path
            return path.resolve(normalizedRootPath, modulePath);
        }
        if (options.includeSystemModules === true && Import._builtInModules.has(modulePath)) {
            return modulePath;
        }
        if (options.allowSelfReference === true) {
            const ownPackage = Import._getPackageName(options.baseFolderPath);
            if (ownPackage && modulePath.startsWith(ownPackage.packageName)) {
                const packagePath = modulePath.substr(ownPackage.packageName.length + 1);
                return path.resolve(ownPackage.packageRootPath, packagePath);
            }
        }
        try {
            return Resolve.sync(
            // Append a slash to the package name to ensure `resolve.sync` doesn't attempt to return a system package
            options.includeSystemModules !== true && modulePath.indexOf('/') === -1
                ? `${modulePath}/`
                : modulePath, {
                basedir: normalizedRootPath,
                preserveSymlinks: false
            });
        }
        catch (e) {
            throw new Error(`Cannot find module "${modulePath}" from "${options.baseFolderPath}".`);
        }
    }
    /**
     * Performs module resolution to determine the folder where a package is installed.
     *
     * @remarks
     * Suppose `example` is an NPM package whose entry point is `lib/index.js`:
     * ```ts
     * // Returns "/path/to/project/node_modules/example"
     * Import.resolvePackage({ packageName: 'example' });
     * ```
     *
     * If you need to resolve a module path, use {@link Import.resolveModule} instead:
     * ```ts
     * // Returns "/path/to/project/node_modules/example/lib/index.js"
     * Import.resolveModule({ modulePath: 'example' });
     * ```
     *
     * @returns the absolute path of the package folder.
     * If {@link IImportResolveOptions.includeSystemModules} is specified
     * and a system module is found, then its name is returned without any file path.
     */
    static resolvePackage(options) {
        const { packageName } = options;
        if (options.includeSystemModules && Import._builtInModules.has(packageName)) {
            return packageName;
        }
        const normalizedRootPath = FileSystem_1.FileSystem.getRealPath(options.baseFolderPath);
        if (options.allowSelfReference) {
            const ownPackage = Import._getPackageName(options.baseFolderPath);
            if (ownPackage && ownPackage.packageName === packageName) {
                return ownPackage.packageRootPath;
            }
        }
        try {
            const resolvedPath = Resolve.sync(packageName, {
                basedir: normalizedRootPath,
                preserveSymlinks: false,
                packageFilter: (pkg) => {
                    // Hardwire "main" to point to a file that is guaranteed to exist.
                    // This helps resolve packages such as @types/node that have no entry point.
                    // And then we can use path.dirname() below to locate the package folder,
                    // even if the real entry point was in an subfolder with arbitrary nesting.
                    pkg.main = 'package.json';
                    return pkg;
                }
            });
            const packagePath = path.dirname(resolvedPath);
            const packageJson = PackageJsonLookup_1.PackageJsonLookup.instance.loadPackageJson(path.join(packagePath, 'package.json'));
            if (packageJson.name === packageName) {
                return packagePath;
            }
            else {
                throw new Error();
            }
        }
        catch (e) {
            throw new Error(`Cannot find package "${packageName}" from "${options.baseFolderPath}".`);
        }
    }
    static _getPackageName(rootPath) {
        const packageJsonPath = PackageJsonLookup_1.PackageJsonLookup.instance.tryGetPackageJsonFilePathFor(rootPath);
        if (packageJsonPath) {
            const packageJson = PackageJsonLookup_1.PackageJsonLookup.instance.loadPackageJson(packageJsonPath);
            return {
                packageRootPath: path.dirname(packageJsonPath),
                packageName: packageJson.name
            };
        }
        else {
            return undefined;
        }
    }
}
exports.Import = Import;
//# sourceMappingURL=Import.js.map

/***/ }),

/***/ 73710:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InternalError = void 0;
/**
 * An `Error` subclass that should be thrown to report an unexpected state that may indicate a software defect.
 * An application may handle this error by instructing the end user to report an issue to the application maintainers.
 *
 * @remarks
 * Do not use this class unless you intend to solicit bug reports from end users.
 *
 * @public
 */
class InternalError extends Error {
    /**
     * Constructs a new instance of the {@link InternalError} class.
     *
     * @param message - A message describing the error.  This will be assigned to
     * {@link InternalError.unformattedMessage}.  The `Error.message` field will have additional boilerplate
     * explaining that the user has encountered a software defect.
     */
    constructor(message) {
        super(InternalError._formatMessage(message));
        // Manually set the prototype, as we can no longer extend built-in classes like Error, Array, Map, etc.
        // https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        //
        // Note: the prototype must also be set on any classes which extend this one
        this.__proto__ = InternalError.prototype; // eslint-disable-line @typescript-eslint/no-explicit-any
        this.unformattedMessage = message;
        if (InternalError.breakInDebugger) {
            // eslint-disable-next-line no-debugger
            debugger;
        }
    }
    static _formatMessage(unformattedMessage) {
        return (`Internal Error: ${unformattedMessage}\n\nYou have encountered a software defect. Please consider` +
            ` reporting the issue to the maintainers of this application.`);
    }
    /** @override */
    toString() {
        return this.message; // Avoid adding the "Error:" prefix
    }
}
exports.InternalError = InternalError;
/**
 * If true, a JavScript `debugger;` statement will be invoked whenever the `InternalError` constructor is called.
 *
 * @remarks
 * Generally applications should not be catching and ignoring an `InternalError`.  Instead, the error should
 * be reported and typically the application will terminate.  Thus, if `InternalError` is constructed, it's
 * almost always something we want to examine in a debugger.
 */
InternalError.breakInDebugger = true;
//# sourceMappingURL=InternalError.js.map

/***/ }),

/***/ 95873:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonFile = void 0;
const os = __importStar(__webpack_require__(12087));
const jju = __importStar(__webpack_require__(93304));
const Text_1 = __webpack_require__(963);
const FileSystem_1 = __webpack_require__(76952);
const DEFAULT_ENCODING = 'utf8';
/**
 * Utilities for reading/writing JSON files.
 * @public
 */
class JsonFile {
    /**
     * Loads a JSON file.
     */
    static load(jsonFilename) {
        try {
            const contents = FileSystem_1.FileSystem.readFile(jsonFilename);
            return jju.parse(contents);
        }
        catch (error) {
            if (FileSystem_1.FileSystem.isNotExistError(error)) {
                throw error;
            }
            else {
                throw new Error(`Error reading "${JsonFile._formatPathForError(jsonFilename)}":` +
                    os.EOL +
                    `  ${error.message}`);
            }
        }
    }
    /**
     * An async version of {@link JsonFile.load}.
     */
    static async loadAsync(jsonFilename) {
        try {
            const contents = await FileSystem_1.FileSystem.readFileAsync(jsonFilename);
            return jju.parse(contents);
        }
        catch (error) {
            if (FileSystem_1.FileSystem.isNotExistError(error)) {
                throw error;
            }
            else {
                throw new Error(`Error reading "${JsonFile._formatPathForError(jsonFilename)}":` +
                    os.EOL +
                    `  ${error.message}`);
            }
        }
    }
    /**
     * Parses a JSON file's contents.
     */
    static parseString(jsonContents) {
        return jju.parse(jsonContents);
    }
    /**
     * Loads a JSON file and validate its schema.
     */
    static loadAndValidate(jsonFilename, jsonSchema, options) {
        const jsonObject = JsonFile.load(jsonFilename);
        jsonSchema.validateObject(jsonObject, jsonFilename, options);
        return jsonObject;
    }
    /**
     * An async version of {@link JsonFile.loadAndValidate}.
     */
    static async loadAndValidateAsync(jsonFilename, jsonSchema, options) {
        const jsonObject = await JsonFile.loadAsync(jsonFilename);
        jsonSchema.validateObject(jsonObject, jsonFilename, options);
        return jsonObject;
    }
    /**
     * Loads a JSON file and validate its schema, reporting errors using a callback
     * @remarks
     * See JsonSchema.validateObjectWithCallback() for more info.
     */
    static loadAndValidateWithCallback(jsonFilename, jsonSchema, errorCallback) {
        const jsonObject = JsonFile.load(jsonFilename);
        jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);
        return jsonObject;
    }
    /**
     * An async version of {@link JsonFile.loadAndValidateWithCallback}.
     */
    static async loadAndValidateWithCallbackAsync(jsonFilename, jsonSchema, errorCallback) {
        const jsonObject = await JsonFile.loadAsync(jsonFilename);
        jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);
        return jsonObject;
    }
    /**
     * Serializes the specified JSON object to a string buffer.
     * @param jsonObject - the object to be serialized
     * @param options - other settings that control serialization
     * @returns a JSON string, with newlines, and indented with two spaces
     */
    static stringify(jsonObject, options) {
        return JsonFile.updateString('', jsonObject, options);
    }
    /**
     * Serializes the specified JSON object to a string buffer.
     * @param jsonObject - the object to be serialized
     * @param options - other settings that control serialization
     * @returns a JSON string, with newlines, and indented with two spaces
     */
    static updateString(previousJson, newJsonObject, options) {
        if (!options) {
            options = {};
        }
        if (!options.ignoreUndefinedValues) {
            // Standard handling of `undefined` in JSON stringification is to discard the key.
            JsonFile.validateNoUndefinedMembers(newJsonObject);
        }
        let stringified;
        if (previousJson !== '') {
            // NOTE: We don't use mode=json here because comments aren't allowed by strict JSON
            stringified = jju.update(previousJson, newJsonObject, {
                mode: 'cjson',
                indent: 2
            });
        }
        else if (options.prettyFormatting) {
            stringified = jju.stringify(newJsonObject, {
                mode: 'json',
                indent: 2
            });
            if (options.headerComment !== undefined) {
                stringified = JsonFile._formatJsonHeaderComment(options.headerComment) + stringified;
            }
        }
        else {
            stringified = JSON.stringify(newJsonObject, undefined, 2);
            if (options.headerComment !== undefined) {
                stringified = JsonFile._formatJsonHeaderComment(options.headerComment) + stringified;
            }
        }
        // Add the trailing newline
        stringified = Text_1.Text.ensureTrailingNewline(stringified);
        if (options && options.newlineConversion) {
            stringified = Text_1.Text.convertTo(stringified, options.newlineConversion);
        }
        return stringified;
    }
    /**
     * Saves the file to disk.  Returns false if nothing was written due to options.onlyIfChanged.
     * @param jsonObject - the object to be saved
     * @param jsonFilename - the file path to write
     * @param options - other settings that control how the file is saved
     * @returns false if ISaveJsonFileOptions.onlyIfChanged didn't save anything; true otherwise
     */
    static save(jsonObject, jsonFilename, options) {
        if (!options) {
            options = {};
        }
        // Do we need to read the previous file contents?
        let oldBuffer = undefined;
        if (options.updateExistingFile || options.onlyIfChanged) {
            try {
                oldBuffer = FileSystem_1.FileSystem.readFileToBuffer(jsonFilename);
            }
            catch (error) {
                if (!FileSystem_1.FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        }
        let jsonToUpdate = '';
        if (options.updateExistingFile && oldBuffer) {
            jsonToUpdate = oldBuffer.toString(DEFAULT_ENCODING);
        }
        const newJson = JsonFile.updateString(jsonToUpdate, jsonObject, options);
        const newBuffer = Buffer.from(newJson, DEFAULT_ENCODING);
        if (options.onlyIfChanged) {
            // Has the file changed?
            if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {
                // Nothing has changed, so don't touch the file
                return false;
            }
        }
        FileSystem_1.FileSystem.writeFile(jsonFilename, newBuffer.toString(DEFAULT_ENCODING), {
            ensureFolderExists: options.ensureFolderExists
        });
        // TEST CODE: Used to verify that onlyIfChanged isn't broken by a hidden transformation during saving.
        /*
        const oldBuffer2: Buffer = FileSystem.readFileToBuffer(jsonFilename);
        if (Buffer.compare(buffer, oldBuffer2) !== 0) {
          console.log('new:' + buffer.toString('hex'));
          console.log('old:' + oldBuffer2.toString('hex'));
    
          throw new Error('onlyIfChanged logic is broken');
        }
        */
        return true;
    }
    /**
     * An async version of {@link JsonFile.save}.
     */
    static async saveAsync(jsonObject, jsonFilename, options) {
        if (!options) {
            options = {};
        }
        // Do we need to read the previous file contents?
        let oldBuffer = undefined;
        if (options.updateExistingFile || options.onlyIfChanged) {
            try {
                oldBuffer = await FileSystem_1.FileSystem.readFileToBufferAsync(jsonFilename);
            }
            catch (error) {
                if (!FileSystem_1.FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        }
        let jsonToUpdate = '';
        if (options.updateExistingFile && oldBuffer) {
            jsonToUpdate = oldBuffer.toString(DEFAULT_ENCODING);
        }
        const newJson = JsonFile.updateString(jsonToUpdate, jsonObject, options);
        const newBuffer = Buffer.from(newJson, DEFAULT_ENCODING);
        if (options.onlyIfChanged) {
            // Has the file changed?
            if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {
                // Nothing has changed, so don't touch the file
                return false;
            }
        }
        await FileSystem_1.FileSystem.writeFileAsync(jsonFilename, newBuffer.toString(DEFAULT_ENCODING), {
            ensureFolderExists: options.ensureFolderExists
        });
        // TEST CODE: Used to verify that onlyIfChanged isn't broken by a hidden transformation during saving.
        /*
        const oldBuffer2: Buffer = await FileSystem.readFileToBufferAsync(jsonFilename);
        if (Buffer.compare(buffer, oldBuffer2) !== 0) {
          console.log('new:' + buffer.toString('hex'));
          console.log('old:' + oldBuffer2.toString('hex'));
    
          throw new Error('onlyIfChanged logic is broken');
        }
        */
        return true;
    }
    /**
     * Used to validate a data structure before writing.  Reports an error if there
     * are any undefined members.
     */
    static validateNoUndefinedMembers(jsonObject) {
        return JsonFile._validateNoUndefinedMembers(jsonObject, []);
    }
    // Private implementation of validateNoUndefinedMembers()
    static _validateNoUndefinedMembers(jsonObject, keyPath) {
        if (!jsonObject) {
            return;
        }
        if (typeof jsonObject === 'object') {
            for (const key of Object.keys(jsonObject)) {
                keyPath.push(key);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const value = jsonObject[key];
                if (value === undefined) {
                    const fullPath = JsonFile._formatKeyPath(keyPath);
                    throw new Error(`The value for ${fullPath} is "undefined" and cannot be serialized as JSON`);
                }
                JsonFile._validateNoUndefinedMembers(value, keyPath);
                keyPath.pop();
            }
        }
    }
    // Given this input:    ['items', '4', 'syntax', 'parameters', 'string "with" symbols", 'type']
    // Return this string:  items[4].syntax.parameters["string \"with\" symbols"].type
    static _formatKeyPath(keyPath) {
        let result = '';
        for (const key of keyPath) {
            if (/^[0-9]+$/.test(key)) {
                // It's an integer, so display like this:  parent[123]
                result += `[${key}]`;
            }
            else if (/^[a-z_][a-z_0-9]*$/i.test(key)) {
                // It's an alphanumeric identifier, so display like this:  parent.name
                if (result) {
                    result += '.';
                }
                result += `${key}`;
            }
            else {
                // It's a freeform string, so display like this:  parent["A path: \"C:\\file\""]
                // Convert this:     A path: "C:\file"
                // To this:          A path: \"C:\\file\"
                const escapedKey = key
                    .replace(/[\\]/g, '\\\\') // escape backslashes
                    .replace(/["]/g, '\\'); // escape quotes
                result += `["${escapedKey}"]`;
            }
        }
        return result;
    }
    static _formatJsonHeaderComment(headerComment) {
        if (headerComment === '') {
            return '';
        }
        const lines = headerComment.split('\n');
        const result = [];
        for (const line of lines) {
            if (!/^\s*$/.test(line) && !/^\s*\/\//.test(line)) {
                throw new Error('The headerComment lines must be blank or start with the "//" prefix.\n' +
                    'Invalid line' +
                    JSON.stringify(line));
            }
            result.push(Text_1.Text.replaceAll(line, '\r', ''));
        }
        return lines.join('\n') + '\n';
    }
}
exports.JsonFile = JsonFile;
/**
 * @internal
 */
JsonFile._formatPathForError = (path) => path;
//# sourceMappingURL=JsonFile.js.map

/***/ }),

/***/ 76792:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonSchema = void 0;
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const JsonFile_1 = __webpack_require__(95873);
const FileSystem_1 = __webpack_require__(76952);
const Validator = __webpack_require__(59997);
/**
 * Represents a JSON schema that can be used to validate JSON data files loaded by the JsonFile class.
 * @remarks
 * The schema itself is normally loaded and compiled later, only if it is actually required to validate
 * an input.  To avoid schema errors at runtime, it's recommended to create a unit test that calls
 * JsonSchema.ensureCompiled() for each of your schema objects.
 *
 * @public
 */
class JsonSchema {
    constructor() {
        this._dependentSchemas = [];
        this._filename = '';
        this._validator = undefined;
        this._schemaObject = undefined;
    }
    /**
     * Registers a JsonSchema that will be loaded from a file on disk.
     * @remarks
     * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
     * until it the schema is actually used.
     */
    static fromFile(filename, options) {
        // This is a quick and inexpensive test to avoid the catch the most common errors early.
        // Full validation will happen later in JsonSchema.compile().
        if (!FileSystem_1.FileSystem.exists(filename)) {
            throw new Error('Schema file not found: ' + filename);
        }
        const schema = new JsonSchema();
        schema._filename = filename;
        if (options) {
            schema._dependentSchemas = options.dependentSchemas || [];
        }
        return schema;
    }
    /**
     * Registers a JsonSchema that will be loaded from a file on disk.
     * @remarks
     * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
     * until it the schema is actually used.
     */
    static fromLoadedObject(schemaObject) {
        const schema = new JsonSchema();
        schema._schemaObject = schemaObject;
        return schema;
    }
    static _collectDependentSchemas(collectedSchemas, dependentSchemas, seenObjects, seenIds) {
        for (const dependentSchema of dependentSchemas) {
            // It's okay for the same schema to appear multiple times in the tree, but we only process it once
            if (seenObjects.has(dependentSchema)) {
                continue;
            }
            seenObjects.add(dependentSchema);
            const schemaId = dependentSchema._ensureLoaded();
            if (schemaId === '') {
                throw new Error(`This schema ${dependentSchema.shortName} cannot be referenced` +
                    ' because is missing the "id" field');
            }
            if (seenIds.has(schemaId)) {
                throw new Error(`This schema ${dependentSchema.shortName} has the same "id" as another schema in this set`);
            }
            seenIds.add(schemaId);
            collectedSchemas.push(dependentSchema);
            JsonSchema._collectDependentSchemas(collectedSchemas, dependentSchema._dependentSchemas, seenObjects, seenIds);
        }
    }
    /**
     * Used to nicely format the ZSchema error tree.
     */
    static _formatErrorDetails(errorDetails) {
        return JsonSchema._formatErrorDetailsHelper(errorDetails, '', '');
    }
    /**
     * Used by _formatErrorDetails.
     */
    static _formatErrorDetailsHelper(errorDetails, indent, buffer) {
        for (const errorDetail of errorDetails) {
            buffer += os.EOL + indent + `Error: ${errorDetail.path}`;
            if (errorDetail.description) {
                const MAX_LENGTH = 40;
                let truncatedDescription = errorDetail.description.trim();
                if (truncatedDescription.length > MAX_LENGTH) {
                    truncatedDescription = truncatedDescription.substr(0, MAX_LENGTH - 3) + '...';
                }
                buffer += ` (${truncatedDescription})`;
            }
            buffer += os.EOL + indent + `       ${errorDetail.message}`;
            if (errorDetail.inner) {
                buffer = JsonSchema._formatErrorDetailsHelper(errorDetail.inner, indent + '  ', buffer);
            }
        }
        return buffer;
    }
    /**
     * Returns a short name for this schema, for use in error messages.
     * @remarks
     * If the schema was loaded from a file, then the base filename is used.  Otherwise, the "id"
     * field is used if available.
     */
    get shortName() {
        if (!this._filename) {
            if (this._schemaObject) {
                const schemaWithId = this._schemaObject;
                if (schemaWithId.id) {
                    return schemaWithId.id;
                }
            }
            return '(anonymous schema)';
        }
        else {
            return path.basename(this._filename);
        }
    }
    /**
     * If not already done, this loads the schema from disk and compiles it.
     * @remarks
     * Any dependencies will be compiled as well.
     */
    ensureCompiled() {
        this._ensureLoaded();
        if (!this._validator) {
            // Don't assign this to _validator until we're sure everything was successful
            const newValidator = new Validator({
                breakOnFirstError: false,
                noTypeless: true,
                noExtraKeywords: true
            });
            const anythingSchema = {
                type: ['array', 'boolean', 'integer', 'number', 'object', 'string']
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            newValidator.setRemoteReference('http://json-schema.org/draft-04/schema', anythingSchema);
            const collectedSchemas = [];
            const seenObjects = new Set();
            const seenIds = new Set();
            JsonSchema._collectDependentSchemas(collectedSchemas, this._dependentSchemas, seenObjects, seenIds);
            // Validate each schema in order.  We specifically do not supply them all together, because we want
            // to make sure that circular references will fail to validate.
            for (const collectedSchema of collectedSchemas) {
                if (!newValidator.validateSchema(collectedSchema._schemaObject)) {
                    throw new Error(`Failed to validate schema "${collectedSchema.shortName}":` +
                        os.EOL +
                        JsonSchema._formatErrorDetails(newValidator.getLastErrors()));
                }
            }
            this._validator = newValidator;
        }
    }
    /**
     * Validates the specified JSON object against this JSON schema.  If the validation fails,
     * an exception will be thrown.
     * @param jsonObject - The JSON data to be validated
     * @param filenameForErrors - The filename that the JSON data was available, or an empty string
     *    if not applicable
     * @param options - Other options that control the validation
     */
    validateObject(jsonObject, filenameForErrors, options) {
        this.validateObjectWithCallback(jsonObject, (errorInfo) => {
            const prefix = options && options.customErrorHeader ? options.customErrorHeader : 'JSON validation failed:';
            throw new Error(prefix + os.EOL + filenameForErrors + os.EOL + errorInfo.details);
        });
    }
    /**
     * Validates the specified JSON object against this JSON schema.  If the validation fails,
     * a callback is called for each validation error.
     */
    validateObjectWithCallback(jsonObject, errorCallback) {
        this.ensureCompiled();
        if (!this._validator.validate(jsonObject, this._schemaObject)) {
            const errorDetails = JsonSchema._formatErrorDetails(this._validator.getLastErrors());
            const args = {
                details: errorDetails
            };
            errorCallback(args);
        }
    }
    _ensureLoaded() {
        if (!this._schemaObject) {
            this._schemaObject = JsonFile_1.JsonFile.load(this._filename);
        }
        return this._schemaObject.id || '';
    }
}
exports.JsonSchema = JsonSchema;
//# sourceMappingURL=JsonSchema.js.map

/***/ }),

/***/ 48547:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LegacyAdapters = void 0;
const timsort_1 = __webpack_require__(46655);
const semver = __importStar(__webpack_require__(11383));
/**
 * Helper functions used when interacting with APIs that do not follow modern coding practices.
 * @public
 */
class LegacyAdapters {
    static convertCallbackToPromise(fn, arg1, arg2, arg3, arg4) {
        return new Promise((resolve, reject) => {
            const cb = (error, result) => {
                if (error) {
                    reject(LegacyAdapters.scrubError(error));
                }
                else {
                    resolve(result);
                }
            };
            try {
                if (arg1 !== undefined && arg2 !== undefined && arg3 !== undefined && arg4 !== undefined) {
                    fn(arg1, arg2, arg3, arg4, cb);
                }
                else if (arg1 !== undefined && arg2 !== undefined && arg3 !== undefined) {
                    fn(arg1, arg2, arg3, cb);
                }
                else if (arg1 !== undefined && arg2 !== undefined) {
                    fn(arg1, arg2, cb);
                }
                else if (arg1 !== undefined) {
                    fn(arg1, cb);
                }
                else {
                    fn(cb);
                }
            }
            catch (e) {
                reject(e);
            }
        });
    }
    /**
     * Normalizes an object into an `Error` object.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static scrubError(error) {
        if (error instanceof Error) {
            return error;
        }
        else if (typeof error === 'string') {
            return new Error(error);
        }
        else {
            const errorObject = new Error('An error occurred.');
            errorObject.errorData = error; // eslint-disable-line @typescript-eslint/no-explicit-any
            return errorObject;
        }
    }
    /**
     * Prior to Node 11.x, the `Array.sort()` algorithm is not guaranteed to be stable.
     * If you need a stable sort, you can use `sortStable()` as a workaround.
     *
     * @remarks
     * On NodeJS 11.x and later, this method simply calls the native `Array.sort()`.
     * For earlier versions, it uses an implementation of Timsort, which is the same algorithm used by modern NodeJS.
     */
    static sortStable(array, compare) {
        if (LegacyAdapters._useTimsort === undefined) {
            LegacyAdapters._useTimsort = semver.major(process.versions.node) < 11;
        }
        if (LegacyAdapters._useTimsort) {
            (0, timsort_1.sort)(array, compare);
        }
        else {
            Array.prototype.sort.call(array, compare);
        }
    }
}
exports.LegacyAdapters = LegacyAdapters;
LegacyAdapters._useTimsort = undefined;
//# sourceMappingURL=LegacyAdapters.js.map

/***/ }),

/***/ 50264:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LockFile = exports.getProcessStartTime = exports.getProcessStartTimeFromProcStat = void 0;
const path = __importStar(__webpack_require__(85622));
const child_process = __importStar(__webpack_require__(63129));
const FileSystem_1 = __webpack_require__(76952);
const FileWriter_1 = __webpack_require__(78439);
const Async_1 = __webpack_require__(45822);
/**
 * http://man7.org/linux/man-pages/man5/proc.5.html
 * (22) starttime  %llu
 * The time the process started after system boot. In kernels before Linux 2.6, this value was
 * expressed in jiffies. Since Linux 2.6, the value is expressed in clock ticks (divide by
 * sysconf(_SC_CLK_TCK)).
 * The format for this field was %lu before Linux 2.6.
 */
const procStatStartTimePos = 22;
/**
 * Parses the process start time from the contents of a linux /proc/[pid]/stat file.
 * @param stat - The contents of a linux /proc/[pid]/stat file.
 * @returns The process start time in jiffies, or undefined if stat has an unexpected format.
 */
function getProcessStartTimeFromProcStat(stat) {
    // Parse the value at position procStatStartTimePos.
    // We cannot just split stat on spaces, because value 2 may contain spaces.
    // For example, when running the following Shell commands:
    // > cp "$(which bash)" ./'bash 2)('
    // > ./'bash 2)(' -c 'OWNPID=$BASHPID;cat /proc/$OWNPID/stat'
    // 59389 (bash 2)() S 59358 59389 59358 34818 59389 4202496 329 0 0 0 0 0 0 0 20 0 1 0
    // > rm -rf ./'bash 2)('
    // The output shows a stat file such that value 2 contains spaces.
    // To still umambiguously parse such output we assume no values after the second ends with a right parenthesis...
    // trimRight to remove the trailing line terminator.
    let values = stat.trimRight().split(' ');
    let i = values.length - 1;
    while (i >= 0 &&
        // charAt returns an empty string if the index is out of bounds.
        values[i].charAt(values[i].length - 1) !== ')') {
        i -= 1;
    }
    // i is the index of the last part of the second value (but i need not be 1).
    if (i < 1) {
        // Format of stat has changed.
        return undefined;
    }
    const value2 = values.slice(1, i + 1).join(' ');
    values = [values[0], value2].concat(values.slice(i + 1));
    if (values.length < procStatStartTimePos) {
        // Older version of linux, or non-standard configuration of linux.
        return undefined;
    }
    const startTimeJiffies = values[procStatStartTimePos - 1];
    // In theory, the representations of start time returned by `cat /proc/[pid]/stat` and `ps -o lstart` can change
    // while the system is running, but we assume this does not happen.
    // So the caller can safely use this value as part of a unique process id (on the machine, without comparing
    // accross reboots).
    return startTimeJiffies;
}
exports.getProcessStartTimeFromProcStat = getProcessStartTimeFromProcStat;
/**
 * Helper function that is exported for unit tests only.
 * Returns undefined if the process doesn't exist with that pid.
 */
function getProcessStartTime(pid) {
    const pidString = pid.toString();
    if (pid < 0 || pidString.indexOf('e') >= 0 || pidString.indexOf('E') >= 0) {
        throw new Error(`"pid" is negative or too large`);
    }
    let args;
    if (process.platform === 'darwin') {
        args = [`-p ${pidString}`, '-o lstart'];
    }
    else if (process.platform === 'linux') {
        args = ['-p', pidString, '-o', 'lstart'];
    }
    else {
        throw new Error(`Unsupported system: ${process.platform}`);
    }
    const psResult = child_process.spawnSync('ps', args, {
        encoding: 'utf8'
    });
    const psStdout = psResult.stdout;
    // If no process with PID pid exists then the exit code is non-zero on linux but stdout is not empty.
    // But if no process exists we do not want to fall back on /proc/*/stat to determine the process
    // start time, so we we additionally test for !psStdout. NOTE: !psStdout evaluates to true if
    // zero bytes are written to stdout.
    if (psResult.status !== 0 && !psStdout && process.platform === 'linux') {
        // Try to read /proc/[pid]/stat and get the value at position procStatStartTimePos.
        let stat;
        try {
            stat = FileSystem_1.FileSystem.readFile(`/proc/${pidString}/stat`);
        }
        catch (error) {
            if (error.code !== 'ENOENT') {
                throw error;
            }
            // Either no process with PID pid exists, or this version/configuration of linux is non-standard.
            // We assume the former.
            return undefined;
        }
        if (stat !== undefined) {
            const startTimeJiffies = getProcessStartTimeFromProcStat(stat);
            if (startTimeJiffies === undefined) {
                throw new Error(`Could not retrieve the start time of process ${pidString} from the OS because the ` +
                    `contents of /proc/${pidString}/stat have an unexpected format`);
            }
            return startTimeJiffies;
        }
    }
    // there was an error executing ps (zero bytes were written to stdout).
    if (!psStdout) {
        throw new Error(`Unexpected output from "ps" command`);
    }
    const psSplit = psStdout.split('\n');
    // successfuly able to run "ps", but no process was found
    if (psSplit[1] === '') {
        return undefined;
    }
    if (psSplit[1]) {
        const trimmed = psSplit[1].trim();
        if (trimmed.length > 10) {
            return trimmed;
        }
    }
    throw new Error(`Unexpected output from the "ps" command`);
}
exports.getProcessStartTime = getProcessStartTime;
/**
 * The `LockFile` implements a file-based mutex for synchronizing access to a shared resource
 * between multiple Node.js processes.  It is not recommended for synchronization solely within
 * a single Node.js process.
 * @remarks
 * The implementation works on Windows, Mac, and Linux without requiring any native helpers.
 * On non-Windows systems, the algorithm requires access to the `ps` shell command.  On Linux,
 * it requires access the `/proc/${pidString}/stat` filesystem.
 * @public
 */
class LockFile {
    constructor(fileWriter, filePath, dirtyWhenAcquired) {
        this._fileWriter = fileWriter;
        this._filePath = filePath;
        this._dirtyWhenAcquired = dirtyWhenAcquired;
    }
    /**
     * Returns the path of the lockfile that will be created when a lock is successfully acquired.
     * @param resourceFolder - The folder where the lock file will be created
     * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
     *   the filename of the temporary file created to manage the lock.
     * @param pid - The PID for the current Node.js process (`process.pid`), which is used by the locking algorithm.
     */
    static getLockFilePath(resourceFolder, resourceName, pid = process.pid) {
        if (!resourceName.match(/^[a-zA-Z0-9][a-zA-Z0-9-.]+[a-zA-Z0-9]$/)) {
            throw new Error(`The resource name "${resourceName}" is invalid.` +
                ` It must be an alphanumberic string with only "-" or "." It must start with an alphanumeric character.`);
        }
        if (process.platform === 'win32') {
            return path.join(path.resolve(resourceFolder), `${resourceName}.lock`);
        }
        else if (process.platform === 'linux' || process.platform === 'darwin') {
            return path.join(path.resolve(resourceFolder), `${resourceName}#${pid}.lock`);
        }
        throw new Error(`File locking not implemented for platform: "${process.platform}"`);
    }
    /**
     * Attempts to create a lockfile with the given filePath.
     * @param resourceFolder - The folder where the lock file will be created
     * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
     *   the filename of the temporary file created to manage the lock.
     * @returns If successful, returns a `LockFile` instance.  If unable to get a lock, returns `undefined`.
     */
    static tryAcquire(resourceFolder, resourceName) {
        FileSystem_1.FileSystem.ensureFolder(resourceFolder);
        if (process.platform === 'win32') {
            return LockFile._tryAcquireWindows(resourceFolder, resourceName);
        }
        else if (process.platform === 'linux' || process.platform === 'darwin') {
            return LockFile._tryAcquireMacOrLinux(resourceFolder, resourceName);
        }
        throw new Error(`File locking not implemented for platform: "${process.platform}"`);
    }
    /**
     * Attempts to create the lockfile.  Will continue to loop at every 100ms until the lock becomes available
     * or the maxWaitMs is surpassed.
     *
     * @remarks
     * This function is subject to starvation, whereby it does not ensure that the process that has been
     * waiting the longest to acquire the lock will get it first. This means that a process could theoretically
     * wait for the lock forever, while other processes skipped it in line and acquired the lock first.
     *
     * @param resourceFolder - The folder where the lock file will be created
     * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
     *   the filename of the temporary file created to manage the lock.
     * @param maxWaitMs - The maximum number of milliseconds to wait for the lock before reporting an error
     */
    static acquire(resourceFolder, resourceName, maxWaitMs) {
        const interval = 100;
        const startTime = Date.now();
        const retryLoop = async () => {
            const lock = LockFile.tryAcquire(resourceFolder, resourceName);
            if (lock) {
                return lock;
            }
            if (maxWaitMs && Date.now() > startTime + maxWaitMs) {
                throw new Error(`Exceeded maximum wait time to acquire lock for resource "${resourceName}"`);
            }
            await Async_1.Async.sleep(interval);
            return retryLoop();
        };
        return retryLoop();
    }
    /**
     * Attempts to acquire the lock on a Linux or OSX machine
     */
    static _tryAcquireMacOrLinux(resourceFolder, resourceName) {
        let dirtyWhenAcquired = false;
        // get the current process' pid
        const pid = process.pid;
        const startTime = LockFile._getStartTime(pid);
        if (!startTime) {
            throw new Error(`Unable to calculate start time for current process.`);
        }
        const pidLockFilePath = LockFile.getLockFilePath(resourceFolder, resourceName);
        let lockFileHandle;
        let lockFile;
        try {
            // open in write mode since if this file exists, it cannot be from the current process
            // TODO: This will malfunction if the same process tries to acquire two locks on the same file.
            // We should ideally maintain a dictionary of normalized acquired filenames
            lockFileHandle = FileWriter_1.FileWriter.open(pidLockFilePath);
            lockFileHandle.write(startTime);
            const currentBirthTimeMs = FileSystem_1.FileSystem.getStatistics(pidLockFilePath).birthtime.getTime();
            let smallestBirthTimeMs = currentBirthTimeMs;
            let smallestBirthTimePid = pid.toString();
            // now, scan the directory for all lockfiles
            const files = FileSystem_1.FileSystem.readFolder(resourceFolder);
            // look for anything ending with # then numbers and ".lock"
            const lockFileRegExp = /^(.+)#([0-9]+)\.lock$/;
            let match;
            let otherPid;
            for (const fileInFolder of files) {
                if ((match = fileInFolder.match(lockFileRegExp)) &&
                    match[1] === resourceName &&
                    (otherPid = match[2]) !== pid.toString()) {
                    // we found at least one lockfile hanging around that isn't ours
                    const fileInFolderPath = path.join(resourceFolder, fileInFolder);
                    dirtyWhenAcquired = true;
                    // console.log(`FOUND OTHER LOCKFILE: ${otherPid}`);
                    const otherPidCurrentStartTime = LockFile._getStartTime(parseInt(otherPid, 10));
                    let otherPidOldStartTime;
                    let otherBirthtimeMs;
                    try {
                        otherPidOldStartTime = FileSystem_1.FileSystem.readFile(fileInFolderPath);
                        // check the timestamp of the file
                        otherBirthtimeMs = FileSystem_1.FileSystem.getStatistics(fileInFolderPath).birthtime.getTime();
                    }
                    catch (err) {
                        // this means the file is probably deleted already
                    }
                    // if the otherPidOldStartTime is invalid, then we should look at the timestamp,
                    // if this file was created after us, ignore it
                    // if it was created within 1 second before us, then it could be good, so we
                    //  will conservatively fail
                    // otherwise it is an old lock file and will be deleted
                    if (otherPidOldStartTime === '' && otherBirthtimeMs !== undefined) {
                        if (otherBirthtimeMs > currentBirthTimeMs) {
                            // ignore this file, he will be unable to get the lock since this process
                            // will hold it
                            // console.log(`Ignoring lock for pid ${otherPid} because its lockfile is newer than ours.`);
                            continue;
                        }
                        else if (otherBirthtimeMs - currentBirthTimeMs < 0 && // it was created before us AND
                            otherBirthtimeMs - currentBirthTimeMs > -1000) {
                            // it was created less than a second before
                            // conservatively be unable to keep the lock
                            return undefined;
                        }
                    }
                    // console.log(`Other pid ${otherPid} lockfile has start time: "${otherPidOldStartTime}"`);
                    // console.log(`Other pid ${otherPid} actually has start time: "${otherPidCurrentStartTime}"`);
                    // this means the process is no longer executing, delete the file
                    if (!otherPidCurrentStartTime || otherPidOldStartTime !== otherPidCurrentStartTime) {
                        // console.log(`Other pid ${otherPid} is no longer executing!`);
                        FileSystem_1.FileSystem.deleteFile(fileInFolderPath);
                        continue;
                    }
                    // console.log(`Pid ${otherPid} lockfile has birth time: ${otherBirthtimeMs}`);
                    // console.log(`Pid ${pid} lockfile has birth time: ${currentBirthTimeMs}`);
                    // this is a lockfile pointing at something valid
                    if (otherBirthtimeMs !== undefined && otherBirthtimeMs < smallestBirthTimeMs) {
                        smallestBirthTimeMs = otherBirthtimeMs;
                        smallestBirthTimePid = otherPid;
                    }
                }
            }
            if (smallestBirthTimePid !== pid.toString()) {
                // we do not have the lock
                return undefined;
            }
            // we have the lock!
            lockFile = new LockFile(lockFileHandle, pidLockFilePath, dirtyWhenAcquired);
            lockFileHandle = undefined; // we have handed the descriptor off to the instance
        }
        finally {
            if (lockFileHandle) {
                // ensure our lock is closed
                lockFileHandle.close();
                FileSystem_1.FileSystem.deleteFile(pidLockFilePath);
            }
        }
        return lockFile;
    }
    /**
     * Attempts to acquire the lock using Windows
     * This algorithm is much simpler since we can rely on the operating system
     */
    static _tryAcquireWindows(resourceFolder, resourceName) {
        const lockFilePath = LockFile.getLockFilePath(resourceFolder, resourceName);
        let dirtyWhenAcquired = false;
        let fileHandle;
        let lockFile;
        try {
            if (FileSystem_1.FileSystem.exists(lockFilePath)) {
                dirtyWhenAcquired = true;
                // If the lockfile is held by an process with an exclusive lock, then removing it will
                // silently fail. OpenSync() below will then fail and we will be unable to create a lock.
                // Otherwise, the lockfile is sitting on disk, but nothing is holding it, implying that
                // the last process to hold it died.
                FileSystem_1.FileSystem.deleteFile(lockFilePath);
            }
            try {
                // Attempt to open an exclusive lockfile
                fileHandle = FileWriter_1.FileWriter.open(lockFilePath, { exclusive: true });
            }
            catch (error) {
                // we tried to delete the lock, but something else is holding it,
                // (probably an active process), therefore we are unable to create a lock
                return undefined;
            }
            // Ensure we can hand off the file descriptor to the lockfile
            lockFile = new LockFile(fileHandle, lockFilePath, dirtyWhenAcquired);
            fileHandle = undefined;
        }
        finally {
            if (fileHandle) {
                fileHandle.close();
            }
        }
        return lockFile;
    }
    /**
     * Unlocks a file and removes it from disk.
     * This can only be called once.
     */
    release() {
        if (this.isReleased) {
            throw new Error(`The lock for file "${path.basename(this._filePath)}" has already been released.`);
        }
        this._fileWriter.close();
        FileSystem_1.FileSystem.deleteFile(this._filePath);
        this._fileWriter = undefined;
    }
    /**
     * Returns the initial state of the lock.
     * This can be used to detect if the previous process was terminated before releasing the resource.
     */
    get dirtyWhenAcquired() {
        return this._dirtyWhenAcquired;
    }
    /**
     * Returns the absolute path to the lockfile
     */
    get filePath() {
        return this._filePath;
    }
    /**
     * Returns true if this lock is currently being held.
     */
    get isReleased() {
        return this._fileWriter === undefined;
    }
}
exports.LockFile = LockFile;
LockFile._getStartTime = getProcessStartTime;
//# sourceMappingURL=LockFile.js.map

/***/ }),

/***/ 71059:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapExtensions = void 0;
/**
 * Helper functions for working with the `Map<K, V>` data type.
 *
 * @public
 */
class MapExtensions {
    /**
     * Adds all the (key, value) pairs from the source map into the target map.
     * @remarks
     * This function modifies targetMap.  Any existing keys will be overwritten.
     * @param targetMap - The map that entries will be added to
     * @param sourceMap - The map containing the entries to be added
     */
    static mergeFromMap(targetMap, sourceMap) {
        for (const pair of sourceMap.entries()) {
            targetMap.set(pair[0], pair[1]);
        }
    }
    /**
     * Converts a string-keyed map to an object.
     * @remarks
     * This function has the same effect as Object.fromEntries(map.entries())
     * in supported versions of Node (\>= 12.0.0).
     * @param map - The map that the object properties will be sourced from
     */
    static toObject(map) {
        const object = {};
        for (const [key, value] of map.entries()) {
            object[key] = value;
        }
        return object;
    }
}
exports.MapExtensions = MapExtensions;
//# sourceMappingURL=MapExtensions.js.map

/***/ }),

/***/ 52453:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageJsonLookup = void 0;
const path = __importStar(__webpack_require__(85622));
const JsonFile_1 = __webpack_require__(95873);
const FileSystem_1 = __webpack_require__(76952);
/**
 * This class provides methods for finding the nearest "package.json" for a folder
 * and retrieving the name of the package.  The results are cached.
 *
 * @public
 */
class PackageJsonLookup {
    constructor(parameters) {
        this._loadExtraFields = false;
        if (parameters) {
            if (parameters.loadExtraFields) {
                this._loadExtraFields = parameters.loadExtraFields;
            }
        }
        this.clearCache();
    }
    /**
     * A singleton instance of `PackageJsonLookup`, which is useful for short-lived processes
     * that can reasonably assume that the file system will not be modified after the cache
     * is populated.
     *
     * @remarks
     * For long-running processes that need to clear the cache at appropriate times,
     * it is recommended to create your own instance of `PackageJsonLookup` instead
     * of relying on this instance.
     */
    static get instance() {
        if (!PackageJsonLookup._instance) {
            PackageJsonLookup._instance = new PackageJsonLookup({ loadExtraFields: true });
        }
        return PackageJsonLookup._instance;
    }
    /**
     * A helper for loading the caller's own package.json file.
     *
     * @remarks
     *
     * This function provides a concise and efficient way for an NPM package to report metadata about itself.
     * For example, a tool might want to report its version.
     *
     * The `loadOwnPackageJson()` probes upwards from the caller's folder, expecting to find a package.json file,
     * which is assumed to be the caller's package.  The result is cached, under the assumption that a tool's
     * own package.json (and intermediary folders) will never change during the lifetime of the process.
     *
     * @example
     * ```ts
     * // Report the version of our NPM package
     * const myPackageVersion: string = PackageJsonLookup.loadOwnPackageJson(__dirname).version;
     * console.log(`Cool Tool - Version ${myPackageVersion}`);
     * ```
     *
     * @param dirnameOfCaller - The NodeJS `__dirname` macro for the caller.
     * @returns This function always returns a valid `IPackageJson` object.  If any problems are encountered during
     * loading, an exception will be thrown instead.
     */
    static loadOwnPackageJson(dirnameOfCaller) {
        const packageJson = PackageJsonLookup.instance.tryLoadPackageJsonFor(dirnameOfCaller);
        if (packageJson === undefined) {
            throw new Error(`PackageJsonLookup.loadOwnPackageJson() failed to find the caller's package.json.` +
                `  The __dirname was: ${dirnameOfCaller}`);
        }
        if (packageJson.version !== undefined) {
            return packageJson;
        }
        const errorPath = PackageJsonLookup.instance.tryGetPackageJsonFilePathFor(dirnameOfCaller) || 'package.json';
        throw new Error(`PackageJsonLookup.loadOwnPackageJson() failed because the "version" field is missing in` +
            ` ${errorPath}`);
    }
    /**
     * Clears the internal file cache.
     * @remarks
     * Call this method if changes have been made to the package.json files on disk.
     */
    clearCache() {
        this._packageFolderCache = new Map();
        this._packageJsonCache = new Map();
    }
    /**
     * Returns the absolute path of a folder containing a package.json file, by looking
     * upwards from the specified fileOrFolderPath.  If no package.json can be found,
     * undefined is returned.
     *
     * @remarks
     * The fileOrFolderPath is not required to actually exist on disk.
     * The fileOrFolderPath itself can be the return value, if it is a folder containing
     * a package.json file.
     * Both positive and negative lookup results are cached.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an absolute path to a folder containing a package.json file
     */
    tryGetPackageFolderFor(fileOrFolderPath) {
        // Convert it to an absolute path
        const resolvedFileOrFolderPath = path.resolve(fileOrFolderPath);
        // Optimistically hope that the starting string is already in the cache,
        // in which case we can avoid disk access entirely.
        //
        // (Two lookups are required, because get() cannot distinguish the undefined value
        // versus a missing key.)
        if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {
            return this._packageFolderCache.get(resolvedFileOrFolderPath);
        }
        // Now call the recursive part of the algorithm
        return this._tryGetPackageFolderFor(resolvedFileOrFolderPath);
    }
    /**
     * If the specified file or folder is part of a package, this returns the absolute path
     * to the associated package.json file.
     *
     * @remarks
     * The package folder is determined using the same algorithm
     * as {@link PackageJsonLookup.tryGetPackageFolderFor}.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an absolute path to * package.json file
     */
    tryGetPackageJsonFilePathFor(fileOrFolderPath) {
        const packageJsonFolder = this.tryGetPackageFolderFor(fileOrFolderPath);
        if (!packageJsonFolder) {
            return undefined;
        }
        return path.join(packageJsonFolder, "package.json" /* PackageJson */);
    }
    /**
     * If the specified file or folder is part of a package, this loads and returns the
     * associated package.json file.
     *
     * @remarks
     * The package folder is determined using the same algorithm
     * as {@link PackageJsonLookup.tryGetPackageFolderFor}.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an IPackageJson object, or undefined if the fileOrFolderPath does not
     * belong to a package
     */
    tryLoadPackageJsonFor(fileOrFolderPath) {
        const packageJsonFilePath = this.tryGetPackageJsonFilePathFor(fileOrFolderPath);
        if (!packageJsonFilePath) {
            return undefined;
        }
        return this.loadPackageJson(packageJsonFilePath);
    }
    /**
     * This function is similar to {@link PackageJsonLookup.tryLoadPackageJsonFor}, except that it does not report
     * an error if the `version` field is missing from the package.json file.
     */
    tryLoadNodePackageJsonFor(fileOrFolderPath) {
        const packageJsonFilePath = this.tryGetPackageJsonFilePathFor(fileOrFolderPath);
        if (!packageJsonFilePath) {
            return undefined;
        }
        return this.loadNodePackageJson(packageJsonFilePath);
    }
    /**
     * Loads the specified package.json file, if it is not already present in the cache.
     *
     * @remarks
     * Unless {@link IPackageJsonLookupParameters.loadExtraFields} was specified,
     * the returned IPackageJson object will contain a subset of essential fields.
     * The returned object should be considered to be immutable; the caller must never
     * modify it.
     *
     * @param jsonFilename - a relative or absolute path to a package.json file
     */
    loadPackageJson(jsonFilename) {
        const packageJson = this.loadNodePackageJson(jsonFilename);
        if (!packageJson.version) {
            throw new Error(`Error reading "${jsonFilename}":\n  The required field "version" was not found`);
        }
        return packageJson;
    }
    /**
     * This function is similar to {@link PackageJsonLookup.loadPackageJson}, except that it does not report an error
     * if the `version` field is missing from the package.json file.
     */
    loadNodePackageJson(jsonFilename) {
        if (!FileSystem_1.FileSystem.exists(jsonFilename)) {
            throw new Error(`Input file not found: ${jsonFilename}`);
        }
        // Since this will be a cache key, follow any symlinks and get an absolute path
        // to minimize duplication.  (Note that duplication can still occur due to e.g. character case.)
        const normalizedFilePath = FileSystem_1.FileSystem.getRealPath(jsonFilename);
        let packageJson = this._packageJsonCache.get(normalizedFilePath);
        if (!packageJson) {
            const loadedPackageJson = JsonFile_1.JsonFile.load(normalizedFilePath);
            // Make sure this is really a package.json file.  CommonJS has fairly strict requirements,
            // but NPM only requires "name" and "version"
            if (!loadedPackageJson.name) {
                throw new Error(`Error reading "${jsonFilename}":\n  The required field "name" was not found`);
            }
            if (this._loadExtraFields) {
                packageJson = loadedPackageJson;
            }
            else {
                packageJson = {};
                // Unless "loadExtraFields" was requested, copy over the essential fields only
                packageJson.bin = loadedPackageJson.bin;
                packageJson.dependencies = loadedPackageJson.dependencies;
                packageJson.description = loadedPackageJson.description;
                packageJson.devDependencies = loadedPackageJson.devDependencies;
                packageJson.homepage = loadedPackageJson.homepage;
                packageJson.license = loadedPackageJson.license;
                packageJson.main = loadedPackageJson.main;
                packageJson.name = loadedPackageJson.name;
                packageJson.optionalDependencies = loadedPackageJson.optionalDependencies;
                packageJson.peerDependencies = loadedPackageJson.peerDependencies;
                packageJson.private = loadedPackageJson.private;
                packageJson.scripts = loadedPackageJson.scripts;
                packageJson.typings = loadedPackageJson.typings || loadedPackageJson.types;
                packageJson.tsdocMetadata = loadedPackageJson.tsdocMetadata;
                packageJson.version = loadedPackageJson.version;
            }
            Object.freeze(packageJson);
            this._packageJsonCache.set(normalizedFilePath, packageJson);
        }
        return packageJson;
    }
    // Recursive part of the algorithm from tryGetPackageFolderFor()
    _tryGetPackageFolderFor(resolvedFileOrFolderPath) {
        // Two lookups are required, because get() cannot distinguish the undefined value
        // versus a missing key.
        if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {
            return this._packageFolderCache.get(resolvedFileOrFolderPath);
        }
        // Is resolvedFileOrFolderPath itself a folder with a package.json file?  If so, return it.
        if (FileSystem_1.FileSystem.exists(path.join(resolvedFileOrFolderPath, "package.json" /* PackageJson */))) {
            this._packageFolderCache.set(resolvedFileOrFolderPath, resolvedFileOrFolderPath);
            return resolvedFileOrFolderPath;
        }
        // Otherwise go up one level
        const parentFolder = path.dirname(resolvedFileOrFolderPath);
        if (!parentFolder || parentFolder === resolvedFileOrFolderPath) {
            // We reached the root directory without finding a package.json file,
            // so cache the negative result
            this._packageFolderCache.set(resolvedFileOrFolderPath, undefined);
            return undefined; // no match
        }
        // Recurse upwards, caching every step along the way
        const parentResult = this._tryGetPackageFolderFor(parentFolder);
        // Cache the parent's answer as well
        this._packageFolderCache.set(resolvedFileOrFolderPath, parentResult);
        return parentResult;
    }
}
exports.PackageJsonLookup = PackageJsonLookup;
//# sourceMappingURL=PackageJsonLookup.js.map

/***/ }),

/***/ 36234:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageName = exports.PackageNameParser = void 0;
/**
 * A configurable parser for validating and manipulating NPM package names such as `my-package` or `@scope/my-package`.
 *
 * @remarks
 * If you do not need to customize the parser configuration, it is recommended to use {@link PackageName}
 * which exposes these operations as a simple static class.
 *
 * @public
 */
class PackageNameParser {
    constructor(options = {}) {
        this._options = Object.assign({}, options);
    }
    /**
     * This attempts to parse a package name that may include a scope component.
     * The packageName must not be an empty string.
     * @remarks
     * This function will not throw an exception.
     *
     * @returns an {@link IParsedPackageNameOrError} structure whose `error` property will be
     * nonempty if the string could not be parsed.
     */
    tryParse(packageName) {
        const result = {
            scope: '',
            unscopedName: '',
            error: ''
        };
        let input = packageName;
        if (input === null || input === undefined) {
            result.error = 'The package name must not be null or undefined';
            return result;
        }
        // Rule from npmjs.com:
        // "The name must be less than or equal to 214 characters. This includes the scope for scoped packages."
        if (packageName.length > 214) {
            // Don't attempt to parse a ridiculously long input
            result.error = 'The package name cannot be longer than 214 characters';
            return result;
        }
        if (input[0] === '@') {
            const indexOfScopeSlash = input.indexOf('/');
            if (indexOfScopeSlash <= 0) {
                result.scope = input;
                result.error = `Error parsing "${packageName}": The scope must be followed by a slash`;
                return result;
            }
            // Extract the scope substring
            result.scope = input.substr(0, indexOfScopeSlash);
            input = input.substr(indexOfScopeSlash + 1);
        }
        result.unscopedName = input;
        if (result.scope === '@') {
            result.error = `Error parsing "${packageName}": The scope name cannot be empty`;
            return result;
        }
        if (result.unscopedName === '') {
            result.error = 'The package name must not be empty';
            return result;
        }
        // Rule from npmjs.com:
        // "The name can't start with a dot or an underscore."
        if (result.unscopedName[0] === '.' || result.unscopedName[0] === '_') {
            result.error = `The package name "${packageName}" starts with an invalid character`;
            return result;
        }
        // Convert "@scope/unscoped-name" --> "scopeunscoped-name"
        const nameWithoutScopeSymbols = (result.scope ? result.scope.slice(1, -1) : '') + result.unscopedName;
        if (!this._options.allowUpperCase) {
            // "New packages must not have uppercase letters in the name."
            // This can't be enforced because "old" packages are still actively maintained.
            // Example: https://www.npmjs.com/package/Base64
            // However it's pretty reasonable to require the scope to be lower case
            if (result.scope !== result.scope.toLowerCase()) {
                result.error = `The package scope "${result.scope}" must not contain upper case characters`;
                return result;
            }
        }
        // "The name ends up being part of a URL, an argument on the command line, and a folder name.
        // Therefore, the name can't contain any non-URL-safe characters"
        const match = nameWithoutScopeSymbols.match(PackageNameParser._invalidNameCharactersRegExp);
        if (match) {
            result.error = `The package name "${packageName}" contains an invalid character: "${match[0]}"`;
            return result;
        }
        return result;
    }
    /**
     * Same as {@link PackageName.tryParse}, except this throws an exception if the input
     * cannot be parsed.
     * @remarks
     * The packageName must not be an empty string.
     */
    parse(packageName) {
        const result = this.tryParse(packageName);
        if (result.error) {
            throw new Error(result.error);
        }
        return result;
    }
    /**
     * {@inheritDoc IParsedPackageName.scope}
     */
    getScope(packageName) {
        return this.parse(packageName).scope;
    }
    /**
     * {@inheritDoc IParsedPackageName.unscopedName}
     */
    getUnscopedName(packageName) {
        return this.parse(packageName).unscopedName;
    }
    /**
     * Returns true if the specified package name is valid, or false otherwise.
     * @remarks
     * This function will not throw an exception.
     */
    isValidName(packageName) {
        const result = this.tryParse(packageName);
        return !result.error;
    }
    /**
     * Throws an exception if the specified name is not a valid package name.
     * The packageName must not be an empty string.
     */
    validate(packageName) {
        this.parse(packageName);
    }
    /**
     * Combines an optional package scope with an unscoped root name.
     * @param scope - Must be either an empty string, or a scope name such as "\@example"
     * @param unscopedName - Must be a nonempty package name that does not contain a scope
     * @returns A full package name such as "\@example/some-library".
     */
    combineParts(scope, unscopedName) {
        if (scope !== '') {
            if (scope[0] !== '@') {
                throw new Error('The scope must start with an "@" character');
            }
        }
        if (scope.indexOf('/') >= 0) {
            throw new Error('The scope must not contain a "/" character');
        }
        if (unscopedName[0] === '@') {
            throw new Error('The unscopedName cannot start with an "@" character');
        }
        if (unscopedName.indexOf('/') >= 0) {
            throw new Error('The unscopedName must not contain a "/" character');
        }
        let result;
        if (scope === '') {
            result = unscopedName;
        }
        else {
            result = scope + '/' + unscopedName;
        }
        // Make sure the result is a valid package name
        this.validate(result);
        return result;
    }
}
exports.PackageNameParser = PackageNameParser;
// encodeURIComponent() escapes all characters except:  A-Z a-z 0-9 - _ . ! ~ * ' ( )
// However, these are disallowed because they are shell characters:       ! ~ * ' ( )
PackageNameParser._invalidNameCharactersRegExp = /[^A-Za-z0-9\-_\.]/;
/**
 * Provides basic operations for validating and manipulating NPM package names such as `my-package`
 * or `@scope/my-package`.
 *
 * @remarks
 * This is the default implementation of {@link PackageNameParser}, exposed as a convenient static class.
 * If you need to configure the parsing rules, use `PackageNameParser` instead.
 *
 * @public
 */
class PackageName {
    /** {@inheritDoc PackageNameParser.tryParse} */
    static tryParse(packageName) {
        return PackageName._parser.tryParse(packageName);
    }
    /** {@inheritDoc PackageNameParser.parse} */
    static parse(packageName) {
        return this._parser.parse(packageName);
    }
    /** {@inheritDoc PackageNameParser.getScope} */
    static getScope(packageName) {
        return this._parser.getScope(packageName);
    }
    /** {@inheritDoc PackageNameParser.getUnscopedName} */
    static getUnscopedName(packageName) {
        return this._parser.getUnscopedName(packageName);
    }
    /** {@inheritDoc PackageNameParser.isValidName} */
    static isValidName(packageName) {
        return this._parser.isValidName(packageName);
    }
    /** {@inheritDoc PackageNameParser.validate} */
    static validate(packageName) {
        return this._parser.validate(packageName);
    }
    /** {@inheritDoc PackageNameParser.combineParts} */
    static combineParts(scope, unscopedName) {
        return this._parser.combineParts(scope, unscopedName);
    }
}
exports.PackageName = PackageName;
PackageName._parser = new PackageNameParser();
//# sourceMappingURL=PackageName.js.map

/***/ }),

/***/ 46520:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Path = void 0;
const path = __importStar(__webpack_require__(85622));
const Text_1 = __webpack_require__(963);
/**
 * Common operations for manipulating file and directory paths.
 * @remarks
 * This API is intended to eventually be a complete replacement for the NodeJS "path" API.
 * @public
 */
class Path {
    /**
     * Returns true if "childPath" is located inside the "parentFolderPath" folder
     * or one of its child folders.  Note that "parentFolderPath" is not considered to be
     * under itself.  The "childPath" can refer to any type of file system object.
     *
     * @remarks
     * The indicated file/folder objects are not required to actually exist on disk.
     * For example, "parentFolderPath" is interpreted as a folder name even if it refers to a file.
     * If the paths are relative, they will first be resolved using path.resolve().
     */
    static isUnder(childPath, parentFolderPath) {
        // If childPath is under parentPath, then relativePath will be something like
        // "../.." or "..\\..", which consists entirely of periods and slashes.
        // (Note that something like "....t" is actually a valid filename, but "...." is not.)
        const relativePath = path.relative(childPath, parentFolderPath);
        return Path._relativePathRegex.test(relativePath);
    }
    /**
     * Returns true if "childPath" is equal to "parentFolderPath", or if it is inside that folder
     * or one of its children.  The "childPath" can refer to any type of file system object.
     *
     * @remarks
     * The indicated file/folder objects are not required to actually exist on disk.
     * For example, "parentFolderPath" is interpreted as a folder name even if it refers to a file.
     * If the paths are relative, they will first be resolved using path.resolve().
     */
    static isUnderOrEqual(childPath, parentFolderPath) {
        const relativePath = path.relative(childPath, parentFolderPath);
        return relativePath === '' || Path._relativePathRegex.test(relativePath);
    }
    /**
     * Returns true if `path1` and `path2` refer to the same underlying path.
     *
     * @remarks
     *
     * The comparison is performed using `path.relative()`.
     */
    static isEqual(path1, path2) {
        return path.relative(path1, path2) === '';
    }
    /**
     * Formats a path to look nice for reporting purposes.
     * @remarks
     * If `pathToConvert` is under the `baseFolder`, then it will be converted to a relative with the `./` prefix.
     * Otherwise, it will be converted to an absolute path.
     *
     * Backslashes will be converted to slashes, unless the path starts with an OS-specific string like `C:\`.
     */
    static formatConcisely(options) {
        // Same logic as Path.isUnderOrEqual()
        const relativePath = path.relative(options.pathToConvert, options.baseFolder);
        const isUnderOrEqual = relativePath === '' || Path._relativePathRegex.test(relativePath);
        if (isUnderOrEqual) {
            // Note that isUnderOrEqual()'s relativePath is the reverse direction
            return './' + Path.convertToSlashes(path.relative(options.baseFolder, options.pathToConvert));
        }
        const absolutePath = path.resolve(options.pathToConvert);
        return absolutePath;
    }
    /**
     * Replaces Windows-style backslashes with POSIX-style slashes.
     *
     * @remarks
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    static convertToSlashes(inputPath) {
        return Text_1.Text.replaceAll(inputPath, '\\', '/');
    }
    /**
     * Replaces POSIX-style slashes with Windows-style backslashes
     *
     * @remarks
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    static convertToBackslashes(inputPath) {
        return Text_1.Text.replaceAll(inputPath, '/', '\\');
    }
    /**
     * Returns true if the specified path is a relative path and does not use `..` to walk upwards.
     *
     * @example
     * ```ts
     * // These evaluate to true
     * isDownwardRelative('folder');
     * isDownwardRelative('file');
     * isDownwardRelative('folder/');
     * isDownwardRelative('./folder/');
     * isDownwardRelative('./folder/file');
     *
     * // These evaluate to false
     * isDownwardRelative('../folder');
     * isDownwardRelative('folder/../file');
     * isDownwardRelative('/folder/file');
     * ```
     */
    static isDownwardRelative(inputPath) {
        if (path.isAbsolute(inputPath)) {
            return false;
        }
        // Does it contain ".."
        if (Path._upwardPathSegmentRegex.test(inputPath)) {
            return false;
        }
        return true;
    }
}
exports.Path = Path;
// Matches a relative path consisting entirely of periods and slashes
// Example: ".", "..", "../..", etc
Path._relativePathRegex = /^[.\/\\]+$/;
// Matches a relative path segment that traverses upwards
// Example: "a/../b"
Path._upwardPathSegmentRegex = /([\/\\]|^)\.\.([\/\\]|$)/;
//# sourceMappingURL=Path.js.map

/***/ }),

/***/ 17192:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtectableMap = void 0;
const ProtectableMapView_1 = __webpack_require__(52878);
/**
 * The ProtectableMap provides an easy way for an API to expose a `Map<K, V>` property
 * while intercepting and validating any write operations that are performed by
 * consumers of the API.
 *
 * @remarks
 * The ProtectableMap itself is intended to be a private object that only its owner
 * can access directly.  Any operations performed directly on the ProtectableMap will
 * bypass the hooks and any validation they perform.  The public property that is exposed
 * to API consumers should return {@link ProtectableMap.protectedView} instead.
 *
 * For example, suppose you want to share your `Map<string, number>` data structure,
 * but you want to enforce that the key must always be an upper case string:
 * You could use the onSet() hook to validate the keys and throw an exception
 * if the key is not uppercase.
 *
 * @public
 */
class ProtectableMap {
    constructor(parameters) {
        this._protectedView = new ProtectableMapView_1.ProtectableMapView(this, parameters);
    }
    /**
     * The owner of the protectable map should return this object via its public API.
     */
    get protectedView() {
        return this._protectedView;
    }
    // ---------------------------------------------------------------------------
    // lib.es2015.collections contract - write operations
    /**
     * Removes all entries from the map.
     * This operation does NOT invoke the ProtectableMap onClear() hook.
     */
    clear() {
        this._protectedView._clearUnprotected();
    }
    /**
     * Removes the specified key from the map.
     * This operation does NOT invoke the ProtectableMap onDelete() hook.
     */
    delete(key) {
        return this._protectedView._deleteUnprotected(key);
    }
    /**
     * Sets a value for the specified key.
     * This operation does NOT invoke the ProtectableMap onSet() hook.
     */
    set(key, value) {
        this._protectedView._setUnprotected(key, value);
        return this;
    }
    // ---------------------------------------------------------------------------
    // lib.es2015.collections contract - read operations
    /**
     * Performs an operation for each (key, value) entries in the map.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    forEach(callbackfn, thisArg) {
        this._protectedView.forEach(callbackfn);
    }
    /**
     * Retrieves the value for the specified key.
     * @returns undefined if the value is undefined OR if the key is missing;
     * otherwise returns the value associated with the key.
     */
    get(key) {
        return this._protectedView.get(key);
    }
    /**
     * Returns true if the specified key belongs to the map.
     */
    has(key) {
        return this._protectedView.has(key);
    }
    /**
     * Returns the number of (key, value) entries in the map.
     */
    get size() {
        return this._protectedView.size;
    }
}
exports.ProtectableMap = ProtectableMap;
//# sourceMappingURL=ProtectableMap.js.map

/***/ }),

/***/ 52878:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtectableMapView = void 0;
/**
 * The internal wrapper used by ProtectableMap.  It extends the real `Map<K, V>` base class,
 * but hooks the destructive operations (clear/delete/set) to give the owner a chance
 * to block them.
 *
 * NOTE: This is not a public API.
 */
class ProtectableMapView extends Map {
    constructor(owner, parameters) {
        super();
        this._owner = owner;
        this._parameters = parameters;
    }
    clear() {
        // override
        if (this._parameters.onClear) {
            this._parameters.onClear(this._owner);
        }
        super.clear();
    }
    delete(key) {
        // override
        if (this._parameters.onDelete) {
            this._parameters.onDelete(this._owner, key);
        }
        return super.delete(key);
    }
    set(key, value) {
        // override
        let modifiedValue = value;
        if (this._parameters.onSet) {
            modifiedValue = this._parameters.onSet(this._owner, key, modifiedValue);
        }
        super.set(key, modifiedValue);
        return this;
    }
    // INTERNAL USAGE ONLY
    _clearUnprotected() {
        super.clear();
    }
    // INTERNAL USAGE ONLY
    _deleteUnprotected(key) {
        return super.delete(key);
    }
    // INTERNAL USAGE ONLY
    _setUnprotected(key, value) {
        super.set(key, value);
    }
}
exports.ProtectableMapView = ProtectableMapView;
//# sourceMappingURL=ProtectableMapView.js.map

/***/ }),

/***/ 60368:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sort = void 0;
const LegacyAdapters_1 = __webpack_require__(48547);
/**
 * Operations for sorting collections.
 *
 * @remarks
 * NOTE: Prior to Node 11.x, the `Array.sort()` algorithm is not guaranteed to be stable.  For maximum
 * compatibility, consider using {@link LegacyAdapters.sortStable} instead of `Array.sort()`.
 *
 * @public
 */
class Sort {
    /**
     * Compares `x` and `y` using the JavaScript `>` and `<` operators.  This function is suitable for usage as
     * the callback for `array.sort()`.
     *
     * @remarks
     *
     * The JavaScript ordering is generalized so that `undefined` \< `null` \< all other values.
     *
     * @returns -1 if `x` is smaller than `y`, 1 if `x` is greater than `y`, or 0 if the values are equal.
     *
     * @example
     *
     * ```ts
     * let array: number[] = [3, 6, 2];
     * array.sort(Sort.compareByValue);  // [2, 3, 6]
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static compareByValue(x, y) {
        if (x === y) {
            return 0;
        }
        // Undefined is smaller than anything else
        if (x === undefined) {
            return -1;
        }
        if (y === undefined) {
            return 1;
        }
        // Null is smaller than anything except undefined
        if (x === null) {
            return -1;
        }
        if (y === null) {
            return 1;
        }
        // These comparisons always return false if either of the arguments is "undefined".
        // These comparisons return nonsense for "null" (true for "null > -1", but false for "null < 0" and "null > 0")
        if (x < y) {
            return -1;
        }
        if (x > y) {
            return 1;
        }
        return 0;
    }
    /**
     * Sorts the array according to a key which is obtained from the array elements.
     * The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let array: string[] = [ 'aaa', 'bb', 'c' ];
     * Sort.sortBy(array, x => x.length);  // [ 'c', 'bb', 'aaa' ]
     * ```
     */
    static sortBy(array, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    keySelector, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    comparer = Sort.compareByValue) {
        LegacyAdapters_1.LegacyAdapters.sortStable(array, (x, y) => comparer(keySelector(x), keySelector(y)));
    }
    /**
     * Returns true if the array is already sorted.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static isSorted(array, comparer = Sort.compareByValue) {
        let previous = undefined;
        for (const element of array) {
            if (comparer(previous, element) > 0) {
                return false;
            }
            previous = element;
        }
        return true;
    }
    /**
     * Returns true if the array is already sorted by the specified key.
     *
     * @example
     *
     * ```ts
     * let array: string[] = [ 'a', 'bb', 'ccc' ];
     * Sort.isSortedBy(array, x => x.length); // true
     * ```
     */
    static isSortedBy(array, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    keySelector, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    comparer = Sort.compareByValue) {
        let previousKey = undefined;
        for (const element of array) {
            const key = keySelector(element);
            if (comparer(previousKey, key) > 0) {
                return false;
            }
            previousKey = key;
        }
        return true;
    }
    /**
     * Sorts the entries in a Map object according to the map keys.
     * The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let map: Map<string, number> = new Map<string, number>();
     * map.set('zebra', 1);
     * map.set('goose', 2);
     * map.set('aardvark', 3);
     * Sort.sortMapKeys(map);
     * console.log(JSON.stringify(Array.from(map.keys()))); // ["aardvark","goose","zebra"]
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static sortMapKeys(map, keyComparer = Sort.compareByValue) {
        const pairs = Array.from(map.entries());
        // Sorting a map is expensive, so first check whether it's already sorted.
        if (Sort.isSortedBy(pairs, (x) => x[0], keyComparer)) {
            return;
        }
        Sort.sortBy(pairs, (x) => x[0], keyComparer);
        map.clear();
        for (const pair of pairs) {
            map.set(pair[0], pair[1]);
        }
    }
    /**
     * Sorts the entries in a Set object according to the specified keys.
     * The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let set: Set<string> = new Set<string>();
     * set.add('aaa');
     * set.add('bb');
     * set.add('c');
     * Sort.sortSetBy(set, x => x.length);
     * console.log(Array.from(set)); // ['c', 'bb', 'aaa']
     * ```
     */
    static sortSetBy(set, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    keySelector, keyComparer = Sort.compareByValue) {
        const array = Array.from(set);
        // Sorting a set is expensive, so first check whether it's already sorted.
        if (Sort.isSortedBy(array, keySelector, keyComparer)) {
            return;
        }
        LegacyAdapters_1.LegacyAdapters.sortStable(array, (x, y) => keyComparer(keySelector(x), keySelector(y)));
        set.clear();
        for (const item of array) {
            set.add(item);
        }
    }
    /**
     * Sorts the entries in a Set object.  The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let set: Set<string> = new Set<string>();
     * set.add('zebra');
     * set.add('goose');
     * set.add('aardvark');
     * Sort.sortSet(set);
     * console.log(Array.from(set)); // ['aardvark', 'goose', 'zebra']
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static sortSet(set, comparer = Sort.compareByValue) {
        const array = Array.from(set);
        // Sorting a set is expensive, so first check whether it's already sorted.
        if (Sort.isSorted(array, comparer)) {
            return;
        }
        LegacyAdapters_1.LegacyAdapters.sortStable(array, (x, y) => comparer(x, y));
        set.clear();
        for (const item of array) {
            set.add(item);
        }
    }
}
exports.Sort = Sort;
//# sourceMappingURL=Sort.js.map

/***/ }),

/***/ 60664:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringBuilder = void 0;
/**
 * This class allows a large text string to be constructed incrementally by appending small chunks.  The final
 * string can be obtained by calling StringBuilder.toString().
 *
 * @remarks
 * A naive approach might use the `+=` operator to append strings:  This would have the downside of copying
 * the entire string each time a chunk is appended, resulting in `O(n^2)` bytes of memory being allocated
 * (and later freed by the garbage  collector), and many of the allocations could be very large objects.
 * StringBuilder avoids this overhead by accumulating the chunks in an array, and efficiently joining them
 * when `getText()` is finally called.
 *
 * @public
 */
class StringBuilder {
    constructor() {
        this._chunks = [];
    }
    /** {@inheritDoc IStringBuilder.append} */
    append(text) {
        this._chunks.push(text);
    }
    /** {@inheritDoc IStringBuilder.toString} */
    toString() {
        if (this._chunks.length === 0) {
            return '';
        }
        if (this._chunks.length > 1) {
            const joined = this._chunks.join('');
            this._chunks.length = 1;
            this._chunks[0] = joined;
        }
        return this._chunks[0];
    }
}
exports.StringBuilder = StringBuilder;
//# sourceMappingURL=StringBuilder.js.map

/***/ }),

/***/ 91053:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnsiEscape = void 0;
const Colors_1 = __webpack_require__(91039);
/**
 * Operations for working with text strings that contain
 * {@link https://en.wikipedia.org/wiki/ANSI_escape_code | ANSI escape codes}.
 * The most commonly used escape codes set the foreground/background color for console output.
 * @public
 */
class AnsiEscape {
    /**
     * Returns the input text with all ANSI escape codes removed.  For example, this is useful when saving
     * colorized console output to a log file.
     */
    static removeCodes(text) {
        // eslint-disable-next-line no-control-regex
        return text.replace(AnsiEscape._csiRegExp, '');
    }
    /**
     * Replaces ANSI escape codes with human-readable tokens.  This is useful for unit tests
     * that compare text strings in test assertions or snapshot files.
     */
    static formatForTests(text, options) {
        if (!options) {
            options = {};
        }
        let result = text.replace(AnsiEscape._csiRegExp, (capture, csiCode) => {
            // If it is an SGR code, then try to show a friendly token
            const match = csiCode.match(AnsiEscape._sgrRegExp);
            if (match) {
                const sgrParameter = parseInt(match[1]);
                const sgrParameterName = AnsiEscape._tryGetSgrFriendlyName(sgrParameter);
                if (sgrParameterName) {
                    // Example: "[black-bg]"
                    return `[${sgrParameterName}]`;
                }
            }
            // Otherwise show the raw code, but without the "[" from the CSI prefix
            // Example: "[31m]"
            return `[${csiCode}]`;
        });
        if (options.encodeNewlines) {
            result = result
                .replace(AnsiEscape._backslashNRegExp, '[n]')
                .replace(AnsiEscape._backslashRRegExp, `[r]`);
        }
        return result;
    }
    // Returns a human-readable token representing an SGR parameter, or undefined for parameter that is not well-known.
    // The SGR parameter numbers are documented in this table:
    // https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_parameters
    static _tryGetSgrFriendlyName(sgiParameter) {
        switch (sgiParameter) {
            case Colors_1.ConsoleColorCodes.BlackForeground:
                return 'black';
            case Colors_1.ConsoleColorCodes.RedForeground:
                return 'red';
            case Colors_1.ConsoleColorCodes.GreenForeground:
                return 'green';
            case Colors_1.ConsoleColorCodes.YellowForeground:
                return 'yellow';
            case Colors_1.ConsoleColorCodes.BlueForeground:
                return 'blue';
            case Colors_1.ConsoleColorCodes.MagentaForeground:
                return 'magenta';
            case Colors_1.ConsoleColorCodes.CyanForeground:
                return 'cyan';
            case Colors_1.ConsoleColorCodes.WhiteForeground:
                return 'white';
            case Colors_1.ConsoleColorCodes.GrayForeground:
                return 'gray';
            case Colors_1.ConsoleColorCodes.DefaultForeground:
                return 'default';
            case Colors_1.ConsoleColorCodes.BlackBackground:
                return 'black-bg';
            case Colors_1.ConsoleColorCodes.RedBackground:
                return 'red-bg';
            case Colors_1.ConsoleColorCodes.GreenBackground:
                return 'green-bg';
            case Colors_1.ConsoleColorCodes.YellowBackground:
                return 'yellow-bg';
            case Colors_1.ConsoleColorCodes.BlueBackground:
                return 'blue-bg';
            case Colors_1.ConsoleColorCodes.MagentaBackground:
                return 'magenta-bg';
            case Colors_1.ConsoleColorCodes.CyanBackground:
                return 'cyan-bg';
            case Colors_1.ConsoleColorCodes.WhiteBackground:
                return 'white-bg';
            case Colors_1.ConsoleColorCodes.GrayBackground:
                return 'gray-bg';
            case Colors_1.ConsoleColorCodes.DefaultBackground:
                return 'default-bg';
            case Colors_1.ConsoleColorCodes.Bold:
                return 'bold';
            case Colors_1.ConsoleColorCodes.Dim:
                return 'dim';
            case Colors_1.ConsoleColorCodes.NormalColorOrIntensity:
                return 'normal';
            case Colors_1.ConsoleColorCodes.Underline:
                return 'underline';
            case Colors_1.ConsoleColorCodes.UnderlineOff:
                return 'underline-off';
            case Colors_1.ConsoleColorCodes.Blink:
                return 'blink';
            case Colors_1.ConsoleColorCodes.BlinkOff:
                return 'blink-off';
            case Colors_1.ConsoleColorCodes.InvertColor:
                return 'invert';
            case Colors_1.ConsoleColorCodes.InvertColorOff:
                return 'invert-off';
            case Colors_1.ConsoleColorCodes.Hidden:
                return 'hidden';
            case Colors_1.ConsoleColorCodes.HiddenOff:
                return 'hidden-off';
            default:
                return undefined;
        }
    }
}
exports.AnsiEscape = AnsiEscape;
// For now, we only care about the Control Sequence Introducer (CSI) commands which always start with "[".
// eslint-disable-next-line no-control-regex
AnsiEscape._csiRegExp = /\x1b\[([\x30-\x3f]*[\x20-\x2f]*[\x40-\x7e])/gu;
// Text coloring is performed using Select Graphic Rendition (SGR) codes, which come after the
// CSI introducer "ESC [".  The SGR sequence is a number followed by "m".
AnsiEscape._sgrRegExp = /([0-9]+)m/u;
AnsiEscape._backslashNRegExp = /\n/g;
AnsiEscape._backslashRRegExp = /\r/g;
//# sourceMappingURL=AnsiEscape.js.map

/***/ }),

/***/ 91039:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Colors = exports.ConsoleColorCodes = exports.TextAttribute = exports.ColorValue = exports.eolSequence = void 0;
exports.eolSequence = {
    isEol: true
};
/**
 * Colors used with {@link IColorableSequence}.
 * @beta
 */
var ColorValue;
(function (ColorValue) {
    ColorValue[ColorValue["Black"] = 0] = "Black";
    ColorValue[ColorValue["Red"] = 1] = "Red";
    ColorValue[ColorValue["Green"] = 2] = "Green";
    ColorValue[ColorValue["Yellow"] = 3] = "Yellow";
    ColorValue[ColorValue["Blue"] = 4] = "Blue";
    ColorValue[ColorValue["Magenta"] = 5] = "Magenta";
    ColorValue[ColorValue["Cyan"] = 6] = "Cyan";
    ColorValue[ColorValue["White"] = 7] = "White";
    ColorValue[ColorValue["Gray"] = 8] = "Gray";
})(ColorValue = exports.ColorValue || (exports.ColorValue = {}));
/**
 * Text styles used with {@link IColorableSequence}.
 * @beta
 */
var TextAttribute;
(function (TextAttribute) {
    TextAttribute[TextAttribute["Bold"] = 0] = "Bold";
    TextAttribute[TextAttribute["Dim"] = 1] = "Dim";
    TextAttribute[TextAttribute["Underline"] = 2] = "Underline";
    TextAttribute[TextAttribute["Blink"] = 3] = "Blink";
    TextAttribute[TextAttribute["InvertColor"] = 4] = "InvertColor";
    TextAttribute[TextAttribute["Hidden"] = 5] = "Hidden";
})(TextAttribute = exports.TextAttribute || (exports.TextAttribute = {}));
var ConsoleColorCodes;
(function (ConsoleColorCodes) {
    ConsoleColorCodes[ConsoleColorCodes["BlackForeground"] = 30] = "BlackForeground";
    ConsoleColorCodes[ConsoleColorCodes["RedForeground"] = 31] = "RedForeground";
    ConsoleColorCodes[ConsoleColorCodes["GreenForeground"] = 32] = "GreenForeground";
    ConsoleColorCodes[ConsoleColorCodes["YellowForeground"] = 33] = "YellowForeground";
    ConsoleColorCodes[ConsoleColorCodes["BlueForeground"] = 34] = "BlueForeground";
    ConsoleColorCodes[ConsoleColorCodes["MagentaForeground"] = 35] = "MagentaForeground";
    ConsoleColorCodes[ConsoleColorCodes["CyanForeground"] = 36] = "CyanForeground";
    ConsoleColorCodes[ConsoleColorCodes["WhiteForeground"] = 37] = "WhiteForeground";
    ConsoleColorCodes[ConsoleColorCodes["GrayForeground"] = 90] = "GrayForeground";
    ConsoleColorCodes[ConsoleColorCodes["DefaultForeground"] = 39] = "DefaultForeground";
    ConsoleColorCodes[ConsoleColorCodes["BlackBackground"] = 40] = "BlackBackground";
    ConsoleColorCodes[ConsoleColorCodes["RedBackground"] = 41] = "RedBackground";
    ConsoleColorCodes[ConsoleColorCodes["GreenBackground"] = 42] = "GreenBackground";
    ConsoleColorCodes[ConsoleColorCodes["YellowBackground"] = 43] = "YellowBackground";
    ConsoleColorCodes[ConsoleColorCodes["BlueBackground"] = 44] = "BlueBackground";
    ConsoleColorCodes[ConsoleColorCodes["MagentaBackground"] = 45] = "MagentaBackground";
    ConsoleColorCodes[ConsoleColorCodes["CyanBackground"] = 46] = "CyanBackground";
    ConsoleColorCodes[ConsoleColorCodes["WhiteBackground"] = 47] = "WhiteBackground";
    ConsoleColorCodes[ConsoleColorCodes["GrayBackground"] = 100] = "GrayBackground";
    ConsoleColorCodes[ConsoleColorCodes["DefaultBackground"] = 49] = "DefaultBackground";
    ConsoleColorCodes[ConsoleColorCodes["Bold"] = 1] = "Bold";
    // On Linux, the "BoldOff" code instead causes the text to be double-underlined:
    // https://en.wikipedia.org/wiki/Talk:ANSI_escape_code#SGR_21%E2%80%94%60Bold_off%60_not_widely_supported
    // Use "NormalColorOrIntensity" instead
    // BoldOff = 21,
    ConsoleColorCodes[ConsoleColorCodes["Dim"] = 2] = "Dim";
    ConsoleColorCodes[ConsoleColorCodes["NormalColorOrIntensity"] = 22] = "NormalColorOrIntensity";
    ConsoleColorCodes[ConsoleColorCodes["Underline"] = 4] = "Underline";
    ConsoleColorCodes[ConsoleColorCodes["UnderlineOff"] = 24] = "UnderlineOff";
    ConsoleColorCodes[ConsoleColorCodes["Blink"] = 5] = "Blink";
    ConsoleColorCodes[ConsoleColorCodes["BlinkOff"] = 25] = "BlinkOff";
    ConsoleColorCodes[ConsoleColorCodes["InvertColor"] = 7] = "InvertColor";
    ConsoleColorCodes[ConsoleColorCodes["InvertColorOff"] = 27] = "InvertColorOff";
    ConsoleColorCodes[ConsoleColorCodes["Hidden"] = 8] = "Hidden";
    ConsoleColorCodes[ConsoleColorCodes["HiddenOff"] = 28] = "HiddenOff";
})(ConsoleColorCodes = exports.ConsoleColorCodes || (exports.ConsoleColorCodes = {}));
/**
 * The static functions on this class are used to produce colored text
 * for use with the node-core-library terminal.
 *
 * @example
 * terminal.writeLine(Colors.green('Green Text!'), ' ', Colors.blue('Blue Text!'));
 *
 * @beta
 */
class Colors {
    static black(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Black });
    }
    static red(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Red });
    }
    static green(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Green });
    }
    static yellow(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Yellow });
    }
    static blue(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Blue });
    }
    static magenta(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Magenta });
    }
    static cyan(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Cyan });
    }
    static white(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.White });
    }
    static gray(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Gray });
    }
    static blackBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Black });
    }
    static redBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Red });
    }
    static greenBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Green });
    }
    static yellowBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Yellow });
    }
    static blueBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Blue });
    }
    static magentaBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Magenta });
    }
    static cyanBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Cyan });
    }
    static whiteBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.White });
    }
    static grayBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Gray });
    }
    static bold(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Bold);
    }
    static dim(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Dim);
    }
    static underline(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Underline);
    }
    static blink(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Blink);
    }
    static invertColor(text) {
        return Colors._applyTextAttribute(text, TextAttribute.InvertColor);
    }
    static hidden(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Hidden);
    }
    /**
     * If called with a string, returns the string wrapped in a {@link IColorableSequence}.
     * If called with a {@link IColorableSequence}, returns the {@link IColorableSequence}.
     *
     * @internal
     */
    static _normalizeStringOrColorableSequence(value) {
        if (typeof value === 'string') {
            return {
                text: value
            };
        }
        else {
            return value;
        }
    }
    static _applyTextAttribute(text, attribute) {
        const sequence = Colors._normalizeStringOrColorableSequence(text);
        if (!sequence.textAttributes) {
            sequence.textAttributes = [];
        }
        sequence.textAttributes.push(attribute);
        return sequence;
    }
}
exports.Colors = Colors;
//# sourceMappingURL=Colors.js.map

/***/ }),

/***/ 95568:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsoleTerminalProvider = void 0;
const os_1 = __webpack_require__(12087);
const safe_1 = __webpack_require__(41997);
const ITerminalProvider_1 = __webpack_require__(87567);
/**
 * Terminal provider that prints to STDOUT (for log- and verbose-level messages) and
 * STDERR (for warning- and error-level messsages).
 *
 * @beta
 */
class ConsoleTerminalProvider {
    constructor(options = {}) {
        /**
         * If true, verbose-level messages should be written to the console.
         */
        this.verboseEnabled = false;
        /**
         * If true, debug-level messages should be written to the console.
         */
        this.debugEnabled = false;
        this.verboseEnabled = !!options.verboseEnabled;
        this.debugEnabled = !!options.debugEnabled;
    }
    /**
     * {@inheritDoc ITerminalProvider.write}
     */
    write(data, severity) {
        switch (severity) {
            case ITerminalProvider_1.TerminalProviderSeverity.warning:
            case ITerminalProvider_1.TerminalProviderSeverity.error: {
                process.stderr.write(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.verbose: {
                if (this.verboseEnabled) {
                    process.stdout.write(data);
                }
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.debug: {
                if (this.debugEnabled) {
                    process.stdout.write(data);
                }
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.log:
            default: {
                process.stdout.write(data);
                break;
            }
        }
    }
    /**
     * {@inheritDoc ITerminalProvider.eolCharacter}
     */
    get eolCharacter() {
        return os_1.EOL;
    }
    /**
     * {@inheritDoc ITerminalProvider.supportsColor}
     */
    get supportsColor() {
        return safe_1.enabled;
    }
}
exports.ConsoleTerminalProvider = ConsoleTerminalProvider;
//# sourceMappingURL=ConsoleTerminalProvider.js.map

/***/ }),

/***/ 87567:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TerminalProviderSeverity = void 0;
/**
 * Similar to many popular logging packages, terminal providers support a range of message
 * severities. These severities have built-in formatting defaults in the Terminal object
 * (warnings are yellow, errors are red, etc.).
 *
 * Terminal providers may choose to suppress certain messages based on their severity,
 * or to route some messages to other providers or not based on severity.
 *
 *   Severity  | Purpose
 *   --------- | -------
 *   error     | Build errors and fatal issues
 *   warning   | Not necessarily fatal, but indicate a problem the user should fix
 *   log       | Informational messages
 *   verbose   | Additional information that may not always be necessary
 *   debug     | Highest detail level, best used for troubleshooting information
 *
 * @beta
 */
var TerminalProviderSeverity;
(function (TerminalProviderSeverity) {
    TerminalProviderSeverity[TerminalProviderSeverity["log"] = 0] = "log";
    TerminalProviderSeverity[TerminalProviderSeverity["warning"] = 1] = "warning";
    TerminalProviderSeverity[TerminalProviderSeverity["error"] = 2] = "error";
    TerminalProviderSeverity[TerminalProviderSeverity["verbose"] = 3] = "verbose";
    TerminalProviderSeverity[TerminalProviderSeverity["debug"] = 4] = "debug";
})(TerminalProviderSeverity = exports.TerminalProviderSeverity || (exports.TerminalProviderSeverity = {}));
//# sourceMappingURL=ITerminalProvider.js.map

/***/ }),

/***/ 35215:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringBufferTerminalProvider = void 0;
const ITerminalProvider_1 = __webpack_require__(87567);
const StringBuilder_1 = __webpack_require__(60664);
const Text_1 = __webpack_require__(963);
const AnsiEscape_1 = __webpack_require__(91053);
/**
 * Terminal provider that stores written data in buffers separated by severity.
 * This terminal provider is designed to be used when code that prints to a terminal
 * is being unit tested.
 *
 * @beta
 */
class StringBufferTerminalProvider {
    constructor(supportsColor = false) {
        this._standardBuffer = new StringBuilder_1.StringBuilder();
        this._verboseBuffer = new StringBuilder_1.StringBuilder();
        this._debugBuffer = new StringBuilder_1.StringBuilder();
        this._warningBuffer = new StringBuilder_1.StringBuilder();
        this._errorBuffer = new StringBuilder_1.StringBuilder();
        this._supportsColor = supportsColor;
    }
    /**
     * {@inheritDoc ITerminalProvider.write}
     */
    write(data, severity) {
        switch (severity) {
            case ITerminalProvider_1.TerminalProviderSeverity.warning: {
                this._warningBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.error: {
                this._errorBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.verbose: {
                this._verboseBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.debug: {
                this._debugBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.log:
            default: {
                this._standardBuffer.append(data);
                break;
            }
        }
    }
    /**
     * {@inheritDoc ITerminalProvider.eolCharacter}
     */
    get eolCharacter() {
        return '[n]';
    }
    /**
     * {@inheritDoc ITerminalProvider.supportsColor}
     */
    get supportsColor() {
        return this._supportsColor;
    }
    /**
     * Get everything that has been written at log-level severity.
     */
    getOutput(options) {
        return this._normalizeOutput(this._standardBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at verbose-level severity.
     */
    getVerbose(options) {
        return this._normalizeOutput(this._verboseBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at debug-level severity.
     */
    getDebugOutput(options) {
        return this._normalizeOutput(this._debugBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at error-level severity.
     */
    getErrorOutput(options) {
        return this._normalizeOutput(this._errorBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at warning-level severity.
     */
    getWarningOutput(options) {
        return this._normalizeOutput(this._warningBuffer.toString(), options);
    }
    _normalizeOutput(s, options) {
        options = Object.assign({ normalizeSpecialCharacters: true }, (options || {}));
        s = Text_1.Text.convertToLf(s);
        if (options.normalizeSpecialCharacters) {
            return AnsiEscape_1.AnsiEscape.formatForTests(s, { encodeNewlines: true });
        }
        else {
            return s;
        }
    }
}
exports.StringBufferTerminalProvider = StringBufferTerminalProvider;
//# sourceMappingURL=StringBufferTerminalProvider.js.map

/***/ }),

/***/ 16035:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Terminal = void 0;
const ITerminalProvider_1 = __webpack_require__(87567);
const Colors_1 = __webpack_require__(91039);
/**
 * This class facilitates writing to a console.
 *
 * @beta
 */
class Terminal {
    constructor(provider) {
        this._providers = new Set();
        this._providers.add(provider);
    }
    /**
     * {@inheritdoc ITerminal.registerProvider}
     */
    registerProvider(provider) {
        this._providers.add(provider);
    }
    /**
     * {@inheritdoc ITerminal.unregisterProvider}
     */
    unregisterProvider(provider) {
        if (this._providers.has(provider)) {
            this._providers.delete(provider);
        }
    }
    /**
     * {@inheritdoc ITerminal.write}
     */
    write(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.log);
    }
    /**
     * {@inheritdoc ITerminal.writeLine}
     */
    writeLine(...messageParts) {
        this.write(...messageParts, Colors_1.eolSequence);
    }
    /**
     * {@inheritdoc ITerminal.writeWarning}
     */
    writeWarning(...messageParts) {
        this._writeSegmentsToProviders(messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Yellow }))), ITerminalProvider_1.TerminalProviderSeverity.warning);
    }
    /**
     * {@inheritdoc ITerminal.writeWarningLine}
     */
    writeWarningLine(...messageParts) {
        this._writeSegmentsToProviders([
            ...messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Yellow }))),
            Colors_1.eolSequence
        ], ITerminalProvider_1.TerminalProviderSeverity.warning);
    }
    /**
     * {@inheritdoc ITerminal.writeError}
     */
    writeError(...messageParts) {
        this._writeSegmentsToProviders(messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Red }))), ITerminalProvider_1.TerminalProviderSeverity.error);
    }
    /**
     * {@inheritdoc ITerminal.writeErrorLine}
     */
    writeErrorLine(...messageParts) {
        this._writeSegmentsToProviders([
            ...messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Red }))),
            Colors_1.eolSequence
        ], ITerminalProvider_1.TerminalProviderSeverity.error);
    }
    /**
     * {@inheritdoc ITerminal.writeVerbose}
     */
    writeVerbose(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.verbose);
    }
    /**
     * {@inheritdoc ITerminal.writeVerboseLine}
     */
    writeVerboseLine(...messageParts) {
        this.writeVerbose(...messageParts, Colors_1.eolSequence);
    }
    /**
     * {@inheritdoc ITerminal.writeDebug}
     */
    writeDebug(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.debug);
    }
    /**
     * {@inheritdoc ITerminal.writeDebugLine}
     */
    writeDebugLine(...messageParts) {
        this.writeDebug(...messageParts, Colors_1.eolSequence);
    }
    _writeSegmentsToProviders(segments, severity) {
        const withColorText = {};
        const withoutColorText = {};
        let withColorLines;
        let withoutColorLines;
        this._providers.forEach((provider) => {
            const eol = provider.eolCharacter;
            let textToWrite;
            if (provider.supportsColor) {
                if (!withColorLines) {
                    withColorLines = this._serializeFormattableTextSegments(segments, true);
                }
                if (!withColorText[eol]) {
                    withColorText[eol] = withColorLines.join(eol);
                }
                textToWrite = withColorText[eol];
            }
            else {
                if (!withoutColorLines) {
                    withoutColorLines = this._serializeFormattableTextSegments(segments, false);
                }
                if (!withoutColorText[eol]) {
                    withoutColorText[eol] = withoutColorLines.join(eol);
                }
                textToWrite = withoutColorText[eol];
            }
            provider.write(textToWrite, severity);
        });
    }
    _serializeFormattableTextSegments(segments, withColor) {
        const lines = [];
        let segmentsToJoin = [];
        let lastSegmentWasEol = false;
        for (let i = 0; i < segments.length; i++) {
            const segment = Colors_1.Colors._normalizeStringOrColorableSequence(segments[i]);
            lastSegmentWasEol = !!segment.isEol;
            if (lastSegmentWasEol) {
                lines.push(segmentsToJoin.join(''));
                segmentsToJoin = [];
            }
            else {
                if (withColor) {
                    const startColorCodes = [];
                    const endColorCodes = [];
                    switch (segment.foregroundColor) {
                        case Colors_1.ColorValue.Black: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlackForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Red: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.RedForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Green: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GreenForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Yellow: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.YellowForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Blue: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlueForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Magenta: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.MagentaForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Cyan: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.CyanForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.White: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.WhiteForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Gray: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GrayForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                    }
                    switch (segment.backgroundColor) {
                        case Colors_1.ColorValue.Black: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlackBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Red: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.RedBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Green: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GreenBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Yellow: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.YellowBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Blue: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlueBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Magenta: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.MagentaBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Cyan: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.CyanBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.White: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.WhiteBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Gray: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GrayBackground);
                            endColorCodes.push(49);
                            break;
                        }
                    }
                    if (segment.textAttributes) {
                        for (const textAttribute of segment.textAttributes) {
                            switch (textAttribute) {
                                case Colors_1.TextAttribute.Bold: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Bold);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.NormalColorOrIntensity);
                                    break;
                                }
                                case Colors_1.TextAttribute.Dim: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Dim);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.NormalColorOrIntensity);
                                    break;
                                }
                                case Colors_1.TextAttribute.Underline: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Underline);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.UnderlineOff);
                                    break;
                                }
                                case Colors_1.TextAttribute.Blink: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Blink);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.BlinkOff);
                                    break;
                                }
                                case Colors_1.TextAttribute.InvertColor: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.InvertColor);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.InvertColorOff);
                                    break;
                                }
                                case Colors_1.TextAttribute.Hidden: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Hidden);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.HiddenOff);
                                    break;
                                }
                            }
                        }
                    }
                    for (let j = 0; j < startColorCodes.length; j++) {
                        const code = startColorCodes[j];
                        segmentsToJoin.push(...['\u001b[', code.toString(), 'm']);
                    }
                    segmentsToJoin.push(segment.text);
                    for (let j = endColorCodes.length - 1; j >= 0; j--) {
                        const code = endColorCodes[j];
                        segmentsToJoin.push(...['\u001b[', code.toString(), 'm']);
                    }
                }
                else {
                    segmentsToJoin.push(segment.text);
                }
            }
        }
        if (segmentsToJoin.length > 0) {
            lines.push(segmentsToJoin.join(''));
        }
        if (lastSegmentWasEol) {
            lines.push('');
        }
        return lines;
    }
}
exports.Terminal = Terminal;
//# sourceMappingURL=Terminal.js.map

/***/ }),

/***/ 963:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Text = void 0;
const os = __importStar(__webpack_require__(12087));
/**
 * Operations for working with strings that contain text.
 *
 * @remarks
 * The utilities provided by this class are intended to be simple, small, and very
 * broadly applicable.
 *
 * @public
 */
class Text {
    /**
     * Returns the same thing as targetString.replace(searchValue, replaceValue), except that
     * all matches are replaced, rather than just the first match.
     * @param input         - The string to be modified
     * @param searchValue   - The value to search for
     * @param replaceValue  - The replacement text
     */
    static replaceAll(input, searchValue, replaceValue) {
        return input.split(searchValue).join(replaceValue);
    }
    /**
     * Converts all newlines in the provided string to use Windows-style CRLF end of line characters.
     */
    static convertToCrLf(input) {
        return input.replace(Text._newLineRegEx, '\r\n');
    }
    /**
     * Converts all newlines in the provided string to use POSIX-style LF end of line characters.
     *
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    static convertToLf(input) {
        return input.replace(Text._newLineRegEx, '\n');
    }
    /**
     * Converts all newlines in the provided string to use the specified newline type.
     */
    static convertTo(input, newlineKind) {
        return input.replace(Text._newLineRegEx, Text.getNewline(newlineKind));
    }
    /**
     * Returns the newline character sequence for the specified `NewlineKind`.
     */
    static getNewline(newlineKind) {
        switch (newlineKind) {
            case "\r\n" /* CrLf */:
                return '\r\n';
            case "\n" /* Lf */:
                return '\n';
            case "os" /* OsDefault */:
                return os.EOL;
            default:
                throw new Error('Unsupported newline kind');
        }
    }
    /**
     * Append characters to the end of a string to ensure the result has a minimum length.
     * @remarks
     * If the string length already exceeds the minimum length, then the string is unchanged.
     * The string is not truncated.
     */
    static padEnd(s, minimumLength, paddingCharacter = ' ') {
        if (paddingCharacter.length !== 1) {
            throw new Error('The paddingCharacter parameter must be a single character.');
        }
        if (s.length < minimumLength) {
            const paddingArray = new Array(minimumLength - s.length);
            paddingArray.unshift(s);
            return paddingArray.join(paddingCharacter);
        }
        else {
            return s;
        }
    }
    /**
     * Append characters to the start of a string to ensure the result has a minimum length.
     * @remarks
     * If the string length already exceeds the minimum length, then the string is unchanged.
     * The string is not truncated.
     */
    static padStart(s, minimumLength, paddingCharacter = ' ') {
        if (paddingCharacter.length !== 1) {
            throw new Error('The paddingCharacter parameter must be a single character.');
        }
        if (s.length < minimumLength) {
            const paddingArray = new Array(minimumLength - s.length);
            paddingArray.push(s);
            return paddingArray.join(paddingCharacter);
        }
        else {
            return s;
        }
    }
    /**
     * If the string is longer than maximumLength characters, truncate it to that length
     * using "..." to indicate the truncation.
     *
     * @remarks
     * For example truncateWithEllipsis('1234578', 5) would produce '12...'.
     */
    static truncateWithEllipsis(s, maximumLength) {
        if (maximumLength < 0) {
            throw new Error('The maximumLength cannot be a negative number');
        }
        if (s.length <= maximumLength) {
            return s;
        }
        if (s.length <= 3) {
            return s.substring(0, maximumLength);
        }
        return s.substring(0, maximumLength - 3) + '...';
    }
    /**
     * Returns the input string with a trailing `\n` character appended, if not already present.
     */
    static ensureTrailingNewline(s, newlineKind = "\n" /* Lf */) {
        // Is there already a newline?
        if (Text._newLineAtEndRegEx.test(s)) {
            return s; // yes, no change
        }
        return s + newlineKind; // no, add it
    }
}
exports.Text = Text;
Text._newLineRegEx = /\r\n|\n\r|\r|\n/g;
Text._newLineAtEndRegEx = /(\r\n|\n\r|\r|\n)$/;
//# sourceMappingURL=Text.js.map

/***/ }),

/***/ 21131:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeUuid = void 0;
const InternalError_1 = __webpack_require__(73710);
const classPrototypeUuidSymbol = Symbol.for('TypeUuid.classPrototypeUuid');
/**
 * Provides a version-independent implementation of the JavaScript `instanceof` operator.
 *
 * @remarks
 * The JavaScript `instanceof` operator normally only identifies objects from a particular library instance.
 * For example, suppose the NPM package `example-lib` has two published versions 1.2.0 and 1.3.0, and
 * it exports a class called `A`.  Suppose some code consumes version `1.3.0` of the library, but it receives
 * an object that was constructed using version `1.2.0`.  In this situation `a instanceof A` will return `false`,
 * even though `a` is an instance of `A`.  The reason is that there are two prototypes for `A`; one for each
 * version.
 *
 * The `TypeUuid` facility provides a way to make `a instanceof A` return true for both prototypes of `A`,
 * by instead using a universally unique identifier (UUID) to detect object instances.
 *
 * You can use `Symbol.hasInstance` to enable the system `instanceof` operator to recognize type UUID equivalence:
 * ```ts
 * const uuidWidget: string = '9c340ef0-d29f-4e2e-a09f-42bacc59024b';
 * class Widget {
 *   public static [Symbol.hasInstance](instance: object): boolean {
 *     return TypeUuid.isInstanceOf(instance, uuidWidget);
 *   }
 * }
 * ```
 * // Example usage:
 * ```ts
 * import { Widget as Widget1 } from 'v1-of-library';
 * import { Widget as Widget2 } from 'v2-of-library';
 * const widget = new Widget2();
 * console.log(widget instanceof Widget1); // prints true
 * ```
 *
 * @public
 */
class TypeUuid {
    /**
     * Registers a JavaScript class as having a type identified by the specified UUID.
     * @privateRemarks
     * We cannot use a construct signature for `targetClass` because it may be an abstract class.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static registerClass(targetClass, typeUuid) {
        if (typeof targetClass !== 'function') {
            throw new Error('The targetClass parameter must be a JavaScript class');
        }
        if (!TypeUuid._uuidRegExp.test(typeUuid)) {
            throw new Error(`The type UUID must be specified as lowercase hexadecimal with dashes: "${typeUuid}"`);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const targetClassPrototype = targetClass.prototype;
        if (Object.hasOwnProperty.call(targetClassPrototype, classPrototypeUuidSymbol)) {
            const existingUuid = targetClassPrototype[classPrototypeUuidSymbol];
            throw new InternalError_1.InternalError(`Cannot register the target class ${targetClass.name || ''} typeUuid=${typeUuid}` +
                ` because it was already registered with typeUuid=${existingUuid}`);
        }
        targetClassPrototype[classPrototypeUuidSymbol] = typeUuid;
    }
    /**
     * Returns true if the `targetObject` is an instance of a JavaScript class that was previously
     * registered using the specified `typeUuid`.  Base classes are also considered.
     */
    static isInstanceOf(targetObject, typeUuid) {
        if (targetObject === undefined || targetObject === null) {
            return false;
        }
        let objectPrototype = Object.getPrototypeOf(targetObject);
        while (objectPrototype !== undefined && objectPrototype !== null) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const registeredUuid = objectPrototype[classPrototypeUuidSymbol];
            if (registeredUuid === typeUuid) {
                return true;
            }
            // Walk upwards an examine base class prototypes
            objectPrototype = Object.getPrototypeOf(objectPrototype);
        }
        return false;
    }
}
exports.TypeUuid = TypeUuid;
TypeUuid._uuidRegExp = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
//# sourceMappingURL=TypeUuid.js.map

/***/ }),

/***/ 24019:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeUuid = exports.StringBufferTerminalProvider = exports.ConsoleTerminalProvider = exports.TerminalProviderSeverity = exports.TextAttribute = exports.ColorValue = exports.Colors = exports.Terminal = exports.StringBuilder = exports.LegacyAdapters = exports.FileWriter = exports.FileSystem = exports.Sort = exports.Text = exports.Path = exports.PackageNameParser = exports.PackageName = exports.PackageJsonLookup = exports.ProtectableMap = exports.MapExtensions = exports.LockFile = exports.JsonSchema = exports.JsonFile = exports.InternalError = exports.Import = exports.Executable = exports.EnvironmentMap = exports.Enum = exports.Async = exports.AnsiEscape = exports.AlreadyReportedError = void 0;
/**
 * Core libraries that every NodeJS toolchain project should use.
 *
 * @packageDocumentation
 */
var AlreadyReportedError_1 = __webpack_require__(26807);
Object.defineProperty(exports, "AlreadyReportedError", ({ enumerable: true, get: function () { return AlreadyReportedError_1.AlreadyReportedError; } }));
var AnsiEscape_1 = __webpack_require__(91053);
Object.defineProperty(exports, "AnsiEscape", ({ enumerable: true, get: function () { return AnsiEscape_1.AnsiEscape; } }));
var Async_1 = __webpack_require__(45822);
Object.defineProperty(exports, "Async", ({ enumerable: true, get: function () { return Async_1.Async; } }));
var Enum_1 = __webpack_require__(46997);
Object.defineProperty(exports, "Enum", ({ enumerable: true, get: function () { return Enum_1.Enum; } }));
var EnvironmentMap_1 = __webpack_require__(90205);
Object.defineProperty(exports, "EnvironmentMap", ({ enumerable: true, get: function () { return EnvironmentMap_1.EnvironmentMap; } }));
var Executable_1 = __webpack_require__(55210);
Object.defineProperty(exports, "Executable", ({ enumerable: true, get: function () { return Executable_1.Executable; } }));
var Import_1 = __webpack_require__(38489);
Object.defineProperty(exports, "Import", ({ enumerable: true, get: function () { return Import_1.Import; } }));
var InternalError_1 = __webpack_require__(73710);
Object.defineProperty(exports, "InternalError", ({ enumerable: true, get: function () { return InternalError_1.InternalError; } }));
var JsonFile_1 = __webpack_require__(95873);
Object.defineProperty(exports, "JsonFile", ({ enumerable: true, get: function () { return JsonFile_1.JsonFile; } }));
var JsonSchema_1 = __webpack_require__(76792);
Object.defineProperty(exports, "JsonSchema", ({ enumerable: true, get: function () { return JsonSchema_1.JsonSchema; } }));
var LockFile_1 = __webpack_require__(50264);
Object.defineProperty(exports, "LockFile", ({ enumerable: true, get: function () { return LockFile_1.LockFile; } }));
var MapExtensions_1 = __webpack_require__(71059);
Object.defineProperty(exports, "MapExtensions", ({ enumerable: true, get: function () { return MapExtensions_1.MapExtensions; } }));
var ProtectableMap_1 = __webpack_require__(17192);
Object.defineProperty(exports, "ProtectableMap", ({ enumerable: true, get: function () { return ProtectableMap_1.ProtectableMap; } }));
var PackageJsonLookup_1 = __webpack_require__(52453);
Object.defineProperty(exports, "PackageJsonLookup", ({ enumerable: true, get: function () { return PackageJsonLookup_1.PackageJsonLookup; } }));
var PackageName_1 = __webpack_require__(36234);
Object.defineProperty(exports, "PackageName", ({ enumerable: true, get: function () { return PackageName_1.PackageName; } }));
Object.defineProperty(exports, "PackageNameParser", ({ enumerable: true, get: function () { return PackageName_1.PackageNameParser; } }));
var Path_1 = __webpack_require__(46520);
Object.defineProperty(exports, "Path", ({ enumerable: true, get: function () { return Path_1.Path; } }));
var Text_1 = __webpack_require__(963);
Object.defineProperty(exports, "Text", ({ enumerable: true, get: function () { return Text_1.Text; } }));
var Sort_1 = __webpack_require__(60368);
Object.defineProperty(exports, "Sort", ({ enumerable: true, get: function () { return Sort_1.Sort; } }));
var FileSystem_1 = __webpack_require__(76952);
Object.defineProperty(exports, "FileSystem", ({ enumerable: true, get: function () { return FileSystem_1.FileSystem; } }));
var FileWriter_1 = __webpack_require__(78439);
Object.defineProperty(exports, "FileWriter", ({ enumerable: true, get: function () { return FileWriter_1.FileWriter; } }));
var LegacyAdapters_1 = __webpack_require__(48547);
Object.defineProperty(exports, "LegacyAdapters", ({ enumerable: true, get: function () { return LegacyAdapters_1.LegacyAdapters; } }));
var StringBuilder_1 = __webpack_require__(60664);
Object.defineProperty(exports, "StringBuilder", ({ enumerable: true, get: function () { return StringBuilder_1.StringBuilder; } }));
var Terminal_1 = __webpack_require__(16035);
Object.defineProperty(exports, "Terminal", ({ enumerable: true, get: function () { return Terminal_1.Terminal; } }));
var Colors_1 = __webpack_require__(91039);
Object.defineProperty(exports, "Colors", ({ enumerable: true, get: function () { return Colors_1.Colors; } }));
Object.defineProperty(exports, "ColorValue", ({ enumerable: true, get: function () { return Colors_1.ColorValue; } }));
Object.defineProperty(exports, "TextAttribute", ({ enumerable: true, get: function () { return Colors_1.TextAttribute; } }));
var ITerminalProvider_1 = __webpack_require__(87567);
Object.defineProperty(exports, "TerminalProviderSeverity", ({ enumerable: true, get: function () { return ITerminalProvider_1.TerminalProviderSeverity; } }));
var ConsoleTerminalProvider_1 = __webpack_require__(95568);
Object.defineProperty(exports, "ConsoleTerminalProvider", ({ enumerable: true, get: function () { return ConsoleTerminalProvider_1.ConsoleTerminalProvider; } }));
var StringBufferTerminalProvider_1 = __webpack_require__(35215);
Object.defineProperty(exports, "StringBufferTerminalProvider", ({ enumerable: true, get: function () { return StringBufferTerminalProvider_1.StringBufferTerminalProvider; } }));
var TypeUuid_1 = __webpack_require__(21131);
Object.defineProperty(exports, "TypeUuid", ({ enumerable: true, get: function () { return TypeUuid_1.TypeUuid; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 36564:
/***/ ((module) => {

// A simple implementation of make-array
function makeArray (subject) {
  return Array.isArray(subject)
    ? subject
    : [subject]
}

const EMPTY = ''
const SPACE = ' '
const ESCAPE = '\\'
const REGEX_TEST_BLANK_LINE = /^\s+$/
const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/
const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/
const REGEX_SPLITALL_CRLF = /\r?\n/g
// /foo,
// ./foo,
// ../foo,
// .
// ..
const REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/

const SLASH = '/'
const KEY_IGNORE = typeof Symbol !== 'undefined'
  ? Symbol.for('node-ignore')
  /* istanbul ignore next */
  : 'node-ignore'

const define = (object, key, value) =>
  Object.defineProperty(object, key, {value})

const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g

// Sanitize the range of a regular expression
// The cases are complicated, see test cases for details
const sanitizeRange = range => range.replace(
  REGEX_REGEXP_RANGE,
  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0)
    ? match
    // Invalid range (out of order) which is ok for gitignore rules but
    //   fatal for JavaScript regular expression, so eliminate it.
    : EMPTY
)

// See fixtures #59
const cleanRangeBackSlash = slashes => {
  const {length} = slashes
  return slashes.slice(0, length - length % 2)
}

// > If the pattern ends with a slash,
// > it is removed for the purpose of the following description,
// > but it would only find a match with a directory.
// > In other words, foo/ will match a directory foo and paths underneath it,
// > but will not match a regular file or a symbolic link foo
// >  (this is consistent with the way how pathspec works in general in Git).
// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
//      you could use option `mark: true` with `glob`

// '`foo/`' should not continue with the '`..`'
const REPLACERS = [

  // > Trailing spaces are ignored unless they are quoted with backslash ("\")
  [
    // (a\ ) -> (a )
    // (a  ) -> (a)
    // (a \ ) -> (a  )
    /\\?\s+$/,
    match => match.indexOf('\\') === 0
      ? SPACE
      : EMPTY
  ],

  // replace (\ ) with ' '
  [
    /\\\s/g,
    () => SPACE
  ],

  // Escape metacharacters
  // which is written down by users but means special for regular expressions.

  // > There are 12 characters with special meanings:
  // > - the backslash \,
  // > - the caret ^,
  // > - the dollar sign $,
  // > - the period or dot .,
  // > - the vertical bar or pipe symbol |,
  // > - the question mark ?,
  // > - the asterisk or star *,
  // > - the plus sign +,
  // > - the opening parenthesis (,
  // > - the closing parenthesis ),
  // > - and the opening square bracket [,
  // > - the opening curly brace {,
  // > These special characters are often called "metacharacters".
  [
    /[\\$.|*+(){^]/g,
    match => `\\${match}`
  ],

  [
    // > a question mark (?) matches a single character
    /(?!\\)\?/g,
    () => '[^/]'
  ],

  // leading slash
  [

    // > A leading slash matches the beginning of the pathname.
    // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
    // A leading slash matches the beginning of the pathname
    /^\//,
    () => '^'
  ],

  // replace special metacharacter slash after the leading slash
  [
    /\//g,
    () => '\\/'
  ],

  [
    // > A leading "**" followed by a slash means match in all directories.
    // > For example, "**/foo" matches file or directory "foo" anywhere,
    // > the same as pattern "foo".
    // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
    // >   under directory "foo".
    // Notice that the '*'s have been replaced as '\\*'
    /^\^*\\\*\\\*\\\//,

    // '**/foo' <-> 'foo'
    () => '^(?:.*\\/)?'
  ],

  // starting
  [
    // there will be no leading '/'
    //   (which has been replaced by section "leading slash")
    // If starts with '**', adding a '^' to the regular expression also works
    /^(?=[^^])/,
    function startingReplacer () {
      // If has a slash `/` at the beginning or middle
      return !/\/(?!$)/.test(this)
        // > Prior to 2.22.1
        // > If the pattern does not contain a slash /,
        // >   Git treats it as a shell glob pattern
        // Actually, if there is only a trailing slash,
        //   git also treats it as a shell glob pattern

        // After 2.22.1 (compatible but clearer)
        // > If there is a separator at the beginning or middle (or both)
        // > of the pattern, then the pattern is relative to the directory
        // > level of the particular .gitignore file itself.
        // > Otherwise the pattern may also match at any level below
        // > the .gitignore level.
        ? '(?:^|\\/)'

        // > Otherwise, Git treats the pattern as a shell glob suitable for
        // >   consumption by fnmatch(3)
        : '^'
    }
  ],

  // two globstars
  [
    // Use lookahead assertions so that we could match more than one `'/**'`
    /\\\/\\\*\\\*(?=\\\/|$)/g,

    // Zero, one or several directories
    // should not use '*', or it will be replaced by the next replacer

    // Check if it is not the last `'/**'`
    (_, index, str) => index + 6 < str.length

      // case: /**/
      // > A slash followed by two consecutive asterisks then a slash matches
      // >   zero or more directories.
      // > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
      // '/**/'
      ? '(?:\\/[^\\/]+)*'

      // case: /**
      // > A trailing `"/**"` matches everything inside.

      // #21: everything inside but it should not include the current folder
      : '\\/.+'
  ],

  // intermediate wildcards
  [
    // Never replace escaped '*'
    // ignore rule '\*' will match the path '*'

    // 'abc.*/' -> go
    // 'abc.*'  -> skip this rule
    /(^|[^\\]+)\\\*(?=.+)/g,

    // '*.js' matches '.js'
    // '*.js' doesn't match 'abc'
    (_, p1) => `${p1}[^\\/]*`
  ],

  [
    // unescape, revert step 3 except for back slash
    // For example, if a user escape a '\\*',
    // after step 3, the result will be '\\\\\\*'
    /\\\\\\(?=[$.|*+(){^])/g,
    () => ESCAPE
  ],

  [
    // '\\\\' -> '\\'
    /\\\\/g,
    () => ESCAPE
  ],

  [
    // > The range notation, e.g. [a-zA-Z],
    // > can be used to match one of the characters in a range.

    // `\` is escaped by step 3
    /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
    (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE
      // '\\[bar]' -> '\\\\[bar\\]'
      ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}`
      : close === ']'
        ? endEscape.length % 2 === 0
          // A normal case, and it is a range notation
          // '[bar]'
          // '[bar\\\\]'
          ? `[${sanitizeRange(range)}${endEscape}]`
          // Invalid range notaton
          // '[bar\\]' -> '[bar\\\\]'
          : '[]'
        : '[]'
  ],

  // ending
  [
    // 'js' will not match 'js.'
    // 'ab' will not match 'abc'
    /(?:[^*])$/,

    // WTF!
    // https://git-scm.com/docs/gitignore
    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
    // which re-fixes #24, #38

    // > If there is a separator at the end of the pattern then the pattern
    // > will only match directories, otherwise the pattern can match both
    // > files and directories.

    // 'js*' will not match 'a.js'
    // 'js/' will not match 'a.js'
    // 'js' will match 'a.js' and 'a.js/'
    match => /\/$/.test(match)
      // foo/ will not match 'foo'
      ? `${match}$`
      // foo matches 'foo' and 'foo/'
      : `${match}(?=$|\\/$)`
  ],

  // trailing wildcard
  [
    /(\^|\\\/)?\\\*$/,
    (_, p1) => {
      const prefix = p1
        // '\^':
        // '/*' does not match EMPTY
        // '/*' does not match everything

        // '\\\/':
        // 'abc/*' does not match 'abc/'
        ? `${p1}[^/]+`

        // 'a*' matches 'a'
        // 'a*' matches 'aa'
        : '[^/]*'

      return `${prefix}(?=$|\\/$)`
    }
  ],
]

// A simple cache, because an ignore rule only has only one certain meaning
const regexCache = Object.create(null)

// @param {pattern}
const makeRegex = (pattern, ignorecase) => {
  let source = regexCache[pattern]

  if (!source) {
    source = REPLACERS.reduce(
      (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
      pattern
    )
    regexCache[pattern] = source
  }

  return ignorecase
    ? new RegExp(source, 'i')
    : new RegExp(source)
}

const isString = subject => typeof subject === 'string'

// > A blank line matches no files, so it can serve as a separator for readability.
const checkPattern = pattern => pattern
  && isString(pattern)
  && !REGEX_TEST_BLANK_LINE.test(pattern)

  // > A line starting with # serves as a comment.
  && pattern.indexOf('#') !== 0

const splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF)

class IgnoreRule {
  constructor (
    origin,
    pattern,
    negative,
    regex
  ) {
    this.origin = origin
    this.pattern = pattern
    this.negative = negative
    this.regex = regex
  }
}

const createRule = (pattern, ignorecase) => {
  const origin = pattern
  let negative = false

  // > An optional prefix "!" which negates the pattern;
  if (pattern.indexOf('!') === 0) {
    negative = true
    pattern = pattern.substr(1)
  }

  pattern = pattern
  // > Put a backslash ("\") in front of the first "!" for patterns that
  // >   begin with a literal "!", for example, `"\!important!.txt"`.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')
  // > Put a backslash ("\") in front of the first hash for patterns that
  // >   begin with a hash.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#')

  const regex = makeRegex(pattern, ignorecase)

  return new IgnoreRule(
    origin,
    pattern,
    negative,
    regex
  )
}

const throwError = (message, Ctor) => {
  throw new Ctor(message)
}

const checkPath = (path, originalPath, doThrow) => {
  if (!isString(path)) {
    return doThrow(
      `path must be a string, but got \`${originalPath}\``,
      TypeError
    )
  }

  // We don't know if we should ignore EMPTY, so throw
  if (!path) {
    return doThrow(`path must not be empty`, TypeError)
  }

  // Check if it is a relative path
  if (checkPath.isNotRelative(path)) {
    const r = '`path.relative()`d'
    return doThrow(
      `path should be a ${r} string, but got "${originalPath}"`,
      RangeError
    )
  }

  return true
}

const isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path)

checkPath.isNotRelative = isNotRelative
checkPath.convert = p => p

class Ignore {
  constructor ({
    ignorecase = true
  } = {}) {
    define(this, KEY_IGNORE, true)

    this._rules = []
    this._ignorecase = ignorecase
    this._initCache()
  }

  _initCache () {
    this._ignoreCache = Object.create(null)
    this._testCache = Object.create(null)
  }

  _addPattern (pattern) {
    // #32
    if (pattern && pattern[KEY_IGNORE]) {
      this._rules = this._rules.concat(pattern._rules)
      this._added = true
      return
    }

    if (checkPattern(pattern)) {
      const rule = createRule(pattern, this._ignorecase)
      this._added = true
      this._rules.push(rule)
    }
  }

  // @param {Array<string> | string | Ignore} pattern
  add (pattern) {
    this._added = false

    makeArray(
      isString(pattern)
        ? splitPattern(pattern)
        : pattern
    ).forEach(this._addPattern, this)

    // Some rules have just added to the ignore,
    // making the behavior changed.
    if (this._added) {
      this._initCache()
    }

    return this
  }

  // legacy
  addPattern (pattern) {
    return this.add(pattern)
  }

  //          |           ignored : unignored
  // negative |   0:0   |   0:1   |   1:0   |   1:1
  // -------- | ------- | ------- | ------- | --------
  //     0    |  TEST   |  TEST   |  SKIP   |    X
  //     1    |  TESTIF |  SKIP   |  TEST   |    X

  // - SKIP: always skip
  // - TEST: always test
  // - TESTIF: only test if checkUnignored
  // - X: that never happen

  // @param {boolean} whether should check if the path is unignored,
  //   setting `checkUnignored` to `false` could reduce additional
  //   path matching.

  // @returns {TestResult} true if a file is ignored
  _testOne (path, checkUnignored) {
    let ignored = false
    let unignored = false

    this._rules.forEach(rule => {
      const {negative} = rule
      if (
        unignored === negative && ignored !== unignored
        || negative && !ignored && !unignored && !checkUnignored
      ) {
        return
      }

      const matched = rule.regex.test(path)

      if (matched) {
        ignored = !negative
        unignored = negative
      }
    })

    return {
      ignored,
      unignored
    }
  }

  // @returns {TestResult}
  _test (originalPath, cache, checkUnignored, slices) {
    const path = originalPath
      // Supports nullable path
      && checkPath.convert(originalPath)

    checkPath(path, originalPath, throwError)

    return this._t(path, cache, checkUnignored, slices)
  }

  _t (path, cache, checkUnignored, slices) {
    if (path in cache) {
      return cache[path]
    }

    if (!slices) {
      // path/to/a.js
      // ['path', 'to', 'a.js']
      slices = path.split(SLASH)
    }

    slices.pop()

    // If the path has no parent directory, just test it
    if (!slices.length) {
      return cache[path] = this._testOne(path, checkUnignored)
    }

    const parent = this._t(
      slices.join(SLASH) + SLASH,
      cache,
      checkUnignored,
      slices
    )

    // If the path contains a parent directory, check the parent first
    return cache[path] = parent.ignored
      // > It is not possible to re-include a file if a parent directory of
      // >   that file is excluded.
      ? parent
      : this._testOne(path, checkUnignored)
  }

  ignores (path) {
    return this._test(path, this._ignoreCache, false).ignored
  }

  createFilter () {
    return path => !this.ignores(path)
  }

  filter (paths) {
    return makeArray(paths).filter(this.createFilter())
  }

  // @returns {TestResult}
  test (path) {
    return this._test(path, this._testCache, true)
  }
}

const factory = options => new Ignore(options)

const returnFalse = () => false

const isPathValid = path =>
  checkPath(path && checkPath.convert(path), path, returnFalse)

factory.isPathValid = isPathValid

// Fixes typescript
factory.default = factory

module.exports = factory

// Windows
// --------------------------------------------------------------
/* istanbul ignore if  */
if (
  // Detect `process` so that it can run in browsers.
  typeof process !== 'undefined'
  && (
    process.env && process.env.IGNORE_TEST_WIN32
    || process.platform === 'win32'
  )
) {
  /* eslint no-control-regex: "off" */
  const makePosix = str => /^\\\\\?\\/.test(str)
  || /["<>|\u0000-\u001F]+/u.test(str)
    ? str
    : str.replace(/\\/g, '/')

  checkPath.convert = makePosix

  // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
  // 'd:\\foo'
  const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i
  checkPath.isNotRelative = path =>
    REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path)
    || isNotRelative(path)
}


/***/ }),

/***/ 48941:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Stream = _interopDefault(__webpack_require__(92413));
var http = _interopDefault(__webpack_require__(15876));
var Url = _interopDefault(__webpack_require__(78835));
var https = _interopDefault(__webpack_require__(57211));
var zlib = _interopDefault(__webpack_require__(78761));

// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js

// fix for "Readable" isn't a named export issue
const Readable = Stream.Readable;

const BUFFER = Symbol('buffer');
const TYPE = Symbol('type');

class Blob {
	constructor() {
		this[TYPE] = '';

		const blobParts = arguments[0];
		const options = arguments[1];

		const buffers = [];
		let size = 0;

		if (blobParts) {
			const a = blobParts;
			const length = Number(a.length);
			for (let i = 0; i < length; i++) {
				const element = a[i];
				let buffer;
				if (element instanceof Buffer) {
					buffer = element;
				} else if (ArrayBuffer.isView(element)) {
					buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
				} else if (element instanceof ArrayBuffer) {
					buffer = Buffer.from(element);
				} else if (element instanceof Blob) {
					buffer = element[BUFFER];
				} else {
					buffer = Buffer.from(typeof element === 'string' ? element : String(element));
				}
				size += buffer.length;
				buffers.push(buffer);
			}
		}

		this[BUFFER] = Buffer.concat(buffers);

		let type = options && options.type !== undefined && String(options.type).toLowerCase();
		if (type && !/[^\u0020-\u007E]/.test(type)) {
			this[TYPE] = type;
		}
	}
	get size() {
		return this[BUFFER].length;
	}
	get type() {
		return this[TYPE];
	}
	text() {
		return Promise.resolve(this[BUFFER].toString());
	}
	arrayBuffer() {
		const buf = this[BUFFER];
		const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		return Promise.resolve(ab);
	}
	stream() {
		const readable = new Readable();
		readable._read = function () {};
		readable.push(this[BUFFER]);
		readable.push(null);
		return readable;
	}
	toString() {
		return '[object Blob]';
	}
	slice() {
		const size = this.size;

		const start = arguments[0];
		const end = arguments[1];
		let relativeStart, relativeEnd;
		if (start === undefined) {
			relativeStart = 0;
		} else if (start < 0) {
			relativeStart = Math.max(size + start, 0);
		} else {
			relativeStart = Math.min(start, size);
		}
		if (end === undefined) {
			relativeEnd = size;
		} else if (end < 0) {
			relativeEnd = Math.max(size + end, 0);
		} else {
			relativeEnd = Math.min(end, size);
		}
		const span = Math.max(relativeEnd - relativeStart, 0);

		const buffer = this[BUFFER];
		const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
		const blob = new Blob([], { type: arguments[2] });
		blob[BUFFER] = slicedBuffer;
		return blob;
	}
}

Object.defineProperties(Blob.prototype, {
	size: { enumerable: true },
	type: { enumerable: true },
	slice: { enumerable: true }
});

Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
	value: 'Blob',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * fetch-error.js
 *
 * FetchError interface for operational errors
 */

/**
 * Create FetchError instance
 *
 * @param   String      message      Error message for human
 * @param   String      type         Error type for machine
 * @param   String      systemError  For Node.js system error
 * @return  FetchError
 */
function FetchError(message, type, systemError) {
  Error.call(this, message);

  this.message = message;
  this.type = type;

  // when err.type is `system`, err.code contains system error code
  if (systemError) {
    this.code = this.errno = systemError.code;
  }

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = 'FetchError';

let convert;
try {
	convert = __webpack_require__(22877).convert;
} catch (e) {}

const INTERNALS = Symbol('Body internals');

// fix an issue where "PassThrough" isn't a named export for node <10
const PassThrough = Stream.PassThrough;

/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
function Body(body) {
	var _this = this;

	var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	    _ref$size = _ref.size;

	let size = _ref$size === undefined ? 0 : _ref$size;
	var _ref$timeout = _ref.timeout;
	let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;

	if (body == null) {
		// body is undefined or null
		body = null;
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		body = Buffer.from(body.toString());
	} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		body = Buffer.from(body);
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
	} else if (body instanceof Stream) ; else {
		// none of the above
		// coerce to string then buffer
		body = Buffer.from(String(body));
	}
	this[INTERNALS] = {
		body,
		disturbed: false,
		error: null
	};
	this.size = size;
	this.timeout = timeout;

	if (body instanceof Stream) {
		body.on('error', function (err) {
			const error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
			_this[INTERNALS].error = error;
		});
	}
}

Body.prototype = {
	get body() {
		return this[INTERNALS].body;
	},

	get bodyUsed() {
		return this[INTERNALS].disturbed;
	},

	/**
  * Decode response as ArrayBuffer
  *
  * @return  Promise
  */
	arrayBuffer() {
		return consumeBody.call(this).then(function (buf) {
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		});
	},

	/**
  * Return raw response as Blob
  *
  * @return Promise
  */
	blob() {
		let ct = this.headers && this.headers.get('content-type') || '';
		return consumeBody.call(this).then(function (buf) {
			return Object.assign(
			// Prevent copying
			new Blob([], {
				type: ct.toLowerCase()
			}), {
				[BUFFER]: buf
			});
		});
	},

	/**
  * Decode response as json
  *
  * @return  Promise
  */
	json() {
		var _this2 = this;

		return consumeBody.call(this).then(function (buffer) {
			try {
				return JSON.parse(buffer.toString());
			} catch (err) {
				return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
			}
		});
	},

	/**
  * Decode response as text
  *
  * @return  Promise
  */
	text() {
		return consumeBody.call(this).then(function (buffer) {
			return buffer.toString();
		});
	},

	/**
  * Decode response as buffer (non-spec api)
  *
  * @return  Promise
  */
	buffer() {
		return consumeBody.call(this);
	},

	/**
  * Decode response as text, while automatically detecting the encoding and
  * trying to decode to UTF-8 (non-spec api)
  *
  * @return  Promise
  */
	textConverted() {
		var _this3 = this;

		return consumeBody.call(this).then(function (buffer) {
			return convertBody(buffer, _this3.headers);
		});
	}
};

// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
	body: { enumerable: true },
	bodyUsed: { enumerable: true },
	arrayBuffer: { enumerable: true },
	blob: { enumerable: true },
	json: { enumerable: true },
	text: { enumerable: true }
});

Body.mixIn = function (proto) {
	for (const name of Object.getOwnPropertyNames(Body.prototype)) {
		// istanbul ignore else: future proof
		if (!(name in proto)) {
			const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
			Object.defineProperty(proto, name, desc);
		}
	}
};

/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return  Promise
 */
function consumeBody() {
	var _this4 = this;

	if (this[INTERNALS].disturbed) {
		return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
	}

	this[INTERNALS].disturbed = true;

	if (this[INTERNALS].error) {
		return Body.Promise.reject(this[INTERNALS].error);
	}

	let body = this.body;

	// body is null
	if (body === null) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is blob
	if (isBlob(body)) {
		body = body.stream();
	}

	// body is buffer
	if (Buffer.isBuffer(body)) {
		return Body.Promise.resolve(body);
	}

	// istanbul ignore if: should never happen
	if (!(body instanceof Stream)) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is stream
	// get ready to actually consume the body
	let accum = [];
	let accumBytes = 0;
	let abort = false;

	return new Body.Promise(function (resolve, reject) {
		let resTimeout;

		// allow timeout on slow response body
		if (_this4.timeout) {
			resTimeout = setTimeout(function () {
				abort = true;
				reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
			}, _this4.timeout);
		}

		// handle stream errors
		body.on('error', function (err) {
			if (err.name === 'AbortError') {
				// if the request was aborted, reject with this Error
				abort = true;
				reject(err);
			} else {
				// other errors, such as incorrect content-encoding
				reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
			}
		});

		body.on('data', function (chunk) {
			if (abort || chunk === null) {
				return;
			}

			if (_this4.size && accumBytes + chunk.length > _this4.size) {
				abort = true;
				reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
				return;
			}

			accumBytes += chunk.length;
			accum.push(chunk);
		});

		body.on('end', function () {
			if (abort) {
				return;
			}

			clearTimeout(resTimeout);

			try {
				resolve(Buffer.concat(accum, accumBytes));
			} catch (err) {
				// handle streams that have accumulated too much data (issue #414)
				reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
			}
		});
	});
}

/**
 * Detect buffer encoding and convert to target encoding
 * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
 *
 * @param   Buffer  buffer    Incoming buffer
 * @param   String  encoding  Target encoding
 * @return  String
 */
function convertBody(buffer, headers) {
	if (typeof convert !== 'function') {
		throw new Error('The package `encoding` must be installed to use the textConverted() function');
	}

	const ct = headers.get('content-type');
	let charset = 'utf-8';
	let res, str;

	// header
	if (ct) {
		res = /charset=([^;]*)/i.exec(ct);
	}

	// no charset in content type, peek at response body for at most 1024 bytes
	str = buffer.slice(0, 1024).toString();

	// html5
	if (!res && str) {
		res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
	}

	// html4
	if (!res && str) {
		res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
		if (!res) {
			res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
			if (res) {
				res.pop(); // drop last quote
			}
		}

		if (res) {
			res = /charset=(.*)/i.exec(res.pop());
		}
	}

	// xml
	if (!res && str) {
		res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
	}

	// found charset
	if (res) {
		charset = res.pop();

		// prevent decode issues when sites use incorrect encoding
		// ref: https://hsivonen.fi/encoding-menu/
		if (charset === 'gb2312' || charset === 'gbk') {
			charset = 'gb18030';
		}
	}

	// turn raw buffers into a single utf-8 buffer
	return convert(buffer, 'UTF-8', charset).toString();
}

/**
 * Detect a URLSearchParams object
 * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
 *
 * @param   Object  obj     Object to detect by type or brand
 * @return  String
 */
function isURLSearchParams(obj) {
	// Duck-typing as a necessary condition.
	if (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {
		return false;
	}

	// Brand-checking and more duck-typing as optional condition.
	return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';
}

/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */
function isBlob(obj) {
	return typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}

/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed  instance  Response or Request instance
 * @return  Mixed
 */
function clone(instance) {
	let p1, p2;
	let body = instance.body;

	// don't allow cloning a used body
	if (instance.bodyUsed) {
		throw new Error('cannot clone body after it is used');
	}

	// check that body is a stream and not form-data object
	// note: we can't clone the form-data object without having it as a dependency
	if (body instanceof Stream && typeof body.getBoundary !== 'function') {
		// tee instance body
		p1 = new PassThrough();
		p2 = new PassThrough();
		body.pipe(p1);
		body.pipe(p2);
		// set instance body to teed body and return the other teed body
		instance[INTERNALS].body = p1;
		body = p2;
	}

	return body;
}

/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param   Mixed  instance  Any options.body input
 */
function extractContentType(body) {
	if (body === null) {
		// body is null
		return null;
	} else if (typeof body === 'string') {
		// body is string
		return 'text/plain;charset=UTF-8';
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		return 'application/x-www-form-urlencoded;charset=UTF-8';
	} else if (isBlob(body)) {
		// body is blob
		return body.type || null;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return null;
	} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		return null;
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		return null;
	} else if (typeof body.getBoundary === 'function') {
		// detect form data input from form-data module
		return `multipart/form-data;boundary=${body.getBoundary()}`;
	} else if (body instanceof Stream) {
		// body is stream
		// can't really do much about this
		return null;
	} else {
		// Body constructor defaults other things to string
		return 'text/plain;charset=UTF-8';
	}
}

/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param   Body    instance   Instance of Body
 * @return  Number?            Number of bytes, or null if not possible
 */
function getTotalBytes(instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		return 0;
	} else if (isBlob(body)) {
		return body.size;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return body.length;
	} else if (body && typeof body.getLengthSync === 'function') {
		// detect form data input from form-data module
		if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
		body.hasKnownLength && body.hasKnownLength()) {
			// 2.x
			return body.getLengthSync();
		}
		return null;
	} else {
		// body is stream
		return null;
	}
}

/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param   Body    instance   Instance of Body
 * @return  Void
 */
function writeToStream(dest, instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		dest.end();
	} else if (isBlob(body)) {
		body.stream().pipe(dest);
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		dest.write(body);
		dest.end();
	} else {
		// body is stream
		body.pipe(dest);
	}
}

// expose Promise
Body.Promise = global.Promise;

/**
 * headers.js
 *
 * Headers class offers convenient helpers
 */

const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

function validateName(name) {
	name = `${name}`;
	if (invalidTokenRegex.test(name) || name === '') {
		throw new TypeError(`${name} is not a legal HTTP header name`);
	}
}

function validateValue(value) {
	value = `${value}`;
	if (invalidHeaderCharRegex.test(value)) {
		throw new TypeError(`${value} is not a legal HTTP header value`);
	}
}

/**
 * Find the key in the map object given a header name.
 *
 * Returns undefined if not found.
 *
 * @param   String  name  Header name
 * @return  String|Undefined
 */
function find(map, name) {
	name = name.toLowerCase();
	for (const key in map) {
		if (key.toLowerCase() === name) {
			return key;
		}
	}
	return undefined;
}

const MAP = Symbol('map');
class Headers {
	/**
  * Headers class
  *
  * @param   Object  headers  Response headers
  * @return  Void
  */
	constructor() {
		let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

		this[MAP] = Object.create(null);

		if (init instanceof Headers) {
			const rawHeaders = init.raw();
			const headerNames = Object.keys(rawHeaders);

			for (const headerName of headerNames) {
				for (const value of rawHeaders[headerName]) {
					this.append(headerName, value);
				}
			}

			return;
		}

		// We don't worry about converting prop to ByteString here as append()
		// will handle it.
		if (init == null) ; else if (typeof init === 'object') {
			const method = init[Symbol.iterator];
			if (method != null) {
				if (typeof method !== 'function') {
					throw new TypeError('Header pairs must be iterable');
				}

				// sequence<sequence<ByteString>>
				// Note: per spec we have to first exhaust the lists then process them
				const pairs = [];
				for (const pair of init) {
					if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
						throw new TypeError('Each header pair must be iterable');
					}
					pairs.push(Array.from(pair));
				}

				for (const pair of pairs) {
					if (pair.length !== 2) {
						throw new TypeError('Each header pair must be a name/value tuple');
					}
					this.append(pair[0], pair[1]);
				}
			} else {
				// record<ByteString, ByteString>
				for (const key of Object.keys(init)) {
					const value = init[key];
					this.append(key, value);
				}
			}
		} else {
			throw new TypeError('Provided initializer must be an object');
		}
	}

	/**
  * Return combined header value given name
  *
  * @param   String  name  Header name
  * @return  Mixed
  */
	get(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key === undefined) {
			return null;
		}

		return this[MAP][key].join(', ');
	}

	/**
  * Iterate over all headers
  *
  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
  * @param   Boolean   thisArg   `this` context for callback function
  * @return  Void
  */
	forEach(callback) {
		let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

		let pairs = getHeaders(this);
		let i = 0;
		while (i < pairs.length) {
			var _pairs$i = pairs[i];
			const name = _pairs$i[0],
			      value = _pairs$i[1];

			callback.call(thisArg, value, name, this);
			pairs = getHeaders(this);
			i++;
		}
	}

	/**
  * Overwrite header values given name
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	set(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		this[MAP][key !== undefined ? key : name] = [value];
	}

	/**
  * Append a value onto existing header
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	append(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			this[MAP][key].push(value);
		} else {
			this[MAP][name] = [value];
		}
	}

	/**
  * Check for header name existence
  *
  * @param   String   name  Header name
  * @return  Boolean
  */
	has(name) {
		name = `${name}`;
		validateName(name);
		return find(this[MAP], name) !== undefined;
	}

	/**
  * Delete all header values given name
  *
  * @param   String  name  Header name
  * @return  Void
  */
	delete(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			delete this[MAP][key];
		}
	}

	/**
  * Return raw headers (non-spec api)
  *
  * @return  Object
  */
	raw() {
		return this[MAP];
	}

	/**
  * Get an iterator on keys.
  *
  * @return  Iterator
  */
	keys() {
		return createHeadersIterator(this, 'key');
	}

	/**
  * Get an iterator on values.
  *
  * @return  Iterator
  */
	values() {
		return createHeadersIterator(this, 'value');
	}

	/**
  * Get an iterator on entries.
  *
  * This is the default iterator of the Headers object.
  *
  * @return  Iterator
  */
	[Symbol.iterator]() {
		return createHeadersIterator(this, 'key+value');
	}
}
Headers.prototype.entries = Headers.prototype[Symbol.iterator];

Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
	value: 'Headers',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Headers.prototype, {
	get: { enumerable: true },
	forEach: { enumerable: true },
	set: { enumerable: true },
	append: { enumerable: true },
	has: { enumerable: true },
	delete: { enumerable: true },
	keys: { enumerable: true },
	values: { enumerable: true },
	entries: { enumerable: true }
});

function getHeaders(headers) {
	let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';

	const keys = Object.keys(headers[MAP]).sort();
	return keys.map(kind === 'key' ? function (k) {
		return k.toLowerCase();
	} : kind === 'value' ? function (k) {
		return headers[MAP][k].join(', ');
	} : function (k) {
		return [k.toLowerCase(), headers[MAP][k].join(', ')];
	});
}

const INTERNAL = Symbol('internal');

function createHeadersIterator(target, kind) {
	const iterator = Object.create(HeadersIteratorPrototype);
	iterator[INTERNAL] = {
		target,
		kind,
		index: 0
	};
	return iterator;
}

const HeadersIteratorPrototype = Object.setPrototypeOf({
	next() {
		// istanbul ignore if
		if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
			throw new TypeError('Value of `this` is not a HeadersIterator');
		}

		var _INTERNAL = this[INTERNAL];
		const target = _INTERNAL.target,
		      kind = _INTERNAL.kind,
		      index = _INTERNAL.index;

		const values = getHeaders(target, kind);
		const len = values.length;
		if (index >= len) {
			return {
				value: undefined,
				done: true
			};
		}

		this[INTERNAL].index = index + 1;

		return {
			value: values[index],
			done: false
		};
	}
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));

Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
	value: 'HeadersIterator',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * Export the Headers object in a form that Node.js can consume.
 *
 * @param   Headers  headers
 * @return  Object
 */
function exportNodeCompatibleHeaders(headers) {
	const obj = Object.assign({ __proto__: null }, headers[MAP]);

	// http.request() only supports string as Host header. This hack makes
	// specifying custom Host header possible.
	const hostHeaderKey = find(headers[MAP], 'Host');
	if (hostHeaderKey !== undefined) {
		obj[hostHeaderKey] = obj[hostHeaderKey][0];
	}

	return obj;
}

/**
 * Create a Headers object from an object of headers, ignoring those that do
 * not conform to HTTP grammar productions.
 *
 * @param   Object  obj  Object of headers
 * @return  Headers
 */
function createHeadersLenient(obj) {
	const headers = new Headers();
	for (const name of Object.keys(obj)) {
		if (invalidTokenRegex.test(name)) {
			continue;
		}
		if (Array.isArray(obj[name])) {
			for (const val of obj[name]) {
				if (invalidHeaderCharRegex.test(val)) {
					continue;
				}
				if (headers[MAP][name] === undefined) {
					headers[MAP][name] = [val];
				} else {
					headers[MAP][name].push(val);
				}
			}
		} else if (!invalidHeaderCharRegex.test(obj[name])) {
			headers[MAP][name] = [obj[name]];
		}
	}
	return headers;
}

const INTERNALS$1 = Symbol('Response internals');

// fix an issue where "STATUS_CODES" aren't a named export for node <10
const STATUS_CODES = http.STATUS_CODES;

/**
 * Response class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
class Response {
	constructor() {
		let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
		let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		Body.call(this, body, opts);

		const status = opts.status || 200;
		const headers = new Headers(opts.headers);

		if (body != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(body);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		this[INTERNALS$1] = {
			url: opts.url,
			status,
			statusText: opts.statusText || STATUS_CODES[status],
			headers,
			counter: opts.counter
		};
	}

	get url() {
		return this[INTERNALS$1].url || '';
	}

	get status() {
		return this[INTERNALS$1].status;
	}

	/**
  * Convenience property representing if the request ended normally
  */
	get ok() {
		return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
	}

	get redirected() {
		return this[INTERNALS$1].counter > 0;
	}

	get statusText() {
		return this[INTERNALS$1].statusText;
	}

	get headers() {
		return this[INTERNALS$1].headers;
	}

	/**
  * Clone this response
  *
  * @return  Response
  */
	clone() {
		return new Response(clone(this), {
			url: this.url,
			status: this.status,
			statusText: this.statusText,
			headers: this.headers,
			ok: this.ok,
			redirected: this.redirected
		});
	}
}

Body.mixIn(Response.prototype);

Object.defineProperties(Response.prototype, {
	url: { enumerable: true },
	status: { enumerable: true },
	ok: { enumerable: true },
	redirected: { enumerable: true },
	statusText: { enumerable: true },
	headers: { enumerable: true },
	clone: { enumerable: true }
});

Object.defineProperty(Response.prototype, Symbol.toStringTag, {
	value: 'Response',
	writable: false,
	enumerable: false,
	configurable: true
});

const INTERNALS$2 = Symbol('Request internals');

// fix an issue where "format", "parse" aren't a named export for node <10
const parse_url = Url.parse;
const format_url = Url.format;

const streamDestructionSupported = 'destroy' in Stream.Readable.prototype;

/**
 * Check if a value is an instance of Request.
 *
 * @param   Mixed   input
 * @return  Boolean
 */
function isRequest(input) {
	return typeof input === 'object' && typeof input[INTERNALS$2] === 'object';
}

function isAbortSignal(signal) {
	const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);
	return !!(proto && proto.constructor.name === 'AbortSignal');
}

/**
 * Request class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */
class Request {
	constructor(input) {
		let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		let parsedURL;

		// normalize input
		if (!isRequest(input)) {
			if (input && input.href) {
				// in order to support Node.js' Url objects; though WHATWG's URL objects
				// will fall into this branch also (since their `toString()` will return
				// `href` property anyway)
				parsedURL = parse_url(input.href);
			} else {
				// coerce input to a string before attempting to parse
				parsedURL = parse_url(`${input}`);
			}
			input = {};
		} else {
			parsedURL = parse_url(input.url);
		}

		let method = init.method || input.method || 'GET';
		method = method.toUpperCase();

		if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
			throw new TypeError('Request with GET/HEAD method cannot have body');
		}

		let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;

		Body.call(this, inputBody, {
			timeout: init.timeout || input.timeout || 0,
			size: init.size || input.size || 0
		});

		const headers = new Headers(init.headers || input.headers || {});

		if (inputBody != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(inputBody);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		let signal = isRequest(input) ? input.signal : null;
		if ('signal' in init) signal = init.signal;

		if (signal != null && !isAbortSignal(signal)) {
			throw new TypeError('Expected signal to be an instanceof AbortSignal');
		}

		this[INTERNALS$2] = {
			method,
			redirect: init.redirect || input.redirect || 'follow',
			headers,
			parsedURL,
			signal
		};

		// node-fetch-only options
		this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
		this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
		this.counter = init.counter || input.counter || 0;
		this.agent = init.agent || input.agent;
	}

	get method() {
		return this[INTERNALS$2].method;
	}

	get url() {
		return format_url(this[INTERNALS$2].parsedURL);
	}

	get headers() {
		return this[INTERNALS$2].headers;
	}

	get redirect() {
		return this[INTERNALS$2].redirect;
	}

	get signal() {
		return this[INTERNALS$2].signal;
	}

	/**
  * Clone this request
  *
  * @return  Request
  */
	clone() {
		return new Request(this);
	}
}

Body.mixIn(Request.prototype);

Object.defineProperty(Request.prototype, Symbol.toStringTag, {
	value: 'Request',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Request.prototype, {
	method: { enumerable: true },
	url: { enumerable: true },
	headers: { enumerable: true },
	redirect: { enumerable: true },
	clone: { enumerable: true },
	signal: { enumerable: true }
});

/**
 * Convert a Request to Node.js http request options.
 *
 * @param   Request  A Request instance
 * @return  Object   The options object to be passed to http.request
 */
function getNodeRequestOptions(request) {
	const parsedURL = request[INTERNALS$2].parsedURL;
	const headers = new Headers(request[INTERNALS$2].headers);

	// fetch step 1.3
	if (!headers.has('Accept')) {
		headers.set('Accept', '*/*');
	}

	// Basic fetch
	if (!parsedURL.protocol || !parsedURL.hostname) {
		throw new TypeError('Only absolute URLs are supported');
	}

	if (!/^https?:$/.test(parsedURL.protocol)) {
		throw new TypeError('Only HTTP(S) protocols are supported');
	}

	if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
		throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
	}

	// HTTP-network-or-cache fetch steps 2.4-2.7
	let contentLengthValue = null;
	if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
		contentLengthValue = '0';
	}
	if (request.body != null) {
		const totalBytes = getTotalBytes(request);
		if (typeof totalBytes === 'number') {
			contentLengthValue = String(totalBytes);
		}
	}
	if (contentLengthValue) {
		headers.set('Content-Length', contentLengthValue);
	}

	// HTTP-network-or-cache fetch step 2.11
	if (!headers.has('User-Agent')) {
		headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
	}

	// HTTP-network-or-cache fetch step 2.15
	if (request.compress && !headers.has('Accept-Encoding')) {
		headers.set('Accept-Encoding', 'gzip,deflate');
	}

	let agent = request.agent;
	if (typeof agent === 'function') {
		agent = agent(parsedURL);
	}

	if (!headers.has('Connection') && !agent) {
		headers.set('Connection', 'close');
	}

	// HTTP-network fetch step 4.2
	// chunked encoding is handled by Node.js

	return Object.assign({}, parsedURL, {
		method: request.method,
		headers: exportNodeCompatibleHeaders(headers),
		agent
	});
}

/**
 * abort-error.js
 *
 * AbortError interface for cancelled requests
 */

/**
 * Create AbortError instance
 *
 * @param   String      message      Error message for human
 * @return  AbortError
 */
function AbortError(message) {
  Error.call(this, message);

  this.type = 'aborted';
  this.message = message;

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

AbortError.prototype = Object.create(Error.prototype);
AbortError.prototype.constructor = AbortError;
AbortError.prototype.name = 'AbortError';

// fix an issue where "PassThrough", "resolve" aren't a named export for node <10
const PassThrough$1 = Stream.PassThrough;
const resolve_url = Url.resolve;

/**
 * Fetch function
 *
 * @param   Mixed    url   Absolute url or Request instance
 * @param   Object   opts  Fetch options
 * @return  Promise
 */
function fetch(url, opts) {

	// allow custom promise
	if (!fetch.Promise) {
		throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
	}

	Body.Promise = fetch.Promise;

	// wrap http.request into fetch
	return new fetch.Promise(function (resolve, reject) {
		// build request object
		const request = new Request(url, opts);
		const options = getNodeRequestOptions(request);

		const send = (options.protocol === 'https:' ? https : http).request;
		const signal = request.signal;

		let response = null;

		const abort = function abort() {
			let error = new AbortError('The user aborted a request.');
			reject(error);
			if (request.body && request.body instanceof Stream.Readable) {
				request.body.destroy(error);
			}
			if (!response || !response.body) return;
			response.body.emit('error', error);
		};

		if (signal && signal.aborted) {
			abort();
			return;
		}

		const abortAndFinalize = function abortAndFinalize() {
			abort();
			finalize();
		};

		// send request
		const req = send(options);
		let reqTimeout;

		if (signal) {
			signal.addEventListener('abort', abortAndFinalize);
		}

		function finalize() {
			req.abort();
			if (signal) signal.removeEventListener('abort', abortAndFinalize);
			clearTimeout(reqTimeout);
		}

		if (request.timeout) {
			req.once('socket', function (socket) {
				reqTimeout = setTimeout(function () {
					reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
					finalize();
				}, request.timeout);
			});
		}

		req.on('error', function (err) {
			reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
			finalize();
		});

		req.on('response', function (res) {
			clearTimeout(reqTimeout);

			const headers = createHeadersLenient(res.headers);

			// HTTP fetch step 5
			if (fetch.isRedirect(res.statusCode)) {
				// HTTP fetch step 5.2
				const location = headers.get('Location');

				// HTTP fetch step 5.3
				const locationURL = location === null ? null : resolve_url(request.url, location);

				// HTTP fetch step 5.5
				switch (request.redirect) {
					case 'error':
						reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
						finalize();
						return;
					case 'manual':
						// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
						if (locationURL !== null) {
							// handle corrupted header
							try {
								headers.set('Location', locationURL);
							} catch (err) {
								// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
								reject(err);
							}
						}
						break;
					case 'follow':
						// HTTP-redirect fetch step 2
						if (locationURL === null) {
							break;
						}

						// HTTP-redirect fetch step 5
						if (request.counter >= request.follow) {
							reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 6 (counter increment)
						// Create a new Request object.
						const requestOpts = {
							headers: new Headers(request.headers),
							follow: request.follow,
							counter: request.counter + 1,
							agent: request.agent,
							compress: request.compress,
							method: request.method,
							body: request.body,
							signal: request.signal,
							timeout: request.timeout,
							size: request.size
						};

						// HTTP-redirect fetch step 9
						if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
							reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 11
						if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
							requestOpts.method = 'GET';
							requestOpts.body = undefined;
							requestOpts.headers.delete('content-length');
						}

						// HTTP-redirect fetch step 15
						resolve(fetch(new Request(locationURL, requestOpts)));
						finalize();
						return;
				}
			}

			// prepare response
			res.once('end', function () {
				if (signal) signal.removeEventListener('abort', abortAndFinalize);
			});
			let body = res.pipe(new PassThrough$1());

			const response_options = {
				url: request.url,
				status: res.statusCode,
				statusText: res.statusMessage,
				headers: headers,
				size: request.size,
				timeout: request.timeout,
				counter: request.counter
			};

			// HTTP-network fetch step 12.1.1.3
			const codings = headers.get('Content-Encoding');

			// HTTP-network fetch step 12.1.1.4: handle content codings

			// in following scenarios we ignore compression support
			// 1. compression support is disabled
			// 2. HEAD request
			// 3. no Content-Encoding header
			// 4. no content response (204)
			// 5. content not modified response (304)
			if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// For Node v6+
			// Be less strict when decoding compressed responses, since sometimes
			// servers send slightly invalid responses that are still accepted
			// by common browsers.
			// Always using Z_SYNC_FLUSH is what cURL does.
			const zlibOptions = {
				flush: zlib.Z_SYNC_FLUSH,
				finishFlush: zlib.Z_SYNC_FLUSH
			};

			// for gzip
			if (codings == 'gzip' || codings == 'x-gzip') {
				body = body.pipe(zlib.createGunzip(zlibOptions));
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// for deflate
			if (codings == 'deflate' || codings == 'x-deflate') {
				// handle the infamous raw deflate response from old servers
				// a hack for old IIS and Apache servers
				const raw = res.pipe(new PassThrough$1());
				raw.once('data', function (chunk) {
					// see http://stackoverflow.com/questions/37519828
					if ((chunk[0] & 0x0F) === 0x08) {
						body = body.pipe(zlib.createInflate());
					} else {
						body = body.pipe(zlib.createInflateRaw());
					}
					response = new Response(body, response_options);
					resolve(response);
				});
				return;
			}

			// for br
			if (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {
				body = body.pipe(zlib.createBrotliDecompress());
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// otherwise, use response as-is
			response = new Response(body, response_options);
			resolve(response);
		});

		writeToStream(req, request);
	});
}
/**
 * Redirect code matching
 *
 * @param   Number   code  Status code
 * @return  Boolean
 */
fetch.isRedirect = function (code) {
	return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
};

// expose Promise
fetch.Promise = global.Promise;

module.exports = exports = fetch;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.default = exports;
exports.Headers = Headers;
exports.Request = Request;
exports.Response = Response;
exports.FetchError = FetchError;


/***/ }),

/***/ 61118:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var async = __webpack_require__(27732);
async.core = __webpack_require__(51043);
async.isCore = __webpack_require__(29728);
async.sync = __webpack_require__(6430);

module.exports = async;


/***/ }),

/***/ 27732:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(35747);
var path = __webpack_require__(85622);
var caller = __webpack_require__(13408);
var nodeModulesPaths = __webpack_require__(86426);
var normalizeOptions = __webpack_require__(93048);
var isCore = __webpack_require__(29728);

var realpathFS = fs.realpath && typeof fs.realpath.native === 'function' ? fs.realpath.native : fs.realpath;

var defaultIsFile = function isFile(file, cb) {
    fs.stat(file, function (err, stat) {
        if (!err) {
            return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};

var defaultIsDir = function isDirectory(dir, cb) {
    fs.stat(dir, function (err, stat) {
        if (!err) {
            return cb(null, stat.isDirectory());
        }
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};

var defaultRealpath = function realpath(x, cb) {
    realpathFS(x, function (realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== 'ENOENT') cb(realpathErr);
        else cb(null, realpathErr ? x : realPath);
    });
};

var maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
    } else {
        cb(null, x);
    }
};

var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
};

module.exports = function resolve(x, options, callback) {
    var cb = callback;
    var opts = options;
    if (typeof options === 'function') {
        cb = opts;
        opts = {};
    }
    if (typeof x !== 'string') {
        var err = new TypeError('Path must be a string.');
        return process.nextTick(function () {
            cb(err);
        });
    }

    opts = normalizeOptions(x, opts);

    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile = opts.readFile || fs.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var packageIterator = opts.packageIterator;

    var extensions = opts.extensions || ['.js'];
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || [];

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = path.resolve(basedir);

    maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function (err, realStart) {
            if (err) cb(err);
            else init(realStart);
        }
    );

    var res;
    function init(basedir) {
        if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
            res = path.resolve(basedir, x);
            if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
            if ((/\/$/).test(x) && res === basedir) {
                loadAsDirectory(res, opts.package, onfile);
            } else loadAsFile(res, opts.package, onfile);
        } else if (isCore(x)) {
            return cb(null, x);
        } else loadNodeModules(x, basedir, function (err, n, pkg) {
            if (err) cb(err);
            else if (n) {
                return maybeRealpath(realpath, n, opts, function (err, realN) {
                    if (err) {
                        cb(err);
                    } else {
                        cb(null, realN, pkg);
                    }
                });
            } else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
            }
        });
    }

    function onfile(err, m, pkg) {
        if (err) cb(err);
        else if (m) cb(null, m, pkg);
        else loadAsDirectory(res, function (err, d, pkg) {
            if (err) cb(err);
            else if (d) {
                maybeRealpath(realpath, d, opts, function (err, realD) {
                    if (err) {
                        cb(err);
                    } else {
                        cb(null, realD, pkg);
                    }
                });
            } else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
            }
        });
    }

    function loadAsFile(x, thePackage, callback) {
        var loadAsFilePackage = thePackage;
        var cb = callback;
        if (typeof loadAsFilePackage === 'function') {
            cb = loadAsFilePackage;
            loadAsFilePackage = undefined;
        }

        var exts = [''].concat(extensions);
        load(exts, x, loadAsFilePackage);

        function load(exts, x, loadPackage) {
            if (exts.length === 0) return cb(null, undefined, loadPackage);
            var file = x + exts[0];

            var pkg = loadPackage;
            if (pkg) onpkg(null, pkg);
            else loadpkg(path.dirname(file), onpkg);

            function onpkg(err, pkg_, dir) {
                pkg = pkg_;
                if (err) return cb(err);
                if (dir && pkg && opts.pathFilter) {
                    var rfile = path.relative(dir, file);
                    var rel = rfile.slice(0, rfile.length - exts[0].length);
                    var r = opts.pathFilter(pkg, x, rel);
                    if (r) return load(
                        [''].concat(extensions.slice()),
                        path.resolve(dir, r),
                        pkg
                    );
                }
                isFile(file, onex);
            }
            function onex(err, ex) {
                if (err) return cb(err);
                if (ex) return cb(null, file, pkg);
                load(exts.slice(1), x, pkg);
            }
        }
    }

    function loadpkg(dir, cb) {
        if (dir === '' || dir === '/') return cb(null);
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
            return cb(null);
        }
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return cb(null);

        maybeRealpath(realpath, dir, opts, function (unwrapErr, pkgdir) {
            if (unwrapErr) return loadpkg(path.dirname(dir), cb);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) {
                // on err, ex is false
                if (!ex) return loadpkg(path.dirname(dir), cb);

                readFile(pkgfile, function (err, body) {
                    if (err) cb(err);
                    try { var pkg = JSON.parse(body); } catch (jsonErr) {}

                    if (pkg && opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }
                    cb(null, pkg, dir);
                });
            });
        });
    }

    function loadAsDirectory(x, loadAsDirectoryPackage, callback) {
        var cb = callback;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === 'function') {
            cb = fpkg;
            fpkg = opts.package;
        }

        maybeRealpath(realpath, x, opts, function (unwrapErr, pkgdir) {
            if (unwrapErr) return cb(unwrapErr);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) {
                if (err) return cb(err);
                if (!ex) return loadAsFile(path.join(x, 'index'), fpkg, cb);

                readFile(pkgfile, function (err, body) {
                    if (err) return cb(err);
                    try {
                        var pkg = JSON.parse(body);
                    } catch (jsonErr) {}

                    if (pkg && opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }

                    if (pkg && pkg.main) {
                        if (typeof pkg.main !== 'string') {
                            var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');
                            mainError.code = 'INVALID_PACKAGE_MAIN';
                            return cb(mainError);
                        }
                        if (pkg.main === '.' || pkg.main === './') {
                            pkg.main = 'index';
                        }
                        loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {
                            if (err) return cb(err);
                            if (m) return cb(null, m, pkg);
                            if (!pkg) return loadAsFile(path.join(x, 'index'), pkg, cb);

                            var dir = path.resolve(x, pkg.main);
                            loadAsDirectory(dir, pkg, function (err, n, pkg) {
                                if (err) return cb(err);
                                if (n) return cb(null, n, pkg);
                                loadAsFile(path.join(x, 'index'), pkg, cb);
                            });
                        });
                        return;
                    }

                    loadAsFile(path.join(x, '/index'), pkg, cb);
                });
            });
        });
    }

    function processDirs(cb, dirs) {
        if (dirs.length === 0) return cb(null, undefined);
        var dir = dirs[0];

        isDirectory(path.dirname(dir), isdir);

        function isdir(err, isdir) {
            if (err) return cb(err);
            if (!isdir) return processDirs(cb, dirs.slice(1));
            loadAsFile(dir, opts.package, onfile);
        }

        function onfile(err, m, pkg) {
            if (err) return cb(err);
            if (m) return cb(null, m, pkg);
            loadAsDirectory(dir, opts.package, ondir);
        }

        function ondir(err, n, pkg) {
            if (err) return cb(err);
            if (n) return cb(null, n, pkg);
            processDirs(cb, dirs.slice(1));
        }
    }
    function loadNodeModules(x, start, cb) {
        var thunk = function () { return getPackageCandidates(x, start, opts); };
        processDirs(
            cb,
            packageIterator ? packageIterator(x, start, thunk, opts) : thunk()
        );
    }
};


/***/ }),

/***/ 13408:
/***/ ((module) => {

module.exports = function () {
    // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function (_, stack) { return stack; };
    var stack = (new Error()).stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
};


/***/ }),

/***/ 51043:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var current = (process.versions && process.versions.node && process.versions.node.split('.')) || [];

function specifierIncluded(specifier) {
    var parts = specifier.split(' ');
    var op = parts.length > 1 ? parts[0] : '=';
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');

    for (var i = 0; i < 3; ++i) {
        var cur = Number(current[i] || 0);
        var ver = Number(versionParts[i] || 0);
        if (cur === ver) {
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        }
        if (op === '<') {
            return cur < ver;
        } else if (op === '>=') {
            return cur >= ver;
        } else {
            return false;
        }
    }
    return op === '>=';
}

function matchesRange(range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) { return false; }
    for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(specifiers[i])) { return false; }
    }
    return true;
}

function versionIncluded(specifierValue) {
    if (typeof specifierValue === 'boolean') { return specifierValue; }
    if (specifierValue && typeof specifierValue === 'object') {
        for (var i = 0; i < specifierValue.length; ++i) {
            if (matchesRange(specifierValue[i])) { return true; }
        }
        return false;
    }
    return matchesRange(specifierValue);
}

var data = __webpack_require__(73394);

var core = {};
for (var mod in data) { // eslint-disable-line no-restricted-syntax
    if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core[mod] = versionIncluded(data[mod]);
    }
}
module.exports = core;


/***/ }),

/***/ 29728:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var core = __webpack_require__(51043);

module.exports = function isCore(x) {
    return Object.prototype.hasOwnProperty.call(core, x);
};


/***/ }),

/***/ 86426:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var path = __webpack_require__(85622);
var parse = path.parse || __webpack_require__(5980);

var getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {
    var prefix = '/';
    if ((/^([A-Za-z]:)/).test(absoluteStart)) {
        prefix = '';
    } else if ((/^\\\\/).test(absoluteStart)) {
        prefix = '\\\\';
    }

    var paths = [absoluteStart];
    var parsed = parse(absoluteStart);
    while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
    }

    return paths.reduce(function (dirs, aPath) {
        return dirs.concat(modules.map(function (moduleDir) {
            return path.resolve(prefix, aPath, moduleDir);
        }));
    }, []);
};

module.exports = function nodeModulesPaths(start, opts, request) {
    var modules = opts && opts.moduleDirectory
        ? [].concat(opts.moduleDirectory)
        : ['node_modules'];

    if (opts && typeof opts.paths === 'function') {
        return opts.paths(
            request,
            start,
            function () { return getNodeModulesDirs(start, modules); },
            opts
        );
    }

    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
};


/***/ }),

/***/ 93048:
/***/ ((module) => {

module.exports = function (x, opts) {
    /**
     * This file is purposefully a passthrough. It's expected that third-party
     * environments will override it at runtime in order to inject special logic
     * into `resolve` (by manipulating the options). One such example is the PnP
     * code path in Yarn.
     */

    return opts || {};
};


/***/ }),

/***/ 6430:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCore = __webpack_require__(29728);
var fs = __webpack_require__(35747);
var path = __webpack_require__(85622);
var caller = __webpack_require__(13408);
var nodeModulesPaths = __webpack_require__(86426);
var normalizeOptions = __webpack_require__(93048);

var realpathFS = fs.realpathSync && typeof fs.realpathSync.native === 'function' ? fs.realpathSync.native : fs.realpathSync;

var defaultIsFile = function isFile(file) {
    try {
        var stat = fs.statSync(file);
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return stat.isFile() || stat.isFIFO();
};

var defaultIsDir = function isDirectory(dir) {
    try {
        var stat = fs.statSync(dir);
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return stat.isDirectory();
};

var defaultRealpathSync = function realpathSync(x) {
    try {
        return realpathFS(x);
    } catch (realpathErr) {
        if (realpathErr.code !== 'ENOENT') {
            throw realpathErr;
        }
    }
    return x;
};

var maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {
    if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
    }
    return x;
};

var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
};

module.exports = function resolveSync(x, options) {
    if (typeof x !== 'string') {
        throw new TypeError('Path must be a string.');
    }
    var opts = normalizeOptions(x, options);

    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var packageIterator = opts.packageIterator;

    var extensions = opts.extensions || ['.js'];
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || [];

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);

    if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
        var res = path.resolve(absoluteStart, x);
        if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m) return maybeRealpathSync(realpathSync, m, opts);
    } else if (isCore(x)) {
        return x;
    } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n) return maybeRealpathSync(realpathSync, n, opts);
    }

    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;

    function loadAsFileSync(x) {
        var pkg = loadpkg(path.dirname(x));

        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
            var rfile = path.relative(pkg.dir, x);
            var r = opts.pathFilter(pkg.pkg, x, rfile);
            if (r) {
                x = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign
            }
        }

        if (isFile(x)) {
            return x;
        }

        for (var i = 0; i < extensions.length; i++) {
            var file = x + extensions[i];
            if (isFile(file)) {
                return file;
            }
        }
    }

    function loadpkg(dir) {
        if (dir === '' || dir === '/') return;
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
            return;
        }
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return;

        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), 'package.json');

        if (!isFile(pkgfile)) {
            return loadpkg(path.dirname(dir));
        }

        var body = readFileSync(pkgfile);

        try {
            var pkg = JSON.parse(body);
        } catch (jsonErr) {}

        if (pkg && opts.packageFilter) {
            // v2 will pass pkgfile
            pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment
        }

        return { pkg: pkg, dir: dir };
    }

    function loadAsDirectorySync(x) {
        var pkgfile = path.join(maybeRealpathSync(realpathSync, x, opts), '/package.json');
        if (isFile(pkgfile)) {
            try {
                var body = readFileSync(pkgfile, 'UTF8');
                var pkg = JSON.parse(body);
            } catch (e) {}

            if (pkg && opts.packageFilter) {
                // v2 will pass pkgfile
                pkg = opts.packageFilter(pkg, /*pkgfile,*/ x); // eslint-disable-line spaced-comment
            }

            if (pkg && pkg.main) {
                if (typeof pkg.main !== 'string') {
                    var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');
                    mainError.code = 'INVALID_PACKAGE_MAIN';
                    throw mainError;
                }
                if (pkg.main === '.' || pkg.main === './') {
                    pkg.main = 'index';
                }
                try {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                    var n = loadAsDirectorySync(path.resolve(x, pkg.main));
                    if (n) return n;
                } catch (e) {}
            }
        }

        return loadAsFileSync(path.join(x, '/index'));
    }

    function loadNodeModulesSync(x, start) {
        var thunk = function () { return getPackageCandidates(x, start, opts); };
        var dirs = packageIterator ? packageIterator(x, start, thunk, opts) : thunk();

        for (var i = 0; i < dirs.length; i++) {
            var dir = dirs[i];
            if (isDirectory(path.dirname(dir))) {
                var m = loadAsFileSync(dir);
                if (m) return m;
                var n = loadAsDirectorySync(dir);
                if (n) return n;
            }
        }
    }
};


/***/ }),

/***/ 40334:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

async function auth(token) {
  const tokenType = token.split(/\./).length === 3 ? "app" : /^v\d+\./.test(token) ? "installation" : "oauth";
  return {
    type: "token",
    token: token,
    tokenType
  };
}

/**
 * Prefix token for usage in the Authorization header
 *
 * @param token OAuth token or JSON Web Token
 */
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }

  return `token ${token}`;
}

async function hook(token, request, route, parameters) {
  const endpoint = request.endpoint.merge(route, parameters);
  endpoint.headers.authorization = withAuthorizationPrefix(token);
  return request(endpoint);
}

const createTokenAuth = function createTokenAuth(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }

  if (typeof token !== "string") {
    throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
  }

  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

exports.createTokenAuth = createTokenAuth;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 76762:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var universalUserAgent = __webpack_require__(45030);
var beforeAfterHook = __webpack_require__(83682);
var request = __webpack_require__(35712);
var graphql = __webpack_require__(88467);
var authToken = __webpack_require__(40334);

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

const VERSION = "3.5.1";

const _excluded = ["authStrategy"];
class Octokit {
  constructor(options = {}) {
    const hook = new beforeAfterHook.Collection();
    const requestDefaults = {
      baseUrl: request.request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        // @ts-ignore internal usage only, no need to type
        hook: hook.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    }; // prepend default user agent with `options.userAgent` if set

    requestDefaults.headers["user-agent"] = [options.userAgent, `octokit-core.js/${VERSION} ${universalUserAgent.getUserAgent()}`].filter(Boolean).join(" ");

    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }

    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }

    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }

    this.request = request.request.defaults(requestDefaults);
    this.graphql = graphql.withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign({
      debug: () => {},
      info: () => {},
      warn: console.warn.bind(console),
      error: console.error.bind(console)
    }, options.log);
    this.hook = hook; // (1) If neither `options.authStrategy` nor `options.auth` are set, the `octokit` instance
    //     is unauthenticated. The `this.auth()` method is a no-op and no request hook is registered.
    // (2) If only `options.auth` is set, use the default token authentication strategy.
    // (3) If `options.authStrategy` is set then use it and pass in `options.auth`. Always pass own request as many strategies accept a custom request instance.
    // TODO: type `options.auth` based on `options.authStrategy`.

    if (!options.authStrategy) {
      if (!options.auth) {
        // (1)
        this.auth = async () => ({
          type: "unauthenticated"
        });
      } else {
        // (2)
        const auth = authToken.createTokenAuth(options.auth); // @ts-ignore  \_()_/

        hook.wrap("request", auth.hook);
        this.auth = auth;
      }
    } else {
      const {
        authStrategy
      } = options,
            otherOptions = _objectWithoutProperties(options, _excluded);

      const auth = authStrategy(Object.assign({
        request: this.request,
        log: this.log,
        // we pass the current octokit instance as well as its constructor options
        // to allow for authentication strategies that return a new octokit instance
        // that shares the same internal state as the current one. The original
        // requirement for this was the "event-octokit" authentication strategy
        // of https://github.com/probot/octokit-auth-probot.
        octokit: this,
        octokitOptions: otherOptions
      }, options.auth)); // @ts-ignore  \_()_/

      hook.wrap("request", auth.hook);
      this.auth = auth;
    } // apply plugins
    // https://stackoverflow.com/a/16345172


    const classConstructor = this.constructor;
    classConstructor.plugins.forEach(plugin => {
      Object.assign(this, plugin(this, options));
    });
  }

  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};

        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }

        super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
          userAgent: `${options.userAgent} ${defaults.userAgent}`
        } : null));
      }

    };
    return OctokitWithDefaults;
  }
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */


  static plugin(...newPlugins) {
    var _a;

    const currentPlugins = this.plugins;
    const NewOctokit = (_a = class extends this {}, _a.plugins = currentPlugins.concat(newPlugins.filter(plugin => !currentPlugins.includes(plugin))), _a);
    return NewOctokit;
  }

}
Octokit.VERSION = VERSION;
Octokit.plugins = [];

exports.Octokit = Octokit;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 59440:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var isPlainObject = __webpack_require__(63287);
var universalUserAgent = __webpack_require__(45030);

function lowercaseKeys(object) {
  if (!object) {
    return {};
  }

  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}

function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach(key => {
    if (isPlainObject.isPlainObject(options[key])) {
      if (!(key in defaults)) Object.assign(result, {
        [key]: options[key]
      });else result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, {
        [key]: options[key]
      });
    }
  });
  return result;
}

function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === undefined) {
      delete obj[key];
    }
  }

  return obj;
}

function merge(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? {
      method,
      url
    } : {
      url: method
    }, options);
  } else {
    options = Object.assign({}, route);
  } // lowercase header names before merging with defaults to avoid duplicates


  options.headers = lowercaseKeys(options.headers); // remove properties with undefined values before merging

  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options); // mediaType.previews arrays are merged, instead of overwritten

  if (defaults && defaults.mediaType.previews.length) {
    mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(preview => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
  }

  mergedOptions.mediaType.previews = mergedOptions.mediaType.previews.map(preview => preview.replace(/-preview/, ""));
  return mergedOptions;
}

function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);

  if (names.length === 0) {
    return url;
  }

  return url + separator + names.map(name => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }

    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}

const urlVariableRegex = /\{[^}]+\}/g;

function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}

function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);

  if (!matches) {
    return [];
  }

  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}

function omit(object, keysToOmit) {
  return Object.keys(object).filter(option => !keysToOmit.includes(option)).reduce((obj, key) => {
    obj[key] = object[key];
    return obj;
  }, {});
}

// Based on https://github.com/bramstein/url-template, licensed under BSD
// TODO: create separate package.
//
// Copyright (c) 2012-2014, Bram Stein
// All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
// EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* istanbul ignore file */
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }

    return part;
  }).join("");
}

function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);

  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}

function isDefined(value) {
  return value !== undefined && value !== null;
}

function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}

function getValues(context, operator, key, modifier) {
  var value = context[key],
      result = [];

  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();

      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }

      result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function (value) {
            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
          });
        } else {
          Object.keys(value).forEach(function (k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];

        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function (value) {
            tmp.push(encodeValue(operator, value));
          });
        } else {
          Object.keys(value).forEach(function (k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }

        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }

  return result;
}

function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}

function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
    if (expression) {
      let operator = "";
      const values = [];

      if (operators.indexOf(expression.charAt(0)) !== -1) {
        operator = expression.charAt(0);
        expression = expression.substr(1);
      }

      expression.split(/,/g).forEach(function (variable) {
        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
        values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
      });

      if (operator && operator !== "+") {
        var separator = ",";

        if (operator === "?") {
          separator = "&";
        } else if (operator !== "#") {
          separator = operator;
        }

        return (values.length !== 0 ? operator : "") + values.join(separator);
      } else {
        return values.join(",");
      }
    } else {
      return encodeReserved(literal);
    }
  });
}

function parse(options) {
  // https://fetch.spec.whatwg.org/#methods
  let method = options.method.toUpperCase(); // replace :varname with {varname} to make it RFC 6570 compatible

  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, ["method", "baseUrl", "url", "headers", "request", "mediaType"]); // extract variable names from URL to calculate remaining variables later

  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);

  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }

  const omittedParameters = Object.keys(options).filter(option => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);

  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      // e.g. application/vnd.github.v3+json => application/vnd.github.v3.raw
      headers.accept = headers.accept.split(/,/).map(preview => preview.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
    }

    if (options.mediaType.previews.length) {
      const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
      headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map(preview => {
        const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
        return `application/vnd.github.${preview}-preview${format}`;
      }).join(",");
    }
  } // for GET/HEAD requests, set URL query parameters from remaining parameters
  // for PATCH/POST/PUT/DELETE requests, set request body from remaining parameters


  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      } else {
        headers["content-length"] = 0;
      }
    }
  } // default content-type for JSON if body is set


  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  } // GitHub expects 'content-length: 0' header for PUT/PATCH requests without body.
  // fetch does not allow to set `content-length` header, but we can set body to an empty string


  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  } // Only return body/request keys if present


  return Object.assign({
    method,
    url,
    headers
  }, typeof body !== "undefined" ? {
    body
  } : null, options.request ? {
    request: options.request
  } : null);
}

function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}

function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS = merge(oldDefaults, newDefaults);
  const endpoint = endpointWithDefaults.bind(null, DEFAULTS);
  return Object.assign(endpoint, {
    DEFAULTS,
    defaults: withDefaults.bind(null, DEFAULTS),
    merge: merge.bind(null, DEFAULTS),
    parse
  });
}

const VERSION = "6.0.12";

const userAgent = `octokit-endpoint.js/${VERSION} ${universalUserAgent.getUserAgent()}`; // DEFAULTS has all properties set that EndpointOptions has, except url.
// So we use RequestParameters and add method as additional required property.

const DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: "",
    previews: []
  }
};

const endpoint = withDefaults(null, DEFAULTS);

exports.endpoint = endpoint;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 88467:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var request = __webpack_require__(35712);
var universalUserAgent = __webpack_require__(45030);

const VERSION = "4.6.4";

class GraphqlError extends Error {
  constructor(request, response) {
    const message = response.data.errors[0].message;
    super(message);
    Object.assign(this, response.data);
    Object.assign(this, {
      headers: response.headers
    });
    this.name = "GraphqlError";
    this.request = request; // Maintains proper stack trace (only available on V8)

    /* istanbul ignore next */

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }

}

const NON_VARIABLE_OPTIONS = ["method", "baseUrl", "url", "headers", "request", "query", "mediaType"];
const FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
const GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
    }

    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;
      return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
    }
  }

  const parsedOptions = typeof query === "string" ? Object.assign({
    query
  }, options) : query;
  const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }

    if (!result.variables) {
      result.variables = {};
    }

    result.variables[key] = parsedOptions[key];
    return result;
  }, {}); // workaround for GitHub Enterprise baseUrl set with /api/v3 suffix
  // https://github.com/octokit/auth-app.js/issues/111#issuecomment-657610451

  const baseUrl = parsedOptions.baseUrl || request.endpoint.DEFAULTS.baseUrl;

  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }

  return request(requestOptions).then(response => {
    if (response.data.errors) {
      const headers = {};

      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }

      throw new GraphqlError(requestOptions, {
        headers,
        data: response.data
      });
    }

    return response.data.data;
  });
}

function withDefaults(request$1, newDefaults) {
  const newRequest = request$1.defaults(newDefaults);

  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };

  return Object.assign(newApi, {
    defaults: withDefaults.bind(null, newRequest),
    endpoint: request.request.endpoint
  });
}

const graphql$1 = withDefaults(request.request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION} ${universalUserAgent.getUserAgent()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

exports.graphql = graphql$1;
exports.withCustomRequest = withCustomRequest;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 64193:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const VERSION = "2.13.5";

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/**
 * Some list response that can be paginated have a different response structure
 *
 * They have a `total_count` key in the response (search also has `incomplete_results`,
 * /installation/repositories also has `repository_selection`), as well as a key with
 * the list of the items which name varies from endpoint to endpoint.
 *
 * Octokit normalizes these responses so that paginated results are always returned following
 * the same structure. One challenge is that if the list response has only one page, no Link
 * header is provided, so this header alone is not sufficient to check wether a response is
 * paginated or not.
 *
 * We check if a "total_count" key is present in the response data, but also make sure that
 * a "url" property is not, as the "Get the combined status for a specific ref" endpoint would
 * otherwise match: https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-ref
 */
function normalizePaginatedListResponse(response) {
  // endpoints can respond with 204 if repository is empty
  if (!response.data) {
    return _objectSpread2(_objectSpread2({}, response), {}, {
      data: []
    });
  }

  const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
  if (!responseNeedsNormalization) return response; // keep the additional properties intact as there is currently no other way
  // to retrieve the same information.

  const incompleteResults = response.data.incomplete_results;
  const repositorySelection = response.data.repository_selection;
  const totalCount = response.data.total_count;
  delete response.data.incomplete_results;
  delete response.data.repository_selection;
  delete response.data.total_count;
  const namespaceKey = Object.keys(response.data)[0];
  const data = response.data[namespaceKey];
  response.data = data;

  if (typeof incompleteResults !== "undefined") {
    response.data.incomplete_results = incompleteResults;
  }

  if (typeof repositorySelection !== "undefined") {
    response.data.repository_selection = repositorySelection;
  }

  response.data.total_count = totalCount;
  return response;
}

function iterator(octokit, route, parameters) {
  const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
  const requestMethod = typeof route === "function" ? route : octokit.request;
  const method = options.method;
  const headers = options.headers;
  let url = options.url;
  return {
    [Symbol.asyncIterator]: () => ({
      async next() {
        if (!url) return {
          done: true
        };

        try {
          const response = await requestMethod({
            method,
            url,
            headers
          });
          const normalizedResponse = normalizePaginatedListResponse(response); // `response.headers.link` format:
          // '<https://api.github.com/users/aseemk/followers?page=2>; rel="next", <https://api.github.com/users/aseemk/followers?page=2>; rel="last"'
          // sets `url` to undefined if "next" URL is not present or `link` header is not set

          url = ((normalizedResponse.headers.link || "").match(/<([^>]+)>;\s*rel="next"/) || [])[1];
          return {
            value: normalizedResponse
          };
        } catch (error) {
          if (error.status !== 409) throw error;
          url = "";
          return {
            value: {
              status: 200,
              headers: {},
              data: []
            }
          };
        }
      }

    })
  };
}

function paginate(octokit, route, parameters, mapFn) {
  if (typeof parameters === "function") {
    mapFn = parameters;
    parameters = undefined;
  }

  return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
}

function gather(octokit, results, iterator, mapFn) {
  return iterator.next().then(result => {
    if (result.done) {
      return results;
    }

    let earlyExit = false;

    function done() {
      earlyExit = true;
    }

    results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);

    if (earlyExit) {
      return results;
    }

    return gather(octokit, results, iterator, mapFn);
  });
}

const composePaginateRest = Object.assign(paginate, {
  iterator
});

const paginatingEndpoints = ["GET /app/installations", "GET /applications/grants", "GET /authorizations", "GET /enterprises/{enterprise}/actions/permissions/organizations", "GET /enterprises/{enterprise}/actions/runner-groups", "GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations", "GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners", "GET /enterprises/{enterprise}/actions/runners", "GET /enterprises/{enterprise}/actions/runners/downloads", "GET /events", "GET /gists", "GET /gists/public", "GET /gists/starred", "GET /gists/{gist_id}/comments", "GET /gists/{gist_id}/commits", "GET /gists/{gist_id}/forks", "GET /installation/repositories", "GET /issues", "GET /marketplace_listing/plans", "GET /marketplace_listing/plans/{plan_id}/accounts", "GET /marketplace_listing/stubbed/plans", "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts", "GET /networks/{owner}/{repo}/events", "GET /notifications", "GET /organizations", "GET /orgs/{org}/actions/permissions/repositories", "GET /orgs/{org}/actions/runner-groups", "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories", "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners", "GET /orgs/{org}/actions/runners", "GET /orgs/{org}/actions/runners/downloads", "GET /orgs/{org}/actions/secrets", "GET /orgs/{org}/actions/secrets/{secret_name}/repositories", "GET /orgs/{org}/blocks", "GET /orgs/{org}/credential-authorizations", "GET /orgs/{org}/events", "GET /orgs/{org}/failed_invitations", "GET /orgs/{org}/hooks", "GET /orgs/{org}/installations", "GET /orgs/{org}/invitations", "GET /orgs/{org}/invitations/{invitation_id}/teams", "GET /orgs/{org}/issues", "GET /orgs/{org}/members", "GET /orgs/{org}/migrations", "GET /orgs/{org}/migrations/{migration_id}/repositories", "GET /orgs/{org}/outside_collaborators", "GET /orgs/{org}/projects", "GET /orgs/{org}/public_members", "GET /orgs/{org}/repos", "GET /orgs/{org}/team-sync/groups", "GET /orgs/{org}/teams", "GET /orgs/{org}/teams/{team_slug}/discussions", "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments", "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions", "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions", "GET /orgs/{org}/teams/{team_slug}/invitations", "GET /orgs/{org}/teams/{team_slug}/members", "GET /orgs/{org}/teams/{team_slug}/projects", "GET /orgs/{org}/teams/{team_slug}/repos", "GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings", "GET /orgs/{org}/teams/{team_slug}/teams", "GET /projects/columns/{column_id}/cards", "GET /projects/{project_id}/collaborators", "GET /projects/{project_id}/columns", "GET /repos/{owner}/{repo}/actions/artifacts", "GET /repos/{owner}/{repo}/actions/runners", "GET /repos/{owner}/{repo}/actions/runners/downloads", "GET /repos/{owner}/{repo}/actions/runs", "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts", "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs", "GET /repos/{owner}/{repo}/actions/secrets", "GET /repos/{owner}/{repo}/actions/workflows", "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs", "GET /repos/{owner}/{repo}/assignees", "GET /repos/{owner}/{repo}/branches", "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations", "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs", "GET /repos/{owner}/{repo}/code-scanning/alerts", "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances", "GET /repos/{owner}/{repo}/code-scanning/analyses", "GET /repos/{owner}/{repo}/collaborators", "GET /repos/{owner}/{repo}/comments", "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions", "GET /repos/{owner}/{repo}/commits", "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head", "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments", "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls", "GET /repos/{owner}/{repo}/commits/{ref}/check-runs", "GET /repos/{owner}/{repo}/commits/{ref}/check-suites", "GET /repos/{owner}/{repo}/commits/{ref}/statuses", "GET /repos/{owner}/{repo}/contributors", "GET /repos/{owner}/{repo}/deployments", "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses", "GET /repos/{owner}/{repo}/events", "GET /repos/{owner}/{repo}/forks", "GET /repos/{owner}/{repo}/git/matching-refs/{ref}", "GET /repos/{owner}/{repo}/hooks", "GET /repos/{owner}/{repo}/invitations", "GET /repos/{owner}/{repo}/issues", "GET /repos/{owner}/{repo}/issues/comments", "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions", "GET /repos/{owner}/{repo}/issues/events", "GET /repos/{owner}/{repo}/issues/{issue_number}/comments", "GET /repos/{owner}/{repo}/issues/{issue_number}/events", "GET /repos/{owner}/{repo}/issues/{issue_number}/labels", "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions", "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline", "GET /repos/{owner}/{repo}/keys", "GET /repos/{owner}/{repo}/labels", "GET /repos/{owner}/{repo}/milestones", "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels", "GET /repos/{owner}/{repo}/notifications", "GET /repos/{owner}/{repo}/pages/builds", "GET /repos/{owner}/{repo}/projects", "GET /repos/{owner}/{repo}/pulls", "GET /repos/{owner}/{repo}/pulls/comments", "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions", "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments", "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits", "GET /repos/{owner}/{repo}/pulls/{pull_number}/files", "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers", "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews", "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments", "GET /repos/{owner}/{repo}/releases", "GET /repos/{owner}/{repo}/releases/{release_id}/assets", "GET /repos/{owner}/{repo}/secret-scanning/alerts", "GET /repos/{owner}/{repo}/stargazers", "GET /repos/{owner}/{repo}/subscribers", "GET /repos/{owner}/{repo}/tags", "GET /repos/{owner}/{repo}/teams", "GET /repositories", "GET /repositories/{repository_id}/environments/{environment_name}/secrets", "GET /scim/v2/enterprises/{enterprise}/Groups", "GET /scim/v2/enterprises/{enterprise}/Users", "GET /scim/v2/organizations/{org}/Users", "GET /search/code", "GET /search/commits", "GET /search/issues", "GET /search/labels", "GET /search/repositories", "GET /search/topics", "GET /search/users", "GET /teams/{team_id}/discussions", "GET /teams/{team_id}/discussions/{discussion_number}/comments", "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions", "GET /teams/{team_id}/discussions/{discussion_number}/reactions", "GET /teams/{team_id}/invitations", "GET /teams/{team_id}/members", "GET /teams/{team_id}/projects", "GET /teams/{team_id}/repos", "GET /teams/{team_id}/team-sync/group-mappings", "GET /teams/{team_id}/teams", "GET /user/blocks", "GET /user/emails", "GET /user/followers", "GET /user/following", "GET /user/gpg_keys", "GET /user/installations", "GET /user/installations/{installation_id}/repositories", "GET /user/issues", "GET /user/keys", "GET /user/marketplace_purchases", "GET /user/marketplace_purchases/stubbed", "GET /user/memberships/orgs", "GET /user/migrations", "GET /user/migrations/{migration_id}/repositories", "GET /user/orgs", "GET /user/public_emails", "GET /user/repos", "GET /user/repository_invitations", "GET /user/starred", "GET /user/subscriptions", "GET /user/teams", "GET /users", "GET /users/{username}/events", "GET /users/{username}/events/orgs/{org}", "GET /users/{username}/events/public", "GET /users/{username}/followers", "GET /users/{username}/following", "GET /users/{username}/gists", "GET /users/{username}/gpg_keys", "GET /users/{username}/keys", "GET /users/{username}/orgs", "GET /users/{username}/projects", "GET /users/{username}/received_events", "GET /users/{username}/received_events/public", "GET /users/{username}/repos", "GET /users/{username}/starred", "GET /users/{username}/subscriptions"];

function isPaginatingEndpoint(arg) {
  if (typeof arg === "string") {
    return paginatingEndpoints.includes(arg);
  } else {
    return false;
  }
}

/**
 * @param octokit Octokit instance
 * @param options Options passed to Octokit constructor
 */

function paginateRest(octokit) {
  return {
    paginate: Object.assign(paginate.bind(null, octokit), {
      iterator: iterator.bind(null, octokit)
    })
  };
}
paginateRest.VERSION = VERSION;

exports.composePaginateRest = composePaginateRest;
exports.isPaginatingEndpoint = isPaginatingEndpoint;
exports.paginateRest = paginateRest;
exports.paginatingEndpoints = paginatingEndpoints;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 83044:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

const Endpoints = {
  actions: {
    addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
    approveWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"],
    cancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"],
    createOrUpdateEnvironmentSecret: ["PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
    createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
    createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    createRegistrationTokenForOrg: ["POST /orgs/{org}/actions/runners/registration-token"],
    createRegistrationTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/registration-token"],
    createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
    createRemoveTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/remove-token"],
    createWorkflowDispatch: ["POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"],
    deleteArtifact: ["DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
    deleteEnvironmentSecret: ["DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
    deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
    deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    deleteSelfHostedRunnerFromOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}"],
    deleteSelfHostedRunnerFromRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"],
    deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
    deleteWorkflowRunLogs: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
    disableSelectedRepositoryGithubActionsOrganization: ["DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"],
    disableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"],
    downloadArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"],
    downloadJobLogsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"],
    downloadWorkflowRunLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
    enableSelectedRepositoryGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"],
    enableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"],
    getAllowedActionsOrganization: ["GET /orgs/{org}/actions/permissions/selected-actions"],
    getAllowedActionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/selected-actions"],
    getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
    getEnvironmentPublicKey: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"],
    getEnvironmentSecret: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
    getGithubActionsPermissionsOrganization: ["GET /orgs/{org}/actions/permissions"],
    getGithubActionsPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions"],
    getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
    getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
    getPendingDeploymentsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
    getRepoPermissions: ["GET /repos/{owner}/{repo}/actions/permissions", {}, {
      renamed: ["actions", "getGithubActionsPermissionsRepository"]
    }],
    getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
    getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    getReviewsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"],
    getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
    getSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}"],
    getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
    getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
    getWorkflowRunUsage: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"],
    getWorkflowUsage: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"],
    listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
    listEnvironmentSecrets: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets"],
    listJobsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"],
    listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
    listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
    listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
    listRunnerApplicationsForRepo: ["GET /repos/{owner}/{repo}/actions/runners/downloads"],
    listSelectedReposForOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}/repositories"],
    listSelectedRepositoriesEnabledGithubActionsOrganization: ["GET /orgs/{org}/actions/permissions/repositories"],
    listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
    listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
    listWorkflowRunArtifacts: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"],
    listWorkflowRuns: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"],
    listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
    reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
    removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
    reviewPendingDeploymentsForRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
    setAllowedActionsOrganization: ["PUT /orgs/{org}/actions/permissions/selected-actions"],
    setAllowedActionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"],
    setGithubActionsPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions"],
    setGithubActionsPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions"],
    setSelectedReposForOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"],
    setSelectedRepositoriesEnabledGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories"]
  },
  activity: {
    checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
    deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
    deleteThreadSubscription: ["DELETE /notifications/threads/{thread_id}/subscription"],
    getFeeds: ["GET /feeds"],
    getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
    getThread: ["GET /notifications/threads/{thread_id}"],
    getThreadSubscriptionForAuthenticatedUser: ["GET /notifications/threads/{thread_id}/subscription"],
    listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
    listNotificationsForAuthenticatedUser: ["GET /notifications"],
    listOrgEventsForAuthenticatedUser: ["GET /users/{username}/events/orgs/{org}"],
    listPublicEvents: ["GET /events"],
    listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
    listPublicEventsForUser: ["GET /users/{username}/events/public"],
    listPublicOrgEvents: ["GET /orgs/{org}/events"],
    listReceivedEventsForUser: ["GET /users/{username}/received_events"],
    listReceivedPublicEventsForUser: ["GET /users/{username}/received_events/public"],
    listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
    listRepoNotificationsForAuthenticatedUser: ["GET /repos/{owner}/{repo}/notifications"],
    listReposStarredByAuthenticatedUser: ["GET /user/starred"],
    listReposStarredByUser: ["GET /users/{username}/starred"],
    listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
    listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
    listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
    listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
    markNotificationsAsRead: ["PUT /notifications"],
    markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
    markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
    setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
    setThreadSubscription: ["PUT /notifications/threads/{thread_id}/subscription"],
    starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
    unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
  },
  apps: {
    addRepoToInstallation: ["PUT /user/installations/{installation_id}/repositories/{repository_id}"],
    checkToken: ["POST /applications/{client_id}/token"],
    createContentAttachment: ["POST /content_references/{content_reference_id}/attachments", {
      mediaType: {
        previews: ["corsair"]
      }
    }],
    createContentAttachmentForRepo: ["POST /repos/{owner}/{repo}/content_references/{content_reference_id}/attachments", {
      mediaType: {
        previews: ["corsair"]
      }
    }],
    createFromManifest: ["POST /app-manifests/{code}/conversions"],
    createInstallationAccessToken: ["POST /app/installations/{installation_id}/access_tokens"],
    deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
    deleteInstallation: ["DELETE /app/installations/{installation_id}"],
    deleteToken: ["DELETE /applications/{client_id}/token"],
    getAuthenticated: ["GET /app"],
    getBySlug: ["GET /apps/{app_slug}"],
    getInstallation: ["GET /app/installations/{installation_id}"],
    getOrgInstallation: ["GET /orgs/{org}/installation"],
    getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
    getSubscriptionPlanForAccount: ["GET /marketplace_listing/accounts/{account_id}"],
    getSubscriptionPlanForAccountStubbed: ["GET /marketplace_listing/stubbed/accounts/{account_id}"],
    getUserInstallation: ["GET /users/{username}/installation"],
    getWebhookConfigForApp: ["GET /app/hook/config"],
    listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
    listAccountsForPlanStubbed: ["GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"],
    listInstallationReposForAuthenticatedUser: ["GET /user/installations/{installation_id}/repositories"],
    listInstallations: ["GET /app/installations"],
    listInstallationsForAuthenticatedUser: ["GET /user/installations"],
    listPlans: ["GET /marketplace_listing/plans"],
    listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
    listReposAccessibleToInstallation: ["GET /installation/repositories"],
    listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
    listSubscriptionsForAuthenticatedUserStubbed: ["GET /user/marketplace_purchases/stubbed"],
    removeRepoFromInstallation: ["DELETE /user/installations/{installation_id}/repositories/{repository_id}"],
    resetToken: ["PATCH /applications/{client_id}/token"],
    revokeInstallationAccessToken: ["DELETE /installation/token"],
    scopeToken: ["POST /applications/{client_id}/token/scoped"],
    suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
    unsuspendInstallation: ["DELETE /app/installations/{installation_id}/suspended"],
    updateWebhookConfigForApp: ["PATCH /app/hook/config"]
  },
  billing: {
    getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
    getGithubActionsBillingUser: ["GET /users/{username}/settings/billing/actions"],
    getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
    getGithubPackagesBillingUser: ["GET /users/{username}/settings/billing/packages"],
    getSharedStorageBillingOrg: ["GET /orgs/{org}/settings/billing/shared-storage"],
    getSharedStorageBillingUser: ["GET /users/{username}/settings/billing/shared-storage"]
  },
  checks: {
    create: ["POST /repos/{owner}/{repo}/check-runs"],
    createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
    get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
    getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
    listAnnotations: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"],
    listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
    listForSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"],
    listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
    rerequestSuite: ["POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"],
    setSuitesPreferences: ["PATCH /repos/{owner}/{repo}/check-suites/preferences"],
    update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
  },
  codeScanning: {
    deleteAnalysis: ["DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"],
    getAlert: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}", {}, {
      renamedParameters: {
        alert_id: "alert_number"
      }
    }],
    getAnalysis: ["GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"],
    getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
    listAlertInstances: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
    listAlertsInstances: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances", {}, {
      renamed: ["codeScanning", "listAlertInstances"]
    }],
    listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
    updateAlert: ["PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"],
    uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
  },
  codesOfConduct: {
    getAllCodesOfConduct: ["GET /codes_of_conduct", {
      mediaType: {
        previews: ["scarlet-witch"]
      }
    }],
    getConductCode: ["GET /codes_of_conduct/{key}", {
      mediaType: {
        previews: ["scarlet-witch"]
      }
    }],
    getForRepo: ["GET /repos/{owner}/{repo}/community/code_of_conduct", {
      mediaType: {
        previews: ["scarlet-witch"]
      }
    }]
  },
  emojis: {
    get: ["GET /emojis"]
  },
  enterpriseAdmin: {
    disableSelectedOrganizationGithubActionsEnterprise: ["DELETE /enterprises/{enterprise}/actions/permissions/organizations/{org_id}"],
    enableSelectedOrganizationGithubActionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/organizations/{org_id}"],
    getAllowedActionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions/selected-actions"],
    getGithubActionsPermissionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions"],
    listSelectedOrganizationsEnabledGithubActionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions/organizations"],
    setAllowedActionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/selected-actions"],
    setGithubActionsPermissionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions"],
    setSelectedOrganizationsEnabledGithubActionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/organizations"]
  },
  gists: {
    checkIsStarred: ["GET /gists/{gist_id}/star"],
    create: ["POST /gists"],
    createComment: ["POST /gists/{gist_id}/comments"],
    delete: ["DELETE /gists/{gist_id}"],
    deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
    fork: ["POST /gists/{gist_id}/forks"],
    get: ["GET /gists/{gist_id}"],
    getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
    getRevision: ["GET /gists/{gist_id}/{sha}"],
    list: ["GET /gists"],
    listComments: ["GET /gists/{gist_id}/comments"],
    listCommits: ["GET /gists/{gist_id}/commits"],
    listForUser: ["GET /users/{username}/gists"],
    listForks: ["GET /gists/{gist_id}/forks"],
    listPublic: ["GET /gists/public"],
    listStarred: ["GET /gists/starred"],
    star: ["PUT /gists/{gist_id}/star"],
    unstar: ["DELETE /gists/{gist_id}/star"],
    update: ["PATCH /gists/{gist_id}"],
    updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
  },
  git: {
    createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
    createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
    createRef: ["POST /repos/{owner}/{repo}/git/refs"],
    createTag: ["POST /repos/{owner}/{repo}/git/tags"],
    createTree: ["POST /repos/{owner}/{repo}/git/trees"],
    deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
    getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
    getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
    getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
    getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
    getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
    listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
    updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
  },
  gitignore: {
    getAllTemplates: ["GET /gitignore/templates"],
    getTemplate: ["GET /gitignore/templates/{name}"]
  },
  interactions: {
    getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
    getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
    getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
    getRestrictionsForYourPublicRepos: ["GET /user/interaction-limits", {}, {
      renamed: ["interactions", "getRestrictionsForAuthenticatedUser"]
    }],
    removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
    removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
    removeRestrictionsForRepo: ["DELETE /repos/{owner}/{repo}/interaction-limits"],
    removeRestrictionsForYourPublicRepos: ["DELETE /user/interaction-limits", {}, {
      renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"]
    }],
    setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
    setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
    setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
    setRestrictionsForYourPublicRepos: ["PUT /user/interaction-limits", {}, {
      renamed: ["interactions", "setRestrictionsForAuthenticatedUser"]
    }]
  },
  issues: {
    addAssignees: ["POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
    addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
    create: ["POST /repos/{owner}/{repo}/issues"],
    createComment: ["POST /repos/{owner}/{repo}/issues/{issue_number}/comments"],
    createLabel: ["POST /repos/{owner}/{repo}/labels"],
    createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
    deleteComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
    deleteMilestone: ["DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"],
    get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
    getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
    getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
    getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
    list: ["GET /issues"],
    listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
    listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
    listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
    listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
    listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
    listEventsForTimeline: ["GET /repos/{owner}/{repo}/issues/{issue_number}/timeline", {
      mediaType: {
        previews: ["mockingbird"]
      }
    }],
    listForAuthenticatedUser: ["GET /user/issues"],
    listForOrg: ["GET /orgs/{org}/issues"],
    listForRepo: ["GET /repos/{owner}/{repo}/issues"],
    listLabelsForMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"],
    listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
    listLabelsOnIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
    lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    removeAllLabels: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    removeAssignees: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
    removeLabel: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"],
    setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
    updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
    updateMilestone: ["PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"]
  },
  licenses: {
    get: ["GET /licenses/{license}"],
    getAllCommonlyUsed: ["GET /licenses"],
    getForRepo: ["GET /repos/{owner}/{repo}/license"]
  },
  markdown: {
    render: ["POST /markdown"],
    renderRaw: ["POST /markdown/raw", {
      headers: {
        "content-type": "text/plain; charset=utf-8"
      }
    }]
  },
  meta: {
    get: ["GET /meta"],
    getOctocat: ["GET /octocat"],
    getZen: ["GET /zen"],
    root: ["GET /"]
  },
  migrations: {
    cancelImport: ["DELETE /repos/{owner}/{repo}/import"],
    deleteArchiveForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/archive", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    deleteArchiveForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/archive", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    downloadArchiveForOrg: ["GET /orgs/{org}/migrations/{migration_id}/archive", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    getArchiveForAuthenticatedUser: ["GET /user/migrations/{migration_id}/archive", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    getCommitAuthors: ["GET /repos/{owner}/{repo}/import/authors"],
    getImportStatus: ["GET /repos/{owner}/{repo}/import"],
    getLargeFiles: ["GET /repos/{owner}/{repo}/import/large_files"],
    getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    listForAuthenticatedUser: ["GET /user/migrations", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    listForOrg: ["GET /orgs/{org}/migrations", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    listReposForUser: ["GET /user/migrations/{migration_id}/repositories", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    mapCommitAuthor: ["PATCH /repos/{owner}/{repo}/import/authors/{author_id}"],
    setLfsPreference: ["PATCH /repos/{owner}/{repo}/import/lfs"],
    startForAuthenticatedUser: ["POST /user/migrations"],
    startForOrg: ["POST /orgs/{org}/migrations"],
    startImport: ["PUT /repos/{owner}/{repo}/import"],
    unlockRepoForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    unlockRepoForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    updateImport: ["PATCH /repos/{owner}/{repo}/import"]
  },
  orgs: {
    blockUser: ["PUT /orgs/{org}/blocks/{username}"],
    cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
    checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
    checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
    checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
    convertMemberToOutsideCollaborator: ["PUT /orgs/{org}/outside_collaborators/{username}"],
    createInvitation: ["POST /orgs/{org}/invitations"],
    createWebhook: ["POST /orgs/{org}/hooks"],
    deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
    get: ["GET /orgs/{org}"],
    getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
    getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
    getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
    getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
    list: ["GET /organizations"],
    listAppInstallations: ["GET /orgs/{org}/installations"],
    listBlockedUsers: ["GET /orgs/{org}/blocks"],
    listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
    listForAuthenticatedUser: ["GET /user/orgs"],
    listForUser: ["GET /users/{username}/orgs"],
    listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
    listMembers: ["GET /orgs/{org}/members"],
    listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
    listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
    listPendingInvitations: ["GET /orgs/{org}/invitations"],
    listPublicMembers: ["GET /orgs/{org}/public_members"],
    listWebhooks: ["GET /orgs/{org}/hooks"],
    pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
    removeMember: ["DELETE /orgs/{org}/members/{username}"],
    removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
    removeOutsideCollaborator: ["DELETE /orgs/{org}/outside_collaborators/{username}"],
    removePublicMembershipForAuthenticatedUser: ["DELETE /orgs/{org}/public_members/{username}"],
    setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
    setPublicMembershipForAuthenticatedUser: ["PUT /orgs/{org}/public_members/{username}"],
    unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
    update: ["PATCH /orgs/{org}"],
    updateMembershipForAuthenticatedUser: ["PATCH /user/memberships/orgs/{org}"],
    updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
    updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
  },
  packages: {
    deletePackageForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}"],
    deletePackageForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}"],
    deletePackageVersionForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
    deletePackageVersionForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
    getAllPackageVersionsForAPackageOwnedByAnOrg: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions", {}, {
      renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"]
    }],
    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions", {}, {
      renamed: ["packages", "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"]
    }],
    getAllPackageVersionsForPackageOwnedByAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions"],
    getAllPackageVersionsForPackageOwnedByOrg: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions"],
    getAllPackageVersionsForPackageOwnedByUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions"],
    getPackageForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}"],
    getPackageForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}"],
    getPackageForUser: ["GET /users/{username}/packages/{package_type}/{package_name}"],
    getPackageVersionForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
    getPackageVersionForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
    getPackageVersionForUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
    restorePackageForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/restore{?token}"],
    restorePackageForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"],
    restorePackageVersionForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
    restorePackageVersionForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"]
  },
  projects: {
    addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    createCard: ["POST /projects/columns/{column_id}/cards", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    createColumn: ["POST /projects/{project_id}/columns", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    createForAuthenticatedUser: ["POST /user/projects", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    createForOrg: ["POST /orgs/{org}/projects", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    createForRepo: ["POST /repos/{owner}/{repo}/projects", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    delete: ["DELETE /projects/{project_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    deleteCard: ["DELETE /projects/columns/cards/{card_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    deleteColumn: ["DELETE /projects/columns/{column_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    get: ["GET /projects/{project_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    getCard: ["GET /projects/columns/cards/{card_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    getColumn: ["GET /projects/columns/{column_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    getPermissionForUser: ["GET /projects/{project_id}/collaborators/{username}/permission", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    listCards: ["GET /projects/columns/{column_id}/cards", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    listCollaborators: ["GET /projects/{project_id}/collaborators", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    listColumns: ["GET /projects/{project_id}/columns", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    listForOrg: ["GET /orgs/{org}/projects", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    listForRepo: ["GET /repos/{owner}/{repo}/projects", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    listForUser: ["GET /users/{username}/projects", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    moveCard: ["POST /projects/columns/cards/{card_id}/moves", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    moveColumn: ["POST /projects/columns/{column_id}/moves", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    removeCollaborator: ["DELETE /projects/{project_id}/collaborators/{username}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    update: ["PATCH /projects/{project_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    updateCard: ["PATCH /projects/columns/cards/{card_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    updateColumn: ["PATCH /projects/columns/{column_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }]
  },
  pulls: {
    checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    create: ["POST /repos/{owner}/{repo}/pulls"],
    createReplyForReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"],
    createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    createReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
    deletePendingReview: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
    deleteReviewComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
    dismissReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"],
    get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
    getReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
    getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
    list: ["GET /repos/{owner}/{repo}/pulls"],
    listCommentsForReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"],
    listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
    listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
    listRequestedReviewers: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
    listReviewComments: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
    listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
    listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    removeRequestedReviewers: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
    requestReviewers: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
    submitReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"],
    update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
    updateBranch: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch", {
      mediaType: {
        previews: ["lydian"]
      }
    }],
    updateReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
    updateReviewComment: ["PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"]
  },
  rateLimit: {
    get: ["GET /rate_limit"]
  },
  reactions: {
    createForCommitComment: ["POST /repos/{owner}/{repo}/comments/{comment_id}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    createForIssue: ["POST /repos/{owner}/{repo}/issues/{issue_number}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    createForIssueComment: ["POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    createForPullRequestReviewComment: ["POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    createForRelease: ["POST /repos/{owner}/{repo}/releases/{release_id}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    createForTeamDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    createForTeamDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    deleteForCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    deleteForIssue: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    deleteForIssueComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    deleteForPullRequestComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    deleteForTeamDiscussion: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    deleteForTeamDiscussionComment: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    deleteLegacy: ["DELETE /reactions/{reaction_id}", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }, {
      deprecated: "octokit.rest.reactions.deleteLegacy() is deprecated, see https://docs.github.com/rest/reference/reactions/#delete-a-reaction-legacy"
    }],
    listForCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    listForIssueComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    listForPullRequestReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    listForTeamDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    listForTeamDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }]
  },
  repos: {
    acceptInvitation: ["PATCH /user/repository_invitations/{invitation_id}"],
    addAppAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
      mapToData: "apps"
    }],
    addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
    addStatusCheckContexts: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
      mapToData: "contexts"
    }],
    addTeamAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
      mapToData: "teams"
    }],
    addUserAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
      mapToData: "users"
    }],
    checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
    checkVulnerabilityAlerts: ["GET /repos/{owner}/{repo}/vulnerability-alerts", {
      mediaType: {
        previews: ["dorian"]
      }
    }],
    compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
    compareCommitsWithBasehead: ["GET /repos/{owner}/{repo}/compare/{basehead}"],
    createCommitComment: ["POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
    createCommitSignatureProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures", {
      mediaType: {
        previews: ["zzzax"]
      }
    }],
    createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
    createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
    createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
    createDeploymentStatus: ["POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
    createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
    createForAuthenticatedUser: ["POST /user/repos"],
    createFork: ["POST /repos/{owner}/{repo}/forks"],
    createInOrg: ["POST /orgs/{org}/repos"],
    createOrUpdateEnvironment: ["PUT /repos/{owner}/{repo}/environments/{environment_name}"],
    createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
    createPagesSite: ["POST /repos/{owner}/{repo}/pages", {
      mediaType: {
        previews: ["switcheroo"]
      }
    }],
    createRelease: ["POST /repos/{owner}/{repo}/releases"],
    createUsingTemplate: ["POST /repos/{template_owner}/{template_repo}/generate", {
      mediaType: {
        previews: ["baptiste"]
      }
    }],
    createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
    declineInvitation: ["DELETE /user/repository_invitations/{invitation_id}"],
    delete: ["DELETE /repos/{owner}/{repo}"],
    deleteAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
    deleteAdminBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
    deleteAnEnvironment: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}"],
    deleteBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection"],
    deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
    deleteCommitSignatureProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures", {
      mediaType: {
        previews: ["zzzax"]
      }
    }],
    deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
    deleteDeployment: ["DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"],
    deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
    deleteInvitation: ["DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"],
    deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages", {
      mediaType: {
        previews: ["switcheroo"]
      }
    }],
    deletePullRequestReviewProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
    deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
    deleteReleaseAsset: ["DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
    disableAutomatedSecurityFixes: ["DELETE /repos/{owner}/{repo}/automated-security-fixes", {
      mediaType: {
        previews: ["london"]
      }
    }],
    disableVulnerabilityAlerts: ["DELETE /repos/{owner}/{repo}/vulnerability-alerts", {
      mediaType: {
        previews: ["dorian"]
      }
    }],
    downloadArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}", {}, {
      renamed: ["repos", "downloadZipballArchive"]
    }],
    downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
    downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
    enableAutomatedSecurityFixes: ["PUT /repos/{owner}/{repo}/automated-security-fixes", {
      mediaType: {
        previews: ["london"]
      }
    }],
    enableVulnerabilityAlerts: ["PUT /repos/{owner}/{repo}/vulnerability-alerts", {
      mediaType: {
        previews: ["dorian"]
      }
    }],
    get: ["GET /repos/{owner}/{repo}"],
    getAccessRestrictions: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
    getAdminBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
    getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
    getAllStatusCheckContexts: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"],
    getAllTopics: ["GET /repos/{owner}/{repo}/topics", {
      mediaType: {
        previews: ["mercy"]
      }
    }],
    getAppsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"],
    getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
    getBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection"],
    getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
    getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
    getCollaboratorPermissionLevel: ["GET /repos/{owner}/{repo}/collaborators/{username}/permission"],
    getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
    getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
    getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
    getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
    getCommitSignatureProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures", {
      mediaType: {
        previews: ["zzzax"]
      }
    }],
    getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
    getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
    getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
    getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
    getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
    getDeploymentStatus: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"],
    getEnvironment: ["GET /repos/{owner}/{repo}/environments/{environment_name}"],
    getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
    getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
    getPages: ["GET /repos/{owner}/{repo}/pages"],
    getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
    getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
    getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
    getPullRequestReviewProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
    getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
    getReadme: ["GET /repos/{owner}/{repo}/readme"],
    getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
    getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
    getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
    getStatusChecksProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
    getTeamsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"],
    getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
    getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
    getUsersWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"],
    getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
    getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
    getWebhookConfigForRepo: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/config"],
    listBranches: ["GET /repos/{owner}/{repo}/branches"],
    listBranchesForHeadCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head", {
      mediaType: {
        previews: ["groot"]
      }
    }],
    listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
    listCommentsForCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
    listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
    listCommitStatusesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/statuses"],
    listCommits: ["GET /repos/{owner}/{repo}/commits"],
    listContributors: ["GET /repos/{owner}/{repo}/contributors"],
    listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
    listDeploymentStatuses: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
    listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
    listForAuthenticatedUser: ["GET /user/repos"],
    listForOrg: ["GET /orgs/{org}/repos"],
    listForUser: ["GET /users/{username}/repos"],
    listForks: ["GET /repos/{owner}/{repo}/forks"],
    listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
    listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
    listLanguages: ["GET /repos/{owner}/{repo}/languages"],
    listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
    listPublic: ["GET /repositories"],
    listPullRequestsAssociatedWithCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls", {
      mediaType: {
        previews: ["groot"]
      }
    }],
    listReleaseAssets: ["GET /repos/{owner}/{repo}/releases/{release_id}/assets"],
    listReleases: ["GET /repos/{owner}/{repo}/releases"],
    listTags: ["GET /repos/{owner}/{repo}/tags"],
    listTeams: ["GET /repos/{owner}/{repo}/teams"],
    listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
    merge: ["POST /repos/{owner}/{repo}/merges"],
    pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
    removeAppAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
      mapToData: "apps"
    }],
    removeCollaborator: ["DELETE /repos/{owner}/{repo}/collaborators/{username}"],
    removeStatusCheckContexts: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
      mapToData: "contexts"
    }],
    removeStatusCheckProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
    removeTeamAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
      mapToData: "teams"
    }],
    removeUserAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
      mapToData: "users"
    }],
    renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
    replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics", {
      mediaType: {
        previews: ["mercy"]
      }
    }],
    requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
    setAdminBranchProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
    setAppAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
      mapToData: "apps"
    }],
    setStatusCheckContexts: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
      mapToData: "contexts"
    }],
    setTeamAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
      mapToData: "teams"
    }],
    setUserAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
      mapToData: "users"
    }],
    testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
    transfer: ["POST /repos/{owner}/{repo}/transfer"],
    update: ["PATCH /repos/{owner}/{repo}"],
    updateBranchProtection: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection"],
    updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
    updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
    updateInvitation: ["PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"],
    updatePullRequestReviewProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
    updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
    updateReleaseAsset: ["PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    updateStatusCheckPotection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks", {}, {
      renamed: ["repos", "updateStatusCheckProtection"]
    }],
    updateStatusCheckProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
    updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
    updateWebhookConfigForRepo: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"],
    uploadReleaseAsset: ["POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}", {
      baseUrl: "https://uploads.github.com"
    }]
  },
  search: {
    code: ["GET /search/code"],
    commits: ["GET /search/commits", {
      mediaType: {
        previews: ["cloak"]
      }
    }],
    issuesAndPullRequests: ["GET /search/issues"],
    labels: ["GET /search/labels"],
    repos: ["GET /search/repositories"],
    topics: ["GET /search/topics", {
      mediaType: {
        previews: ["mercy"]
      }
    }],
    users: ["GET /search/users"]
  },
  secretScanning: {
    getAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
    updateAlert: ["PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"]
  },
  teams: {
    addOrUpdateMembershipForUserInOrg: ["PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"],
    addOrUpdateProjectPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    addOrUpdateRepoPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
    checkPermissionsForProjectInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects/{project_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    checkPermissionsForRepoInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
    create: ["POST /orgs/{org}/teams"],
    createDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
    createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
    deleteDiscussionCommentInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
    deleteDiscussionInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
    deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
    getByName: ["GET /orgs/{org}/teams/{team_slug}"],
    getDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
    getDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
    getMembershipForUserInOrg: ["GET /orgs/{org}/teams/{team_slug}/memberships/{username}"],
    list: ["GET /orgs/{org}/teams"],
    listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
    listDiscussionCommentsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
    listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
    listForAuthenticatedUser: ["GET /user/teams"],
    listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
    listPendingInvitationsInOrg: ["GET /orgs/{org}/teams/{team_slug}/invitations"],
    listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
    removeMembershipForUserInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"],
    removeProjectInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
    removeRepoInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
    updateDiscussionCommentInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
    updateDiscussionInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
    updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
  },
  users: {
    addEmailForAuthenticated: ["POST /user/emails"],
    block: ["PUT /user/blocks/{username}"],
    checkBlocked: ["GET /user/blocks/{username}"],
    checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
    checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
    createGpgKeyForAuthenticated: ["POST /user/gpg_keys"],
    createPublicSshKeyForAuthenticated: ["POST /user/keys"],
    deleteEmailForAuthenticated: ["DELETE /user/emails"],
    deleteGpgKeyForAuthenticated: ["DELETE /user/gpg_keys/{gpg_key_id}"],
    deletePublicSshKeyForAuthenticated: ["DELETE /user/keys/{key_id}"],
    follow: ["PUT /user/following/{username}"],
    getAuthenticated: ["GET /user"],
    getByUsername: ["GET /users/{username}"],
    getContextForUser: ["GET /users/{username}/hovercard"],
    getGpgKeyForAuthenticated: ["GET /user/gpg_keys/{gpg_key_id}"],
    getPublicSshKeyForAuthenticated: ["GET /user/keys/{key_id}"],
    list: ["GET /users"],
    listBlockedByAuthenticated: ["GET /user/blocks"],
    listEmailsForAuthenticated: ["GET /user/emails"],
    listFollowedByAuthenticated: ["GET /user/following"],
    listFollowersForAuthenticatedUser: ["GET /user/followers"],
    listFollowersForUser: ["GET /users/{username}/followers"],
    listFollowingForUser: ["GET /users/{username}/following"],
    listGpgKeysForAuthenticated: ["GET /user/gpg_keys"],
    listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
    listPublicEmailsForAuthenticated: ["GET /user/public_emails"],
    listPublicKeysForUser: ["GET /users/{username}/keys"],
    listPublicSshKeysForAuthenticated: ["GET /user/keys"],
    setPrimaryEmailVisibilityForAuthenticated: ["PATCH /user/email/visibility"],
    unblock: ["DELETE /user/blocks/{username}"],
    unfollow: ["DELETE /user/following/{username}"],
    updateAuthenticated: ["PATCH /user"]
  }
};

const VERSION = "5.3.1";

function endpointsToMethods(octokit, endpointsMap) {
  const newMethods = {};

  for (const [scope, endpoints] of Object.entries(endpointsMap)) {
    for (const [methodName, endpoint] of Object.entries(endpoints)) {
      const [route, defaults, decorations] = endpoint;
      const [method, url] = route.split(/ /);
      const endpointDefaults = Object.assign({
        method,
        url
      }, defaults);

      if (!newMethods[scope]) {
        newMethods[scope] = {};
      }

      const scopeMethods = newMethods[scope];

      if (decorations) {
        scopeMethods[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
        continue;
      }

      scopeMethods[methodName] = octokit.request.defaults(endpointDefaults);
    }
  }

  return newMethods;
}

function decorate(octokit, scope, methodName, defaults, decorations) {
  const requestWithDefaults = octokit.request.defaults(defaults);
  /* istanbul ignore next */

  function withDecorations(...args) {
    // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
    let options = requestWithDefaults.endpoint.merge(...args); // There are currently no other decorations than `.mapToData`

    if (decorations.mapToData) {
      options = Object.assign({}, options, {
        data: options[decorations.mapToData],
        [decorations.mapToData]: undefined
      });
      return requestWithDefaults(options);
    }

    if (decorations.renamed) {
      const [newScope, newMethodName] = decorations.renamed;
      octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
    }

    if (decorations.deprecated) {
      octokit.log.warn(decorations.deprecated);
    }

    if (decorations.renamedParameters) {
      // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
      const options = requestWithDefaults.endpoint.merge(...args);

      for (const [name, alias] of Object.entries(decorations.renamedParameters)) {
        if (name in options) {
          octokit.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`);

          if (!(alias in options)) {
            options[alias] = options[name];
          }

          delete options[name];
        }
      }

      return requestWithDefaults(options);
    } // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488


    return requestWithDefaults(...args);
  }

  return Object.assign(withDecorations, requestWithDefaults);
}

function restEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit, Endpoints);
  return {
    rest: api
  };
}
restEndpointMethods.VERSION = VERSION;
function legacyRestEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit, Endpoints);
  return _objectSpread2(_objectSpread2({}, api), {}, {
    rest: api
  });
}
legacyRestEndpointMethods.VERSION = VERSION;

exports.legacyRestEndpointMethods = legacyRestEndpointMethods;
exports.restEndpointMethods = restEndpointMethods;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 10537:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var deprecation = __webpack_require__(58932);
var once = _interopDefault(__webpack_require__(1223));

const logOnceCode = once(deprecation => console.warn(deprecation));
const logOnceHeaders = once(deprecation => console.warn(deprecation));
/**
 * Error with extra properties to help with debugging
 */

class RequestError extends Error {
  constructor(message, statusCode, options) {
    super(message); // Maintains proper stack trace (only available on V8)

    /* istanbul ignore next */

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    this.name = "HttpError";
    this.status = statusCode;
    let headers;

    if ("headers" in options && typeof options.headers !== "undefined") {
      headers = options.headers;
    }

    if ("response" in options) {
      this.response = options.response;
      headers = options.response.headers;
    } // redact request credentials without mutating original request options


    const requestCopy = Object.assign({}, options.request);

    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(/ .*$/, " [REDACTED]")
      });
    }

    requestCopy.url = requestCopy.url // client_id & client_secret can be passed as URL query parameters to increase rate limit
    // see https://developer.github.com/v3/#increasing-the-unauthenticated-rate-limit-for-oauth-applications
    .replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]") // OAuth tokens can be passed as URL query parameters, although it is not recommended
    // see https://developer.github.com/v3/#oauth2-token-sent-in-a-header
    .replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy; // deprecations

    Object.defineProperty(this, "code", {
      get() {
        logOnceCode(new deprecation.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
        return statusCode;
      }

    });
    Object.defineProperty(this, "headers", {
      get() {
        logOnceHeaders(new deprecation.Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."));
        return headers || {};
      }

    });
  }

}

exports.RequestError = RequestError;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 35712:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var endpoint = __webpack_require__(59440);
var universalUserAgent = __webpack_require__(45030);
var isPlainObject = __webpack_require__(63287);
var nodeFetch = _interopDefault(__webpack_require__(80467));
var requestError = __webpack_require__(10537);

const VERSION = "5.6.0";

function getBufferResponse(response) {
  return response.arrayBuffer();
}

function fetchWrapper(requestOptions) {
  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;

  if (isPlainObject.isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }

  let headers = {};
  let status;
  let url;
  const fetch = requestOptions.request && requestOptions.request.fetch || nodeFetch;
  return fetch(requestOptions.url, Object.assign({
    method: requestOptions.method,
    body: requestOptions.body,
    headers: requestOptions.headers,
    redirect: requestOptions.redirect
  }, // `requestOptions.request.agent` type is incompatible
  // see https://github.com/octokit/types.ts/pull/264
  requestOptions.request)).then(async response => {
    url = response.url;
    status = response.status;

    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }

    if ("deprecation" in headers) {
      const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
      const deprecationLink = matches && matches.pop();
      log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
    }

    if (status === 204 || status === 205) {
      return;
    } // GitHub API returns 200 for HEAD requests


    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }

      throw new requestError.RequestError(response.statusText, status, {
        response: {
          url,
          status,
          headers,
          data: undefined
        },
        request: requestOptions
      });
    }

    if (status === 304) {
      throw new requestError.RequestError("Not modified", status, {
        response: {
          url,
          status,
          headers,
          data: await getResponseData(response)
        },
        request: requestOptions
      });
    }

    if (status >= 400) {
      const data = await getResponseData(response);
      const error = new requestError.RequestError(toErrorMessage(data), status, {
        response: {
          url,
          status,
          headers,
          data
        },
        request: requestOptions
      });
      throw error;
    }

    return getResponseData(response);
  }).then(data => {
    return {
      status,
      url,
      headers,
      data
    };
  }).catch(error => {
    if (error instanceof requestError.RequestError) throw error;
    throw new requestError.RequestError(error.message, 500, {
      request: requestOptions
    });
  });
}

async function getResponseData(response) {
  const contentType = response.headers.get("content-type");

  if (/application\/json/.test(contentType)) {
    return response.json();
  }

  if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
    return response.text();
  }

  return getBufferResponse(response);
}

function toErrorMessage(data) {
  if (typeof data === "string") return data; // istanbul ignore else - just in case

  if ("message" in data) {
    if (Array.isArray(data.errors)) {
      return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}`;
    }

    return data.message;
  } // istanbul ignore next - just in case


  return `Unknown error: ${JSON.stringify(data)}`;
}

function withDefaults(oldEndpoint, newDefaults) {
  const endpoint = oldEndpoint.defaults(newDefaults);

  const newApi = function (route, parameters) {
    const endpointOptions = endpoint.merge(route, parameters);

    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint.parse(endpointOptions));
    }

    const request = (route, parameters) => {
      return fetchWrapper(endpoint.parse(endpoint.merge(route, parameters)));
    };

    Object.assign(request, {
      endpoint,
      defaults: withDefaults.bind(null, endpoint)
    });
    return endpointOptions.request.hook(request, endpointOptions);
  };

  return Object.assign(newApi, {
    endpoint,
    defaults: withDefaults.bind(null, endpoint)
  });
}

const request = withDefaults(endpoint.endpoint, {
  headers: {
    "user-agent": `octokit-request.js/${VERSION} ${universalUserAgent.getUserAgent()}`
  }
});

exports.request = request;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 73911:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationFile = exports.PathResolutionMethod = exports.InheritanceType = void 0;
const nodeJsPath = __importStar(__webpack_require__(85622));
const jsonpath_plus_1 = __webpack_require__(63269);
const node_core_library_1 = __webpack_require__(24247);
/**
 * @beta
 */
var InheritanceType;
(function (InheritanceType) {
    /**
     * Append additional elements after elements from the parent file's property
     */
    InheritanceType["append"] = "append";
    /**
     * Discard elements from the parent file's property
     */
    InheritanceType["replace"] = "replace";
    /**
     * Custom inheritance functionality
     */
    InheritanceType["custom"] = "custom";
})(InheritanceType = exports.InheritanceType || (exports.InheritanceType = {}));
/**
 * @beta
 */
var PathResolutionMethod;
(function (PathResolutionMethod) {
    /**
     * Resolve a path relative to the configuration file
     */
    PathResolutionMethod[PathResolutionMethod["resolvePathRelativeToConfigurationFile"] = 0] = "resolvePathRelativeToConfigurationFile";
    /**
     * Resolve a path relative to the root of the project containing the configuration file
     */
    PathResolutionMethod[PathResolutionMethod["resolvePathRelativeToProjectRoot"] = 1] = "resolvePathRelativeToProjectRoot";
    /**
     * Treat the property as a NodeJS-style require/import reference and resolve using standard
     * NodeJS filesystem resolution
     */
    PathResolutionMethod[PathResolutionMethod["NodeResolve"] = 2] = "NodeResolve";
    /**
     * Resolve the property using a custom resolver.
     */
    PathResolutionMethod[PathResolutionMethod["custom"] = 3] = "custom";
})(PathResolutionMethod = exports.PathResolutionMethod || (exports.PathResolutionMethod = {}));
const CONFIGURATION_FILE_FIELD_ANNOTATION = Symbol('configuration-file-field-annotation');
/**
 * @beta
 */
class ConfigurationFile {
    constructor(options) {
        this._configPromiseCache = new Map();
        this._packageJsonLookup = new node_core_library_1.PackageJsonLookup();
        this.projectRelativeFilePath = options.projectRelativeFilePath;
        this._schemaPath = options.jsonSchemaPath;
        this._jsonPathMetadata = options.jsonPathMetadata || {};
        this._propertyInheritanceTypes = options.propertyInheritance || {};
    }
    get _schema() {
        if (!this.__schema) {
            this.__schema = node_core_library_1.JsonSchema.fromFile(this._schemaPath);
        }
        return this.__schema;
    }
    /**
     * Find and return a configuration file for the specified project, automatically resolving
     * `extends` properties and handling rigged configuration files. Will throw an error if a configuration
     * file cannot be found in the rig or project config folder.
     */
    async loadConfigurationFileForProjectAsync(terminal, projectPath, rigConfig) {
        const projectConfigurationFilePath = this._getConfigurationFilePathForProject(projectPath);
        return await this._loadConfigurationFileInnerWithCacheAsync(terminal, projectConfigurationFilePath, new Set(), rigConfig);
    }
    /**
     * This function is identical to {@link ConfigurationFile.loadConfigurationFileForProjectAsync}, except
     * that it returns `undefined` instead of throwing an error if the configuration file cannot be found.
     */
    async tryLoadConfigurationFileForProjectAsync(terminal, projectPath, rigConfig) {
        try {
            return await this.loadConfigurationFileForProjectAsync(terminal, projectPath, rigConfig);
        }
        catch (e) {
            if (node_core_library_1.FileSystem.isNotExistError(e)) {
                return undefined;
            }
            throw e;
        }
    }
    /**
     * Get the path to the source file that the referenced property was originally
     * loaded from.
     */
    getObjectSourceFilePath(obj) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const annotation = obj[CONFIGURATION_FILE_FIELD_ANNOTATION];
        if (annotation) {
            return annotation.configurationFilePath;
        }
        return undefined;
    }
    /**
     * Get the value of the specified property on the specified object that was originally
     * loaded from a configuration file.
     */
    getPropertyOriginalValue(options) {
        const annotation = 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        options.parentObject[CONFIGURATION_FILE_FIELD_ANNOTATION];
        if (annotation && annotation.originalValues.hasOwnProperty(options.propertyName)) {
            return annotation.originalValues[options.propertyName];
        }
        else {
            return undefined;
        }
    }
    async _loadConfigurationFileInnerWithCacheAsync(terminal, resolvedConfigurationFilePath, visitedConfigurationFilePaths, rigConfig) {
        let cacheEntryPromise = this._configPromiseCache.get(resolvedConfigurationFilePath);
        if (!cacheEntryPromise) {
            cacheEntryPromise = this._loadConfigurationFileInnerAsync(terminal, resolvedConfigurationFilePath, visitedConfigurationFilePaths, rigConfig);
            this._configPromiseCache.set(resolvedConfigurationFilePath, cacheEntryPromise);
        }
        // We check for loops after caching a promise for this config file, but before attempting
        // to resolve the promise. We can't handle loop detection in the `InnerAsync` function, because
        // we could end up waiting for a cached promise (like A -> B -> A) that never resolves.
        if (visitedConfigurationFilePaths.has(resolvedConfigurationFilePath)) {
            const resolvedConfigurationFilePathForLogging = ConfigurationFile._formatPathForLogging(resolvedConfigurationFilePath);
            throw new Error('A loop has been detected in the "extends" properties of configuration file at ' +
                `"${resolvedConfigurationFilePathForLogging}".`);
        }
        visitedConfigurationFilePaths.add(resolvedConfigurationFilePath);
        return await cacheEntryPromise;
    }
    // NOTE: Internal calls to load a configuration file should use `_loadConfigurationFileInnerWithCacheAsync`.
    // Don't call this function directly, as it does not provide config file loop detection,
    // and you won't get the advantage of queueing up for a config file that is already loading.
    async _loadConfigurationFileInnerAsync(terminal, resolvedConfigurationFilePath, visitedConfigurationFilePaths, rigConfig) {
        const resolvedConfigurationFilePathForLogging = ConfigurationFile._formatPathForLogging(resolvedConfigurationFilePath);
        let fileText;
        try {
            fileText = await node_core_library_1.FileSystem.readFileAsync(resolvedConfigurationFilePath);
        }
        catch (e) {
            if (node_core_library_1.FileSystem.isNotExistError(e)) {
                if (rigConfig) {
                    terminal.writeDebugLine(`Config file "${resolvedConfigurationFilePathForLogging}" does not exist. Attempting to load via rig.`);
                    const rigResult = await this._tryLoadConfigurationFileInRigAsync(terminal, rigConfig, visitedConfigurationFilePaths);
                    if (rigResult) {
                        return rigResult;
                    }
                }
                else {
                    terminal.writeDebugLine(`Configuration file "${resolvedConfigurationFilePathForLogging}" not found.`);
                }
                e.message = `File does not exist: ${resolvedConfigurationFilePathForLogging}`;
            }
            throw e;
        }
        let configurationJson;
        try {
            configurationJson = await node_core_library_1.JsonFile.parseString(fileText);
        }
        catch (e) {
            throw new Error(`In config file "${resolvedConfigurationFilePathForLogging}": ${e}`);
        }
        this._schema.validateObject(configurationJson, resolvedConfigurationFilePathForLogging);
        this._annotateProperties(resolvedConfigurationFilePath, configurationJson);
        for (const [jsonPath, metadata] of Object.entries(this._jsonPathMetadata)) {
            (0, jsonpath_plus_1.JSONPath)({
                path: jsonPath,
                json: configurationJson,
                callback: (payload, payloadType, fullPayload) => {
                    const resolvedPath = this._resolvePathProperty(resolvedConfigurationFilePath, fullPayload.path, fullPayload.value, metadata);
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    fullPayload.parent[fullPayload.parentProperty] = resolvedPath;
                },
                otherTypeCallback: () => {
                    throw new Error('@other() tags are not supported');
                }
            });
        }
        let parentConfiguration = {};
        if (configurationJson.extends) {
            try {
                const resolvedParentConfigPath = node_core_library_1.Import.resolveModule({
                    modulePath: configurationJson.extends,
                    baseFolderPath: nodeJsPath.dirname(resolvedConfigurationFilePath)
                });
                parentConfiguration = await this._loadConfigurationFileInnerWithCacheAsync(terminal, resolvedParentConfigPath, visitedConfigurationFilePaths, undefined);
            }
            catch (e) {
                if (node_core_library_1.FileSystem.isNotExistError(e)) {
                    throw new Error(`In file "${resolvedConfigurationFilePathForLogging}", file referenced in "extends" property ` +
                        `("${configurationJson.extends}") cannot be resolved.`);
                }
                else {
                    throw e;
                }
            }
        }
        const propertyNames = new Set([
            ...Object.keys(parentConfiguration),
            ...Object.keys(configurationJson)
        ]);
        const resultAnnotation = {
            configurationFilePath: resolvedConfigurationFilePath,
            originalValues: {}
        };
        const result = {
            [CONFIGURATION_FILE_FIELD_ANNOTATION]: resultAnnotation
        };
        for (const propertyName of propertyNames) {
            if (propertyName === '$schema' || propertyName === 'extends') {
                continue;
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const propertyValue = configurationJson[propertyName];
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const parentPropertyValue = parentConfiguration[propertyName];
            const bothAreArrays = Array.isArray(propertyValue) && Array.isArray(parentPropertyValue);
            const defaultInheritanceType = bothAreArrays
                ? { inheritanceType: InheritanceType.append }
                : { inheritanceType: InheritanceType.replace };
            const propertyInheritance = 
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this._propertyInheritanceTypes[propertyName] !== undefined
                ? // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    this._propertyInheritanceTypes[propertyName]
                : defaultInheritanceType;
            let newValue;
            const usePropertyValue = () => {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                resultAnnotation.originalValues[propertyName] = this.getPropertyOriginalValue({
                    parentObject: configurationJson,
                    propertyName: propertyName
                });
                newValue = propertyValue;
            };
            const useParentPropertyValue = () => {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                resultAnnotation.originalValues[propertyName] = this.getPropertyOriginalValue({
                    parentObject: parentConfiguration,
                    propertyName: propertyName
                });
                newValue = parentPropertyValue;
            };
            if (propertyValue !== undefined && parentPropertyValue === undefined) {
                usePropertyValue();
            }
            else if (parentPropertyValue !== undefined && propertyValue === undefined) {
                useParentPropertyValue();
            }
            else {
                switch (propertyInheritance.inheritanceType) {
                    case InheritanceType.replace: {
                        if (propertyValue !== undefined) {
                            usePropertyValue();
                        }
                        else {
                            useParentPropertyValue();
                        }
                        break;
                    }
                    case InheritanceType.append: {
                        if (propertyValue !== undefined && parentPropertyValue === undefined) {
                            usePropertyValue();
                        }
                        else if (propertyValue === undefined && parentPropertyValue !== undefined) {
                            useParentPropertyValue();
                        }
                        else {
                            if (!Array.isArray(propertyValue) || !Array.isArray(parentPropertyValue)) {
                                throw new Error(`Issue in processing configuration file property "${propertyName}". ` +
                                    `Property is not an array, but the inheritance type is set as "${InheritanceType.append}"`);
                            }
                            newValue = [...parentPropertyValue, ...propertyValue];
                            newValue[CONFIGURATION_FILE_FIELD_ANNOTATION] = {
                                configurationFilePath: undefined,
                                originalValues: Object.assign(Object.assign({}, parentPropertyValue[CONFIGURATION_FILE_FIELD_ANNOTATION].originalValues), propertyValue[CONFIGURATION_FILE_FIELD_ANNOTATION].originalValues)
                            };
                        }
                        break;
                    }
                    case InheritanceType.custom: {
                        const customInheritance = propertyInheritance;
                        if (!customInheritance.inheritanceFunction ||
                            typeof customInheritance.inheritanceFunction !== 'function') {
                            throw new Error('For property inheritance type "InheritanceType.custom", an inheritanceFunction must be provided.');
                        }
                        newValue = customInheritance.inheritanceFunction(propertyValue, parentPropertyValue);
                        break;
                    }
                    default: {
                        throw new Error(`Unknown inheritance type "${propertyInheritance}"`);
                    }
                }
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            result[propertyName] = newValue;
        }
        try {
            this._schema.validateObject(result, resolvedConfigurationFilePathForLogging);
        }
        catch (e) {
            throw new Error(`Resolved configuration object does not match schema: ${e}`);
        }
        return result;
    }
    async _tryLoadConfigurationFileInRigAsync(terminal, rigConfig, visitedConfigurationFilePaths) {
        if (rigConfig.rigFound) {
            const rigProfileFolder = await rigConfig.getResolvedProfileFolderAsync();
            try {
                return await this._loadConfigurationFileInnerWithCacheAsync(terminal, nodeJsPath.resolve(rigProfileFolder, this.projectRelativeFilePath), visitedConfigurationFilePaths, undefined);
            }
            catch (e) {
                // Ignore cases where a configuration file doesn't exist in a rig
                if (!node_core_library_1.FileSystem.isNotExistError(e)) {
                    throw e;
                }
                else {
                    terminal.writeDebugLine(`Configuration file "${this.projectRelativeFilePath}" not found in rig ("${ConfigurationFile._formatPathForLogging(rigProfileFolder)}")`);
                }
            }
        }
        else {
            terminal.writeDebugLine(`No rig found for "${ConfigurationFile._formatPathForLogging(rigConfig.projectFolderPath)}"`);
        }
        return undefined;
    }
    _annotateProperties(resolvedConfigurationFilePath, obj) {
        if (!obj) {
            return;
        }
        if (typeof obj === 'object') {
            this._annotateProperty(resolvedConfigurationFilePath, obj);
            for (const objValue of Object.values(obj)) {
                this._annotateProperties(resolvedConfigurationFilePath, objValue);
            }
        }
    }
    _annotateProperty(resolvedConfigurationFilePath, obj) {
        if (!obj) {
            return;
        }
        if (typeof obj === 'object') {
            obj[CONFIGURATION_FILE_FIELD_ANNOTATION] = {
                configurationFilePath: resolvedConfigurationFilePath,
                originalValues: Object.assign({}, obj)
            };
        }
    }
    _resolvePathProperty(configurationFilePath, propertyName, propertyValue, metadata) {
        const resolutionMethod = metadata.pathResolutionMethod;
        if (resolutionMethod === undefined) {
            return propertyValue;
        }
        switch (metadata.pathResolutionMethod) {
            case PathResolutionMethod.resolvePathRelativeToConfigurationFile: {
                return nodeJsPath.resolve(nodeJsPath.dirname(configurationFilePath), propertyValue);
            }
            case PathResolutionMethod.resolvePathRelativeToProjectRoot: {
                const packageRoot = this._packageJsonLookup.tryGetPackageFolderFor(configurationFilePath);
                if (!packageRoot) {
                    throw new Error(`Could not find a package root for path "${ConfigurationFile._formatPathForLogging(configurationFilePath)}"`);
                }
                return nodeJsPath.resolve(packageRoot, propertyValue);
            }
            case PathResolutionMethod.NodeResolve: {
                return node_core_library_1.Import.resolveModule({
                    modulePath: propertyValue,
                    baseFolderPath: nodeJsPath.dirname(configurationFilePath)
                });
            }
            case PathResolutionMethod.custom: {
                if (!metadata.customResolver) {
                    throw new Error(`The pathResolutionMethod was set to "${PathResolutionMethod[resolutionMethod]}", but a custom ` +
                        'resolver was not provided.');
                }
                return metadata.customResolver(configurationFilePath, propertyName, propertyValue);
            }
            default: {
                throw new Error(`Unsupported PathResolutionMethod: ${PathResolutionMethod[resolutionMethod]} (${resolutionMethod})`);
            }
        }
    }
    _getConfigurationFilePathForProject(projectPath) {
        return nodeJsPath.resolve(projectPath, this.projectRelativeFilePath);
    }
}
exports.ConfigurationFile = ConfigurationFile;
/**
 * @internal
 */
ConfigurationFile._formatPathForLogging = (path) => path;
//# sourceMappingURL=ConfigurationFile.js.map

/***/ }),

/***/ 42166:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PathResolutionMethod = exports.InheritanceType = exports.ConfigurationFile = void 0;
var ConfigurationFile_1 = __webpack_require__(73911);
Object.defineProperty(exports, "ConfigurationFile", ({ enumerable: true, get: function () { return ConfigurationFile_1.ConfigurationFile; } }));
Object.defineProperty(exports, "InheritanceType", ({ enumerable: true, get: function () { return ConfigurationFile_1.InheritanceType; } }));
Object.defineProperty(exports, "PathResolutionMethod", ({ enumerable: true, get: function () { return ConfigurationFile_1.PathResolutionMethod; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 50025:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AlreadyReportedError = void 0;
const TypeUuid_1 = __webpack_require__(92736);
const uuidAlreadyReportedError = 'f26b0640-a49b-49d1-9ead-1a516d5920c7';
/**
 * This exception can be thrown to indicate that an operation failed and an error message has already
 * been reported appropriately. Thus, the catch handler does not have responsibility for reporting
 * the error.
 *
 * @remarks
 * For example, suppose a tool writes interactive output to `console.log()`.  When an exception is thrown,
 * the `catch` handler will typically provide simplistic reporting such as this:
 *
 * ```ts
 * catch (error) {
 *   console.log("ERROR: " + error.message);
 * }
 * ```
 *
 * Suppose that the code performing the operation normally prints rich output to the console.  It may be able to
 * present an error message more nicely (for example, as part of a table, or structured log format).  Throwing
 * `AlreadyReportedError` provides a way to use exception handling to abort the operation, but instruct the `catch`
 * handler not to print an error a second time:
 *
 * ```ts
 * catch (error) {
 *   if (error instanceof AlreadyReportedError) {
 *     return;
 *   }
 *   console.log("ERROR: " + error.message);
 * }
 * ```
 *
 * @public
 */
class AlreadyReportedError extends Error {
    constructor() {
        super('An error occurred.');
        // Manually set the prototype, as we can no longer extend built-in classes like Error, Array, Map, etc
        // [https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work](https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work)
        //
        // Note: the prototype must also be set on any classes which extend this one
        this.__proto__ = AlreadyReportedError.prototype; // eslint-disable-line @typescript-eslint/no-explicit-any
    }
    static [Symbol.hasInstance](instance) {
        return TypeUuid_1.TypeUuid.isInstanceOf(instance, uuidAlreadyReportedError);
    }
}
exports.AlreadyReportedError = AlreadyReportedError;
TypeUuid_1.TypeUuid.registerClass(AlreadyReportedError, uuidAlreadyReportedError);
//# sourceMappingURL=AlreadyReportedError.js.map

/***/ }),

/***/ 78869:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Async = void 0;
/**
 * Utilities for parallel asynchronous operations, for use with the system `Promise` APIs.
 *
 * @beta
 */
class Async {
    /**
     * Given an input array and a `callback` function, invoke the callback to start a
     * promise for each element in the array.  Returns an array containing the results.
     *
     * @remarks
     * This API is similar to the system `Array#map`, except that the loop is asynchronous,
     * and the maximum number of concurrent promises can be throttled
     * using {@link IAsyncParallelismOptions.concurrency}.
     *
     * If `callback` throws a synchronous exception, or if it returns a promise that rejects,
     * then the loop stops immediately.  Any remaining array items will be skipped, and
     * overall operation will reject with the first error that was encountered.
     *
     * @param iterable - the array of inputs for the callback function
     * @param callback - a function that starts an asynchronous promise for an element
     *   from the array
     * @param options - options for customizing the control flow
     * @returns an array containing the result for each callback, in the same order
     *   as the original input `array`
     */
    static async mapAsync(iterable, callback, options) {
        const result = [];
        await Async.forEachAsync(iterable, async (item, arrayIndex) => {
            result[arrayIndex] = await callback(item, arrayIndex);
        }, options);
        return result;
    }
    /**
     * Given an input array and a `callback` function, invoke the callback to start a
     * promise for each element in the array.
     *
     * @remarks
     * This API is similar to the system `Array#forEach`, except that the loop is asynchronous,
     * and the maximum number of concurrent promises can be throttled
     * using {@link IAsyncParallelismOptions.concurrency}.
     *
     * If `callback` throws a synchronous exception, or if it returns a promise that rejects,
     * then the loop stops immediately.  Any remaining array items will be skipped, and
     * overall operation will reject with the first error that was encountered.
     *
     * @param iterable - the array of inputs for the callback function
     * @param callback - a function that starts an asynchronous promise for an element
     *   from the array
     * @param options - options for customizing the control flow
     */
    static async forEachAsync(iterable, callback, options) {
        await new Promise((resolve, reject) => {
            const concurrency = (options === null || options === void 0 ? void 0 : options.concurrency) && options.concurrency > 0 ? options.concurrency : Infinity;
            let operationsInProgress = 0;
            const iterator = (iterable[Symbol.iterator] ||
                iterable[Symbol.asyncIterator]).call(iterable);
            let arrayIndex = 0;
            let iteratorIsComplete = false;
            let promiseHasResolvedOrRejected = false;
            async function queueOperationsAsync() {
                while (operationsInProgress < concurrency && !iteratorIsComplete && !promiseHasResolvedOrRejected) {
                    const currentIteratorResult = await iterator.next();
                    // eslint-disable-next-line require-atomic-updates
                    iteratorIsComplete = !!currentIteratorResult.done;
                    if (!iteratorIsComplete) {
                        operationsInProgress++;
                        Promise.resolve(callback(currentIteratorResult.value, arrayIndex++))
                            .then(async () => {
                            operationsInProgress--;
                            await onOperationCompletionAsync();
                        })
                            .catch((error) => {
                            promiseHasResolvedOrRejected = true;
                            reject(error);
                        });
                    }
                }
                if (iteratorIsComplete) {
                    await onOperationCompletionAsync();
                }
            }
            async function onOperationCompletionAsync() {
                if (!promiseHasResolvedOrRejected) {
                    if (operationsInProgress === 0 && iteratorIsComplete) {
                        promiseHasResolvedOrRejected = true;
                        resolve();
                    }
                    else if (!iteratorIsComplete) {
                        await queueOperationsAsync();
                    }
                }
            }
            queueOperationsAsync().catch((error) => {
                promiseHasResolvedOrRejected = true;
                reject(error);
            });
        });
    }
    /**
     * Return a promise that resolves after the specified number of milliseconds.
     */
    static async sleep(ms) {
        await new Promise((resolve) => {
            setTimeout(resolve, ms);
        });
    }
}
exports.Async = Async;
//# sourceMappingURL=Async.js.map

/***/ }),

/***/ 35948:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Enum = void 0;
/**
 * A helper for looking up TypeScript `enum` keys/values.
 *
 * @remarks
 * TypeScript enums implement a lookup table for mapping between their keys and values:
 *
 * ```ts
 * enum Colors {
 *   Red = 1
 * }
 *
 * // Prints "Red"
 * console.log(Colors[1]);
 *
 * // Prints "1"
 * console.log(Colors["Red]);
 * ```
 *
 * However the compiler's "noImplicitAny" validation has trouble with these mappings, because
 * there are so many possible types for the map elements:
 *
 * ```ts
 * function f(s: string): Colors | undefined {
 *   // (TS 7015) Element implicitly has an 'any' type because
 *   // index expression is not of type 'number'.
 *   return Colors[s];
 * }
 * ```
 *
 * The `Enum` helper provides a more specific, strongly typed way to access members:
 *
 * ```ts
 * function f(s: string): Colors | undefined {
 *   return Enum.tryGetValueByKey(Colors, s);
 * }
 * ```
 *
 * @public
 */
class Enum {
    constructor() { }
    /**
     * Returns an enum value, given its key. Returns `undefined` if no matching key is found.
     *
     * @example
     *
     * Example usage:
     * ```ts
     * enum Colors {
     *   Red = 1
     * }
     *
     * // Prints "1"
     * console.log(Enum.tryGetValueByKey(Colors, "Red"));
     *
     * // Prints "undefined"
     * console.log(Enum.tryGetValueByKey(Colors, "Black"));
     * ```
     */
    static tryGetValueByKey(enumObject, key) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return enumObject[key];
    }
    /**
     * This API is similar to {@link Enum.tryGetValueByKey}, except that it throws an exception
     * if the key is undefined.
     */
    static getValueByKey(enumObject, key) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const result = enumObject[key];
        if (result === undefined) {
            throw new Error(`The lookup key ${JSON.stringify(key)} is not defined`);
        }
        return result;
    }
    /**
     * Returns an enum string key, given its numeric value.  Returns `undefined` if no matching value
     * is found.
     *
     * @remarks
     * The TypeScript compiler only creates a reverse mapping for enum members whose value is numeric.
     * For example:
     *
     * ```ts
     * enum E {
     *   A = 1,
     *   B = 'c'
     * }
     *
     * // Prints "A"
     * console.log(E[1]);
     *
     * // Prints "undefined"
     * console.log(E["c"]);
     * ```
     *
     * @example
     *
     * Example usage:
     * ```ts
     * enum Colors {
     *   Red = 1,
     *   Blue = 'blue'
     * }
     *
     * // Prints "Red"
     * console.log(Enum.tryGetKeyByNumber(Colors, 1));
     *
     * // Prints "undefined"
     * console.log(Enum.tryGetKeyByNumber(Colors, -1));
     * ```
     */
    static tryGetKeyByNumber(enumObject, value) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return enumObject[value];
    }
    /**
     * This API is similar to {@link Enum.tryGetKeyByNumber}, except that it throws an exception
     * if the key is undefined.
     */
    static getKeyByNumber(enumObject, value) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const result = enumObject[value];
        if (result === undefined) {
            throw new Error(`The value ${value} does not exist in the mapping`);
        }
        return result;
    }
}
exports.Enum = Enum;
//# sourceMappingURL=Enum.js.map

/***/ }),

/***/ 75777:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnvironmentMap = void 0;
const process_1 = __importDefault(__webpack_require__(61765));
const InternalError_1 = __webpack_require__(22182);
/**
 * A map data structure that stores process environment variables.  On Windows
 * operating system, the variable names are case-insensitive.
 * @public
 */
class EnvironmentMap {
    constructor(environmentObject = {}) {
        this._map = new Map();
        // This property helps catch a mistake where an instance of `EnvironmentMap` is accidentally passed to
        // a function that expects a `Record<string, string>` (as would be used with the `process.env` API).
        // The property getter will throw an exception if that function tries to enumerate the object values.
        Object.defineProperty(this, '_sanityCheck', {
            enumerable: true,
            get: function () {
                throw new InternalError_1.InternalError('Attempt to read EnvironmentMap class as an object');
            }
        });
        this.caseSensitive = process_1.default.platform !== 'win32';
        this.mergeFromObject(environmentObject);
    }
    /**
     * Clears all entries, resulting in an empty map.
     */
    clear() {
        this._map.clear();
    }
    /**
     * Assigns the variable to the specified value.  A previous value will be overwritten.
     *
     * @remarks
     * The value can be an empty string.  To completely remove the entry, use
     * {@link EnvironmentMap.unset} instead.
     */
    set(name, value) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        this._map.set(key, { name: name, value });
    }
    /**
     * Removes the key from the map, if present.
     */
    unset(name) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        this._map.delete(key);
    }
    /**
     * Returns the value of the specified variable, or `undefined` if the map does not contain that name.
     */
    get(name) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        const entry = this._map.get(key);
        if (entry === undefined) {
            return undefined;
        }
        return entry.value;
    }
    /**
     * Returns the map keys, which are environment variable names.
     */
    names() {
        return this._map.keys();
    }
    /**
     * Returns the map entries.
     */
    entries() {
        return this._map.values();
    }
    /**
     * Adds each entry from `environmentMap` to this map.
     */
    mergeFrom(environmentMap) {
        for (const entry of environmentMap.entries()) {
            this.set(entry.name, entry.value);
        }
    }
    /**
     * Merges entries from a plain JavaScript object, such as would be used with the `process.env` API.
     */
    mergeFromObject(environmentObject = {}) {
        for (const [name, value] of Object.entries(environmentObject)) {
            if (value !== undefined) {
                this.set(name, value);
            }
        }
    }
    /**
     * Returns the keys as a plain JavaScript object similar to the object returned by the `process.env` API.
     */
    toObject() {
        const result = {};
        for (const entry of this.entries()) {
            result[entry.name] = entry.value;
        }
        return result;
    }
}
exports.EnvironmentMap = EnvironmentMap;
//# sourceMappingURL=EnvironmentMap.js.map

/***/ }),

/***/ 23529:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Executable = void 0;
const child_process = __importStar(__webpack_require__(63129));
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const EnvironmentMap_1 = __webpack_require__(75777);
const FileSystem_1 = __webpack_require__(28517);
/**
 * The Executable class provides a safe, portable, recommended solution for tools that need
 * to launch child processes.
 *
 * @remarks
 * The NodeJS child_process API provides a solution for launching child processes, however
 * its design encourages reliance on the operating system shell for certain features.
 * Invoking the OS shell is not safe, not portable, and generally not recommended:
 *
 * - Different shells have different behavior and command-line syntax, and which shell you
 *   will get with NodeJS is unpredictable.  There is no universal shell guaranteed to be
 *   available on all platforms.
 *
 * - If a command parameter contains symbol characters, a shell may interpret them, which
 *   can introduce a security vulnerability
 *
 * - Each shell has different rules for escaping these symbols.  On Windows, the default
 *   shell is incapable of escaping certain character sequences.
 *
 * The Executable API provides a pure JavaScript implementation of primitive shell-like
 * functionality for searching the default PATH, appending default file extensions on Windows,
 * and executing a file that may contain a POSIX shebang.  This primitive functionality
 * is sufficient (and recommended) for most tooling scenarios.
 *
 * If you need additional shell features such as wildcard globbing, environment variable
 * expansion, piping, or built-in commands, then we recommend to use the `@microsoft/rushell`
 * library instead.  Rushell is a pure JavaScript shell with a standard syntax that is
 * guaranteed to work consistently across all platforms.
 *
 * @public
 */
class Executable {
    /**
     * Synchronously create a child process and optionally capture its output.
     *
     * @remarks
     * This function is similar to child_process.spawnSync().  The main differences are:
     *
     * - It does not invoke the OS shell unless the executable file is a shell script.
     * - Command-line arguments containing special characters are more accurately passed
     *   through to the child process.
     * - If the filename is missing a path, then the shell's default PATH will be searched.
     * - If the filename is missing a file extension, then Windows default file extensions
     *   will be searched.
     *
     * @param filename - The name of the executable file.  This string must not contain any
     * command-line arguments.  If the name contains any path delimiters, then the shell's
     * default PATH will not be searched.
     * @param args - The command-line arguments to be passed to the process.
     * @param options - Additional options
     * @returns the same data type as returned by the NodeJS child_process.spawnSync() API
     *
     * @privateRemarks
     *
     * NOTE: The NodeJS spawnSync() returns SpawnSyncReturns<string> or SpawnSyncReturns<Buffer>
     * polymorphically based on the options.encoding parameter value.  This is a fairly confusing
     * design.  In most cases, developers want string with the default encoding.  If/when someone
     * wants binary output or a non-default text encoding, we will introduce a separate API function
     * with a name like "spawnWithBufferSync".
     */
    static spawnSync(filename, args, options) {
        if (!options) {
            options = {};
        }
        const context = Executable._getExecutableContext(options);
        const resolvedPath = Executable._tryResolve(filename, options, context);
        if (!resolvedPath) {
            throw new Error(`The executable file was not found: "${filename}"`);
        }
        const spawnOptions = {
            cwd: context.currentWorkingDirectory,
            env: context.environmentMap.toObject(),
            input: options.input,
            stdio: options.stdio,
            timeout: options.timeoutMs,
            maxBuffer: options.maxBuffer,
            // Contrary to what the NodeJS typings imply, we must explicitly specify "utf8" here
            // if we want the result to be SpawnSyncReturns<string> instead of SpawnSyncReturns<Buffer>.
            encoding: 'utf8',
            // NOTE: This is always false, because Rushell will be recommended instead of relying on the OS shell.
            shell: false
        };
        const normalizedCommandLine = Executable._buildCommandLineFixup(resolvedPath, args, context);
        return child_process.spawnSync(normalizedCommandLine.path, normalizedCommandLine.args, spawnOptions);
    }
    /**
     * Start a child process.
     *
     * @remarks
     * This function is similar to child_process.spawn().  The main differences are:
     *
     * - It does not invoke the OS shell unless the executable file is a shell script.
     * - Command-line arguments containing special characters are more accurately passed
     *   through to the child process.
     * - If the filename is missing a path, then the shell's default PATH will be searched.
     * - If the filename is missing a file extension, then Windows default file extensions
     *   will be searched.
     *
     * This command is asynchronous, but it does not return a `Promise`.  Instead it returns
     * a Node.js `ChildProcess` supporting event notifications.
     *
     * @param filename - The name of the executable file.  This string must not contain any
     * command-line arguments.  If the name contains any path delimiters, then the shell's
     * default PATH will not be searched.
     * @param args - The command-line arguments to be passed to the process.
     * @param options - Additional options
     * @returns the same data type as returned by the NodeJS child_process.spawnSync() API
     */
    static spawn(filename, args, options) {
        if (!options) {
            options = {};
        }
        const context = Executable._getExecutableContext(options);
        const resolvedPath = Executable._tryResolve(filename, options, context);
        if (!resolvedPath) {
            throw new Error(`The executable file was not found: "${filename}"`);
        }
        const spawnOptions = {
            cwd: context.currentWorkingDirectory,
            env: context.environmentMap.toObject(),
            stdio: options.stdio,
            // NOTE: This is always false, because Rushell will be recommended instead of relying on the OS shell.
            shell: false
        };
        const normalizedCommandLine = Executable._buildCommandLineFixup(resolvedPath, args, context);
        return child_process.spawn(normalizedCommandLine.path, normalizedCommandLine.args, spawnOptions);
    }
    // PROBLEM: Given an "args" array of strings that may contain special characters (e.g. spaces,
    // backslashes, quotes), ensure that these strings pass through to the child process's ARGV array
    // without anything getting corrupted along the way.
    //
    // On Unix you just pass the array to spawnSync().  But on Windows, this is a very complex problem:
    // - The Win32 CreateProcess() API expects the args to be encoded as a single text string
    // - The decoding of this string is up to the application (not the OS), and there are 3 different
    //   algorithms in common usage:  the cmd.exe shell, the Microsoft CRT library init code, and
    //   the Win32 CommandLineToArgvW()
    // - The encodings are counterintuitive and have lots of special cases
    // - NodeJS spawnSync() tries do the encoding without knowing which decoder will be used
    //
    // See these articles for a full analysis:
    // http://www.windowsinspired.com/understanding-the-command-line-string-and-arguments-received-by-a-windows-program/
    // http://www.windowsinspired.com/how-a-windows-programs-splits-its-command-line-into-individual-arguments/
    static _buildCommandLineFixup(resolvedPath, args, context) {
        const fileExtension = path.extname(resolvedPath);
        if (os.platform() === 'win32') {
            // Do we need a custom handler for this file type?
            switch (fileExtension.toUpperCase()) {
                case '.EXE':
                case '.COM':
                    // okay to execute directly
                    break;
                case '.BAT':
                case '.CMD': {
                    Executable._validateArgsForWindowsShell(args);
                    // These file types must be invoked via the Windows shell
                    let shellPath = context.environmentMap.get('COMSPEC');
                    if (!shellPath || !Executable._canExecute(shellPath, context)) {
                        shellPath = Executable.tryResolve('cmd.exe');
                    }
                    if (!shellPath) {
                        throw new Error(`Unable to execute "${path.basename(resolvedPath)}" ` +
                            `because CMD.exe was not found in the PATH`);
                    }
                    const shellArgs = [];
                    // /D: Disable execution of AutoRun commands when starting the new shell context
                    shellArgs.push('/d');
                    // /S: Disable Cmd.exe's parsing of double-quote characters inside the command-line
                    shellArgs.push('/s');
                    // /C: Execute the following command and then exit immediately
                    shellArgs.push('/c');
                    // If the path contains special charactrers (e.g. spaces), escape them so that
                    // they don't get interpreted by the shell
                    shellArgs.push(Executable._getEscapedForWindowsShell(resolvedPath));
                    shellArgs.push(...args);
                    return { path: shellPath, args: shellArgs };
                }
                default:
                    throw new Error(`Cannot execute "${path.basename(resolvedPath)}" because the file type is not supported`);
            }
        }
        return {
            path: resolvedPath,
            args: args
        };
    }
    /**
     * Given a filename, this determines the absolute path of the executable file that would
     * be executed by a shell:
     *
     * - If the filename is missing a path, then the shell's default PATH will be searched.
     * - If the filename is missing a file extension, then Windows default file extensions
     *   will be searched.
     *
     * @remarks
     *
     * @param filename - The name of the executable file.  This string must not contain any
     * command-line arguments.  If the name contains any path delimiters, then the shell's
     * default PATH will not be searched.
     * @param options - optional other parameters
     * @returns the absolute path of the executable, or undefined if it was not found
     */
    static tryResolve(filename, options) {
        return Executable._tryResolve(filename, options || {}, Executable._getExecutableContext(options));
    }
    static _tryResolve(filename, options, context) {
        // NOTE: Since "filename" cannot contain command-line arguments, the "/" here
        // must be interpreted as a path delimiter
        const hasPathSeparators = filename.indexOf('/') >= 0 || (os.platform() === 'win32' && filename.indexOf('\\') >= 0);
        // Are there any path separators?
        if (hasPathSeparators) {
            // If so, then don't search the PATH.  Just resolve relative to the current working directory
            const resolvedPath = path.resolve(context.currentWorkingDirectory, filename);
            return Executable._tryResolveFileExtension(resolvedPath, context);
        }
        else {
            // Otherwise if it's a bare name, then try everything in the shell PATH
            const pathsToSearch = Executable._getSearchFolders(context);
            for (const pathToSearch of pathsToSearch) {
                const resolvedPath = path.join(pathToSearch, filename);
                const result = Executable._tryResolveFileExtension(resolvedPath, context);
                if (result) {
                    return result;
                }
            }
            // No match was found
            return undefined;
        }
    }
    static _tryResolveFileExtension(resolvedPath, context) {
        if (Executable._canExecute(resolvedPath, context)) {
            return resolvedPath;
        }
        // Try the default file extensions
        for (const shellExtension of context.windowsExecutableExtensions) {
            const resolvedNameWithExtension = resolvedPath + shellExtension;
            if (Executable._canExecute(resolvedNameWithExtension, context)) {
                return resolvedNameWithExtension;
            }
        }
        return undefined;
    }
    static _buildEnvironmentMap(options) {
        const environmentMap = new EnvironmentMap_1.EnvironmentMap();
        if (options.environment !== undefined && options.environmentMap !== undefined) {
            throw new Error('IExecutableResolveOptions.environment and IExecutableResolveOptions.environmentMap' +
                ' cannot both be specified');
        }
        if (options.environment !== undefined) {
            environmentMap.mergeFromObject(options.environment);
        }
        else if (options.environmentMap !== undefined) {
            environmentMap.mergeFrom(options.environmentMap);
        }
        else {
            environmentMap.mergeFromObject(process.env);
        }
        return environmentMap;
    }
    /**
     * This is used when searching the shell PATH for an executable, to determine
     * whether a match should be skipped or not.  If it returns true, this does not
     * guarantee that the file can be successfully executed.
     */
    static _canExecute(filePath, context) {
        if (!FileSystem_1.FileSystem.exists(filePath)) {
            return false;
        }
        if (os.platform() === 'win32') {
            // NOTE: For Windows, we don't validate that the file extension appears in PATHEXT.
            // That environment variable determines which extensions can be appended if the
            // extension is missing, but it does not affect whether a file may be executed or not.
            // Windows does have a (seldom used) ACL that can be used to deny execution permissions
            // for a file, but NodeJS doesn't expose that API, so we don't bother checking it.
            // However, Windows *does* require that the file has some kind of file extension
            if (path.extname(filePath) === '') {
                return false;
            }
        }
        else {
            // For Unix, check whether any of the POSIX execute bits are set
            try {
                // eslint-disable-next-line no-bitwise
                if ((FileSystem_1.FileSystem.getPosixModeBits(filePath) & 73 /* AllExecute */) === 0) {
                    return false; // not executable
                }
            }
            catch (error) {
                // If we have trouble accessing the file, ignore the error and consider it "not executable"
                // since that's what a shell would do
            }
        }
        return true;
    }
    /**
     * Returns the list of folders where we will search for an executable,
     * based on the PATH environment variable.
     */
    static _getSearchFolders(context) {
        const pathList = context.environmentMap.get('PATH') || '';
        const folders = [];
        // Avoid processing duplicates
        const seenPaths = new Set();
        // NOTE: Cmd.exe on Windows always searches the current working directory first.
        // PowerShell and Unix shells do NOT do that, because it's a security concern.
        // We follow their behavior.
        for (const splitPath of pathList.split(path.delimiter)) {
            const trimmedPath = splitPath.trim();
            if (trimmedPath !== '') {
                if (!seenPaths.has(trimmedPath)) {
                    // Fun fact: If you put relative paths in your PATH environment variable,
                    // all shells will dynamically match them against the current working directory.
                    // This is a terrible design, and in practice nobody does that, but it is supported...
                    // so we allow it here.
                    const resolvedPath = path.resolve(context.currentWorkingDirectory, trimmedPath);
                    if (!seenPaths.has(resolvedPath)) {
                        if (FileSystem_1.FileSystem.exists(resolvedPath)) {
                            folders.push(resolvedPath);
                        }
                        seenPaths.add(resolvedPath);
                    }
                    seenPaths.add(trimmedPath);
                }
            }
        }
        return folders;
    }
    static _getExecutableContext(options) {
        if (!options) {
            options = {};
        }
        const environment = Executable._buildEnvironmentMap(options);
        let currentWorkingDirectory;
        if (options.currentWorkingDirectory) {
            currentWorkingDirectory = path.resolve(options.currentWorkingDirectory);
        }
        else {
            currentWorkingDirectory = process.cwd();
        }
        const windowsExecutableExtensions = [];
        if (os.platform() === 'win32') {
            const pathExtVariable = environment.get('PATHEXT') || '';
            for (const splitValue of pathExtVariable.split(';')) {
                const trimmed = splitValue.trim().toLowerCase();
                // Ignore malformed extensions
                if (/^\.[a-z0-9\.]*[a-z0-9]$/i.test(trimmed)) {
                    // Don't add the same extension twice
                    if (windowsExecutableExtensions.indexOf(trimmed) < 0) {
                        windowsExecutableExtensions.push(trimmed);
                    }
                }
            }
        }
        return {
            environmentMap: environment,
            currentWorkingDirectory,
            windowsExecutableExtensions
        };
    }
    /**
     * Given an input string containing special symbol characters, this inserts the "^" escape
     * character to ensure the symbols are interpreted literally by the Windows shell.
     */
    static _getEscapedForWindowsShell(text) {
        const escapableCharRegExp = /[%\^&|<> ]/g;
        return text.replace(escapableCharRegExp, (value) => '^' + value);
    }
    /**
     * Checks for characters that are unsafe to pass to a Windows batch file
     * due to the way that cmd.exe implements escaping.
     */
    static _validateArgsForWindowsShell(args) {
        const specialCharRegExp = /[%\^&|<>\r\n]/g;
        for (const arg of args) {
            const match = arg.match(specialCharRegExp);
            if (match) {
                // NOTE: It is possible to escape some of these characters by prefixing them
                // with a caret (^), which allows these characters to be successfully passed
                // through to the batch file %1 variables.  But they will be expanded again
                // whenever they are used.  For example, NPM's binary wrapper batch files
                // use "%*" to pass their arguments to Node.exe, which causes them to be expanded
                // again.  Unfortunately the Cmd.exe batch language provides native escaping
                // function (that could be used to insert the carets again).
                //
                // We could work around that by adding double carets, but in general there
                // is no way to predict how many times the variable will get expanded.
                // Thus, there is no generally reliable way to pass these characters.
                throw new Error(`The command line argument ${JSON.stringify(arg)} contains a` +
                    ` special character ${JSON.stringify(match[0])} that cannot be escaped for the Windows shell`);
            }
        }
    }
}
exports.Executable = Executable;
//# sourceMappingURL=Executable.js.map

/***/ }),

/***/ 28517:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileSystem = void 0;
const nodeJsPath = __importStar(__webpack_require__(85622));
const fs = __importStar(__webpack_require__(35747));
const fsx = __importStar(__webpack_require__(5630));
const Text_1 = __webpack_require__(28188);
const MOVE_DEFAULT_OPTIONS = {
    overwrite: true,
    ensureFolderExists: false
};
const READ_FOLDER_DEFAULT_OPTIONS = {
    absolutePaths: false
};
const WRITE_FILE_DEFAULT_OPTIONS = {
    ensureFolderExists: false,
    convertLineEndings: undefined,
    encoding: "utf8" /* Utf8 */
};
const APPEND_TO_FILE_DEFAULT_OPTIONS = Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS);
const READ_FILE_DEFAULT_OPTIONS = {
    encoding: "utf8" /* Utf8 */,
    convertLineEndings: undefined
};
const COPY_FILE_DEFAULT_OPTIONS = {
    alreadyExistsBehavior: "overwrite" /* Overwrite */
};
const COPY_FILES_DEFAULT_OPTIONS = {
    alreadyExistsBehavior: "overwrite" /* Overwrite */
};
const DELETE_FILE_DEFAULT_OPTIONS = {
    throwIfNotExists: false
};
/**
 * The FileSystem API provides a complete set of recommended operations for interacting with the file system.
 *
 * @remarks
 * We recommend to use this instead of the native `fs` API, because `fs` is a minimal set of low-level
 * primitives that must be mapped for each supported operating system. The FileSystem API takes a
 * philosophical approach of providing "one obvious way" to do each operation. We also prefer synchronous
 * operations except in cases where there would be a clear performance benefit for using async, since synchronous
 * code is much easier to read and debug. Also, indiscriminate parallelism has been seen to actually worsen
 * performance, versus improving it.
 *
 * Note that in the documentation, we refer to "filesystem objects", this can be a
 * file, folder, symbolic link, hard link, directory junction, etc.
 *
 * @public
 */
class FileSystem {
    // ===============
    // COMMON OPERATIONS
    // ===============
    /**
     * Returns true if the path exists on disk.
     * Behind the scenes it uses `fs.existsSync()`.
     * @remarks
     * There is a debate about the fact that after `fs.existsSync()` returns true,
     * the file might be deleted before fs.readSync() is called, which would imply that everybody
     * should catch a `readSync()` exception, and nobody should ever use `fs.existsSync()`.
     * We find this to be unpersuasive, since "unexceptional exceptions" really hinder the
     * break-on-exception debugging experience. Also, throwing/catching is generally slow.
     * @param path - The absolute or relative path to the filesystem object.
     */
    static exists(path) {
        return FileSystem._wrapException(() => {
            return fsx.existsSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.exists}.
     */
    static async existsAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return new Promise((resolve) => {
                fsx.exists(path, resolve);
            });
        });
    }
    /**
     * Gets the statistics for a particular filesystem object.
     * If the path is a link, this function follows the link and returns statistics about the link target.
     * Behind the scenes it uses `fs.statSync()`.
     * @param path - The absolute or relative path to the filesystem object.
     */
    static getStatistics(path) {
        return FileSystem._wrapException(() => {
            return fsx.statSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.getStatistics}.
     */
    static async getStatisticsAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.stat(path);
        });
    }
    /**
     * Updates the accessed and modified timestamps of the filesystem object referenced by path.
     * Behind the scenes it uses `fs.utimesSync()`.
     * The caller should specify both times in the `times` parameter.
     * @param path - The path of the file that should be modified.
     * @param times - The times that the object should be updated to reflect.
     */
    static updateTimes(path, times) {
        return FileSystem._wrapException(() => {
            fsx.utimesSync(path, times.accessedTime, times.modifiedTime);
        });
    }
    /**
     * An async version of {@link FileSystem.updateTimes}.
     */
    static async updateTimesAsync(path, times) {
        await FileSystem._wrapExceptionAsync(() => {
            // This cast is needed because the fs-extra typings require both parameters
            // to have the same type (number or Date), whereas Node.js does not require that.
            return fsx.utimes(path, times.accessedTime, times.modifiedTime);
        });
    }
    /**
     * Changes the permissions (i.e. file mode bits) for a filesystem object.
     * Behind the scenes it uses `fs.chmodSync()`.
     * @param path - The absolute or relative path to the object that should be updated.
     * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum
     */
    static changePosixModeBits(path, mode) {
        FileSystem._wrapException(() => {
            fs.chmodSync(path, mode);
        });
    }
    /**
     * An async version of {@link FileSystem.changePosixModeBits}.
     */
    static async changePosixModeBitsAsync(path, mode) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.chmod(path, mode);
        });
    }
    /**
     * Retrieves the permissions (i.e. file mode bits) for a filesystem object.
     * Behind the scenes it uses `fs.chmodSync()`.
     * @param path - The absolute or relative path to the object that should be updated.
     *
     * @remarks
     * This calls {@link FileSystem.getStatistics} to get the POSIX mode bits.
     * If statistics in addition to the mode bits are needed, it is more efficient
     * to call {@link FileSystem.getStatistics} directly instead.
     */
    static getPosixModeBits(path) {
        return FileSystem._wrapException(() => {
            return FileSystem.getStatistics(path).mode;
        });
    }
    /**
     * An async version of {@link FileSystem.getPosixModeBits}.
     */
    static async getPosixModeBitsAsync(path) {
        return await FileSystem._wrapExceptionAsync(async () => {
            return (await FileSystem.getStatisticsAsync(path)).mode;
        });
    }
    /**
     * Returns a 10-character string representation of a PosixModeBits value similar to what
     * would be displayed by a command such as "ls -l" on a POSIX-like operating system.
     * @remarks
     * For example, `PosixModeBits.AllRead | PosixModeBits.AllWrite` would be formatted as "-rw-rw-rw-".
     * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum
     */
    static formatPosixModeBits(modeBits) {
        let result = '-'; // (later we may add support for additional states such as S_IFDIR or S_ISUID)
        result += modeBits & 256 /* UserRead */ ? 'r' : '-';
        result += modeBits & 128 /* UserWrite */ ? 'w' : '-';
        result += modeBits & 64 /* UserExecute */ ? 'x' : '-';
        result += modeBits & 32 /* GroupRead */ ? 'r' : '-';
        result += modeBits & 16 /* GroupWrite */ ? 'w' : '-';
        result += modeBits & 8 /* GroupExecute */ ? 'x' : '-';
        result += modeBits & 4 /* OthersRead */ ? 'r' : '-';
        result += modeBits & 2 /* OthersWrite */ ? 'w' : '-';
        result += modeBits & 1 /* OthersExecute */ ? 'x' : '-';
        return result;
    }
    /**
     * Moves a file. The folder must exist, unless the `ensureFolderExists` option is provided.
     * Behind the scenes it uses `fs-extra.moveSync()`
     */
    static move(options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, MOVE_DEFAULT_OPTIONS), options);
            try {
                fsx.moveSync(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(options.destinationPath);
                    FileSystem.ensureFolder(folderPath);
                    fsx.moveSync(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.move}.
     */
    static async moveAsync(options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, MOVE_DEFAULT_OPTIONS), options);
            try {
                await fsx.move(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(options.destinationPath);
                    await FileSystem.ensureFolderAsync(nodeJsPath.dirname(folderPath));
                    await fsx.move(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
                }
                else {
                    throw error;
                }
            }
        });
    }
    // ===============
    // FOLDER OPERATIONS
    // ===============
    /**
     * Recursively creates a folder at a given path.
     * Behind the scenes is uses `fs-extra.ensureDirSync()`.
     * @remarks
     * Throws an exception if anything in the folderPath is not a folder.
     * @param folderPath - The absolute or relative path of the folder which should be created.
     */
    static ensureFolder(folderPath) {
        FileSystem._wrapException(() => {
            fsx.ensureDirSync(folderPath);
        });
    }
    /**
     * An async version of {@link FileSystem.ensureFolder}.
     */
    static async ensureFolderAsync(folderPath) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.ensureDir(folderPath);
        });
    }
    /**
     * Reads the contents of the folder, not including "." or "..".
     * Behind the scenes it uses `fs.readdirSync()`.
     * @param folderPath - The absolute or relative path to the folder which should be read.
     * @param options - Optional settings that can change the behavior. Type: `IReadFolderOptions`
     */
    static readFolder(folderPath, options) {
        return FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, READ_FOLDER_DEFAULT_OPTIONS), options);
            // @todo: Update this to use Node 10's `withFileTypes: true` option when we drop support for Node 8
            const fileNames = fsx.readdirSync(folderPath);
            if (options.absolutePaths) {
                return fileNames.map((fileName) => nodeJsPath.resolve(folderPath, fileName));
            }
            else {
                return fileNames;
            }
        });
    }
    /**
     * An async version of {@link FileSystem.readFolder}.
     */
    static async readFolderAsync(folderPath, options) {
        return await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, READ_FOLDER_DEFAULT_OPTIONS), options);
            // @todo: Update this to use Node 10's `withFileTypes: true` option when we drop support for Node 8
            const fileNames = await fsx.readdir(folderPath);
            if (options.absolutePaths) {
                return fileNames.map((fileName) => nodeJsPath.resolve(folderPath, fileName));
            }
            else {
                return fileNames;
            }
        });
    }
    /**
     * Deletes a folder, including all of its contents.
     * Behind the scenes is uses `fs-extra.removeSync()`.
     * @remarks
     * Does not throw if the folderPath does not exist.
     * @param folderPath - The absolute or relative path to the folder which should be deleted.
     */
    static deleteFolder(folderPath) {
        FileSystem._wrapException(() => {
            fsx.removeSync(folderPath);
        });
    }
    /**
     * An async version of {@link FileSystem.deleteFolder}.
     */
    static async deleteFolderAsync(folderPath) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.remove(folderPath);
        });
    }
    /**
     * Deletes the content of a folder, but not the folder itself. Also ensures the folder exists.
     * Behind the scenes it uses `fs-extra.emptyDirSync()`.
     * @remarks
     * This is a workaround for a common race condition, where the virus scanner holds a lock on the folder
     * for a brief period after it was deleted, causing EBUSY errors for any code that tries to recreate the folder.
     * @param folderPath - The absolute or relative path to the folder which should have its contents deleted.
     */
    static ensureEmptyFolder(folderPath) {
        FileSystem._wrapException(() => {
            fsx.emptyDirSync(folderPath);
        });
    }
    /**
     * An async version of {@link FileSystem.ensureEmptyFolder}.
     */
    static async ensureEmptyFolderAsync(folderPath) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.emptyDir(folderPath);
        });
    }
    // ===============
    // FILE OPERATIONS
    // ===============
    /**
     * Writes a text string to a file on disk, overwriting the file if it already exists.
     * Behind the scenes it uses `fs.writeFileSync()`.
     * @remarks
     * Throws an error if the folder doesn't exist, unless ensureFolder=true.
     * @param filePath - The absolute or relative path of the file.
     * @param contents - The text that should be written to the file.
     * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`
     */
    static writeFile(filePath, contents, options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                fsx.writeFileSync(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    FileSystem.ensureFolder(folderPath);
                    fsx.writeFileSync(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.writeFile}.
     */
    static async writeFileAsync(filePath, contents, options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                await fsx.writeFile(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    await FileSystem.ensureFolderAsync(folderPath);
                    await fsx.writeFile(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * Writes a text string to a file on disk, appending to the file if it already exists.
     * Behind the scenes it uses `fs.appendFileSync()`.
     * @remarks
     * Throws an error if the folder doesn't exist, unless ensureFolder=true.
     * @param filePath - The absolute or relative path of the file.
     * @param contents - The text that should be written to the file.
     * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`
     */
    static appendToFile(filePath, contents, options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, APPEND_TO_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                fsx.appendFileSync(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    FileSystem.ensureFolder(folderPath);
                    fsx.appendFileSync(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.appendToFile}.
     */
    static async appendToFileAsync(filePath, contents, options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, APPEND_TO_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                await fsx.appendFile(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    await FileSystem.ensureFolderAsync(folderPath);
                    await fsx.appendFile(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * Reads the contents of a file into a string.
     * Behind the scenes it uses `fs.readFileSync()`.
     * @param filePath - The relative or absolute path to the file whose contents should be read.
     * @param options - Optional settings that can change the behavior. Type: `IReadFileOptions`
     */
    static readFile(filePath, options) {
        return FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, READ_FILE_DEFAULT_OPTIONS), options);
            let contents = FileSystem.readFileToBuffer(filePath).toString(options.encoding);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents, options.convertLineEndings);
            }
            return contents;
        });
    }
    /**
     * An async version of {@link FileSystem.readFile}.
     */
    static async readFileAsync(filePath, options) {
        return await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, READ_FILE_DEFAULT_OPTIONS), options);
            let contents = (await FileSystem.readFileToBufferAsync(filePath)).toString(options.encoding);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents, options.convertLineEndings);
            }
            return contents;
        });
    }
    /**
     * Reads the contents of a file into a buffer.
     * Behind the scenes is uses `fs.readFileSync()`.
     * @param filePath - The relative or absolute path to the file whose contents should be read.
     */
    static readFileToBuffer(filePath) {
        return FileSystem._wrapException(() => {
            return fsx.readFileSync(filePath);
        });
    }
    /**
     * An async version of {@link FileSystem.readFileToBuffer}.
     */
    static async readFileToBufferAsync(filePath) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.readFile(filePath);
        });
    }
    /**
     * Copies a single file from one location to another.
     * By default, destinationPath is overwritten if it already exists.
     *
     * @remarks
     * The `copyFile()` API cannot be used to copy folders.  It copies at most one file.
     * Use {@link FileSystem.copyFiles} if you need to recursively copy a tree of folders.
     *
     * The implementation is based on `copySync()` from the `fs-extra` package.
     */
    static copyFile(options) {
        options = Object.assign(Object.assign({}, COPY_FILE_DEFAULT_OPTIONS), options);
        if (FileSystem.getStatistics(options.sourcePath).isDirectory()) {
            throw new Error('The specified path refers to a folder; this operation expects a file object:\n' + options.sourcePath);
        }
        FileSystem._wrapException(() => {
            fsx.copySync(options.sourcePath, options.destinationPath, {
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */
            });
        });
    }
    /**
     * An async version of {@link FileSystem.copyFile}.
     */
    static async copyFileAsync(options) {
        options = Object.assign(Object.assign({}, COPY_FILE_DEFAULT_OPTIONS), options);
        if (FileSystem.getStatistics(options.sourcePath).isDirectory()) {
            throw new Error('The specified path refers to a folder; this operation expects a file object:\n' + options.sourcePath);
        }
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.copy(options.sourcePath, options.destinationPath, {
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */
            });
        });
    }
    /**
     * Copies a file or folder from one location to another, recursively copying any folder contents.
     * By default, destinationPath is overwritten if it already exists.
     *
     * @remarks
     * If you only intend to copy a single file, it is recommended to use {@link FileSystem.copyFile}
     * instead to more clearly communicate the intended operation.
     *
     * The implementation is based on `copySync()` from the `fs-extra` package.
     */
    static copyFiles(options) {
        options = Object.assign(Object.assign({}, COPY_FILES_DEFAULT_OPTIONS), options);
        FileSystem._wrapException(() => {
            fsx.copySync(options.sourcePath, options.destinationPath, {
                dereference: !!options.dereferenceSymlinks,
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */,
                preserveTimestamps: !!options.preserveTimestamps,
                filter: options.filter
            });
        });
    }
    /**
     * An async version of {@link FileSystem.copyFiles}.
     */
    static async copyFilesAsync(options) {
        options = Object.assign(Object.assign({}, COPY_FILES_DEFAULT_OPTIONS), options);
        await FileSystem._wrapExceptionAsync(async () => {
            fsx.copySync(options.sourcePath, options.destinationPath, {
                dereference: !!options.dereferenceSymlinks,
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */,
                preserveTimestamps: !!options.preserveTimestamps,
                filter: options.filter
            });
        });
    }
    /**
     * Deletes a file. Can optionally throw if the file doesn't exist.
     * Behind the scenes it uses `fs.unlinkSync()`.
     * @param filePath - The absolute or relative path to the file that should be deleted.
     * @param options - Optional settings that can change the behavior. Type: `IDeleteFileOptions`
     */
    static deleteFile(filePath, options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, DELETE_FILE_DEFAULT_OPTIONS), options);
            try {
                fsx.unlinkSync(filePath);
            }
            catch (error) {
                if (options.throwIfNotExists || !FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.deleteFile}.
     */
    static async deleteFileAsync(filePath, options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, DELETE_FILE_DEFAULT_OPTIONS), options);
            try {
                await fsx.unlink(filePath);
            }
            catch (error) {
                if (options.throwIfNotExists || !FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        });
    }
    // ===============
    // LINK OPERATIONS
    // ===============
    /**
     * Gets the statistics of a filesystem object. Does NOT follow the link to its target.
     * Behind the scenes it uses `fs.lstatSync()`.
     * @param path - The absolute or relative path to the filesystem object.
     */
    static getLinkStatistics(path) {
        return FileSystem._wrapException(() => {
            return fsx.lstatSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.getLinkStatistics}.
     */
    static async getLinkStatisticsAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.lstat(path);
        });
    }
    /**
     * If `path` refers to a symbolic link, this returns the path of the link target, which may be
     * an absolute or relative path.
     *
     * @remarks
     * If `path` refers to a filesystem object that is not a symbolic link, then an `ErrnoException` is thrown
     * with code 'UNKNOWN'.  If `path` does not exist, then an `ErrnoException` is thrown with code `ENOENT`.
     *
     * @param path - The absolute or relative path to the symbolic link.
     * @returns the path of the link target
     */
    static readLink(path) {
        return FileSystem._wrapException(() => {
            return fsx.readlinkSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.readLink}.
     */
    static async readLinkAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.readlink(path);
        });
    }
    /**
     * Creates an NTFS "directory junction" on Windows operating systems; for other operating systems, it
     * creates a regular symbolic link.  The link target must be a folder, not a file.
     * Behind the scenes it uses `fs.symlinkSync()`.
     *
     * @remarks
     * For security reasons, Windows operating systems by default require administrator elevation to create
     * symbolic links.  As a result, on Windows it's generally recommended for Node.js tools to use hard links
     * (for files) or NTFS directory junctions (for folders), since regular users are allowed to create them.
     * Hard links and junctions are less vulnerable to symlink attacks because they cannot reference a network share,
     * and their target must exist at the time of link creation.  Non-Windows operating systems generally don't
     * restrict symlink creation, and as such are more vulnerable to symlink attacks.  Note that Windows can be
     * configured to permit regular users to create symlinks, for example by enabling Windows 10 "developer mode."
     *
     * A directory junction requires the link source and target to both be located on local disk volumes;
     * if not, use a symbolic link instead.
     */
    static createSymbolicLinkJunction(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                // For directories, we use a Windows "junction".  On POSIX operating systems, this produces a regular symlink.
                return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'junction');
            }, options);
        });
    }
    /**
     * An async version of {@link FileSystem.createSymbolicLinkJunction}.
     */
    static async createSymbolicLinkJunctionAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                // For directories, we use a Windows "junction".  On POSIX operating systems, this produces a regular symlink.
                return fsx.symlink(options.linkTargetPath, options.newLinkPath, 'junction');
            }, options);
        });
    }
    /**
     * Creates a symbolic link to a file.  On Windows operating systems, this may require administrator elevation.
     * Behind the scenes it uses `fs.symlinkSync()`.
     *
     * @remarks
     * To avoid administrator elevation on Windows, use {@link FileSystem.createHardLink} instead.
     *
     * On Windows operating systems, the NTFS file system distinguishes file symlinks versus directory symlinks:
     * If the target is not the correct type, the symlink will be created successfully, but will fail to resolve.
     * Other operating systems do not make this distinction, in which case {@link FileSystem.createSymbolicLinkFile}
     * and {@link FileSystem.createSymbolicLinkFolder} can be used interchangeably, but doing so will make your
     * tool incompatible with Windows.
     */
    static createSymbolicLinkFile(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'file');
            }, options);
        });
    }
    /**
     * An async version of {@link FileSystem.createSymbolicLinkFile}.
     */
    static async createSymbolicLinkFileAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                return fsx.symlink(options.linkTargetPath, options.newLinkPath, 'file');
            }, options);
        });
    }
    /**
     * Creates a symbolic link to a folder.  On Windows operating systems, this may require administrator elevation.
     * Behind the scenes it uses `fs.symlinkSync()`.
     *
     * @remarks
     * To avoid administrator elevation on Windows, use {@link FileSystem.createSymbolicLinkJunction} instead.
     *
     * On Windows operating systems, the NTFS file system distinguishes file symlinks versus directory symlinks:
     * If the target is not the correct type, the symlink will be created successfully, but will fail to resolve.
     * Other operating systems do not make this distinction, in which case {@link FileSystem.createSymbolicLinkFile}
     * and {@link FileSystem.createSymbolicLinkFolder} can be used interchangeably, but doing so will make your
     * tool incompatible with Windows.
     */
    static createSymbolicLinkFolder(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'dir');
            }, options);
        });
    }
    /**
     * An async version of {@link FileSystem.createSymbolicLinkFolder}.
     */
    static async createSymbolicLinkFolderAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                return fsx.symlink(options.linkTargetPath, options.newLinkPath, 'dir');
            }, options);
        });
    }
    /**
     * Creates a hard link.  The link target must be a file, not a folder.
     * Behind the scenes it uses `fs.linkSync()`.
     *
     * @remarks
     * For security reasons, Windows operating systems by default require administrator elevation to create
     * symbolic links.  As a result, on Windows it's generally recommended for Node.js tools to use hard links
     * (for files) or NTFS directory junctions (for folders), since regular users are allowed to create them.
     * Hard links and junctions are less vulnerable to symlink attacks because they cannot reference a network share,
     * and their target must exist at the time of link creation.  Non-Windows operating systems generally don't
     * restrict symlink creation, and as such are more vulnerable to symlink attacks.  Note that Windows can be
     * configured to permit regular users to create symlinks, for example by enabling Windows 10 "developer mode."
     *
     * A hard link requires the link source and target to both be located on same disk volume;
     * if not, use a symbolic link instead.
     */
    static createHardLink(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                return fsx.linkSync(options.linkTargetPath, options.newLinkPath);
            }, Object.assign(Object.assign({}, options), { linkTargetMustExist: true }));
        });
    }
    /**
     * An async version of {@link FileSystem.createHardLink}.
     */
    static async createHardLinkAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                return fsx.link(options.linkTargetPath, options.newLinkPath);
            }, Object.assign(Object.assign({}, options), { linkTargetMustExist: true }));
        });
    }
    /**
     * Follows a link to its destination and returns the absolute path to the final target of the link.
     * Behind the scenes it uses `fs.realpathSync()`.
     * @param linkPath - The path to the link.
     */
    static getRealPath(linkPath) {
        return FileSystem._wrapException(() => {
            return fsx.realpathSync(linkPath);
        });
    }
    /**
     * An async version of {@link FileSystem.getRealPath}.
     */
    static async getRealPathAsync(linkPath) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.realpath(linkPath);
        });
    }
    // ===============
    // UTILITY FUNCTIONS
    // ===============
    /**
     * Returns true if the error object indicates the file or folder already exists (`EEXIST`).
     */
    static isExistError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'EEXIST';
    }
    /**
     * Returns true if the error object indicates the file or folder does not exist (`ENOENT` or `ENOTDIR`)
     */
    static isNotExistError(error) {
        return FileSystem.isFileDoesNotExistError(error) || FileSystem.isFolderDoesNotExistError(error);
    }
    /**
     * Returns true if the error object indicates the file does not exist (`ENOENT`).
     */
    static isFileDoesNotExistError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'ENOENT';
    }
    /**
     * Returns true if the error object indicates the folder does not exist (`ENOTDIR`).
     */
    static isFolderDoesNotExistError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'ENOTDIR';
    }
    /**
     * Returns true if the error object indicates that the `unlink` system call failed
     * due to a permissions issue (`EPERM`).
     */
    static isUnlinkNotPermittedError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'EPERM' && error.syscall === 'unlink';
    }
    /**
     * Detects if the provided error object is a `NodeJS.ErrnoException`
     */
    static isErrnoException(error) {
        const typedError = error;
        return (typeof typedError.code === 'string' &&
            typeof typedError.errno === 'number' &&
            typeof typedError.path === 'string' &&
            typeof typedError.syscall === 'string');
    }
    static _handleLink(linkFn, options) {
        try {
            linkFn();
        }
        catch (error) {
            if (FileSystem.isExistError(error)) {
                // Link exists, handle it
                switch (options.alreadyExistsBehavior) {
                    case "ignore" /* Ignore */:
                        break;
                    case "overwrite" /* Overwrite */:
                        // fsx.linkSync does not allow overwriting so we must manually delete. If it's
                        // a folder, it will throw an error.
                        this.deleteFile(options.newLinkPath);
                        linkFn();
                        break;
                    case "error" /* Error */:
                    default:
                        throw error;
                }
            }
            else {
                // When attempting to create a link in a directory that does not exist, an ENOENT
                // or ENOTDIR error is thrown, so we should ensure the directory exists before
                // retrying. There are also cases where the target file must exist, so validate in
                // those cases to avoid confusing the missing directory with the missing target file.
                if (FileSystem.isNotExistError(error) &&
                    (!options.linkTargetMustExist || FileSystem.exists(options.linkTargetPath))) {
                    this.ensureFolder(nodeJsPath.dirname(options.newLinkPath));
                    linkFn();
                }
                else {
                    throw error;
                }
            }
        }
    }
    static async _handleLinkAsync(linkFn, options) {
        try {
            await linkFn();
        }
        catch (error) {
            if (FileSystem.isExistError(error)) {
                // Link exists, handle it
                switch (options.alreadyExistsBehavior) {
                    case "ignore" /* Ignore */:
                        break;
                    case "overwrite" /* Overwrite */:
                        // fsx.linkSync does not allow overwriting so we must manually delete. If it's
                        // a folder, it will throw an error.
                        await this.deleteFileAsync(options.newLinkPath);
                        await linkFn();
                        break;
                    case "error" /* Error */:
                    default:
                        throw error;
                }
            }
            else {
                // When attempting to create a link in a directory that does not exist, an ENOENT
                // or ENOTDIR error is thrown, so we should ensure the directory exists before
                // retrying. There are also cases where the target file must exist, so validate in
                // those cases to avoid confusing the missing directory with the missing target file.
                if (FileSystem.isNotExistError(error) &&
                    (!options.linkTargetMustExist || (await FileSystem.existsAsync(options.linkTargetPath)))) {
                    await this.ensureFolderAsync(nodeJsPath.dirname(options.newLinkPath));
                    await linkFn();
                }
                else {
                    throw error;
                }
            }
        }
    }
    static _wrapException(fn) {
        try {
            return fn();
        }
        catch (error) {
            FileSystem._updateErrorMessage(error);
            throw error;
        }
    }
    static async _wrapExceptionAsync(fn) {
        try {
            return await fn();
        }
        catch (error) {
            FileSystem._updateErrorMessage(error);
            throw error;
        }
    }
    static _updateErrorMessage(error) {
        if (FileSystem.isErrnoException(error)) {
            if (FileSystem.isFileDoesNotExistError(error)) {
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `File does not exist: ${error.path}\n${error.message}`;
            }
            else if (FileSystem.isFolderDoesNotExistError(error)) {
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `Folder does not exist: ${error.path}\n${error.message}`;
            }
            else if (FileSystem.isExistError(error)) {
                // Oddly, the typing does not include the `dest` property even though the documentation
                // indicates it is there: https://nodejs.org/docs/latest-v10.x/api/errors.html#errors_error_dest
                const extendedError = error;
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `File or folder already exists: ${extendedError.dest}\n${error.message}`;
            }
            else if (FileSystem.isUnlinkNotPermittedError(error)) {
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `File or folder could not be deleted: ${error.path}\n${error.message}`;
            }
        }
    }
}
exports.FileSystem = FileSystem;
//# sourceMappingURL=FileSystem.js.map

/***/ }),

/***/ 24064:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileWriter = void 0;
const Import_1 = __webpack_require__(26302);
const fsx = Import_1.Import.lazy('fs-extra', require);
/**
 * API for interacting with file handles.
 * @public
 */
class FileWriter {
    constructor(fileDescriptor, filePath) {
        this._fileDescriptor = fileDescriptor;
        this.filePath = filePath;
    }
    /**
     * Opens a new file handle to the file at the specified path and given mode.
     * Behind the scenes it uses `fs.openSync()`.
     * The behaviour of this function is platform specific.
     * See: https://nodejs.org/docs/latest-v8.x/api/fs.html#fs_fs_open_path_flags_mode_callback
     * @param filePath - The absolute or relative path to the file handle that should be opened.
     * @param flags - The flags for opening the handle
     */
    static open(filePath, flags) {
        return new FileWriter(fsx.openSync(filePath, FileWriter._convertFlagsForNode(flags)), filePath);
    }
    /**
     * Helper function to convert the file writer array to a Node.js style string (e.g. "wx" or "a").
     * @param flags - The flags that should be converted.
     */
    static _convertFlagsForNode(flags) {
        flags = Object.assign({ append: false, exclusive: false }, flags);
        return [flags.append ? 'a' : 'w', flags.exclusive ? 'x' : ''].join('');
    }
    /**
     * Writes some text to the given file handle. Throws if the file handle has been closed.
     * Behind the scenes it uses `fs.writeSync()`.
     * @param text - The text to write to the file.
     */
    write(text) {
        if (!this._fileDescriptor) {
            throw new Error(`Cannot write to file, file descriptor has already been released.`);
        }
        fsx.writeSync(this._fileDescriptor, text);
    }
    /**
     * Closes the file handle permanently. No operations can be made on this file handle after calling this.
     * Behind the scenes it uses `fs.closeSync()` and releases the file descriptor to be re-used.
     *
     * @remarks
     * The `close()` method can be called more than once; additional calls are ignored.
     */
    close() {
        const fd = this._fileDescriptor;
        if (fd) {
            this._fileDescriptor = undefined;
            fsx.closeSync(fd);
        }
    }
}
exports.FileWriter = FileWriter;
//# sourceMappingURL=FileWriter.js.map

/***/ }),

/***/ 26302:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Import = void 0;
const path = __importStar(__webpack_require__(85622));
const importLazy = __webpack_require__(41239);
const Resolve = __importStar(__webpack_require__(95591));
const nodeModule = __webpack_require__(32282);
const PackageJsonLookup_1 = __webpack_require__(31386);
const FileSystem_1 = __webpack_require__(28517);
/**
 * Helpers for resolving and importing Node.js modules.
 * @public
 */
class Import {
    static get _builtInModules() {
        if (!Import.__builtInModules) {
            Import.__builtInModules = new Set(nodeModule.builtinModules);
        }
        return Import.__builtInModules;
    }
    /**
     * Provides a way to improve process startup times by lazy-loading imported modules.
     *
     * @remarks
     * This is a more structured wrapper for the {@link https://www.npmjs.com/package/import-lazy|import-lazy}
     * package.  It enables you to replace an import like this:
     *
     * ```ts
     * import * as example from 'example'; // <-- 100ms load time
     *
     * if (condition) {
     *   example.doSomething();
     * }
     * ```
     *
     * ...with a pattern like this:
     *
     * ```ts
     * const example: typeof import('example') = Import.lazy('example', require);
     *
     * if (condition) {
     *   example.doSomething(); // <-- 100ms load time occurs here, only if needed
     * }
     * ```
     *
     * The implementation relies on JavaScript's `Proxy` feature to intercept access to object members.  Thus
     * it will only work correctly with certain types of module exports.  If a particular export isn't well behaved,
     * you may need to find (or introduce) some other module in your dependency graph to apply the optimization to.
     *
     * Usage guidelines:
     *
     * - Always specify types using `typeof` as shown above.
     *
     * - Never apply lazy-loading in a way that would convert the module's type to `any`. Losing type safety
     *   seriously impacts the maintainability of the code base.
     *
     * - In cases where the non-runtime types are needed, import them separately using the `Types` suffix:
     *
     * ```ts
     * const example: typeof import('example') = Import.lazy('example', require);
     * import type * as exampleTypes from 'example';
     * ```
     *
     * - If the imported module confusingly has the same name as its export, then use the Module suffix:
     *
     * ```ts
     * const exampleModule: typeof import('../../logic/Example') = Import.lazy(
     *   '../../logic/Example', require);
     * import type * as exampleTypes from '../../logic/Example';
     * ```
     *
     * - If the exports cause a lot of awkwardness (e.g. too many expressions need to have `exampleModule.` inserted
     *   into them), or if some exports cannot be proxied (e.g. `Import.lazy('example', require)` returns a function
     *   signature), then do not lazy-load that module.  Instead, apply lazy-loading to some other module which is
     *   better behaved.
     *
     * - It's recommended to sort imports in a standard ordering:
     *
     * ```ts
     * // 1. external imports
     * import * as path from 'path';
     * import { Import, JsonFile, JsonObject } from '@rushstack/node-core-library';
     *
     * // 2. local imports
     * import { LocalFile } from './path/LocalFile';
     *
     * // 3. lazy-imports (which are technically variables, not imports)
     * const semver: typeof import('semver') = Import.lazy('semver', require);
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static lazy(moduleName, require) {
        const importLazyLocal = importLazy(require);
        return importLazyLocal(moduleName);
    }
    /**
     * This resolves a module path using similar logic as the Node.js `require.resolve()` API,
     * but supporting extra features such as specifying the base folder.
     *
     * @remarks
     * A module path is a text string that might appear in a statement such as
     * `import { X } from "____";` or `const x = require("___");`.  The implementation is based
     * on the popular `resolve` NPM package.
     *
     * Suppose `example` is an NPM package whose entry point is `lib/index.js`:
     * ```ts
     * // Returns "/path/to/project/node_modules/example/lib/index.js"
     * Import.resolveModule({ modulePath: 'example' });
     *
     * // Returns "/path/to/project/node_modules/example/lib/other.js"
     * Import.resolveModule({ modulePath: 'example/lib/other' });
     * ```
     * If you need to determine the containing package folder
     * (`/path/to/project/node_modules/example`), use {@link Import.resolvePackage} instead.
     *
     * @returns the absolute path of the resolved module.
     * If {@link IImportResolveOptions.includeSystemModules} is specified
     * and a system module is found, then its name is returned without any file path.
     */
    static resolveModule(options) {
        const { modulePath } = options;
        if (path.isAbsolute(modulePath)) {
            return modulePath;
        }
        const normalizedRootPath = FileSystem_1.FileSystem.getRealPath(options.baseFolderPath);
        if (modulePath.startsWith('.')) {
            // This looks like a conventional relative path
            return path.resolve(normalizedRootPath, modulePath);
        }
        if (options.includeSystemModules === true && Import._builtInModules.has(modulePath)) {
            return modulePath;
        }
        if (options.allowSelfReference === true) {
            const ownPackage = Import._getPackageName(options.baseFolderPath);
            if (ownPackage && modulePath.startsWith(ownPackage.packageName)) {
                const packagePath = modulePath.substr(ownPackage.packageName.length + 1);
                return path.resolve(ownPackage.packageRootPath, packagePath);
            }
        }
        try {
            return Resolve.sync(
            // Append a slash to the package name to ensure `resolve.sync` doesn't attempt to return a system package
            options.includeSystemModules !== true && modulePath.indexOf('/') === -1
                ? `${modulePath}/`
                : modulePath, {
                basedir: normalizedRootPath,
                preserveSymlinks: false
            });
        }
        catch (e) {
            throw new Error(`Cannot find module "${modulePath}" from "${options.baseFolderPath}".`);
        }
    }
    /**
     * Performs module resolution to determine the folder where a package is installed.
     *
     * @remarks
     * Suppose `example` is an NPM package whose entry point is `lib/index.js`:
     * ```ts
     * // Returns "/path/to/project/node_modules/example"
     * Import.resolvePackage({ packageName: 'example' });
     * ```
     *
     * If you need to resolve a module path, use {@link Import.resolveModule} instead:
     * ```ts
     * // Returns "/path/to/project/node_modules/example/lib/index.js"
     * Import.resolveModule({ modulePath: 'example' });
     * ```
     *
     * @returns the absolute path of the package folder.
     * If {@link IImportResolveOptions.includeSystemModules} is specified
     * and a system module is found, then its name is returned without any file path.
     */
    static resolvePackage(options) {
        const { packageName } = options;
        if (options.includeSystemModules && Import._builtInModules.has(packageName)) {
            return packageName;
        }
        const normalizedRootPath = FileSystem_1.FileSystem.getRealPath(options.baseFolderPath);
        if (options.allowSelfReference) {
            const ownPackage = Import._getPackageName(options.baseFolderPath);
            if (ownPackage && ownPackage.packageName === packageName) {
                return ownPackage.packageRootPath;
            }
        }
        try {
            const resolvedPath = Resolve.sync(packageName, {
                basedir: normalizedRootPath,
                preserveSymlinks: false,
                packageFilter: (pkg) => {
                    // Hardwire "main" to point to a file that is guaranteed to exist.
                    // This helps resolve packages such as @types/node that have no entry point.
                    // And then we can use path.dirname() below to locate the package folder,
                    // even if the real entry point was in an subfolder with arbitrary nesting.
                    pkg.main = 'package.json';
                    return pkg;
                }
            });
            const packagePath = path.dirname(resolvedPath);
            const packageJson = PackageJsonLookup_1.PackageJsonLookup.instance.loadPackageJson(path.join(packagePath, 'package.json'));
            if (packageJson.name === packageName) {
                return packagePath;
            }
            else {
                throw new Error();
            }
        }
        catch (e) {
            throw new Error(`Cannot find package "${packageName}" from "${options.baseFolderPath}".`);
        }
    }
    static _getPackageName(rootPath) {
        const packageJsonPath = PackageJsonLookup_1.PackageJsonLookup.instance.tryGetPackageJsonFilePathFor(rootPath);
        if (packageJsonPath) {
            const packageJson = PackageJsonLookup_1.PackageJsonLookup.instance.loadPackageJson(packageJsonPath);
            return {
                packageRootPath: path.dirname(packageJsonPath),
                packageName: packageJson.name
            };
        }
        else {
            return undefined;
        }
    }
}
exports.Import = Import;
//# sourceMappingURL=Import.js.map

/***/ }),

/***/ 22182:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InternalError = void 0;
/**
 * An `Error` subclass that should be thrown to report an unexpected state that may indicate a software defect.
 * An application may handle this error by instructing the end user to report an issue to the application maintainers.
 *
 * @remarks
 * Do not use this class unless you intend to solicit bug reports from end users.
 *
 * @public
 */
class InternalError extends Error {
    /**
     * Constructs a new instance of the {@link InternalError} class.
     *
     * @param message - A message describing the error.  This will be assigned to
     * {@link InternalError.unformattedMessage}.  The `Error.message` field will have additional boilerplate
     * explaining that the user has encountered a software defect.
     */
    constructor(message) {
        super(InternalError._formatMessage(message));
        // Manually set the prototype, as we can no longer extend built-in classes like Error, Array, Map, etc.
        // https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        //
        // Note: the prototype must also be set on any classes which extend this one
        this.__proto__ = InternalError.prototype; // eslint-disable-line @typescript-eslint/no-explicit-any
        this.unformattedMessage = message;
        if (InternalError.breakInDebugger) {
            // eslint-disable-next-line no-debugger
            debugger;
        }
    }
    static _formatMessage(unformattedMessage) {
        return (`Internal Error: ${unformattedMessage}\n\nYou have encountered a software defect. Please consider` +
            ` reporting the issue to the maintainers of this application.`);
    }
    /** @override */
    toString() {
        return this.message; // Avoid adding the "Error:" prefix
    }
}
exports.InternalError = InternalError;
/**
 * If true, a JavScript `debugger;` statement will be invoked whenever the `InternalError` constructor is called.
 *
 * @remarks
 * Generally applications should not be catching and ignoring an `InternalError`.  Instead, the error should
 * be reported and typically the application will terminate.  Thus, if `InternalError` is constructed, it's
 * almost always something we want to examine in a debugger.
 */
InternalError.breakInDebugger = true;
//# sourceMappingURL=InternalError.js.map

/***/ }),

/***/ 42023:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonFile = void 0;
const os = __importStar(__webpack_require__(12087));
const jju = __importStar(__webpack_require__(93304));
const Text_1 = __webpack_require__(28188);
const FileSystem_1 = __webpack_require__(28517);
const DEFAULT_ENCODING = 'utf8';
/**
 * Utilities for reading/writing JSON files.
 * @public
 */
class JsonFile {
    /**
     * Loads a JSON file.
     */
    static load(jsonFilename) {
        try {
            const contents = FileSystem_1.FileSystem.readFile(jsonFilename);
            return jju.parse(contents);
        }
        catch (error) {
            if (FileSystem_1.FileSystem.isNotExistError(error)) {
                throw error;
            }
            else {
                throw new Error(`Error reading "${JsonFile._formatPathForError(jsonFilename)}":` +
                    os.EOL +
                    `  ${error.message}`);
            }
        }
    }
    /**
     * An async version of {@link JsonFile.load}.
     */
    static async loadAsync(jsonFilename) {
        try {
            const contents = await FileSystem_1.FileSystem.readFileAsync(jsonFilename);
            return jju.parse(contents);
        }
        catch (error) {
            if (FileSystem_1.FileSystem.isNotExistError(error)) {
                throw error;
            }
            else {
                throw new Error(`Error reading "${JsonFile._formatPathForError(jsonFilename)}":` +
                    os.EOL +
                    `  ${error.message}`);
            }
        }
    }
    /**
     * Parses a JSON file's contents.
     */
    static parseString(jsonContents) {
        return jju.parse(jsonContents);
    }
    /**
     * Loads a JSON file and validate its schema.
     */
    static loadAndValidate(jsonFilename, jsonSchema, options) {
        const jsonObject = JsonFile.load(jsonFilename);
        jsonSchema.validateObject(jsonObject, jsonFilename, options);
        return jsonObject;
    }
    /**
     * An async version of {@link JsonFile.loadAndValidate}.
     */
    static async loadAndValidateAsync(jsonFilename, jsonSchema, options) {
        const jsonObject = await JsonFile.loadAsync(jsonFilename);
        jsonSchema.validateObject(jsonObject, jsonFilename, options);
        return jsonObject;
    }
    /**
     * Loads a JSON file and validate its schema, reporting errors using a callback
     * @remarks
     * See JsonSchema.validateObjectWithCallback() for more info.
     */
    static loadAndValidateWithCallback(jsonFilename, jsonSchema, errorCallback) {
        const jsonObject = JsonFile.load(jsonFilename);
        jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);
        return jsonObject;
    }
    /**
     * An async version of {@link JsonFile.loadAndValidateWithCallback}.
     */
    static async loadAndValidateWithCallbackAsync(jsonFilename, jsonSchema, errorCallback) {
        const jsonObject = await JsonFile.loadAsync(jsonFilename);
        jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);
        return jsonObject;
    }
    /**
     * Serializes the specified JSON object to a string buffer.
     * @param jsonObject - the object to be serialized
     * @param options - other settings that control serialization
     * @returns a JSON string, with newlines, and indented with two spaces
     */
    static stringify(jsonObject, options) {
        return JsonFile.updateString('', jsonObject, options);
    }
    /**
     * Serializes the specified JSON object to a string buffer.
     * @param jsonObject - the object to be serialized
     * @param options - other settings that control serialization
     * @returns a JSON string, with newlines, and indented with two spaces
     */
    static updateString(previousJson, newJsonObject, options) {
        if (!options) {
            options = {};
        }
        if (!options.ignoreUndefinedValues) {
            // Standard handling of `undefined` in JSON stringification is to discard the key.
            JsonFile.validateNoUndefinedMembers(newJsonObject);
        }
        let stringified;
        if (previousJson !== '') {
            // NOTE: We don't use mode=json here because comments aren't allowed by strict JSON
            stringified = jju.update(previousJson, newJsonObject, {
                mode: 'cjson',
                indent: 2
            });
        }
        else if (options.prettyFormatting) {
            stringified = jju.stringify(newJsonObject, {
                mode: 'json',
                indent: 2
            });
            if (options.headerComment !== undefined) {
                stringified = JsonFile._formatJsonHeaderComment(options.headerComment) + stringified;
            }
        }
        else {
            stringified = JSON.stringify(newJsonObject, undefined, 2);
            if (options.headerComment !== undefined) {
                stringified = JsonFile._formatJsonHeaderComment(options.headerComment) + stringified;
            }
        }
        // Add the trailing newline
        stringified = Text_1.Text.ensureTrailingNewline(stringified);
        if (options && options.newlineConversion) {
            stringified = Text_1.Text.convertTo(stringified, options.newlineConversion);
        }
        return stringified;
    }
    /**
     * Saves the file to disk.  Returns false if nothing was written due to options.onlyIfChanged.
     * @param jsonObject - the object to be saved
     * @param jsonFilename - the file path to write
     * @param options - other settings that control how the file is saved
     * @returns false if ISaveJsonFileOptions.onlyIfChanged didn't save anything; true otherwise
     */
    static save(jsonObject, jsonFilename, options) {
        if (!options) {
            options = {};
        }
        // Do we need to read the previous file contents?
        let oldBuffer = undefined;
        if (options.updateExistingFile || options.onlyIfChanged) {
            try {
                oldBuffer = FileSystem_1.FileSystem.readFileToBuffer(jsonFilename);
            }
            catch (error) {
                if (!FileSystem_1.FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        }
        let jsonToUpdate = '';
        if (options.updateExistingFile && oldBuffer) {
            jsonToUpdate = oldBuffer.toString(DEFAULT_ENCODING);
        }
        const newJson = JsonFile.updateString(jsonToUpdate, jsonObject, options);
        const newBuffer = Buffer.from(newJson, DEFAULT_ENCODING);
        if (options.onlyIfChanged) {
            // Has the file changed?
            if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {
                // Nothing has changed, so don't touch the file
                return false;
            }
        }
        FileSystem_1.FileSystem.writeFile(jsonFilename, newBuffer.toString(DEFAULT_ENCODING), {
            ensureFolderExists: options.ensureFolderExists
        });
        // TEST CODE: Used to verify that onlyIfChanged isn't broken by a hidden transformation during saving.
        /*
        const oldBuffer2: Buffer = FileSystem.readFileToBuffer(jsonFilename);
        if (Buffer.compare(buffer, oldBuffer2) !== 0) {
          console.log('new:' + buffer.toString('hex'));
          console.log('old:' + oldBuffer2.toString('hex'));
    
          throw new Error('onlyIfChanged logic is broken');
        }
        */
        return true;
    }
    /**
     * An async version of {@link JsonFile.save}.
     */
    static async saveAsync(jsonObject, jsonFilename, options) {
        if (!options) {
            options = {};
        }
        // Do we need to read the previous file contents?
        let oldBuffer = undefined;
        if (options.updateExistingFile || options.onlyIfChanged) {
            try {
                oldBuffer = await FileSystem_1.FileSystem.readFileToBufferAsync(jsonFilename);
            }
            catch (error) {
                if (!FileSystem_1.FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        }
        let jsonToUpdate = '';
        if (options.updateExistingFile && oldBuffer) {
            jsonToUpdate = oldBuffer.toString(DEFAULT_ENCODING);
        }
        const newJson = JsonFile.updateString(jsonToUpdate, jsonObject, options);
        const newBuffer = Buffer.from(newJson, DEFAULT_ENCODING);
        if (options.onlyIfChanged) {
            // Has the file changed?
            if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {
                // Nothing has changed, so don't touch the file
                return false;
            }
        }
        await FileSystem_1.FileSystem.writeFileAsync(jsonFilename, newBuffer.toString(DEFAULT_ENCODING), {
            ensureFolderExists: options.ensureFolderExists
        });
        // TEST CODE: Used to verify that onlyIfChanged isn't broken by a hidden transformation during saving.
        /*
        const oldBuffer2: Buffer = await FileSystem.readFileToBufferAsync(jsonFilename);
        if (Buffer.compare(buffer, oldBuffer2) !== 0) {
          console.log('new:' + buffer.toString('hex'));
          console.log('old:' + oldBuffer2.toString('hex'));
    
          throw new Error('onlyIfChanged logic is broken');
        }
        */
        return true;
    }
    /**
     * Used to validate a data structure before writing.  Reports an error if there
     * are any undefined members.
     */
    static validateNoUndefinedMembers(jsonObject) {
        return JsonFile._validateNoUndefinedMembers(jsonObject, []);
    }
    // Private implementation of validateNoUndefinedMembers()
    static _validateNoUndefinedMembers(jsonObject, keyPath) {
        if (!jsonObject) {
            return;
        }
        if (typeof jsonObject === 'object') {
            for (const key of Object.keys(jsonObject)) {
                keyPath.push(key);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const value = jsonObject[key];
                if (value === undefined) {
                    const fullPath = JsonFile._formatKeyPath(keyPath);
                    throw new Error(`The value for ${fullPath} is "undefined" and cannot be serialized as JSON`);
                }
                JsonFile._validateNoUndefinedMembers(value, keyPath);
                keyPath.pop();
            }
        }
    }
    // Given this input:    ['items', '4', 'syntax', 'parameters', 'string "with" symbols", 'type']
    // Return this string:  items[4].syntax.parameters["string \"with\" symbols"].type
    static _formatKeyPath(keyPath) {
        let result = '';
        for (const key of keyPath) {
            if (/^[0-9]+$/.test(key)) {
                // It's an integer, so display like this:  parent[123]
                result += `[${key}]`;
            }
            else if (/^[a-z_][a-z_0-9]*$/i.test(key)) {
                // It's an alphanumeric identifier, so display like this:  parent.name
                if (result) {
                    result += '.';
                }
                result += `${key}`;
            }
            else {
                // It's a freeform string, so display like this:  parent["A path: \"C:\\file\""]
                // Convert this:     A path: "C:\file"
                // To this:          A path: \"C:\\file\"
                const escapedKey = key
                    .replace(/[\\]/g, '\\\\') // escape backslashes
                    .replace(/["]/g, '\\'); // escape quotes
                result += `["${escapedKey}"]`;
            }
        }
        return result;
    }
    static _formatJsonHeaderComment(headerComment) {
        if (headerComment === '') {
            return '';
        }
        const lines = headerComment.split('\n');
        const result = [];
        for (const line of lines) {
            if (!/^\s*$/.test(line) && !/^\s*\/\//.test(line)) {
                throw new Error('The headerComment lines must be blank or start with the "//" prefix.\n' +
                    'Invalid line' +
                    JSON.stringify(line));
            }
            result.push(Text_1.Text.replaceAll(line, '\r', ''));
        }
        return lines.join('\n') + '\n';
    }
}
exports.JsonFile = JsonFile;
/**
 * @internal
 */
JsonFile._formatPathForError = (path) => path;
//# sourceMappingURL=JsonFile.js.map

/***/ }),

/***/ 12451:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonSchema = void 0;
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const JsonFile_1 = __webpack_require__(42023);
const FileSystem_1 = __webpack_require__(28517);
const Validator = __webpack_require__(59997);
/**
 * Represents a JSON schema that can be used to validate JSON data files loaded by the JsonFile class.
 * @remarks
 * The schema itself is normally loaded and compiled later, only if it is actually required to validate
 * an input.  To avoid schema errors at runtime, it's recommended to create a unit test that calls
 * JsonSchema.ensureCompiled() for each of your schema objects.
 *
 * @public
 */
class JsonSchema {
    constructor() {
        this._dependentSchemas = [];
        this._filename = '';
        this._validator = undefined;
        this._schemaObject = undefined;
    }
    /**
     * Registers a JsonSchema that will be loaded from a file on disk.
     * @remarks
     * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
     * until it the schema is actually used.
     */
    static fromFile(filename, options) {
        // This is a quick and inexpensive test to avoid the catch the most common errors early.
        // Full validation will happen later in JsonSchema.compile().
        if (!FileSystem_1.FileSystem.exists(filename)) {
            throw new Error('Schema file not found: ' + filename);
        }
        const schema = new JsonSchema();
        schema._filename = filename;
        if (options) {
            schema._dependentSchemas = options.dependentSchemas || [];
        }
        return schema;
    }
    /**
     * Registers a JsonSchema that will be loaded from a file on disk.
     * @remarks
     * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
     * until it the schema is actually used.
     */
    static fromLoadedObject(schemaObject) {
        const schema = new JsonSchema();
        schema._schemaObject = schemaObject;
        return schema;
    }
    static _collectDependentSchemas(collectedSchemas, dependentSchemas, seenObjects, seenIds) {
        for (const dependentSchema of dependentSchemas) {
            // It's okay for the same schema to appear multiple times in the tree, but we only process it once
            if (seenObjects.has(dependentSchema)) {
                continue;
            }
            seenObjects.add(dependentSchema);
            const schemaId = dependentSchema._ensureLoaded();
            if (schemaId === '') {
                throw new Error(`This schema ${dependentSchema.shortName} cannot be referenced` +
                    ' because is missing the "id" field');
            }
            if (seenIds.has(schemaId)) {
                throw new Error(`This schema ${dependentSchema.shortName} has the same "id" as another schema in this set`);
            }
            seenIds.add(schemaId);
            collectedSchemas.push(dependentSchema);
            JsonSchema._collectDependentSchemas(collectedSchemas, dependentSchema._dependentSchemas, seenObjects, seenIds);
        }
    }
    /**
     * Used to nicely format the ZSchema error tree.
     */
    static _formatErrorDetails(errorDetails) {
        return JsonSchema._formatErrorDetailsHelper(errorDetails, '', '');
    }
    /**
     * Used by _formatErrorDetails.
     */
    static _formatErrorDetailsHelper(errorDetails, indent, buffer) {
        for (const errorDetail of errorDetails) {
            buffer += os.EOL + indent + `Error: ${errorDetail.path}`;
            if (errorDetail.description) {
                const MAX_LENGTH = 40;
                let truncatedDescription = errorDetail.description.trim();
                if (truncatedDescription.length > MAX_LENGTH) {
                    truncatedDescription = truncatedDescription.substr(0, MAX_LENGTH - 3) + '...';
                }
                buffer += ` (${truncatedDescription})`;
            }
            buffer += os.EOL + indent + `       ${errorDetail.message}`;
            if (errorDetail.inner) {
                buffer = JsonSchema._formatErrorDetailsHelper(errorDetail.inner, indent + '  ', buffer);
            }
        }
        return buffer;
    }
    /**
     * Returns a short name for this schema, for use in error messages.
     * @remarks
     * If the schema was loaded from a file, then the base filename is used.  Otherwise, the "id"
     * field is used if available.
     */
    get shortName() {
        if (!this._filename) {
            if (this._schemaObject) {
                const schemaWithId = this._schemaObject;
                if (schemaWithId.id) {
                    return schemaWithId.id;
                }
            }
            return '(anonymous schema)';
        }
        else {
            return path.basename(this._filename);
        }
    }
    /**
     * If not already done, this loads the schema from disk and compiles it.
     * @remarks
     * Any dependencies will be compiled as well.
     */
    ensureCompiled() {
        this._ensureLoaded();
        if (!this._validator) {
            // Don't assign this to _validator until we're sure everything was successful
            const newValidator = new Validator({
                breakOnFirstError: false,
                noTypeless: true,
                noExtraKeywords: true
            });
            const anythingSchema = {
                type: ['array', 'boolean', 'integer', 'number', 'object', 'string']
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            newValidator.setRemoteReference('http://json-schema.org/draft-04/schema', anythingSchema);
            const collectedSchemas = [];
            const seenObjects = new Set();
            const seenIds = new Set();
            JsonSchema._collectDependentSchemas(collectedSchemas, this._dependentSchemas, seenObjects, seenIds);
            // Validate each schema in order.  We specifically do not supply them all together, because we want
            // to make sure that circular references will fail to validate.
            for (const collectedSchema of collectedSchemas) {
                if (!newValidator.validateSchema(collectedSchema._schemaObject)) {
                    throw new Error(`Failed to validate schema "${collectedSchema.shortName}":` +
                        os.EOL +
                        JsonSchema._formatErrorDetails(newValidator.getLastErrors()));
                }
            }
            this._validator = newValidator;
        }
    }
    /**
     * Validates the specified JSON object against this JSON schema.  If the validation fails,
     * an exception will be thrown.
     * @param jsonObject - The JSON data to be validated
     * @param filenameForErrors - The filename that the JSON data was available, or an empty string
     *    if not applicable
     * @param options - Other options that control the validation
     */
    validateObject(jsonObject, filenameForErrors, options) {
        this.validateObjectWithCallback(jsonObject, (errorInfo) => {
            const prefix = options && options.customErrorHeader ? options.customErrorHeader : 'JSON validation failed:';
            throw new Error(prefix + os.EOL + filenameForErrors + os.EOL + errorInfo.details);
        });
    }
    /**
     * Validates the specified JSON object against this JSON schema.  If the validation fails,
     * a callback is called for each validation error.
     */
    validateObjectWithCallback(jsonObject, errorCallback) {
        this.ensureCompiled();
        if (!this._validator.validate(jsonObject, this._schemaObject)) {
            const errorDetails = JsonSchema._formatErrorDetails(this._validator.getLastErrors());
            const args = {
                details: errorDetails
            };
            errorCallback(args);
        }
    }
    _ensureLoaded() {
        if (!this._schemaObject) {
            this._schemaObject = JsonFile_1.JsonFile.load(this._filename);
        }
        return this._schemaObject.id || '';
    }
}
exports.JsonSchema = JsonSchema;
//# sourceMappingURL=JsonSchema.js.map

/***/ }),

/***/ 31160:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LegacyAdapters = void 0;
const timsort_1 = __webpack_require__(46655);
const semver = __importStar(__webpack_require__(11383));
/**
 * Helper functions used when interacting with APIs that do not follow modern coding practices.
 * @public
 */
class LegacyAdapters {
    static convertCallbackToPromise(fn, arg1, arg2, arg3, arg4) {
        return new Promise((resolve, reject) => {
            const cb = (error, result) => {
                if (error) {
                    reject(LegacyAdapters.scrubError(error));
                }
                else {
                    resolve(result);
                }
            };
            try {
                if (arg1 !== undefined && arg2 !== undefined && arg3 !== undefined && arg4 !== undefined) {
                    fn(arg1, arg2, arg3, arg4, cb);
                }
                else if (arg1 !== undefined && arg2 !== undefined && arg3 !== undefined) {
                    fn(arg1, arg2, arg3, cb);
                }
                else if (arg1 !== undefined && arg2 !== undefined) {
                    fn(arg1, arg2, cb);
                }
                else if (arg1 !== undefined) {
                    fn(arg1, cb);
                }
                else {
                    fn(cb);
                }
            }
            catch (e) {
                reject(e);
            }
        });
    }
    /**
     * Normalizes an object into an `Error` object.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static scrubError(error) {
        if (error instanceof Error) {
            return error;
        }
        else if (typeof error === 'string') {
            return new Error(error);
        }
        else {
            const errorObject = new Error('An error occurred.');
            errorObject.errorData = error; // eslint-disable-line @typescript-eslint/no-explicit-any
            return errorObject;
        }
    }
    /**
     * Prior to Node 11.x, the `Array.sort()` algorithm is not guaranteed to be stable.
     * If you need a stable sort, you can use `sortStable()` as a workaround.
     *
     * @remarks
     * On NodeJS 11.x and later, this method simply calls the native `Array.sort()`.
     * For earlier versions, it uses an implementation of Timsort, which is the same algorithm used by modern NodeJS.
     */
    static sortStable(array, compare) {
        if (LegacyAdapters._useTimsort === undefined) {
            LegacyAdapters._useTimsort = semver.major(process.versions.node) < 11;
        }
        if (LegacyAdapters._useTimsort) {
            (0, timsort_1.sort)(array, compare);
        }
        else {
            Array.prototype.sort.call(array, compare);
        }
    }
}
exports.LegacyAdapters = LegacyAdapters;
LegacyAdapters._useTimsort = undefined;
//# sourceMappingURL=LegacyAdapters.js.map

/***/ }),

/***/ 50272:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LockFile = exports.getProcessStartTime = exports.getProcessStartTimeFromProcStat = void 0;
const path = __importStar(__webpack_require__(85622));
const child_process = __importStar(__webpack_require__(63129));
const FileSystem_1 = __webpack_require__(28517);
const FileWriter_1 = __webpack_require__(24064);
const Async_1 = __webpack_require__(78869);
/**
 * http://man7.org/linux/man-pages/man5/proc.5.html
 * (22) starttime  %llu
 * The time the process started after system boot. In kernels before Linux 2.6, this value was
 * expressed in jiffies. Since Linux 2.6, the value is expressed in clock ticks (divide by
 * sysconf(_SC_CLK_TCK)).
 * The format for this field was %lu before Linux 2.6.
 */
const procStatStartTimePos = 22;
/**
 * Parses the process start time from the contents of a linux /proc/[pid]/stat file.
 * @param stat - The contents of a linux /proc/[pid]/stat file.
 * @returns The process start time in jiffies, or undefined if stat has an unexpected format.
 */
function getProcessStartTimeFromProcStat(stat) {
    // Parse the value at position procStatStartTimePos.
    // We cannot just split stat on spaces, because value 2 may contain spaces.
    // For example, when running the following Shell commands:
    // > cp "$(which bash)" ./'bash 2)('
    // > ./'bash 2)(' -c 'OWNPID=$BASHPID;cat /proc/$OWNPID/stat'
    // 59389 (bash 2)() S 59358 59389 59358 34818 59389 4202496 329 0 0 0 0 0 0 0 20 0 1 0
    // > rm -rf ./'bash 2)('
    // The output shows a stat file such that value 2 contains spaces.
    // To still umambiguously parse such output we assume no values after the second ends with a right parenthesis...
    // trimRight to remove the trailing line terminator.
    let values = stat.trimRight().split(' ');
    let i = values.length - 1;
    while (i >= 0 &&
        // charAt returns an empty string if the index is out of bounds.
        values[i].charAt(values[i].length - 1) !== ')') {
        i -= 1;
    }
    // i is the index of the last part of the second value (but i need not be 1).
    if (i < 1) {
        // Format of stat has changed.
        return undefined;
    }
    const value2 = values.slice(1, i + 1).join(' ');
    values = [values[0], value2].concat(values.slice(i + 1));
    if (values.length < procStatStartTimePos) {
        // Older version of linux, or non-standard configuration of linux.
        return undefined;
    }
    const startTimeJiffies = values[procStatStartTimePos - 1];
    // In theory, the representations of start time returned by `cat /proc/[pid]/stat` and `ps -o lstart` can change
    // while the system is running, but we assume this does not happen.
    // So the caller can safely use this value as part of a unique process id (on the machine, without comparing
    // accross reboots).
    return startTimeJiffies;
}
exports.getProcessStartTimeFromProcStat = getProcessStartTimeFromProcStat;
/**
 * Helper function that is exported for unit tests only.
 * Returns undefined if the process doesn't exist with that pid.
 */
function getProcessStartTime(pid) {
    const pidString = pid.toString();
    if (pid < 0 || pidString.indexOf('e') >= 0 || pidString.indexOf('E') >= 0) {
        throw new Error(`"pid" is negative or too large`);
    }
    let args;
    if (process.platform === 'darwin') {
        args = [`-p ${pidString}`, '-o lstart'];
    }
    else if (process.platform === 'linux') {
        args = ['-p', pidString, '-o', 'lstart'];
    }
    else {
        throw new Error(`Unsupported system: ${process.platform}`);
    }
    const psResult = child_process.spawnSync('ps', args, {
        encoding: 'utf8'
    });
    const psStdout = psResult.stdout;
    // If no process with PID pid exists then the exit code is non-zero on linux but stdout is not empty.
    // But if no process exists we do not want to fall back on /proc/*/stat to determine the process
    // start time, so we we additionally test for !psStdout. NOTE: !psStdout evaluates to true if
    // zero bytes are written to stdout.
    if (psResult.status !== 0 && !psStdout && process.platform === 'linux') {
        // Try to read /proc/[pid]/stat and get the value at position procStatStartTimePos.
        let stat;
        try {
            stat = FileSystem_1.FileSystem.readFile(`/proc/${pidString}/stat`);
        }
        catch (error) {
            if (error.code !== 'ENOENT') {
                throw error;
            }
            // Either no process with PID pid exists, or this version/configuration of linux is non-standard.
            // We assume the former.
            return undefined;
        }
        if (stat !== undefined) {
            const startTimeJiffies = getProcessStartTimeFromProcStat(stat);
            if (startTimeJiffies === undefined) {
                throw new Error(`Could not retrieve the start time of process ${pidString} from the OS because the ` +
                    `contents of /proc/${pidString}/stat have an unexpected format`);
            }
            return startTimeJiffies;
        }
    }
    // there was an error executing ps (zero bytes were written to stdout).
    if (!psStdout) {
        throw new Error(`Unexpected output from "ps" command`);
    }
    const psSplit = psStdout.split('\n');
    // successfuly able to run "ps", but no process was found
    if (psSplit[1] === '') {
        return undefined;
    }
    if (psSplit[1]) {
        const trimmed = psSplit[1].trim();
        if (trimmed.length > 10) {
            return trimmed;
        }
    }
    throw new Error(`Unexpected output from the "ps" command`);
}
exports.getProcessStartTime = getProcessStartTime;
/**
 * The `LockFile` implements a file-based mutex for synchronizing access to a shared resource
 * between multiple Node.js processes.  It is not recommended for synchronization solely within
 * a single Node.js process.
 * @remarks
 * The implementation works on Windows, Mac, and Linux without requiring any native helpers.
 * On non-Windows systems, the algorithm requires access to the `ps` shell command.  On Linux,
 * it requires access the `/proc/${pidString}/stat` filesystem.
 * @public
 */
class LockFile {
    constructor(fileWriter, filePath, dirtyWhenAcquired) {
        this._fileWriter = fileWriter;
        this._filePath = filePath;
        this._dirtyWhenAcquired = dirtyWhenAcquired;
    }
    /**
     * Returns the path of the lockfile that will be created when a lock is successfully acquired.
     * @param resourceFolder - The folder where the lock file will be created
     * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
     *   the filename of the temporary file created to manage the lock.
     * @param pid - The PID for the current Node.js process (`process.pid`), which is used by the locking algorithm.
     */
    static getLockFilePath(resourceFolder, resourceName, pid = process.pid) {
        if (!resourceName.match(/^[a-zA-Z0-9][a-zA-Z0-9-.]+[a-zA-Z0-9]$/)) {
            throw new Error(`The resource name "${resourceName}" is invalid.` +
                ` It must be an alphanumberic string with only "-" or "." It must start with an alphanumeric character.`);
        }
        if (process.platform === 'win32') {
            return path.join(path.resolve(resourceFolder), `${resourceName}.lock`);
        }
        else if (process.platform === 'linux' || process.platform === 'darwin') {
            return path.join(path.resolve(resourceFolder), `${resourceName}#${pid}.lock`);
        }
        throw new Error(`File locking not implemented for platform: "${process.platform}"`);
    }
    /**
     * Attempts to create a lockfile with the given filePath.
     * @param resourceFolder - The folder where the lock file will be created
     * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
     *   the filename of the temporary file created to manage the lock.
     * @returns If successful, returns a `LockFile` instance.  If unable to get a lock, returns `undefined`.
     */
    static tryAcquire(resourceFolder, resourceName) {
        FileSystem_1.FileSystem.ensureFolder(resourceFolder);
        if (process.platform === 'win32') {
            return LockFile._tryAcquireWindows(resourceFolder, resourceName);
        }
        else if (process.platform === 'linux' || process.platform === 'darwin') {
            return LockFile._tryAcquireMacOrLinux(resourceFolder, resourceName);
        }
        throw new Error(`File locking not implemented for platform: "${process.platform}"`);
    }
    /**
     * Attempts to create the lockfile.  Will continue to loop at every 100ms until the lock becomes available
     * or the maxWaitMs is surpassed.
     *
     * @remarks
     * This function is subject to starvation, whereby it does not ensure that the process that has been
     * waiting the longest to acquire the lock will get it first. This means that a process could theoretically
     * wait for the lock forever, while other processes skipped it in line and acquired the lock first.
     *
     * @param resourceFolder - The folder where the lock file will be created
     * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
     *   the filename of the temporary file created to manage the lock.
     * @param maxWaitMs - The maximum number of milliseconds to wait for the lock before reporting an error
     */
    static acquire(resourceFolder, resourceName, maxWaitMs) {
        const interval = 100;
        const startTime = Date.now();
        const retryLoop = async () => {
            const lock = LockFile.tryAcquire(resourceFolder, resourceName);
            if (lock) {
                return lock;
            }
            if (maxWaitMs && Date.now() > startTime + maxWaitMs) {
                throw new Error(`Exceeded maximum wait time to acquire lock for resource "${resourceName}"`);
            }
            await Async_1.Async.sleep(interval);
            return retryLoop();
        };
        return retryLoop();
    }
    /**
     * Attempts to acquire the lock on a Linux or OSX machine
     */
    static _tryAcquireMacOrLinux(resourceFolder, resourceName) {
        let dirtyWhenAcquired = false;
        // get the current process' pid
        const pid = process.pid;
        const startTime = LockFile._getStartTime(pid);
        if (!startTime) {
            throw new Error(`Unable to calculate start time for current process.`);
        }
        const pidLockFilePath = LockFile.getLockFilePath(resourceFolder, resourceName);
        let lockFileHandle;
        let lockFile;
        try {
            // open in write mode since if this file exists, it cannot be from the current process
            // TODO: This will malfunction if the same process tries to acquire two locks on the same file.
            // We should ideally maintain a dictionary of normalized acquired filenames
            lockFileHandle = FileWriter_1.FileWriter.open(pidLockFilePath);
            lockFileHandle.write(startTime);
            const currentBirthTimeMs = FileSystem_1.FileSystem.getStatistics(pidLockFilePath).birthtime.getTime();
            let smallestBirthTimeMs = currentBirthTimeMs;
            let smallestBirthTimePid = pid.toString();
            // now, scan the directory for all lockfiles
            const files = FileSystem_1.FileSystem.readFolder(resourceFolder);
            // look for anything ending with # then numbers and ".lock"
            const lockFileRegExp = /^(.+)#([0-9]+)\.lock$/;
            let match;
            let otherPid;
            for (const fileInFolder of files) {
                if ((match = fileInFolder.match(lockFileRegExp)) &&
                    match[1] === resourceName &&
                    (otherPid = match[2]) !== pid.toString()) {
                    // we found at least one lockfile hanging around that isn't ours
                    const fileInFolderPath = path.join(resourceFolder, fileInFolder);
                    dirtyWhenAcquired = true;
                    // console.log(`FOUND OTHER LOCKFILE: ${otherPid}`);
                    const otherPidCurrentStartTime = LockFile._getStartTime(parseInt(otherPid, 10));
                    let otherPidOldStartTime;
                    let otherBirthtimeMs;
                    try {
                        otherPidOldStartTime = FileSystem_1.FileSystem.readFile(fileInFolderPath);
                        // check the timestamp of the file
                        otherBirthtimeMs = FileSystem_1.FileSystem.getStatistics(fileInFolderPath).birthtime.getTime();
                    }
                    catch (err) {
                        // this means the file is probably deleted already
                    }
                    // if the otherPidOldStartTime is invalid, then we should look at the timestamp,
                    // if this file was created after us, ignore it
                    // if it was created within 1 second before us, then it could be good, so we
                    //  will conservatively fail
                    // otherwise it is an old lock file and will be deleted
                    if (otherPidOldStartTime === '' && otherBirthtimeMs !== undefined) {
                        if (otherBirthtimeMs > currentBirthTimeMs) {
                            // ignore this file, he will be unable to get the lock since this process
                            // will hold it
                            // console.log(`Ignoring lock for pid ${otherPid} because its lockfile is newer than ours.`);
                            continue;
                        }
                        else if (otherBirthtimeMs - currentBirthTimeMs < 0 && // it was created before us AND
                            otherBirthtimeMs - currentBirthTimeMs > -1000) {
                            // it was created less than a second before
                            // conservatively be unable to keep the lock
                            return undefined;
                        }
                    }
                    // console.log(`Other pid ${otherPid} lockfile has start time: "${otherPidOldStartTime}"`);
                    // console.log(`Other pid ${otherPid} actually has start time: "${otherPidCurrentStartTime}"`);
                    // this means the process is no longer executing, delete the file
                    if (!otherPidCurrentStartTime || otherPidOldStartTime !== otherPidCurrentStartTime) {
                        // console.log(`Other pid ${otherPid} is no longer executing!`);
                        FileSystem_1.FileSystem.deleteFile(fileInFolderPath);
                        continue;
                    }
                    // console.log(`Pid ${otherPid} lockfile has birth time: ${otherBirthtimeMs}`);
                    // console.log(`Pid ${pid} lockfile has birth time: ${currentBirthTimeMs}`);
                    // this is a lockfile pointing at something valid
                    if (otherBirthtimeMs !== undefined && otherBirthtimeMs < smallestBirthTimeMs) {
                        smallestBirthTimeMs = otherBirthtimeMs;
                        smallestBirthTimePid = otherPid;
                    }
                }
            }
            if (smallestBirthTimePid !== pid.toString()) {
                // we do not have the lock
                return undefined;
            }
            // we have the lock!
            lockFile = new LockFile(lockFileHandle, pidLockFilePath, dirtyWhenAcquired);
            lockFileHandle = undefined; // we have handed the descriptor off to the instance
        }
        finally {
            if (lockFileHandle) {
                // ensure our lock is closed
                lockFileHandle.close();
                FileSystem_1.FileSystem.deleteFile(pidLockFilePath);
            }
        }
        return lockFile;
    }
    /**
     * Attempts to acquire the lock using Windows
     * This algorithm is much simpler since we can rely on the operating system
     */
    static _tryAcquireWindows(resourceFolder, resourceName) {
        const lockFilePath = LockFile.getLockFilePath(resourceFolder, resourceName);
        let dirtyWhenAcquired = false;
        let fileHandle;
        let lockFile;
        try {
            if (FileSystem_1.FileSystem.exists(lockFilePath)) {
                dirtyWhenAcquired = true;
                // If the lockfile is held by an process with an exclusive lock, then removing it will
                // silently fail. OpenSync() below will then fail and we will be unable to create a lock.
                // Otherwise, the lockfile is sitting on disk, but nothing is holding it, implying that
                // the last process to hold it died.
                FileSystem_1.FileSystem.deleteFile(lockFilePath);
            }
            try {
                // Attempt to open an exclusive lockfile
                fileHandle = FileWriter_1.FileWriter.open(lockFilePath, { exclusive: true });
            }
            catch (error) {
                // we tried to delete the lock, but something else is holding it,
                // (probably an active process), therefore we are unable to create a lock
                return undefined;
            }
            // Ensure we can hand off the file descriptor to the lockfile
            lockFile = new LockFile(fileHandle, lockFilePath, dirtyWhenAcquired);
            fileHandle = undefined;
        }
        finally {
            if (fileHandle) {
                fileHandle.close();
            }
        }
        return lockFile;
    }
    /**
     * Unlocks a file and removes it from disk.
     * This can only be called once.
     */
    release() {
        if (this.isReleased) {
            throw new Error(`The lock for file "${path.basename(this._filePath)}" has already been released.`);
        }
        this._fileWriter.close();
        FileSystem_1.FileSystem.deleteFile(this._filePath);
        this._fileWriter = undefined;
    }
    /**
     * Returns the initial state of the lock.
     * This can be used to detect if the previous process was terminated before releasing the resource.
     */
    get dirtyWhenAcquired() {
        return this._dirtyWhenAcquired;
    }
    /**
     * Returns the absolute path to the lockfile
     */
    get filePath() {
        return this._filePath;
    }
    /**
     * Returns true if this lock is currently being held.
     */
    get isReleased() {
        return this._fileWriter === undefined;
    }
}
exports.LockFile = LockFile;
LockFile._getStartTime = getProcessStartTime;
//# sourceMappingURL=LockFile.js.map

/***/ }),

/***/ 18187:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapExtensions = void 0;
/**
 * Helper functions for working with the `Map<K, V>` data type.
 *
 * @public
 */
class MapExtensions {
    /**
     * Adds all the (key, value) pairs from the source map into the target map.
     * @remarks
     * This function modifies targetMap.  Any existing keys will be overwritten.
     * @param targetMap - The map that entries will be added to
     * @param sourceMap - The map containing the entries to be added
     */
    static mergeFromMap(targetMap, sourceMap) {
        for (const pair of sourceMap.entries()) {
            targetMap.set(pair[0], pair[1]);
        }
    }
    /**
     * Converts a string-keyed map to an object.
     * @remarks
     * This function has the same effect as Object.fromEntries(map.entries())
     * in supported versions of Node (\>= 12.0.0).
     * @param map - The map that the object properties will be sourced from
     */
    static toObject(map) {
        const object = {};
        for (const [key, value] of map.entries()) {
            object[key] = value;
        }
        return object;
    }
}
exports.MapExtensions = MapExtensions;
//# sourceMappingURL=MapExtensions.js.map

/***/ }),

/***/ 31386:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageJsonLookup = void 0;
const path = __importStar(__webpack_require__(85622));
const JsonFile_1 = __webpack_require__(42023);
const FileSystem_1 = __webpack_require__(28517);
/**
 * This class provides methods for finding the nearest "package.json" for a folder
 * and retrieving the name of the package.  The results are cached.
 *
 * @public
 */
class PackageJsonLookup {
    constructor(parameters) {
        this._loadExtraFields = false;
        if (parameters) {
            if (parameters.loadExtraFields) {
                this._loadExtraFields = parameters.loadExtraFields;
            }
        }
        this.clearCache();
    }
    /**
     * A singleton instance of `PackageJsonLookup`, which is useful for short-lived processes
     * that can reasonably assume that the file system will not be modified after the cache
     * is populated.
     *
     * @remarks
     * For long-running processes that need to clear the cache at appropriate times,
     * it is recommended to create your own instance of `PackageJsonLookup` instead
     * of relying on this instance.
     */
    static get instance() {
        if (!PackageJsonLookup._instance) {
            PackageJsonLookup._instance = new PackageJsonLookup({ loadExtraFields: true });
        }
        return PackageJsonLookup._instance;
    }
    /**
     * A helper for loading the caller's own package.json file.
     *
     * @remarks
     *
     * This function provides a concise and efficient way for an NPM package to report metadata about itself.
     * For example, a tool might want to report its version.
     *
     * The `loadOwnPackageJson()` probes upwards from the caller's folder, expecting to find a package.json file,
     * which is assumed to be the caller's package.  The result is cached, under the assumption that a tool's
     * own package.json (and intermediary folders) will never change during the lifetime of the process.
     *
     * @example
     * ```ts
     * // Report the version of our NPM package
     * const myPackageVersion: string = PackageJsonLookup.loadOwnPackageJson(__dirname).version;
     * console.log(`Cool Tool - Version ${myPackageVersion}`);
     * ```
     *
     * @param dirnameOfCaller - The NodeJS `__dirname` macro for the caller.
     * @returns This function always returns a valid `IPackageJson` object.  If any problems are encountered during
     * loading, an exception will be thrown instead.
     */
    static loadOwnPackageJson(dirnameOfCaller) {
        const packageJson = PackageJsonLookup.instance.tryLoadPackageJsonFor(dirnameOfCaller);
        if (packageJson === undefined) {
            throw new Error(`PackageJsonLookup.loadOwnPackageJson() failed to find the caller's package.json.` +
                `  The __dirname was: ${dirnameOfCaller}`);
        }
        if (packageJson.version !== undefined) {
            return packageJson;
        }
        const errorPath = PackageJsonLookup.instance.tryGetPackageJsonFilePathFor(dirnameOfCaller) || 'package.json';
        throw new Error(`PackageJsonLookup.loadOwnPackageJson() failed because the "version" field is missing in` +
            ` ${errorPath}`);
    }
    /**
     * Clears the internal file cache.
     * @remarks
     * Call this method if changes have been made to the package.json files on disk.
     */
    clearCache() {
        this._packageFolderCache = new Map();
        this._packageJsonCache = new Map();
    }
    /**
     * Returns the absolute path of a folder containing a package.json file, by looking
     * upwards from the specified fileOrFolderPath.  If no package.json can be found,
     * undefined is returned.
     *
     * @remarks
     * The fileOrFolderPath is not required to actually exist on disk.
     * The fileOrFolderPath itself can be the return value, if it is a folder containing
     * a package.json file.
     * Both positive and negative lookup results are cached.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an absolute path to a folder containing a package.json file
     */
    tryGetPackageFolderFor(fileOrFolderPath) {
        // Convert it to an absolute path
        const resolvedFileOrFolderPath = path.resolve(fileOrFolderPath);
        // Optimistically hope that the starting string is already in the cache,
        // in which case we can avoid disk access entirely.
        //
        // (Two lookups are required, because get() cannot distinguish the undefined value
        // versus a missing key.)
        if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {
            return this._packageFolderCache.get(resolvedFileOrFolderPath);
        }
        // Now call the recursive part of the algorithm
        return this._tryGetPackageFolderFor(resolvedFileOrFolderPath);
    }
    /**
     * If the specified file or folder is part of a package, this returns the absolute path
     * to the associated package.json file.
     *
     * @remarks
     * The package folder is determined using the same algorithm
     * as {@link PackageJsonLookup.tryGetPackageFolderFor}.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an absolute path to * package.json file
     */
    tryGetPackageJsonFilePathFor(fileOrFolderPath) {
        const packageJsonFolder = this.tryGetPackageFolderFor(fileOrFolderPath);
        if (!packageJsonFolder) {
            return undefined;
        }
        return path.join(packageJsonFolder, "package.json" /* PackageJson */);
    }
    /**
     * If the specified file or folder is part of a package, this loads and returns the
     * associated package.json file.
     *
     * @remarks
     * The package folder is determined using the same algorithm
     * as {@link PackageJsonLookup.tryGetPackageFolderFor}.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an IPackageJson object, or undefined if the fileOrFolderPath does not
     * belong to a package
     */
    tryLoadPackageJsonFor(fileOrFolderPath) {
        const packageJsonFilePath = this.tryGetPackageJsonFilePathFor(fileOrFolderPath);
        if (!packageJsonFilePath) {
            return undefined;
        }
        return this.loadPackageJson(packageJsonFilePath);
    }
    /**
     * This function is similar to {@link PackageJsonLookup.tryLoadPackageJsonFor}, except that it does not report
     * an error if the `version` field is missing from the package.json file.
     */
    tryLoadNodePackageJsonFor(fileOrFolderPath) {
        const packageJsonFilePath = this.tryGetPackageJsonFilePathFor(fileOrFolderPath);
        if (!packageJsonFilePath) {
            return undefined;
        }
        return this.loadNodePackageJson(packageJsonFilePath);
    }
    /**
     * Loads the specified package.json file, if it is not already present in the cache.
     *
     * @remarks
     * Unless {@link IPackageJsonLookupParameters.loadExtraFields} was specified,
     * the returned IPackageJson object will contain a subset of essential fields.
     * The returned object should be considered to be immutable; the caller must never
     * modify it.
     *
     * @param jsonFilename - a relative or absolute path to a package.json file
     */
    loadPackageJson(jsonFilename) {
        const packageJson = this.loadNodePackageJson(jsonFilename);
        if (!packageJson.version) {
            throw new Error(`Error reading "${jsonFilename}":\n  The required field "version" was not found`);
        }
        return packageJson;
    }
    /**
     * This function is similar to {@link PackageJsonLookup.loadPackageJson}, except that it does not report an error
     * if the `version` field is missing from the package.json file.
     */
    loadNodePackageJson(jsonFilename) {
        if (!FileSystem_1.FileSystem.exists(jsonFilename)) {
            throw new Error(`Input file not found: ${jsonFilename}`);
        }
        // Since this will be a cache key, follow any symlinks and get an absolute path
        // to minimize duplication.  (Note that duplication can still occur due to e.g. character case.)
        const normalizedFilePath = FileSystem_1.FileSystem.getRealPath(jsonFilename);
        let packageJson = this._packageJsonCache.get(normalizedFilePath);
        if (!packageJson) {
            const loadedPackageJson = JsonFile_1.JsonFile.load(normalizedFilePath);
            // Make sure this is really a package.json file.  CommonJS has fairly strict requirements,
            // but NPM only requires "name" and "version"
            if (!loadedPackageJson.name) {
                throw new Error(`Error reading "${jsonFilename}":\n  The required field "name" was not found`);
            }
            if (this._loadExtraFields) {
                packageJson = loadedPackageJson;
            }
            else {
                packageJson = {};
                // Unless "loadExtraFields" was requested, copy over the essential fields only
                packageJson.bin = loadedPackageJson.bin;
                packageJson.dependencies = loadedPackageJson.dependencies;
                packageJson.description = loadedPackageJson.description;
                packageJson.devDependencies = loadedPackageJson.devDependencies;
                packageJson.homepage = loadedPackageJson.homepage;
                packageJson.license = loadedPackageJson.license;
                packageJson.main = loadedPackageJson.main;
                packageJson.name = loadedPackageJson.name;
                packageJson.optionalDependencies = loadedPackageJson.optionalDependencies;
                packageJson.peerDependencies = loadedPackageJson.peerDependencies;
                packageJson.private = loadedPackageJson.private;
                packageJson.scripts = loadedPackageJson.scripts;
                packageJson.typings = loadedPackageJson.typings || loadedPackageJson.types;
                packageJson.tsdocMetadata = loadedPackageJson.tsdocMetadata;
                packageJson.version = loadedPackageJson.version;
            }
            Object.freeze(packageJson);
            this._packageJsonCache.set(normalizedFilePath, packageJson);
        }
        return packageJson;
    }
    // Recursive part of the algorithm from tryGetPackageFolderFor()
    _tryGetPackageFolderFor(resolvedFileOrFolderPath) {
        // Two lookups are required, because get() cannot distinguish the undefined value
        // versus a missing key.
        if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {
            return this._packageFolderCache.get(resolvedFileOrFolderPath);
        }
        // Is resolvedFileOrFolderPath itself a folder with a package.json file?  If so, return it.
        if (FileSystem_1.FileSystem.exists(path.join(resolvedFileOrFolderPath, "package.json" /* PackageJson */))) {
            this._packageFolderCache.set(resolvedFileOrFolderPath, resolvedFileOrFolderPath);
            return resolvedFileOrFolderPath;
        }
        // Otherwise go up one level
        const parentFolder = path.dirname(resolvedFileOrFolderPath);
        if (!parentFolder || parentFolder === resolvedFileOrFolderPath) {
            // We reached the root directory without finding a package.json file,
            // so cache the negative result
            this._packageFolderCache.set(resolvedFileOrFolderPath, undefined);
            return undefined; // no match
        }
        // Recurse upwards, caching every step along the way
        const parentResult = this._tryGetPackageFolderFor(parentFolder);
        // Cache the parent's answer as well
        this._packageFolderCache.set(resolvedFileOrFolderPath, parentResult);
        return parentResult;
    }
}
exports.PackageJsonLookup = PackageJsonLookup;
//# sourceMappingURL=PackageJsonLookup.js.map

/***/ }),

/***/ 18398:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageName = exports.PackageNameParser = void 0;
/**
 * A configurable parser for validating and manipulating NPM package names such as `my-package` or `@scope/my-package`.
 *
 * @remarks
 * If you do not need to customize the parser configuration, it is recommended to use {@link PackageName}
 * which exposes these operations as a simple static class.
 *
 * @public
 */
class PackageNameParser {
    constructor(options = {}) {
        this._options = Object.assign({}, options);
    }
    /**
     * This attempts to parse a package name that may include a scope component.
     * The packageName must not be an empty string.
     * @remarks
     * This function will not throw an exception.
     *
     * @returns an {@link IParsedPackageNameOrError} structure whose `error` property will be
     * nonempty if the string could not be parsed.
     */
    tryParse(packageName) {
        const result = {
            scope: '',
            unscopedName: '',
            error: ''
        };
        let input = packageName;
        if (input === null || input === undefined) {
            result.error = 'The package name must not be null or undefined';
            return result;
        }
        // Rule from npmjs.com:
        // "The name must be less than or equal to 214 characters. This includes the scope for scoped packages."
        if (packageName.length > 214) {
            // Don't attempt to parse a ridiculously long input
            result.error = 'The package name cannot be longer than 214 characters';
            return result;
        }
        if (input[0] === '@') {
            const indexOfScopeSlash = input.indexOf('/');
            if (indexOfScopeSlash <= 0) {
                result.scope = input;
                result.error = `Error parsing "${packageName}": The scope must be followed by a slash`;
                return result;
            }
            // Extract the scope substring
            result.scope = input.substr(0, indexOfScopeSlash);
            input = input.substr(indexOfScopeSlash + 1);
        }
        result.unscopedName = input;
        if (result.scope === '@') {
            result.error = `Error parsing "${packageName}": The scope name cannot be empty`;
            return result;
        }
        if (result.unscopedName === '') {
            result.error = 'The package name must not be empty';
            return result;
        }
        // Rule from npmjs.com:
        // "The name can't start with a dot or an underscore."
        if (result.unscopedName[0] === '.' || result.unscopedName[0] === '_') {
            result.error = `The package name "${packageName}" starts with an invalid character`;
            return result;
        }
        // Convert "@scope/unscoped-name" --> "scopeunscoped-name"
        const nameWithoutScopeSymbols = (result.scope ? result.scope.slice(1, -1) : '') + result.unscopedName;
        if (!this._options.allowUpperCase) {
            // "New packages must not have uppercase letters in the name."
            // This can't be enforced because "old" packages are still actively maintained.
            // Example: https://www.npmjs.com/package/Base64
            // However it's pretty reasonable to require the scope to be lower case
            if (result.scope !== result.scope.toLowerCase()) {
                result.error = `The package scope "${result.scope}" must not contain upper case characters`;
                return result;
            }
        }
        // "The name ends up being part of a URL, an argument on the command line, and a folder name.
        // Therefore, the name can't contain any non-URL-safe characters"
        const match = nameWithoutScopeSymbols.match(PackageNameParser._invalidNameCharactersRegExp);
        if (match) {
            result.error = `The package name "${packageName}" contains an invalid character: "${match[0]}"`;
            return result;
        }
        return result;
    }
    /**
     * Same as {@link PackageName.tryParse}, except this throws an exception if the input
     * cannot be parsed.
     * @remarks
     * The packageName must not be an empty string.
     */
    parse(packageName) {
        const result = this.tryParse(packageName);
        if (result.error) {
            throw new Error(result.error);
        }
        return result;
    }
    /**
     * {@inheritDoc IParsedPackageName.scope}
     */
    getScope(packageName) {
        return this.parse(packageName).scope;
    }
    /**
     * {@inheritDoc IParsedPackageName.unscopedName}
     */
    getUnscopedName(packageName) {
        return this.parse(packageName).unscopedName;
    }
    /**
     * Returns true if the specified package name is valid, or false otherwise.
     * @remarks
     * This function will not throw an exception.
     */
    isValidName(packageName) {
        const result = this.tryParse(packageName);
        return !result.error;
    }
    /**
     * Throws an exception if the specified name is not a valid package name.
     * The packageName must not be an empty string.
     */
    validate(packageName) {
        this.parse(packageName);
    }
    /**
     * Combines an optional package scope with an unscoped root name.
     * @param scope - Must be either an empty string, or a scope name such as "\@example"
     * @param unscopedName - Must be a nonempty package name that does not contain a scope
     * @returns A full package name such as "\@example/some-library".
     */
    combineParts(scope, unscopedName) {
        if (scope !== '') {
            if (scope[0] !== '@') {
                throw new Error('The scope must start with an "@" character');
            }
        }
        if (scope.indexOf('/') >= 0) {
            throw new Error('The scope must not contain a "/" character');
        }
        if (unscopedName[0] === '@') {
            throw new Error('The unscopedName cannot start with an "@" character');
        }
        if (unscopedName.indexOf('/') >= 0) {
            throw new Error('The unscopedName must not contain a "/" character');
        }
        let result;
        if (scope === '') {
            result = unscopedName;
        }
        else {
            result = scope + '/' + unscopedName;
        }
        // Make sure the result is a valid package name
        this.validate(result);
        return result;
    }
}
exports.PackageNameParser = PackageNameParser;
// encodeURIComponent() escapes all characters except:  A-Z a-z 0-9 - _ . ! ~ * ' ( )
// However, these are disallowed because they are shell characters:       ! ~ * ' ( )
PackageNameParser._invalidNameCharactersRegExp = /[^A-Za-z0-9\-_\.]/;
/**
 * Provides basic operations for validating and manipulating NPM package names such as `my-package`
 * or `@scope/my-package`.
 *
 * @remarks
 * This is the default implementation of {@link PackageNameParser}, exposed as a convenient static class.
 * If you need to configure the parsing rules, use `PackageNameParser` instead.
 *
 * @public
 */
class PackageName {
    /** {@inheritDoc PackageNameParser.tryParse} */
    static tryParse(packageName) {
        return PackageName._parser.tryParse(packageName);
    }
    /** {@inheritDoc PackageNameParser.parse} */
    static parse(packageName) {
        return this._parser.parse(packageName);
    }
    /** {@inheritDoc PackageNameParser.getScope} */
    static getScope(packageName) {
        return this._parser.getScope(packageName);
    }
    /** {@inheritDoc PackageNameParser.getUnscopedName} */
    static getUnscopedName(packageName) {
        return this._parser.getUnscopedName(packageName);
    }
    /** {@inheritDoc PackageNameParser.isValidName} */
    static isValidName(packageName) {
        return this._parser.isValidName(packageName);
    }
    /** {@inheritDoc PackageNameParser.validate} */
    static validate(packageName) {
        return this._parser.validate(packageName);
    }
    /** {@inheritDoc PackageNameParser.combineParts} */
    static combineParts(scope, unscopedName) {
        return this._parser.combineParts(scope, unscopedName);
    }
}
exports.PackageName = PackageName;
PackageName._parser = new PackageNameParser();
//# sourceMappingURL=PackageName.js.map

/***/ }),

/***/ 3120:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Path = void 0;
const path = __importStar(__webpack_require__(85622));
const Text_1 = __webpack_require__(28188);
/**
 * Common operations for manipulating file and directory paths.
 * @remarks
 * This API is intended to eventually be a complete replacement for the NodeJS "path" API.
 * @public
 */
class Path {
    /**
     * Returns true if "childPath" is located inside the "parentFolderPath" folder
     * or one of its child folders.  Note that "parentFolderPath" is not considered to be
     * under itself.  The "childPath" can refer to any type of file system object.
     *
     * @remarks
     * The indicated file/folder objects are not required to actually exist on disk.
     * For example, "parentFolderPath" is interpreted as a folder name even if it refers to a file.
     * If the paths are relative, they will first be resolved using path.resolve().
     */
    static isUnder(childPath, parentFolderPath) {
        // If childPath is under parentPath, then relativePath will be something like
        // "../.." or "..\\..", which consists entirely of periods and slashes.
        // (Note that something like "....t" is actually a valid filename, but "...." is not.)
        const relativePath = path.relative(childPath, parentFolderPath);
        return Path._relativePathRegex.test(relativePath);
    }
    /**
     * Returns true if "childPath" is equal to "parentFolderPath", or if it is inside that folder
     * or one of its children.  The "childPath" can refer to any type of file system object.
     *
     * @remarks
     * The indicated file/folder objects are not required to actually exist on disk.
     * For example, "parentFolderPath" is interpreted as a folder name even if it refers to a file.
     * If the paths are relative, they will first be resolved using path.resolve().
     */
    static isUnderOrEqual(childPath, parentFolderPath) {
        const relativePath = path.relative(childPath, parentFolderPath);
        return relativePath === '' || Path._relativePathRegex.test(relativePath);
    }
    /**
     * Returns true if `path1` and `path2` refer to the same underlying path.
     *
     * @remarks
     *
     * The comparison is performed using `path.relative()`.
     */
    static isEqual(path1, path2) {
        return path.relative(path1, path2) === '';
    }
    /**
     * Formats a path to look nice for reporting purposes.
     * @remarks
     * If `pathToConvert` is under the `baseFolder`, then it will be converted to a relative with the `./` prefix.
     * Otherwise, it will be converted to an absolute path.
     *
     * Backslashes will be converted to slashes, unless the path starts with an OS-specific string like `C:\`.
     */
    static formatConcisely(options) {
        // Same logic as Path.isUnderOrEqual()
        const relativePath = path.relative(options.pathToConvert, options.baseFolder);
        const isUnderOrEqual = relativePath === '' || Path._relativePathRegex.test(relativePath);
        if (isUnderOrEqual) {
            // Note that isUnderOrEqual()'s relativePath is the reverse direction
            return './' + Path.convertToSlashes(path.relative(options.baseFolder, options.pathToConvert));
        }
        const absolutePath = path.resolve(options.pathToConvert);
        return absolutePath;
    }
    /**
     * Replaces Windows-style backslashes with POSIX-style slashes.
     *
     * @remarks
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    static convertToSlashes(inputPath) {
        return Text_1.Text.replaceAll(inputPath, '\\', '/');
    }
    /**
     * Replaces POSIX-style slashes with Windows-style backslashes
     *
     * @remarks
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    static convertToBackslashes(inputPath) {
        return Text_1.Text.replaceAll(inputPath, '/', '\\');
    }
    /**
     * Returns true if the specified path is a relative path and does not use `..` to walk upwards.
     *
     * @example
     * ```ts
     * // These evaluate to true
     * isDownwardRelative('folder');
     * isDownwardRelative('file');
     * isDownwardRelative('folder/');
     * isDownwardRelative('./folder/');
     * isDownwardRelative('./folder/file');
     *
     * // These evaluate to false
     * isDownwardRelative('../folder');
     * isDownwardRelative('folder/../file');
     * isDownwardRelative('/folder/file');
     * ```
     */
    static isDownwardRelative(inputPath) {
        if (path.isAbsolute(inputPath)) {
            return false;
        }
        // Does it contain ".."
        if (Path._upwardPathSegmentRegex.test(inputPath)) {
            return false;
        }
        return true;
    }
}
exports.Path = Path;
// Matches a relative path consisting entirely of periods and slashes
// Example: ".", "..", "../..", etc
Path._relativePathRegex = /^[.\/\\]+$/;
// Matches a relative path segment that traverses upwards
// Example: "a/../b"
Path._upwardPathSegmentRegex = /([\/\\]|^)\.\.([\/\\]|$)/;
//# sourceMappingURL=Path.js.map

/***/ }),

/***/ 67321:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtectableMap = void 0;
const ProtectableMapView_1 = __webpack_require__(69465);
/**
 * The ProtectableMap provides an easy way for an API to expose a `Map<K, V>` property
 * while intercepting and validating any write operations that are performed by
 * consumers of the API.
 *
 * @remarks
 * The ProtectableMap itself is intended to be a private object that only its owner
 * can access directly.  Any operations performed directly on the ProtectableMap will
 * bypass the hooks and any validation they perform.  The public property that is exposed
 * to API consumers should return {@link ProtectableMap.protectedView} instead.
 *
 * For example, suppose you want to share your `Map<string, number>` data structure,
 * but you want to enforce that the key must always be an upper case string:
 * You could use the onSet() hook to validate the keys and throw an exception
 * if the key is not uppercase.
 *
 * @public
 */
class ProtectableMap {
    constructor(parameters) {
        this._protectedView = new ProtectableMapView_1.ProtectableMapView(this, parameters);
    }
    /**
     * The owner of the protectable map should return this object via its public API.
     */
    get protectedView() {
        return this._protectedView;
    }
    // ---------------------------------------------------------------------------
    // lib.es2015.collections contract - write operations
    /**
     * Removes all entries from the map.
     * This operation does NOT invoke the ProtectableMap onClear() hook.
     */
    clear() {
        this._protectedView._clearUnprotected();
    }
    /**
     * Removes the specified key from the map.
     * This operation does NOT invoke the ProtectableMap onDelete() hook.
     */
    delete(key) {
        return this._protectedView._deleteUnprotected(key);
    }
    /**
     * Sets a value for the specified key.
     * This operation does NOT invoke the ProtectableMap onSet() hook.
     */
    set(key, value) {
        this._protectedView._setUnprotected(key, value);
        return this;
    }
    // ---------------------------------------------------------------------------
    // lib.es2015.collections contract - read operations
    /**
     * Performs an operation for each (key, value) entries in the map.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    forEach(callbackfn, thisArg) {
        this._protectedView.forEach(callbackfn);
    }
    /**
     * Retrieves the value for the specified key.
     * @returns undefined if the value is undefined OR if the key is missing;
     * otherwise returns the value associated with the key.
     */
    get(key) {
        return this._protectedView.get(key);
    }
    /**
     * Returns true if the specified key belongs to the map.
     */
    has(key) {
        return this._protectedView.has(key);
    }
    /**
     * Returns the number of (key, value) entries in the map.
     */
    get size() {
        return this._protectedView.size;
    }
}
exports.ProtectableMap = ProtectableMap;
//# sourceMappingURL=ProtectableMap.js.map

/***/ }),

/***/ 69465:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtectableMapView = void 0;
/**
 * The internal wrapper used by ProtectableMap.  It extends the real `Map<K, V>` base class,
 * but hooks the destructive operations (clear/delete/set) to give the owner a chance
 * to block them.
 *
 * NOTE: This is not a public API.
 */
class ProtectableMapView extends Map {
    constructor(owner, parameters) {
        super();
        this._owner = owner;
        this._parameters = parameters;
    }
    clear() {
        // override
        if (this._parameters.onClear) {
            this._parameters.onClear(this._owner);
        }
        super.clear();
    }
    delete(key) {
        // override
        if (this._parameters.onDelete) {
            this._parameters.onDelete(this._owner, key);
        }
        return super.delete(key);
    }
    set(key, value) {
        // override
        let modifiedValue = value;
        if (this._parameters.onSet) {
            modifiedValue = this._parameters.onSet(this._owner, key, modifiedValue);
        }
        super.set(key, modifiedValue);
        return this;
    }
    // INTERNAL USAGE ONLY
    _clearUnprotected() {
        super.clear();
    }
    // INTERNAL USAGE ONLY
    _deleteUnprotected(key) {
        return super.delete(key);
    }
    // INTERNAL USAGE ONLY
    _setUnprotected(key, value) {
        super.set(key, value);
    }
}
exports.ProtectableMapView = ProtectableMapView;
//# sourceMappingURL=ProtectableMapView.js.map

/***/ }),

/***/ 25540:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sort = void 0;
const LegacyAdapters_1 = __webpack_require__(31160);
/**
 * Operations for sorting collections.
 *
 * @remarks
 * NOTE: Prior to Node 11.x, the `Array.sort()` algorithm is not guaranteed to be stable.  For maximum
 * compatibility, consider using {@link LegacyAdapters.sortStable} instead of `Array.sort()`.
 *
 * @public
 */
class Sort {
    /**
     * Compares `x` and `y` using the JavaScript `>` and `<` operators.  This function is suitable for usage as
     * the callback for `array.sort()`.
     *
     * @remarks
     *
     * The JavaScript ordering is generalized so that `undefined` \< `null` \< all other values.
     *
     * @returns -1 if `x` is smaller than `y`, 1 if `x` is greater than `y`, or 0 if the values are equal.
     *
     * @example
     *
     * ```ts
     * let array: number[] = [3, 6, 2];
     * array.sort(Sort.compareByValue);  // [2, 3, 6]
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static compareByValue(x, y) {
        if (x === y) {
            return 0;
        }
        // Undefined is smaller than anything else
        if (x === undefined) {
            return -1;
        }
        if (y === undefined) {
            return 1;
        }
        // Null is smaller than anything except undefined
        if (x === null) {
            return -1;
        }
        if (y === null) {
            return 1;
        }
        // These comparisons always return false if either of the arguments is "undefined".
        // These comparisons return nonsense for "null" (true for "null > -1", but false for "null < 0" and "null > 0")
        if (x < y) {
            return -1;
        }
        if (x > y) {
            return 1;
        }
        return 0;
    }
    /**
     * Sorts the array according to a key which is obtained from the array elements.
     * The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let array: string[] = [ 'aaa', 'bb', 'c' ];
     * Sort.sortBy(array, x => x.length);  // [ 'c', 'bb', 'aaa' ]
     * ```
     */
    static sortBy(array, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    keySelector, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    comparer = Sort.compareByValue) {
        LegacyAdapters_1.LegacyAdapters.sortStable(array, (x, y) => comparer(keySelector(x), keySelector(y)));
    }
    /**
     * Returns true if the array is already sorted.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static isSorted(array, comparer = Sort.compareByValue) {
        let previous = undefined;
        for (const element of array) {
            if (comparer(previous, element) > 0) {
                return false;
            }
            previous = element;
        }
        return true;
    }
    /**
     * Returns true if the array is already sorted by the specified key.
     *
     * @example
     *
     * ```ts
     * let array: string[] = [ 'a', 'bb', 'ccc' ];
     * Sort.isSortedBy(array, x => x.length); // true
     * ```
     */
    static isSortedBy(array, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    keySelector, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    comparer = Sort.compareByValue) {
        let previousKey = undefined;
        for (const element of array) {
            const key = keySelector(element);
            if (comparer(previousKey, key) > 0) {
                return false;
            }
            previousKey = key;
        }
        return true;
    }
    /**
     * Sorts the entries in a Map object according to the map keys.
     * The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let map: Map<string, number> = new Map<string, number>();
     * map.set('zebra', 1);
     * map.set('goose', 2);
     * map.set('aardvark', 3);
     * Sort.sortMapKeys(map);
     * console.log(JSON.stringify(Array.from(map.keys()))); // ["aardvark","goose","zebra"]
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static sortMapKeys(map, keyComparer = Sort.compareByValue) {
        const pairs = Array.from(map.entries());
        // Sorting a map is expensive, so first check whether it's already sorted.
        if (Sort.isSortedBy(pairs, (x) => x[0], keyComparer)) {
            return;
        }
        Sort.sortBy(pairs, (x) => x[0], keyComparer);
        map.clear();
        for (const pair of pairs) {
            map.set(pair[0], pair[1]);
        }
    }
    /**
     * Sorts the entries in a Set object according to the specified keys.
     * The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let set: Set<string> = new Set<string>();
     * set.add('aaa');
     * set.add('bb');
     * set.add('c');
     * Sort.sortSetBy(set, x => x.length);
     * console.log(Array.from(set)); // ['c', 'bb', 'aaa']
     * ```
     */
    static sortSetBy(set, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    keySelector, keyComparer = Sort.compareByValue) {
        const array = Array.from(set);
        // Sorting a set is expensive, so first check whether it's already sorted.
        if (Sort.isSortedBy(array, keySelector, keyComparer)) {
            return;
        }
        LegacyAdapters_1.LegacyAdapters.sortStable(array, (x, y) => keyComparer(keySelector(x), keySelector(y)));
        set.clear();
        for (const item of array) {
            set.add(item);
        }
    }
    /**
     * Sorts the entries in a Set object.  The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let set: Set<string> = new Set<string>();
     * set.add('zebra');
     * set.add('goose');
     * set.add('aardvark');
     * Sort.sortSet(set);
     * console.log(Array.from(set)); // ['aardvark', 'goose', 'zebra']
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static sortSet(set, comparer = Sort.compareByValue) {
        const array = Array.from(set);
        // Sorting a set is expensive, so first check whether it's already sorted.
        if (Sort.isSorted(array, comparer)) {
            return;
        }
        LegacyAdapters_1.LegacyAdapters.sortStable(array, (x, y) => comparer(x, y));
        set.clear();
        for (const item of array) {
            set.add(item);
        }
    }
}
exports.Sort = Sort;
//# sourceMappingURL=Sort.js.map

/***/ }),

/***/ 75313:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringBuilder = void 0;
/**
 * This class allows a large text string to be constructed incrementally by appending small chunks.  The final
 * string can be obtained by calling StringBuilder.toString().
 *
 * @remarks
 * A naive approach might use the `+=` operator to append strings:  This would have the downside of copying
 * the entire string each time a chunk is appended, resulting in `O(n^2)` bytes of memory being allocated
 * (and later freed by the garbage  collector), and many of the allocations could be very large objects.
 * StringBuilder avoids this overhead by accumulating the chunks in an array, and efficiently joining them
 * when `getText()` is finally called.
 *
 * @public
 */
class StringBuilder {
    constructor() {
        this._chunks = [];
    }
    /** {@inheritDoc IStringBuilder.append} */
    append(text) {
        this._chunks.push(text);
    }
    /** {@inheritDoc IStringBuilder.toString} */
    toString() {
        if (this._chunks.length === 0) {
            return '';
        }
        if (this._chunks.length > 1) {
            const joined = this._chunks.join('');
            this._chunks.length = 1;
            this._chunks[0] = joined;
        }
        return this._chunks[0];
    }
}
exports.StringBuilder = StringBuilder;
//# sourceMappingURL=StringBuilder.js.map

/***/ }),

/***/ 6682:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnsiEscape = void 0;
const Colors_1 = __webpack_require__(89699);
/**
 * Operations for working with text strings that contain
 * {@link https://en.wikipedia.org/wiki/ANSI_escape_code | ANSI escape codes}.
 * The most commonly used escape codes set the foreground/background color for console output.
 * @public
 */
class AnsiEscape {
    /**
     * Returns the input text with all ANSI escape codes removed.  For example, this is useful when saving
     * colorized console output to a log file.
     */
    static removeCodes(text) {
        // eslint-disable-next-line no-control-regex
        return text.replace(AnsiEscape._csiRegExp, '');
    }
    /**
     * Replaces ANSI escape codes with human-readable tokens.  This is useful for unit tests
     * that compare text strings in test assertions or snapshot files.
     */
    static formatForTests(text, options) {
        if (!options) {
            options = {};
        }
        let result = text.replace(AnsiEscape._csiRegExp, (capture, csiCode) => {
            // If it is an SGR code, then try to show a friendly token
            const match = csiCode.match(AnsiEscape._sgrRegExp);
            if (match) {
                const sgrParameter = parseInt(match[1]);
                const sgrParameterName = AnsiEscape._tryGetSgrFriendlyName(sgrParameter);
                if (sgrParameterName) {
                    // Example: "[black-bg]"
                    return `[${sgrParameterName}]`;
                }
            }
            // Otherwise show the raw code, but without the "[" from the CSI prefix
            // Example: "[31m]"
            return `[${csiCode}]`;
        });
        if (options.encodeNewlines) {
            result = result
                .replace(AnsiEscape._backslashNRegExp, '[n]')
                .replace(AnsiEscape._backslashRRegExp, `[r]`);
        }
        return result;
    }
    // Returns a human-readable token representing an SGR parameter, or undefined for parameter that is not well-known.
    // The SGR parameter numbers are documented in this table:
    // https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_parameters
    static _tryGetSgrFriendlyName(sgiParameter) {
        switch (sgiParameter) {
            case Colors_1.ConsoleColorCodes.BlackForeground:
                return 'black';
            case Colors_1.ConsoleColorCodes.RedForeground:
                return 'red';
            case Colors_1.ConsoleColorCodes.GreenForeground:
                return 'green';
            case Colors_1.ConsoleColorCodes.YellowForeground:
                return 'yellow';
            case Colors_1.ConsoleColorCodes.BlueForeground:
                return 'blue';
            case Colors_1.ConsoleColorCodes.MagentaForeground:
                return 'magenta';
            case Colors_1.ConsoleColorCodes.CyanForeground:
                return 'cyan';
            case Colors_1.ConsoleColorCodes.WhiteForeground:
                return 'white';
            case Colors_1.ConsoleColorCodes.GrayForeground:
                return 'gray';
            case Colors_1.ConsoleColorCodes.DefaultForeground:
                return 'default';
            case Colors_1.ConsoleColorCodes.BlackBackground:
                return 'black-bg';
            case Colors_1.ConsoleColorCodes.RedBackground:
                return 'red-bg';
            case Colors_1.ConsoleColorCodes.GreenBackground:
                return 'green-bg';
            case Colors_1.ConsoleColorCodes.YellowBackground:
                return 'yellow-bg';
            case Colors_1.ConsoleColorCodes.BlueBackground:
                return 'blue-bg';
            case Colors_1.ConsoleColorCodes.MagentaBackground:
                return 'magenta-bg';
            case Colors_1.ConsoleColorCodes.CyanBackground:
                return 'cyan-bg';
            case Colors_1.ConsoleColorCodes.WhiteBackground:
                return 'white-bg';
            case Colors_1.ConsoleColorCodes.GrayBackground:
                return 'gray-bg';
            case Colors_1.ConsoleColorCodes.DefaultBackground:
                return 'default-bg';
            case Colors_1.ConsoleColorCodes.Bold:
                return 'bold';
            case Colors_1.ConsoleColorCodes.Dim:
                return 'dim';
            case Colors_1.ConsoleColorCodes.NormalColorOrIntensity:
                return 'normal';
            case Colors_1.ConsoleColorCodes.Underline:
                return 'underline';
            case Colors_1.ConsoleColorCodes.UnderlineOff:
                return 'underline-off';
            case Colors_1.ConsoleColorCodes.Blink:
                return 'blink';
            case Colors_1.ConsoleColorCodes.BlinkOff:
                return 'blink-off';
            case Colors_1.ConsoleColorCodes.InvertColor:
                return 'invert';
            case Colors_1.ConsoleColorCodes.InvertColorOff:
                return 'invert-off';
            case Colors_1.ConsoleColorCodes.Hidden:
                return 'hidden';
            case Colors_1.ConsoleColorCodes.HiddenOff:
                return 'hidden-off';
            default:
                return undefined;
        }
    }
}
exports.AnsiEscape = AnsiEscape;
// For now, we only care about the Control Sequence Introducer (CSI) commands which always start with "[".
// eslint-disable-next-line no-control-regex
AnsiEscape._csiRegExp = /\x1b\[([\x30-\x3f]*[\x20-\x2f]*[\x40-\x7e])/gu;
// Text coloring is performed using Select Graphic Rendition (SGR) codes, which come after the
// CSI introducer "ESC [".  The SGR sequence is a number followed by "m".
AnsiEscape._sgrRegExp = /([0-9]+)m/u;
AnsiEscape._backslashNRegExp = /\n/g;
AnsiEscape._backslashRRegExp = /\r/g;
//# sourceMappingURL=AnsiEscape.js.map

/***/ }),

/***/ 89699:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Colors = exports.ConsoleColorCodes = exports.TextAttribute = exports.ColorValue = exports.eolSequence = void 0;
exports.eolSequence = {
    isEol: true
};
/**
 * Colors used with {@link IColorableSequence}.
 * @beta
 */
var ColorValue;
(function (ColorValue) {
    ColorValue[ColorValue["Black"] = 0] = "Black";
    ColorValue[ColorValue["Red"] = 1] = "Red";
    ColorValue[ColorValue["Green"] = 2] = "Green";
    ColorValue[ColorValue["Yellow"] = 3] = "Yellow";
    ColorValue[ColorValue["Blue"] = 4] = "Blue";
    ColorValue[ColorValue["Magenta"] = 5] = "Magenta";
    ColorValue[ColorValue["Cyan"] = 6] = "Cyan";
    ColorValue[ColorValue["White"] = 7] = "White";
    ColorValue[ColorValue["Gray"] = 8] = "Gray";
})(ColorValue = exports.ColorValue || (exports.ColorValue = {}));
/**
 * Text styles used with {@link IColorableSequence}.
 * @beta
 */
var TextAttribute;
(function (TextAttribute) {
    TextAttribute[TextAttribute["Bold"] = 0] = "Bold";
    TextAttribute[TextAttribute["Dim"] = 1] = "Dim";
    TextAttribute[TextAttribute["Underline"] = 2] = "Underline";
    TextAttribute[TextAttribute["Blink"] = 3] = "Blink";
    TextAttribute[TextAttribute["InvertColor"] = 4] = "InvertColor";
    TextAttribute[TextAttribute["Hidden"] = 5] = "Hidden";
})(TextAttribute = exports.TextAttribute || (exports.TextAttribute = {}));
var ConsoleColorCodes;
(function (ConsoleColorCodes) {
    ConsoleColorCodes[ConsoleColorCodes["BlackForeground"] = 30] = "BlackForeground";
    ConsoleColorCodes[ConsoleColorCodes["RedForeground"] = 31] = "RedForeground";
    ConsoleColorCodes[ConsoleColorCodes["GreenForeground"] = 32] = "GreenForeground";
    ConsoleColorCodes[ConsoleColorCodes["YellowForeground"] = 33] = "YellowForeground";
    ConsoleColorCodes[ConsoleColorCodes["BlueForeground"] = 34] = "BlueForeground";
    ConsoleColorCodes[ConsoleColorCodes["MagentaForeground"] = 35] = "MagentaForeground";
    ConsoleColorCodes[ConsoleColorCodes["CyanForeground"] = 36] = "CyanForeground";
    ConsoleColorCodes[ConsoleColorCodes["WhiteForeground"] = 37] = "WhiteForeground";
    ConsoleColorCodes[ConsoleColorCodes["GrayForeground"] = 90] = "GrayForeground";
    ConsoleColorCodes[ConsoleColorCodes["DefaultForeground"] = 39] = "DefaultForeground";
    ConsoleColorCodes[ConsoleColorCodes["BlackBackground"] = 40] = "BlackBackground";
    ConsoleColorCodes[ConsoleColorCodes["RedBackground"] = 41] = "RedBackground";
    ConsoleColorCodes[ConsoleColorCodes["GreenBackground"] = 42] = "GreenBackground";
    ConsoleColorCodes[ConsoleColorCodes["YellowBackground"] = 43] = "YellowBackground";
    ConsoleColorCodes[ConsoleColorCodes["BlueBackground"] = 44] = "BlueBackground";
    ConsoleColorCodes[ConsoleColorCodes["MagentaBackground"] = 45] = "MagentaBackground";
    ConsoleColorCodes[ConsoleColorCodes["CyanBackground"] = 46] = "CyanBackground";
    ConsoleColorCodes[ConsoleColorCodes["WhiteBackground"] = 47] = "WhiteBackground";
    ConsoleColorCodes[ConsoleColorCodes["GrayBackground"] = 100] = "GrayBackground";
    ConsoleColorCodes[ConsoleColorCodes["DefaultBackground"] = 49] = "DefaultBackground";
    ConsoleColorCodes[ConsoleColorCodes["Bold"] = 1] = "Bold";
    // On Linux, the "BoldOff" code instead causes the text to be double-underlined:
    // https://en.wikipedia.org/wiki/Talk:ANSI_escape_code#SGR_21%E2%80%94%60Bold_off%60_not_widely_supported
    // Use "NormalColorOrIntensity" instead
    // BoldOff = 21,
    ConsoleColorCodes[ConsoleColorCodes["Dim"] = 2] = "Dim";
    ConsoleColorCodes[ConsoleColorCodes["NormalColorOrIntensity"] = 22] = "NormalColorOrIntensity";
    ConsoleColorCodes[ConsoleColorCodes["Underline"] = 4] = "Underline";
    ConsoleColorCodes[ConsoleColorCodes["UnderlineOff"] = 24] = "UnderlineOff";
    ConsoleColorCodes[ConsoleColorCodes["Blink"] = 5] = "Blink";
    ConsoleColorCodes[ConsoleColorCodes["BlinkOff"] = 25] = "BlinkOff";
    ConsoleColorCodes[ConsoleColorCodes["InvertColor"] = 7] = "InvertColor";
    ConsoleColorCodes[ConsoleColorCodes["InvertColorOff"] = 27] = "InvertColorOff";
    ConsoleColorCodes[ConsoleColorCodes["Hidden"] = 8] = "Hidden";
    ConsoleColorCodes[ConsoleColorCodes["HiddenOff"] = 28] = "HiddenOff";
})(ConsoleColorCodes = exports.ConsoleColorCodes || (exports.ConsoleColorCodes = {}));
/**
 * The static functions on this class are used to produce colored text
 * for use with the node-core-library terminal.
 *
 * @example
 * terminal.writeLine(Colors.green('Green Text!'), ' ', Colors.blue('Blue Text!'));
 *
 * @beta
 */
class Colors {
    static black(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Black });
    }
    static red(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Red });
    }
    static green(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Green });
    }
    static yellow(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Yellow });
    }
    static blue(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Blue });
    }
    static magenta(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Magenta });
    }
    static cyan(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Cyan });
    }
    static white(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.White });
    }
    static gray(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Gray });
    }
    static blackBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Black });
    }
    static redBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Red });
    }
    static greenBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Green });
    }
    static yellowBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Yellow });
    }
    static blueBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Blue });
    }
    static magentaBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Magenta });
    }
    static cyanBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Cyan });
    }
    static whiteBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.White });
    }
    static grayBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Gray });
    }
    static bold(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Bold);
    }
    static dim(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Dim);
    }
    static underline(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Underline);
    }
    static blink(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Blink);
    }
    static invertColor(text) {
        return Colors._applyTextAttribute(text, TextAttribute.InvertColor);
    }
    static hidden(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Hidden);
    }
    /**
     * If called with a string, returns the string wrapped in a {@link IColorableSequence}.
     * If called with a {@link IColorableSequence}, returns the {@link IColorableSequence}.
     *
     * @internal
     */
    static _normalizeStringOrColorableSequence(value) {
        if (typeof value === 'string') {
            return {
                text: value
            };
        }
        else {
            return value;
        }
    }
    static _applyTextAttribute(text, attribute) {
        const sequence = Colors._normalizeStringOrColorableSequence(text);
        if (!sequence.textAttributes) {
            sequence.textAttributes = [];
        }
        sequence.textAttributes.push(attribute);
        return sequence;
    }
}
exports.Colors = Colors;
//# sourceMappingURL=Colors.js.map

/***/ }),

/***/ 74298:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsoleTerminalProvider = void 0;
const os_1 = __webpack_require__(12087);
const safe_1 = __webpack_require__(41997);
const ITerminalProvider_1 = __webpack_require__(24175);
/**
 * Terminal provider that prints to STDOUT (for log- and verbose-level messages) and
 * STDERR (for warning- and error-level messsages).
 *
 * @beta
 */
class ConsoleTerminalProvider {
    constructor(options = {}) {
        /**
         * If true, verbose-level messages should be written to the console.
         */
        this.verboseEnabled = false;
        /**
         * If true, debug-level messages should be written to the console.
         */
        this.debugEnabled = false;
        this.verboseEnabled = !!options.verboseEnabled;
        this.debugEnabled = !!options.debugEnabled;
    }
    /**
     * {@inheritDoc ITerminalProvider.write}
     */
    write(data, severity) {
        switch (severity) {
            case ITerminalProvider_1.TerminalProviderSeverity.warning:
            case ITerminalProvider_1.TerminalProviderSeverity.error: {
                process.stderr.write(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.verbose: {
                if (this.verboseEnabled) {
                    process.stdout.write(data);
                }
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.debug: {
                if (this.debugEnabled) {
                    process.stdout.write(data);
                }
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.log:
            default: {
                process.stdout.write(data);
                break;
            }
        }
    }
    /**
     * {@inheritDoc ITerminalProvider.eolCharacter}
     */
    get eolCharacter() {
        return os_1.EOL;
    }
    /**
     * {@inheritDoc ITerminalProvider.supportsColor}
     */
    get supportsColor() {
        return safe_1.enabled;
    }
}
exports.ConsoleTerminalProvider = ConsoleTerminalProvider;
//# sourceMappingURL=ConsoleTerminalProvider.js.map

/***/ }),

/***/ 24175:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TerminalProviderSeverity = void 0;
/**
 * Similar to many popular logging packages, terminal providers support a range of message
 * severities. These severities have built-in formatting defaults in the Terminal object
 * (warnings are yellow, errors are red, etc.).
 *
 * Terminal providers may choose to suppress certain messages based on their severity,
 * or to route some messages to other providers or not based on severity.
 *
 *   Severity  | Purpose
 *   --------- | -------
 *   error     | Build errors and fatal issues
 *   warning   | Not necessarily fatal, but indicate a problem the user should fix
 *   log       | Informational messages
 *   verbose   | Additional information that may not always be necessary
 *   debug     | Highest detail level, best used for troubleshooting information
 *
 * @beta
 */
var TerminalProviderSeverity;
(function (TerminalProviderSeverity) {
    TerminalProviderSeverity[TerminalProviderSeverity["log"] = 0] = "log";
    TerminalProviderSeverity[TerminalProviderSeverity["warning"] = 1] = "warning";
    TerminalProviderSeverity[TerminalProviderSeverity["error"] = 2] = "error";
    TerminalProviderSeverity[TerminalProviderSeverity["verbose"] = 3] = "verbose";
    TerminalProviderSeverity[TerminalProviderSeverity["debug"] = 4] = "debug";
})(TerminalProviderSeverity = exports.TerminalProviderSeverity || (exports.TerminalProviderSeverity = {}));
//# sourceMappingURL=ITerminalProvider.js.map

/***/ }),

/***/ 26238:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringBufferTerminalProvider = void 0;
const ITerminalProvider_1 = __webpack_require__(24175);
const StringBuilder_1 = __webpack_require__(75313);
const Text_1 = __webpack_require__(28188);
const AnsiEscape_1 = __webpack_require__(6682);
/**
 * Terminal provider that stores written data in buffers separated by severity.
 * This terminal provider is designed to be used when code that prints to a terminal
 * is being unit tested.
 *
 * @beta
 */
class StringBufferTerminalProvider {
    constructor(supportsColor = false) {
        this._standardBuffer = new StringBuilder_1.StringBuilder();
        this._verboseBuffer = new StringBuilder_1.StringBuilder();
        this._debugBuffer = new StringBuilder_1.StringBuilder();
        this._warningBuffer = new StringBuilder_1.StringBuilder();
        this._errorBuffer = new StringBuilder_1.StringBuilder();
        this._supportsColor = supportsColor;
    }
    /**
     * {@inheritDoc ITerminalProvider.write}
     */
    write(data, severity) {
        switch (severity) {
            case ITerminalProvider_1.TerminalProviderSeverity.warning: {
                this._warningBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.error: {
                this._errorBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.verbose: {
                this._verboseBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.debug: {
                this._debugBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.log:
            default: {
                this._standardBuffer.append(data);
                break;
            }
        }
    }
    /**
     * {@inheritDoc ITerminalProvider.eolCharacter}
     */
    get eolCharacter() {
        return '[n]';
    }
    /**
     * {@inheritDoc ITerminalProvider.supportsColor}
     */
    get supportsColor() {
        return this._supportsColor;
    }
    /**
     * Get everything that has been written at log-level severity.
     */
    getOutput(options) {
        return this._normalizeOutput(this._standardBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at verbose-level severity.
     */
    getVerbose(options) {
        return this._normalizeOutput(this._verboseBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at debug-level severity.
     */
    getDebugOutput(options) {
        return this._normalizeOutput(this._debugBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at error-level severity.
     */
    getErrorOutput(options) {
        return this._normalizeOutput(this._errorBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at warning-level severity.
     */
    getWarningOutput(options) {
        return this._normalizeOutput(this._warningBuffer.toString(), options);
    }
    _normalizeOutput(s, options) {
        options = Object.assign({ normalizeSpecialCharacters: true }, (options || {}));
        s = Text_1.Text.convertToLf(s);
        if (options.normalizeSpecialCharacters) {
            return AnsiEscape_1.AnsiEscape.formatForTests(s, { encodeNewlines: true });
        }
        else {
            return s;
        }
    }
}
exports.StringBufferTerminalProvider = StringBufferTerminalProvider;
//# sourceMappingURL=StringBufferTerminalProvider.js.map

/***/ }),

/***/ 81593:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Terminal = void 0;
const ITerminalProvider_1 = __webpack_require__(24175);
const Colors_1 = __webpack_require__(89699);
/**
 * This class facilitates writing to a console.
 *
 * @beta
 */
class Terminal {
    constructor(provider) {
        this._providers = new Set();
        this._providers.add(provider);
    }
    /**
     * {@inheritdoc ITerminal.registerProvider}
     */
    registerProvider(provider) {
        this._providers.add(provider);
    }
    /**
     * {@inheritdoc ITerminal.unregisterProvider}
     */
    unregisterProvider(provider) {
        if (this._providers.has(provider)) {
            this._providers.delete(provider);
        }
    }
    /**
     * {@inheritdoc ITerminal.write}
     */
    write(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.log);
    }
    /**
     * {@inheritdoc ITerminal.writeLine}
     */
    writeLine(...messageParts) {
        this.write(...messageParts, Colors_1.eolSequence);
    }
    /**
     * {@inheritdoc ITerminal.writeWarning}
     */
    writeWarning(...messageParts) {
        this._writeSegmentsToProviders(messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Yellow }))), ITerminalProvider_1.TerminalProviderSeverity.warning);
    }
    /**
     * {@inheritdoc ITerminal.writeWarningLine}
     */
    writeWarningLine(...messageParts) {
        this._writeSegmentsToProviders([
            ...messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Yellow }))),
            Colors_1.eolSequence
        ], ITerminalProvider_1.TerminalProviderSeverity.warning);
    }
    /**
     * {@inheritdoc ITerminal.writeError}
     */
    writeError(...messageParts) {
        this._writeSegmentsToProviders(messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Red }))), ITerminalProvider_1.TerminalProviderSeverity.error);
    }
    /**
     * {@inheritdoc ITerminal.writeErrorLine}
     */
    writeErrorLine(...messageParts) {
        this._writeSegmentsToProviders([
            ...messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Red }))),
            Colors_1.eolSequence
        ], ITerminalProvider_1.TerminalProviderSeverity.error);
    }
    /**
     * {@inheritdoc ITerminal.writeVerbose}
     */
    writeVerbose(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.verbose);
    }
    /**
     * {@inheritdoc ITerminal.writeVerboseLine}
     */
    writeVerboseLine(...messageParts) {
        this.writeVerbose(...messageParts, Colors_1.eolSequence);
    }
    /**
     * {@inheritdoc ITerminal.writeDebug}
     */
    writeDebug(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.debug);
    }
    /**
     * {@inheritdoc ITerminal.writeDebugLine}
     */
    writeDebugLine(...messageParts) {
        this.writeDebug(...messageParts, Colors_1.eolSequence);
    }
    _writeSegmentsToProviders(segments, severity) {
        const withColorText = {};
        const withoutColorText = {};
        let withColorLines;
        let withoutColorLines;
        this._providers.forEach((provider) => {
            const eol = provider.eolCharacter;
            let textToWrite;
            if (provider.supportsColor) {
                if (!withColorLines) {
                    withColorLines = this._serializeFormattableTextSegments(segments, true);
                }
                if (!withColorText[eol]) {
                    withColorText[eol] = withColorLines.join(eol);
                }
                textToWrite = withColorText[eol];
            }
            else {
                if (!withoutColorLines) {
                    withoutColorLines = this._serializeFormattableTextSegments(segments, false);
                }
                if (!withoutColorText[eol]) {
                    withoutColorText[eol] = withoutColorLines.join(eol);
                }
                textToWrite = withoutColorText[eol];
            }
            provider.write(textToWrite, severity);
        });
    }
    _serializeFormattableTextSegments(segments, withColor) {
        const lines = [];
        let segmentsToJoin = [];
        let lastSegmentWasEol = false;
        for (let i = 0; i < segments.length; i++) {
            const segment = Colors_1.Colors._normalizeStringOrColorableSequence(segments[i]);
            lastSegmentWasEol = !!segment.isEol;
            if (lastSegmentWasEol) {
                lines.push(segmentsToJoin.join(''));
                segmentsToJoin = [];
            }
            else {
                if (withColor) {
                    const startColorCodes = [];
                    const endColorCodes = [];
                    switch (segment.foregroundColor) {
                        case Colors_1.ColorValue.Black: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlackForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Red: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.RedForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Green: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GreenForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Yellow: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.YellowForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Blue: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlueForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Magenta: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.MagentaForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Cyan: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.CyanForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.White: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.WhiteForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Gray: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GrayForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                    }
                    switch (segment.backgroundColor) {
                        case Colors_1.ColorValue.Black: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlackBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Red: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.RedBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Green: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GreenBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Yellow: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.YellowBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Blue: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlueBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Magenta: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.MagentaBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Cyan: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.CyanBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.White: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.WhiteBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Gray: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GrayBackground);
                            endColorCodes.push(49);
                            break;
                        }
                    }
                    if (segment.textAttributes) {
                        for (const textAttribute of segment.textAttributes) {
                            switch (textAttribute) {
                                case Colors_1.TextAttribute.Bold: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Bold);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.NormalColorOrIntensity);
                                    break;
                                }
                                case Colors_1.TextAttribute.Dim: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Dim);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.NormalColorOrIntensity);
                                    break;
                                }
                                case Colors_1.TextAttribute.Underline: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Underline);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.UnderlineOff);
                                    break;
                                }
                                case Colors_1.TextAttribute.Blink: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Blink);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.BlinkOff);
                                    break;
                                }
                                case Colors_1.TextAttribute.InvertColor: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.InvertColor);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.InvertColorOff);
                                    break;
                                }
                                case Colors_1.TextAttribute.Hidden: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Hidden);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.HiddenOff);
                                    break;
                                }
                            }
                        }
                    }
                    for (let j = 0; j < startColorCodes.length; j++) {
                        const code = startColorCodes[j];
                        segmentsToJoin.push(...['\u001b[', code.toString(), 'm']);
                    }
                    segmentsToJoin.push(segment.text);
                    for (let j = endColorCodes.length - 1; j >= 0; j--) {
                        const code = endColorCodes[j];
                        segmentsToJoin.push(...['\u001b[', code.toString(), 'm']);
                    }
                }
                else {
                    segmentsToJoin.push(segment.text);
                }
            }
        }
        if (segmentsToJoin.length > 0) {
            lines.push(segmentsToJoin.join(''));
        }
        if (lastSegmentWasEol) {
            lines.push('');
        }
        return lines;
    }
}
exports.Terminal = Terminal;
//# sourceMappingURL=Terminal.js.map

/***/ }),

/***/ 28188:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Text = void 0;
const os = __importStar(__webpack_require__(12087));
/**
 * Operations for working with strings that contain text.
 *
 * @remarks
 * The utilities provided by this class are intended to be simple, small, and very
 * broadly applicable.
 *
 * @public
 */
class Text {
    /**
     * Returns the same thing as targetString.replace(searchValue, replaceValue), except that
     * all matches are replaced, rather than just the first match.
     * @param input         - The string to be modified
     * @param searchValue   - The value to search for
     * @param replaceValue  - The replacement text
     */
    static replaceAll(input, searchValue, replaceValue) {
        return input.split(searchValue).join(replaceValue);
    }
    /**
     * Converts all newlines in the provided string to use Windows-style CRLF end of line characters.
     */
    static convertToCrLf(input) {
        return input.replace(Text._newLineRegEx, '\r\n');
    }
    /**
     * Converts all newlines in the provided string to use POSIX-style LF end of line characters.
     *
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    static convertToLf(input) {
        return input.replace(Text._newLineRegEx, '\n');
    }
    /**
     * Converts all newlines in the provided string to use the specified newline type.
     */
    static convertTo(input, newlineKind) {
        return input.replace(Text._newLineRegEx, Text.getNewline(newlineKind));
    }
    /**
     * Returns the newline character sequence for the specified `NewlineKind`.
     */
    static getNewline(newlineKind) {
        switch (newlineKind) {
            case "\r\n" /* CrLf */:
                return '\r\n';
            case "\n" /* Lf */:
                return '\n';
            case "os" /* OsDefault */:
                return os.EOL;
            default:
                throw new Error('Unsupported newline kind');
        }
    }
    /**
     * Append characters to the end of a string to ensure the result has a minimum length.
     * @remarks
     * If the string length already exceeds the minimum length, then the string is unchanged.
     * The string is not truncated.
     */
    static padEnd(s, minimumLength, paddingCharacter = ' ') {
        if (paddingCharacter.length !== 1) {
            throw new Error('The paddingCharacter parameter must be a single character.');
        }
        if (s.length < minimumLength) {
            const paddingArray = new Array(minimumLength - s.length);
            paddingArray.unshift(s);
            return paddingArray.join(paddingCharacter);
        }
        else {
            return s;
        }
    }
    /**
     * Append characters to the start of a string to ensure the result has a minimum length.
     * @remarks
     * If the string length already exceeds the minimum length, then the string is unchanged.
     * The string is not truncated.
     */
    static padStart(s, minimumLength, paddingCharacter = ' ') {
        if (paddingCharacter.length !== 1) {
            throw new Error('The paddingCharacter parameter must be a single character.');
        }
        if (s.length < minimumLength) {
            const paddingArray = new Array(minimumLength - s.length);
            paddingArray.push(s);
            return paddingArray.join(paddingCharacter);
        }
        else {
            return s;
        }
    }
    /**
     * If the string is longer than maximumLength characters, truncate it to that length
     * using "..." to indicate the truncation.
     *
     * @remarks
     * For example truncateWithEllipsis('1234578', 5) would produce '12...'.
     */
    static truncateWithEllipsis(s, maximumLength) {
        if (maximumLength < 0) {
            throw new Error('The maximumLength cannot be a negative number');
        }
        if (s.length <= maximumLength) {
            return s;
        }
        if (s.length <= 3) {
            return s.substring(0, maximumLength);
        }
        return s.substring(0, maximumLength - 3) + '...';
    }
    /**
     * Returns the input string with a trailing `\n` character appended, if not already present.
     */
    static ensureTrailingNewline(s, newlineKind = "\n" /* Lf */) {
        // Is there already a newline?
        if (Text._newLineAtEndRegEx.test(s)) {
            return s; // yes, no change
        }
        return s + newlineKind; // no, add it
    }
}
exports.Text = Text;
Text._newLineRegEx = /\r\n|\n\r|\r|\n/g;
Text._newLineAtEndRegEx = /(\r\n|\n\r|\r|\n)$/;
//# sourceMappingURL=Text.js.map

/***/ }),

/***/ 92736:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeUuid = void 0;
const InternalError_1 = __webpack_require__(22182);
const classPrototypeUuidSymbol = Symbol.for('TypeUuid.classPrototypeUuid');
/**
 * Provides a version-independent implementation of the JavaScript `instanceof` operator.
 *
 * @remarks
 * The JavaScript `instanceof` operator normally only identifies objects from a particular library instance.
 * For example, suppose the NPM package `example-lib` has two published versions 1.2.0 and 1.3.0, and
 * it exports a class called `A`.  Suppose some code consumes version `1.3.0` of the library, but it receives
 * an object that was constructed using version `1.2.0`.  In this situation `a instanceof A` will return `false`,
 * even though `a` is an instance of `A`.  The reason is that there are two prototypes for `A`; one for each
 * version.
 *
 * The `TypeUuid` facility provides a way to make `a instanceof A` return true for both prototypes of `A`,
 * by instead using a universally unique identifier (UUID) to detect object instances.
 *
 * You can use `Symbol.hasInstance` to enable the system `instanceof` operator to recognize type UUID equivalence:
 * ```ts
 * const uuidWidget: string = '9c340ef0-d29f-4e2e-a09f-42bacc59024b';
 * class Widget {
 *   public static [Symbol.hasInstance](instance: object): boolean {
 *     return TypeUuid.isInstanceOf(instance, uuidWidget);
 *   }
 * }
 * ```
 * // Example usage:
 * ```ts
 * import { Widget as Widget1 } from 'v1-of-library';
 * import { Widget as Widget2 } from 'v2-of-library';
 * const widget = new Widget2();
 * console.log(widget instanceof Widget1); // prints true
 * ```
 *
 * @public
 */
class TypeUuid {
    /**
     * Registers a JavaScript class as having a type identified by the specified UUID.
     * @privateRemarks
     * We cannot use a construct signature for `targetClass` because it may be an abstract class.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static registerClass(targetClass, typeUuid) {
        if (typeof targetClass !== 'function') {
            throw new Error('The targetClass parameter must be a JavaScript class');
        }
        if (!TypeUuid._uuidRegExp.test(typeUuid)) {
            throw new Error(`The type UUID must be specified as lowercase hexadecimal with dashes: "${typeUuid}"`);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const targetClassPrototype = targetClass.prototype;
        if (Object.hasOwnProperty.call(targetClassPrototype, classPrototypeUuidSymbol)) {
            const existingUuid = targetClassPrototype[classPrototypeUuidSymbol];
            throw new InternalError_1.InternalError(`Cannot register the target class ${targetClass.name || ''} typeUuid=${typeUuid}` +
                ` because it was already registered with typeUuid=${existingUuid}`);
        }
        targetClassPrototype[classPrototypeUuidSymbol] = typeUuid;
    }
    /**
     * Returns true if the `targetObject` is an instance of a JavaScript class that was previously
     * registered using the specified `typeUuid`.  Base classes are also considered.
     */
    static isInstanceOf(targetObject, typeUuid) {
        if (targetObject === undefined || targetObject === null) {
            return false;
        }
        let objectPrototype = Object.getPrototypeOf(targetObject);
        while (objectPrototype !== undefined && objectPrototype !== null) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const registeredUuid = objectPrototype[classPrototypeUuidSymbol];
            if (registeredUuid === typeUuid) {
                return true;
            }
            // Walk upwards an examine base class prototypes
            objectPrototype = Object.getPrototypeOf(objectPrototype);
        }
        return false;
    }
}
exports.TypeUuid = TypeUuid;
TypeUuid._uuidRegExp = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
//# sourceMappingURL=TypeUuid.js.map

/***/ }),

/***/ 24247:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeUuid = exports.StringBufferTerminalProvider = exports.ConsoleTerminalProvider = exports.TerminalProviderSeverity = exports.TextAttribute = exports.ColorValue = exports.Colors = exports.Terminal = exports.StringBuilder = exports.LegacyAdapters = exports.FileWriter = exports.FileSystem = exports.Sort = exports.Text = exports.Path = exports.PackageNameParser = exports.PackageName = exports.PackageJsonLookup = exports.ProtectableMap = exports.MapExtensions = exports.LockFile = exports.JsonSchema = exports.JsonFile = exports.InternalError = exports.Import = exports.Executable = exports.EnvironmentMap = exports.Enum = exports.Async = exports.AnsiEscape = exports.AlreadyReportedError = void 0;
/**
 * Core libraries that every NodeJS toolchain project should use.
 *
 * @packageDocumentation
 */
var AlreadyReportedError_1 = __webpack_require__(50025);
Object.defineProperty(exports, "AlreadyReportedError", ({ enumerable: true, get: function () { return AlreadyReportedError_1.AlreadyReportedError; } }));
var AnsiEscape_1 = __webpack_require__(6682);
Object.defineProperty(exports, "AnsiEscape", ({ enumerable: true, get: function () { return AnsiEscape_1.AnsiEscape; } }));
var Async_1 = __webpack_require__(78869);
Object.defineProperty(exports, "Async", ({ enumerable: true, get: function () { return Async_1.Async; } }));
var Enum_1 = __webpack_require__(35948);
Object.defineProperty(exports, "Enum", ({ enumerable: true, get: function () { return Enum_1.Enum; } }));
var EnvironmentMap_1 = __webpack_require__(75777);
Object.defineProperty(exports, "EnvironmentMap", ({ enumerable: true, get: function () { return EnvironmentMap_1.EnvironmentMap; } }));
var Executable_1 = __webpack_require__(23529);
Object.defineProperty(exports, "Executable", ({ enumerable: true, get: function () { return Executable_1.Executable; } }));
var Import_1 = __webpack_require__(26302);
Object.defineProperty(exports, "Import", ({ enumerable: true, get: function () { return Import_1.Import; } }));
var InternalError_1 = __webpack_require__(22182);
Object.defineProperty(exports, "InternalError", ({ enumerable: true, get: function () { return InternalError_1.InternalError; } }));
var JsonFile_1 = __webpack_require__(42023);
Object.defineProperty(exports, "JsonFile", ({ enumerable: true, get: function () { return JsonFile_1.JsonFile; } }));
var JsonSchema_1 = __webpack_require__(12451);
Object.defineProperty(exports, "JsonSchema", ({ enumerable: true, get: function () { return JsonSchema_1.JsonSchema; } }));
var LockFile_1 = __webpack_require__(50272);
Object.defineProperty(exports, "LockFile", ({ enumerable: true, get: function () { return LockFile_1.LockFile; } }));
var MapExtensions_1 = __webpack_require__(18187);
Object.defineProperty(exports, "MapExtensions", ({ enumerable: true, get: function () { return MapExtensions_1.MapExtensions; } }));
var ProtectableMap_1 = __webpack_require__(67321);
Object.defineProperty(exports, "ProtectableMap", ({ enumerable: true, get: function () { return ProtectableMap_1.ProtectableMap; } }));
var PackageJsonLookup_1 = __webpack_require__(31386);
Object.defineProperty(exports, "PackageJsonLookup", ({ enumerable: true, get: function () { return PackageJsonLookup_1.PackageJsonLookup; } }));
var PackageName_1 = __webpack_require__(18398);
Object.defineProperty(exports, "PackageName", ({ enumerable: true, get: function () { return PackageName_1.PackageName; } }));
Object.defineProperty(exports, "PackageNameParser", ({ enumerable: true, get: function () { return PackageName_1.PackageNameParser; } }));
var Path_1 = __webpack_require__(3120);
Object.defineProperty(exports, "Path", ({ enumerable: true, get: function () { return Path_1.Path; } }));
var Text_1 = __webpack_require__(28188);
Object.defineProperty(exports, "Text", ({ enumerable: true, get: function () { return Text_1.Text; } }));
var Sort_1 = __webpack_require__(25540);
Object.defineProperty(exports, "Sort", ({ enumerable: true, get: function () { return Sort_1.Sort; } }));
var FileSystem_1 = __webpack_require__(28517);
Object.defineProperty(exports, "FileSystem", ({ enumerable: true, get: function () { return FileSystem_1.FileSystem; } }));
var FileWriter_1 = __webpack_require__(24064);
Object.defineProperty(exports, "FileWriter", ({ enumerable: true, get: function () { return FileWriter_1.FileWriter; } }));
var LegacyAdapters_1 = __webpack_require__(31160);
Object.defineProperty(exports, "LegacyAdapters", ({ enumerable: true, get: function () { return LegacyAdapters_1.LegacyAdapters; } }));
var StringBuilder_1 = __webpack_require__(75313);
Object.defineProperty(exports, "StringBuilder", ({ enumerable: true, get: function () { return StringBuilder_1.StringBuilder; } }));
var Terminal_1 = __webpack_require__(81593);
Object.defineProperty(exports, "Terminal", ({ enumerable: true, get: function () { return Terminal_1.Terminal; } }));
var Colors_1 = __webpack_require__(89699);
Object.defineProperty(exports, "Colors", ({ enumerable: true, get: function () { return Colors_1.Colors; } }));
Object.defineProperty(exports, "ColorValue", ({ enumerable: true, get: function () { return Colors_1.ColorValue; } }));
Object.defineProperty(exports, "TextAttribute", ({ enumerable: true, get: function () { return Colors_1.TextAttribute; } }));
var ITerminalProvider_1 = __webpack_require__(24175);
Object.defineProperty(exports, "TerminalProviderSeverity", ({ enumerable: true, get: function () { return ITerminalProvider_1.TerminalProviderSeverity; } }));
var ConsoleTerminalProvider_1 = __webpack_require__(74298);
Object.defineProperty(exports, "ConsoleTerminalProvider", ({ enumerable: true, get: function () { return ConsoleTerminalProvider_1.ConsoleTerminalProvider; } }));
var StringBufferTerminalProvider_1 = __webpack_require__(26238);
Object.defineProperty(exports, "StringBufferTerminalProvider", ({ enumerable: true, get: function () { return StringBufferTerminalProvider_1.StringBufferTerminalProvider; } }));
var TypeUuid_1 = __webpack_require__(92736);
Object.defineProperty(exports, "TypeUuid", ({ enumerable: true, get: function () { return TypeUuid_1.TypeUuid; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 95591:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var async = __webpack_require__(63538);
async.core = __webpack_require__(72357);
async.isCore = __webpack_require__(89811);
async.sync = __webpack_require__(99280);

module.exports = async;


/***/ }),

/***/ 63538:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(35747);
var path = __webpack_require__(85622);
var caller = __webpack_require__(51270);
var nodeModulesPaths = __webpack_require__(96236);
var normalizeOptions = __webpack_require__(38760);
var isCore = __webpack_require__(89811);

var realpathFS = fs.realpath && typeof fs.realpath.native === 'function' ? fs.realpath.native : fs.realpath;

var defaultIsFile = function isFile(file, cb) {
    fs.stat(file, function (err, stat) {
        if (!err) {
            return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};

var defaultIsDir = function isDirectory(dir, cb) {
    fs.stat(dir, function (err, stat) {
        if (!err) {
            return cb(null, stat.isDirectory());
        }
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};

var defaultRealpath = function realpath(x, cb) {
    realpathFS(x, function (realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== 'ENOENT') cb(realpathErr);
        else cb(null, realpathErr ? x : realPath);
    });
};

var maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
    } else {
        cb(null, x);
    }
};

var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
};

module.exports = function resolve(x, options, callback) {
    var cb = callback;
    var opts = options;
    if (typeof options === 'function') {
        cb = opts;
        opts = {};
    }
    if (typeof x !== 'string') {
        var err = new TypeError('Path must be a string.');
        return process.nextTick(function () {
            cb(err);
        });
    }

    opts = normalizeOptions(x, opts);

    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile = opts.readFile || fs.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var packageIterator = opts.packageIterator;

    var extensions = opts.extensions || ['.js'];
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || [];

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = path.resolve(basedir);

    maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function (err, realStart) {
            if (err) cb(err);
            else init(realStart);
        }
    );

    var res;
    function init(basedir) {
        if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
            res = path.resolve(basedir, x);
            if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
            if ((/\/$/).test(x) && res === basedir) {
                loadAsDirectory(res, opts.package, onfile);
            } else loadAsFile(res, opts.package, onfile);
        } else if (isCore(x)) {
            return cb(null, x);
        } else loadNodeModules(x, basedir, function (err, n, pkg) {
            if (err) cb(err);
            else if (n) {
                return maybeRealpath(realpath, n, opts, function (err, realN) {
                    if (err) {
                        cb(err);
                    } else {
                        cb(null, realN, pkg);
                    }
                });
            } else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
            }
        });
    }

    function onfile(err, m, pkg) {
        if (err) cb(err);
        else if (m) cb(null, m, pkg);
        else loadAsDirectory(res, function (err, d, pkg) {
            if (err) cb(err);
            else if (d) {
                maybeRealpath(realpath, d, opts, function (err, realD) {
                    if (err) {
                        cb(err);
                    } else {
                        cb(null, realD, pkg);
                    }
                });
            } else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
            }
        });
    }

    function loadAsFile(x, thePackage, callback) {
        var loadAsFilePackage = thePackage;
        var cb = callback;
        if (typeof loadAsFilePackage === 'function') {
            cb = loadAsFilePackage;
            loadAsFilePackage = undefined;
        }

        var exts = [''].concat(extensions);
        load(exts, x, loadAsFilePackage);

        function load(exts, x, loadPackage) {
            if (exts.length === 0) return cb(null, undefined, loadPackage);
            var file = x + exts[0];

            var pkg = loadPackage;
            if (pkg) onpkg(null, pkg);
            else loadpkg(path.dirname(file), onpkg);

            function onpkg(err, pkg_, dir) {
                pkg = pkg_;
                if (err) return cb(err);
                if (dir && pkg && opts.pathFilter) {
                    var rfile = path.relative(dir, file);
                    var rel = rfile.slice(0, rfile.length - exts[0].length);
                    var r = opts.pathFilter(pkg, x, rel);
                    if (r) return load(
                        [''].concat(extensions.slice()),
                        path.resolve(dir, r),
                        pkg
                    );
                }
                isFile(file, onex);
            }
            function onex(err, ex) {
                if (err) return cb(err);
                if (ex) return cb(null, file, pkg);
                load(exts.slice(1), x, pkg);
            }
        }
    }

    function loadpkg(dir, cb) {
        if (dir === '' || dir === '/') return cb(null);
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
            return cb(null);
        }
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return cb(null);

        maybeRealpath(realpath, dir, opts, function (unwrapErr, pkgdir) {
            if (unwrapErr) return loadpkg(path.dirname(dir), cb);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) {
                // on err, ex is false
                if (!ex) return loadpkg(path.dirname(dir), cb);

                readFile(pkgfile, function (err, body) {
                    if (err) cb(err);
                    try { var pkg = JSON.parse(body); } catch (jsonErr) {}

                    if (pkg && opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }
                    cb(null, pkg, dir);
                });
            });
        });
    }

    function loadAsDirectory(x, loadAsDirectoryPackage, callback) {
        var cb = callback;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === 'function') {
            cb = fpkg;
            fpkg = opts.package;
        }

        maybeRealpath(realpath, x, opts, function (unwrapErr, pkgdir) {
            if (unwrapErr) return cb(unwrapErr);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) {
                if (err) return cb(err);
                if (!ex) return loadAsFile(path.join(x, 'index'), fpkg, cb);

                readFile(pkgfile, function (err, body) {
                    if (err) return cb(err);
                    try {
                        var pkg = JSON.parse(body);
                    } catch (jsonErr) {}

                    if (pkg && opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }

                    if (pkg && pkg.main) {
                        if (typeof pkg.main !== 'string') {
                            var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');
                            mainError.code = 'INVALID_PACKAGE_MAIN';
                            return cb(mainError);
                        }
                        if (pkg.main === '.' || pkg.main === './') {
                            pkg.main = 'index';
                        }
                        loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {
                            if (err) return cb(err);
                            if (m) return cb(null, m, pkg);
                            if (!pkg) return loadAsFile(path.join(x, 'index'), pkg, cb);

                            var dir = path.resolve(x, pkg.main);
                            loadAsDirectory(dir, pkg, function (err, n, pkg) {
                                if (err) return cb(err);
                                if (n) return cb(null, n, pkg);
                                loadAsFile(path.join(x, 'index'), pkg, cb);
                            });
                        });
                        return;
                    }

                    loadAsFile(path.join(x, '/index'), pkg, cb);
                });
            });
        });
    }

    function processDirs(cb, dirs) {
        if (dirs.length === 0) return cb(null, undefined);
        var dir = dirs[0];

        isDirectory(path.dirname(dir), isdir);

        function isdir(err, isdir) {
            if (err) return cb(err);
            if (!isdir) return processDirs(cb, dirs.slice(1));
            loadAsFile(dir, opts.package, onfile);
        }

        function onfile(err, m, pkg) {
            if (err) return cb(err);
            if (m) return cb(null, m, pkg);
            loadAsDirectory(dir, opts.package, ondir);
        }

        function ondir(err, n, pkg) {
            if (err) return cb(err);
            if (n) return cb(null, n, pkg);
            processDirs(cb, dirs.slice(1));
        }
    }
    function loadNodeModules(x, start, cb) {
        var thunk = function () { return getPackageCandidates(x, start, opts); };
        processDirs(
            cb,
            packageIterator ? packageIterator(x, start, thunk, opts) : thunk()
        );
    }
};


/***/ }),

/***/ 51270:
/***/ ((module) => {

module.exports = function () {
    // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function (_, stack) { return stack; };
    var stack = (new Error()).stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
};


/***/ }),

/***/ 72357:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var current = (process.versions && process.versions.node && process.versions.node.split('.')) || [];

function specifierIncluded(specifier) {
    var parts = specifier.split(' ');
    var op = parts.length > 1 ? parts[0] : '=';
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');

    for (var i = 0; i < 3; ++i) {
        var cur = Number(current[i] || 0);
        var ver = Number(versionParts[i] || 0);
        if (cur === ver) {
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        }
        if (op === '<') {
            return cur < ver;
        } else if (op === '>=') {
            return cur >= ver;
        } else {
            return false;
        }
    }
    return op === '>=';
}

function matchesRange(range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) { return false; }
    for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(specifiers[i])) { return false; }
    }
    return true;
}

function versionIncluded(specifierValue) {
    if (typeof specifierValue === 'boolean') { return specifierValue; }
    if (specifierValue && typeof specifierValue === 'object') {
        for (var i = 0; i < specifierValue.length; ++i) {
            if (matchesRange(specifierValue[i])) { return true; }
        }
        return false;
    }
    return matchesRange(specifierValue);
}

var data = __webpack_require__(94302);

var core = {};
for (var mod in data) { // eslint-disable-line no-restricted-syntax
    if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core[mod] = versionIncluded(data[mod]);
    }
}
module.exports = core;


/***/ }),

/***/ 89811:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var core = __webpack_require__(72357);

module.exports = function isCore(x) {
    return Object.prototype.hasOwnProperty.call(core, x);
};


/***/ }),

/***/ 96236:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var path = __webpack_require__(85622);
var parse = path.parse || __webpack_require__(5980);

var getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {
    var prefix = '/';
    if ((/^([A-Za-z]:)/).test(absoluteStart)) {
        prefix = '';
    } else if ((/^\\\\/).test(absoluteStart)) {
        prefix = '\\\\';
    }

    var paths = [absoluteStart];
    var parsed = parse(absoluteStart);
    while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
    }

    return paths.reduce(function (dirs, aPath) {
        return dirs.concat(modules.map(function (moduleDir) {
            return path.resolve(prefix, aPath, moduleDir);
        }));
    }, []);
};

module.exports = function nodeModulesPaths(start, opts, request) {
    var modules = opts && opts.moduleDirectory
        ? [].concat(opts.moduleDirectory)
        : ['node_modules'];

    if (opts && typeof opts.paths === 'function') {
        return opts.paths(
            request,
            start,
            function () { return getNodeModulesDirs(start, modules); },
            opts
        );
    }

    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
};


/***/ }),

/***/ 38760:
/***/ ((module) => {

module.exports = function (x, opts) {
    /**
     * This file is purposefully a passthrough. It's expected that third-party
     * environments will override it at runtime in order to inject special logic
     * into `resolve` (by manipulating the options). One such example is the PnP
     * code path in Yarn.
     */

    return opts || {};
};


/***/ }),

/***/ 99280:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCore = __webpack_require__(89811);
var fs = __webpack_require__(35747);
var path = __webpack_require__(85622);
var caller = __webpack_require__(51270);
var nodeModulesPaths = __webpack_require__(96236);
var normalizeOptions = __webpack_require__(38760);

var realpathFS = fs.realpathSync && typeof fs.realpathSync.native === 'function' ? fs.realpathSync.native : fs.realpathSync;

var defaultIsFile = function isFile(file) {
    try {
        var stat = fs.statSync(file);
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return stat.isFile() || stat.isFIFO();
};

var defaultIsDir = function isDirectory(dir) {
    try {
        var stat = fs.statSync(dir);
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return stat.isDirectory();
};

var defaultRealpathSync = function realpathSync(x) {
    try {
        return realpathFS(x);
    } catch (realpathErr) {
        if (realpathErr.code !== 'ENOENT') {
            throw realpathErr;
        }
    }
    return x;
};

var maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {
    if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
    }
    return x;
};

var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
};

module.exports = function resolveSync(x, options) {
    if (typeof x !== 'string') {
        throw new TypeError('Path must be a string.');
    }
    var opts = normalizeOptions(x, options);

    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var packageIterator = opts.packageIterator;

    var extensions = opts.extensions || ['.js'];
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || [];

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);

    if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
        var res = path.resolve(absoluteStart, x);
        if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m) return maybeRealpathSync(realpathSync, m, opts);
    } else if (isCore(x)) {
        return x;
    } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n) return maybeRealpathSync(realpathSync, n, opts);
    }

    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;

    function loadAsFileSync(x) {
        var pkg = loadpkg(path.dirname(x));

        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
            var rfile = path.relative(pkg.dir, x);
            var r = opts.pathFilter(pkg.pkg, x, rfile);
            if (r) {
                x = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign
            }
        }

        if (isFile(x)) {
            return x;
        }

        for (var i = 0; i < extensions.length; i++) {
            var file = x + extensions[i];
            if (isFile(file)) {
                return file;
            }
        }
    }

    function loadpkg(dir) {
        if (dir === '' || dir === '/') return;
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
            return;
        }
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return;

        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), 'package.json');

        if (!isFile(pkgfile)) {
            return loadpkg(path.dirname(dir));
        }

        var body = readFileSync(pkgfile);

        try {
            var pkg = JSON.parse(body);
        } catch (jsonErr) {}

        if (pkg && opts.packageFilter) {
            // v2 will pass pkgfile
            pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment
        }

        return { pkg: pkg, dir: dir };
    }

    function loadAsDirectorySync(x) {
        var pkgfile = path.join(maybeRealpathSync(realpathSync, x, opts), '/package.json');
        if (isFile(pkgfile)) {
            try {
                var body = readFileSync(pkgfile, 'UTF8');
                var pkg = JSON.parse(body);
            } catch (e) {}

            if (pkg && opts.packageFilter) {
                // v2 will pass pkgfile
                pkg = opts.packageFilter(pkg, /*pkgfile,*/ x); // eslint-disable-line spaced-comment
            }

            if (pkg && pkg.main) {
                if (typeof pkg.main !== 'string') {
                    var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');
                    mainError.code = 'INVALID_PACKAGE_MAIN';
                    throw mainError;
                }
                if (pkg.main === '.' || pkg.main === './') {
                    pkg.main = 'index';
                }
                try {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                    var n = loadAsDirectorySync(path.resolve(x, pkg.main));
                    if (n) return n;
                } catch (e) {}
            }
        }

        return loadAsFileSync(path.join(x, '/index'));
    }

    function loadNodeModulesSync(x, start) {
        var thunk = function () { return getPackageCandidates(x, start, opts); };
        var dirs = packageIterator ? packageIterator(x, start, thunk, opts) : thunk();

        for (var i = 0; i < dirs.length; i++) {
            var dir = dirs[i];
            if (isDirectory(path.dirname(dir))) {
                var m = loadAsFileSync(dir);
                if (m) return m;
                var n = loadAsDirectorySync(dir);
                if (n) return n;
            }
        }
    }
};


/***/ }),

/***/ 30390:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AlreadyReportedError = void 0;
const TypeUuid_1 = __webpack_require__(76778);
const uuidAlreadyReportedError = 'f26b0640-a49b-49d1-9ead-1a516d5920c7';
/**
 * This exception can be thrown to indicate that an operation failed and an error message has already
 * been reported appropriately. Thus, the catch handler does not have responsibility for reporting
 * the error.
 *
 * @remarks
 * For example, suppose a tool writes interactive output to `console.log()`.  When an exception is thrown,
 * the `catch` handler will typically provide simplistic reporting such as this:
 *
 * ```ts
 * catch (error) {
 *   console.log("ERROR: " + error.message);
 * }
 * ```
 *
 * Suppose that the code performing the operation normally prints rich output to the console.  It may be able to
 * present an error message more nicely (for example, as part of a table, or structured log format).  Throwing
 * `AlreadyReportedError` provides a way to use exception handling to abort the operation, but instruct the `catch`
 * handler not to print an error a second time:
 *
 * ```ts
 * catch (error) {
 *   if (error instanceof AlreadyReportedError) {
 *     return;
 *   }
 *   console.log("ERROR: " + error.message);
 * }
 * ```
 *
 * @public
 */
class AlreadyReportedError extends Error {
    constructor() {
        super('An error occurred.');
        // Manually set the prototype, as we can no longer extend built-in classes like Error, Array, Map, etc
        // [https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work](https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work)
        //
        // Note: the prototype must also be set on any classes which extend this one
        this.__proto__ = AlreadyReportedError.prototype; // eslint-disable-line @typescript-eslint/no-explicit-any
    }
    static [Symbol.hasInstance](instance) {
        return TypeUuid_1.TypeUuid.isInstanceOf(instance, uuidAlreadyReportedError);
    }
}
exports.AlreadyReportedError = AlreadyReportedError;
TypeUuid_1.TypeUuid.registerClass(AlreadyReportedError, uuidAlreadyReportedError);
//# sourceMappingURL=AlreadyReportedError.js.map

/***/ }),

/***/ 18635:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Async = void 0;
/**
 * Utilities for parallel asynchronous operations, for use with the system `Promise` APIs.
 *
 * @beta
 */
class Async {
    /**
     * Given an input array and a `callback` function, invoke the callback to start a
     * promise for each element in the array.  Returns an array containing the results.
     *
     * @remarks
     * This API is similar to the system `Array#map`, except that the loop is asynchronous,
     * and the maximum number of concurrent promises can be throttled
     * using {@link IAsyncParallelismOptions.concurrency}.
     *
     * If `callback` throws a synchronous exception, or if it returns a promise that rejects,
     * then the loop stops immediately.  Any remaining array items will be skipped, and
     * overall operation will reject with the first error that was encountered.
     *
     * @param iterable - the array of inputs for the callback function
     * @param callback - a function that starts an asynchronous promise for an element
     *   from the array
     * @param options - options for customizing the control flow
     * @returns an array containing the result for each callback, in the same order
     *   as the original input `array`
     */
    static async mapAsync(iterable, callback, options) {
        const result = [];
        await Async.forEachAsync(iterable, async (item, arrayIndex) => {
            result[arrayIndex] = await callback(item, arrayIndex);
        }, options);
        return result;
    }
    /**
     * Given an input array and a `callback` function, invoke the callback to start a
     * promise for each element in the array.
     *
     * @remarks
     * This API is similar to the system `Array#forEach`, except that the loop is asynchronous,
     * and the maximum number of concurrent promises can be throttled
     * using {@link IAsyncParallelismOptions.concurrency}.
     *
     * If `callback` throws a synchronous exception, or if it returns a promise that rejects,
     * then the loop stops immediately.  Any remaining array items will be skipped, and
     * overall operation will reject with the first error that was encountered.
     *
     * @param iterable - the array of inputs for the callback function
     * @param callback - a function that starts an asynchronous promise for an element
     *   from the array
     * @param options - options for customizing the control flow
     */
    static async forEachAsync(iterable, callback, options) {
        await new Promise((resolve, reject) => {
            const concurrency = (options === null || options === void 0 ? void 0 : options.concurrency) && options.concurrency > 0 ? options.concurrency : Infinity;
            let operationsInProgress = 0;
            const iterator = (iterable[Symbol.iterator] ||
                iterable[Symbol.asyncIterator]).call(iterable);
            let arrayIndex = 0;
            let iteratorIsComplete = false;
            let promiseHasResolvedOrRejected = false;
            async function queueOperationsAsync() {
                while (operationsInProgress < concurrency && !iteratorIsComplete && !promiseHasResolvedOrRejected) {
                    const currentIteratorResult = await iterator.next();
                    // eslint-disable-next-line require-atomic-updates
                    iteratorIsComplete = !!currentIteratorResult.done;
                    if (!iteratorIsComplete) {
                        operationsInProgress++;
                        Promise.resolve(callback(currentIteratorResult.value, arrayIndex++))
                            .then(async () => {
                            operationsInProgress--;
                            await onOperationCompletionAsync();
                        })
                            .catch((error) => {
                            promiseHasResolvedOrRejected = true;
                            reject(error);
                        });
                    }
                }
                if (iteratorIsComplete) {
                    await onOperationCompletionAsync();
                }
            }
            async function onOperationCompletionAsync() {
                if (!promiseHasResolvedOrRejected) {
                    if (operationsInProgress === 0 && iteratorIsComplete) {
                        promiseHasResolvedOrRejected = true;
                        resolve();
                    }
                    else if (!iteratorIsComplete) {
                        await queueOperationsAsync();
                    }
                }
            }
            queueOperationsAsync().catch((error) => {
                promiseHasResolvedOrRejected = true;
                reject(error);
            });
        });
    }
    /**
     * Return a promise that resolves after the specified number of milliseconds.
     */
    static async sleep(ms) {
        await new Promise((resolve) => {
            setTimeout(resolve, ms);
        });
    }
}
exports.Async = Async;
//# sourceMappingURL=Async.js.map

/***/ }),

/***/ 86312:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Enum = void 0;
/**
 * A helper for looking up TypeScript `enum` keys/values.
 *
 * @remarks
 * TypeScript enums implement a lookup table for mapping between their keys and values:
 *
 * ```ts
 * enum Colors {
 *   Red = 1
 * }
 *
 * // Prints "Red"
 * console.log(Colors[1]);
 *
 * // Prints "1"
 * console.log(Colors["Red]);
 * ```
 *
 * However the compiler's "noImplicitAny" validation has trouble with these mappings, because
 * there are so many possible types for the map elements:
 *
 * ```ts
 * function f(s: string): Colors | undefined {
 *   // (TS 7015) Element implicitly has an 'any' type because
 *   // index expression is not of type 'number'.
 *   return Colors[s];
 * }
 * ```
 *
 * The `Enum` helper provides a more specific, strongly typed way to access members:
 *
 * ```ts
 * function f(s: string): Colors | undefined {
 *   return Enum.tryGetValueByKey(Colors, s);
 * }
 * ```
 *
 * @public
 */
class Enum {
    constructor() { }
    /**
     * Returns an enum value, given its key. Returns `undefined` if no matching key is found.
     *
     * @example
     *
     * Example usage:
     * ```ts
     * enum Colors {
     *   Red = 1
     * }
     *
     * // Prints "1"
     * console.log(Enum.tryGetValueByKey(Colors, "Red"));
     *
     * // Prints "undefined"
     * console.log(Enum.tryGetValueByKey(Colors, "Black"));
     * ```
     */
    static tryGetValueByKey(enumObject, key) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return enumObject[key];
    }
    /**
     * This API is similar to {@link Enum.tryGetValueByKey}, except that it throws an exception
     * if the key is undefined.
     */
    static getValueByKey(enumObject, key) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const result = enumObject[key];
        if (result === undefined) {
            throw new Error(`The lookup key ${JSON.stringify(key)} is not defined`);
        }
        return result;
    }
    /**
     * Returns an enum string key, given its numeric value.  Returns `undefined` if no matching value
     * is found.
     *
     * @remarks
     * The TypeScript compiler only creates a reverse mapping for enum members whose value is numeric.
     * For example:
     *
     * ```ts
     * enum E {
     *   A = 1,
     *   B = 'c'
     * }
     *
     * // Prints "A"
     * console.log(E[1]);
     *
     * // Prints "undefined"
     * console.log(E["c"]);
     * ```
     *
     * @example
     *
     * Example usage:
     * ```ts
     * enum Colors {
     *   Red = 1,
     *   Blue = 'blue'
     * }
     *
     * // Prints "Red"
     * console.log(Enum.tryGetKeyByNumber(Colors, 1));
     *
     * // Prints "undefined"
     * console.log(Enum.tryGetKeyByNumber(Colors, -1));
     * ```
     */
    static tryGetKeyByNumber(enumObject, value) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return enumObject[value];
    }
    /**
     * This API is similar to {@link Enum.tryGetKeyByNumber}, except that it throws an exception
     * if the key is undefined.
     */
    static getKeyByNumber(enumObject, value) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const result = enumObject[value];
        if (result === undefined) {
            throw new Error(`The value ${value} does not exist in the mapping`);
        }
        return result;
    }
}
exports.Enum = Enum;
//# sourceMappingURL=Enum.js.map

/***/ }),

/***/ 17291:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnvironmentMap = void 0;
const process_1 = __importDefault(__webpack_require__(61765));
const InternalError_1 = __webpack_require__(74436);
/**
 * A map data structure that stores process environment variables.  On Windows
 * operating system, the variable names are case-insensitive.
 * @public
 */
class EnvironmentMap {
    constructor(environmentObject = {}) {
        this._map = new Map();
        // This property helps catch a mistake where an instance of `EnvironmentMap` is accidentally passed to
        // a function that expects a `Record<string, string>` (as would be used with the `process.env` API).
        // The property getter will throw an exception if that function tries to enumerate the object values.
        Object.defineProperty(this, '_sanityCheck', {
            enumerable: true,
            get: function () {
                throw new InternalError_1.InternalError('Attempt to read EnvironmentMap class as an object');
            }
        });
        this.caseSensitive = process_1.default.platform !== 'win32';
        this.mergeFromObject(environmentObject);
    }
    /**
     * Clears all entries, resulting in an empty map.
     */
    clear() {
        this._map.clear();
    }
    /**
     * Assigns the variable to the specified value.  A previous value will be overwritten.
     *
     * @remarks
     * The value can be an empty string.  To completely remove the entry, use
     * {@link EnvironmentMap.unset} instead.
     */
    set(name, value) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        this._map.set(key, { name: name, value });
    }
    /**
     * Removes the key from the map, if present.
     */
    unset(name) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        this._map.delete(key);
    }
    /**
     * Returns the value of the specified variable, or `undefined` if the map does not contain that name.
     */
    get(name) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        const entry = this._map.get(key);
        if (entry === undefined) {
            return undefined;
        }
        return entry.value;
    }
    /**
     * Returns the map keys, which are environment variable names.
     */
    names() {
        return this._map.keys();
    }
    /**
     * Returns the map entries.
     */
    entries() {
        return this._map.values();
    }
    /**
     * Adds each entry from `environmentMap` to this map.
     */
    mergeFrom(environmentMap) {
        for (const entry of environmentMap.entries()) {
            this.set(entry.name, entry.value);
        }
    }
    /**
     * Merges entries from a plain JavaScript object, such as would be used with the `process.env` API.
     */
    mergeFromObject(environmentObject = {}) {
        for (const [name, value] of Object.entries(environmentObject)) {
            if (value !== undefined) {
                this.set(name, value);
            }
        }
    }
    /**
     * Returns the keys as a plain JavaScript object similar to the object returned by the `process.env` API.
     */
    toObject() {
        const result = {};
        for (const entry of this.entries()) {
            result[entry.name] = entry.value;
        }
        return result;
    }
}
exports.EnvironmentMap = EnvironmentMap;
//# sourceMappingURL=EnvironmentMap.js.map

/***/ }),

/***/ 26266:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Executable = void 0;
const child_process = __importStar(__webpack_require__(63129));
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const EnvironmentMap_1 = __webpack_require__(17291);
const FileSystem_1 = __webpack_require__(19334);
/**
 * The Executable class provides a safe, portable, recommended solution for tools that need
 * to launch child processes.
 *
 * @remarks
 * The NodeJS child_process API provides a solution for launching child processes, however
 * its design encourages reliance on the operating system shell for certain features.
 * Invoking the OS shell is not safe, not portable, and generally not recommended:
 *
 * - Different shells have different behavior and command-line syntax, and which shell you
 *   will get with NodeJS is unpredictable.  There is no universal shell guaranteed to be
 *   available on all platforms.
 *
 * - If a command parameter contains symbol characters, a shell may interpret them, which
 *   can introduce a security vulnerability
 *
 * - Each shell has different rules for escaping these symbols.  On Windows, the default
 *   shell is incapable of escaping certain character sequences.
 *
 * The Executable API provides a pure JavaScript implementation of primitive shell-like
 * functionality for searching the default PATH, appending default file extensions on Windows,
 * and executing a file that may contain a POSIX shebang.  This primitive functionality
 * is sufficient (and recommended) for most tooling scenarios.
 *
 * If you need additional shell features such as wildcard globbing, environment variable
 * expansion, piping, or built-in commands, then we recommend to use the `@microsoft/rushell`
 * library instead.  Rushell is a pure JavaScript shell with a standard syntax that is
 * guaranteed to work consistently across all platforms.
 *
 * @public
 */
class Executable {
    /**
     * Synchronously create a child process and optionally capture its output.
     *
     * @remarks
     * This function is similar to child_process.spawnSync().  The main differences are:
     *
     * - It does not invoke the OS shell unless the executable file is a shell script.
     * - Command-line arguments containing special characters are more accurately passed
     *   through to the child process.
     * - If the filename is missing a path, then the shell's default PATH will be searched.
     * - If the filename is missing a file extension, then Windows default file extensions
     *   will be searched.
     *
     * @param filename - The name of the executable file.  This string must not contain any
     * command-line arguments.  If the name contains any path delimiters, then the shell's
     * default PATH will not be searched.
     * @param args - The command-line arguments to be passed to the process.
     * @param options - Additional options
     * @returns the same data type as returned by the NodeJS child_process.spawnSync() API
     *
     * @privateRemarks
     *
     * NOTE: The NodeJS spawnSync() returns SpawnSyncReturns<string> or SpawnSyncReturns<Buffer>
     * polymorphically based on the options.encoding parameter value.  This is a fairly confusing
     * design.  In most cases, developers want string with the default encoding.  If/when someone
     * wants binary output or a non-default text encoding, we will introduce a separate API function
     * with a name like "spawnWithBufferSync".
     */
    static spawnSync(filename, args, options) {
        if (!options) {
            options = {};
        }
        const context = Executable._getExecutableContext(options);
        const resolvedPath = Executable._tryResolve(filename, options, context);
        if (!resolvedPath) {
            throw new Error(`The executable file was not found: "${filename}"`);
        }
        const spawnOptions = {
            cwd: context.currentWorkingDirectory,
            env: context.environmentMap.toObject(),
            input: options.input,
            stdio: options.stdio,
            timeout: options.timeoutMs,
            maxBuffer: options.maxBuffer,
            // Contrary to what the NodeJS typings imply, we must explicitly specify "utf8" here
            // if we want the result to be SpawnSyncReturns<string> instead of SpawnSyncReturns<Buffer>.
            encoding: 'utf8',
            // NOTE: This is always false, because Rushell will be recommended instead of relying on the OS shell.
            shell: false
        };
        const normalizedCommandLine = Executable._buildCommandLineFixup(resolvedPath, args, context);
        return child_process.spawnSync(normalizedCommandLine.path, normalizedCommandLine.args, spawnOptions);
    }
    /**
     * Start a child process.
     *
     * @remarks
     * This function is similar to child_process.spawn().  The main differences are:
     *
     * - It does not invoke the OS shell unless the executable file is a shell script.
     * - Command-line arguments containing special characters are more accurately passed
     *   through to the child process.
     * - If the filename is missing a path, then the shell's default PATH will be searched.
     * - If the filename is missing a file extension, then Windows default file extensions
     *   will be searched.
     *
     * This command is asynchronous, but it does not return a `Promise`.  Instead it returns
     * a Node.js `ChildProcess` supporting event notifications.
     *
     * @param filename - The name of the executable file.  This string must not contain any
     * command-line arguments.  If the name contains any path delimiters, then the shell's
     * default PATH will not be searched.
     * @param args - The command-line arguments to be passed to the process.
     * @param options - Additional options
     * @returns the same data type as returned by the NodeJS child_process.spawnSync() API
     */
    static spawn(filename, args, options) {
        if (!options) {
            options = {};
        }
        const context = Executable._getExecutableContext(options);
        const resolvedPath = Executable._tryResolve(filename, options, context);
        if (!resolvedPath) {
            throw new Error(`The executable file was not found: "${filename}"`);
        }
        const spawnOptions = {
            cwd: context.currentWorkingDirectory,
            env: context.environmentMap.toObject(),
            stdio: options.stdio,
            // NOTE: This is always false, because Rushell will be recommended instead of relying on the OS shell.
            shell: false
        };
        const normalizedCommandLine = Executable._buildCommandLineFixup(resolvedPath, args, context);
        return child_process.spawn(normalizedCommandLine.path, normalizedCommandLine.args, spawnOptions);
    }
    // PROBLEM: Given an "args" array of strings that may contain special characters (e.g. spaces,
    // backslashes, quotes), ensure that these strings pass through to the child process's ARGV array
    // without anything getting corrupted along the way.
    //
    // On Unix you just pass the array to spawnSync().  But on Windows, this is a very complex problem:
    // - The Win32 CreateProcess() API expects the args to be encoded as a single text string
    // - The decoding of this string is up to the application (not the OS), and there are 3 different
    //   algorithms in common usage:  the cmd.exe shell, the Microsoft CRT library init code, and
    //   the Win32 CommandLineToArgvW()
    // - The encodings are counterintuitive and have lots of special cases
    // - NodeJS spawnSync() tries do the encoding without knowing which decoder will be used
    //
    // See these articles for a full analysis:
    // http://www.windowsinspired.com/understanding-the-command-line-string-and-arguments-received-by-a-windows-program/
    // http://www.windowsinspired.com/how-a-windows-programs-splits-its-command-line-into-individual-arguments/
    static _buildCommandLineFixup(resolvedPath, args, context) {
        const fileExtension = path.extname(resolvedPath);
        if (os.platform() === 'win32') {
            // Do we need a custom handler for this file type?
            switch (fileExtension.toUpperCase()) {
                case '.EXE':
                case '.COM':
                    // okay to execute directly
                    break;
                case '.BAT':
                case '.CMD': {
                    Executable._validateArgsForWindowsShell(args);
                    // These file types must be invoked via the Windows shell
                    let shellPath = context.environmentMap.get('COMSPEC');
                    if (!shellPath || !Executable._canExecute(shellPath, context)) {
                        shellPath = Executable.tryResolve('cmd.exe');
                    }
                    if (!shellPath) {
                        throw new Error(`Unable to execute "${path.basename(resolvedPath)}" ` +
                            `because CMD.exe was not found in the PATH`);
                    }
                    const shellArgs = [];
                    // /D: Disable execution of AutoRun commands when starting the new shell context
                    shellArgs.push('/d');
                    // /S: Disable Cmd.exe's parsing of double-quote characters inside the command-line
                    shellArgs.push('/s');
                    // /C: Execute the following command and then exit immediately
                    shellArgs.push('/c');
                    // If the path contains special charactrers (e.g. spaces), escape them so that
                    // they don't get interpreted by the shell
                    shellArgs.push(Executable._getEscapedForWindowsShell(resolvedPath));
                    shellArgs.push(...args);
                    return { path: shellPath, args: shellArgs };
                }
                default:
                    throw new Error(`Cannot execute "${path.basename(resolvedPath)}" because the file type is not supported`);
            }
        }
        return {
            path: resolvedPath,
            args: args
        };
    }
    /**
     * Given a filename, this determines the absolute path of the executable file that would
     * be executed by a shell:
     *
     * - If the filename is missing a path, then the shell's default PATH will be searched.
     * - If the filename is missing a file extension, then Windows default file extensions
     *   will be searched.
     *
     * @remarks
     *
     * @param filename - The name of the executable file.  This string must not contain any
     * command-line arguments.  If the name contains any path delimiters, then the shell's
     * default PATH will not be searched.
     * @param options - optional other parameters
     * @returns the absolute path of the executable, or undefined if it was not found
     */
    static tryResolve(filename, options) {
        return Executable._tryResolve(filename, options || {}, Executable._getExecutableContext(options));
    }
    static _tryResolve(filename, options, context) {
        // NOTE: Since "filename" cannot contain command-line arguments, the "/" here
        // must be interpreted as a path delimiter
        const hasPathSeparators = filename.indexOf('/') >= 0 || (os.platform() === 'win32' && filename.indexOf('\\') >= 0);
        // Are there any path separators?
        if (hasPathSeparators) {
            // If so, then don't search the PATH.  Just resolve relative to the current working directory
            const resolvedPath = path.resolve(context.currentWorkingDirectory, filename);
            return Executable._tryResolveFileExtension(resolvedPath, context);
        }
        else {
            // Otherwise if it's a bare name, then try everything in the shell PATH
            const pathsToSearch = Executable._getSearchFolders(context);
            for (const pathToSearch of pathsToSearch) {
                const resolvedPath = path.join(pathToSearch, filename);
                const result = Executable._tryResolveFileExtension(resolvedPath, context);
                if (result) {
                    return result;
                }
            }
            // No match was found
            return undefined;
        }
    }
    static _tryResolveFileExtension(resolvedPath, context) {
        if (Executable._canExecute(resolvedPath, context)) {
            return resolvedPath;
        }
        // Try the default file extensions
        for (const shellExtension of context.windowsExecutableExtensions) {
            const resolvedNameWithExtension = resolvedPath + shellExtension;
            if (Executable._canExecute(resolvedNameWithExtension, context)) {
                return resolvedNameWithExtension;
            }
        }
        return undefined;
    }
    static _buildEnvironmentMap(options) {
        const environmentMap = new EnvironmentMap_1.EnvironmentMap();
        if (options.environment !== undefined && options.environmentMap !== undefined) {
            throw new Error('IExecutableResolveOptions.environment and IExecutableResolveOptions.environmentMap' +
                ' cannot both be specified');
        }
        if (options.environment !== undefined) {
            environmentMap.mergeFromObject(options.environment);
        }
        else if (options.environmentMap !== undefined) {
            environmentMap.mergeFrom(options.environmentMap);
        }
        else {
            environmentMap.mergeFromObject(process.env);
        }
        return environmentMap;
    }
    /**
     * This is used when searching the shell PATH for an executable, to determine
     * whether a match should be skipped or not.  If it returns true, this does not
     * guarantee that the file can be successfully executed.
     */
    static _canExecute(filePath, context) {
        if (!FileSystem_1.FileSystem.exists(filePath)) {
            return false;
        }
        if (os.platform() === 'win32') {
            // NOTE: For Windows, we don't validate that the file extension appears in PATHEXT.
            // That environment variable determines which extensions can be appended if the
            // extension is missing, but it does not affect whether a file may be executed or not.
            // Windows does have a (seldom used) ACL that can be used to deny execution permissions
            // for a file, but NodeJS doesn't expose that API, so we don't bother checking it.
            // However, Windows *does* require that the file has some kind of file extension
            if (path.extname(filePath) === '') {
                return false;
            }
        }
        else {
            // For Unix, check whether any of the POSIX execute bits are set
            try {
                // eslint-disable-next-line no-bitwise
                if ((FileSystem_1.FileSystem.getPosixModeBits(filePath) & 73 /* AllExecute */) === 0) {
                    return false; // not executable
                }
            }
            catch (error) {
                // If we have trouble accessing the file, ignore the error and consider it "not executable"
                // since that's what a shell would do
            }
        }
        return true;
    }
    /**
     * Returns the list of folders where we will search for an executable,
     * based on the PATH environment variable.
     */
    static _getSearchFolders(context) {
        const pathList = context.environmentMap.get('PATH') || '';
        const folders = [];
        // Avoid processing duplicates
        const seenPaths = new Set();
        // NOTE: Cmd.exe on Windows always searches the current working directory first.
        // PowerShell and Unix shells do NOT do that, because it's a security concern.
        // We follow their behavior.
        for (const splitPath of pathList.split(path.delimiter)) {
            const trimmedPath = splitPath.trim();
            if (trimmedPath !== '') {
                if (!seenPaths.has(trimmedPath)) {
                    // Fun fact: If you put relative paths in your PATH environment variable,
                    // all shells will dynamically match them against the current working directory.
                    // This is a terrible design, and in practice nobody does that, but it is supported...
                    // so we allow it here.
                    const resolvedPath = path.resolve(context.currentWorkingDirectory, trimmedPath);
                    if (!seenPaths.has(resolvedPath)) {
                        if (FileSystem_1.FileSystem.exists(resolvedPath)) {
                            folders.push(resolvedPath);
                        }
                        seenPaths.add(resolvedPath);
                    }
                    seenPaths.add(trimmedPath);
                }
            }
        }
        return folders;
    }
    static _getExecutableContext(options) {
        if (!options) {
            options = {};
        }
        const environment = Executable._buildEnvironmentMap(options);
        let currentWorkingDirectory;
        if (options.currentWorkingDirectory) {
            currentWorkingDirectory = path.resolve(options.currentWorkingDirectory);
        }
        else {
            currentWorkingDirectory = process.cwd();
        }
        const windowsExecutableExtensions = [];
        if (os.platform() === 'win32') {
            const pathExtVariable = environment.get('PATHEXT') || '';
            for (const splitValue of pathExtVariable.split(';')) {
                const trimmed = splitValue.trim().toLowerCase();
                // Ignore malformed extensions
                if (/^\.[a-z0-9\.]*[a-z0-9]$/i.test(trimmed)) {
                    // Don't add the same extension twice
                    if (windowsExecutableExtensions.indexOf(trimmed) < 0) {
                        windowsExecutableExtensions.push(trimmed);
                    }
                }
            }
        }
        return {
            environmentMap: environment,
            currentWorkingDirectory,
            windowsExecutableExtensions
        };
    }
    /**
     * Given an input string containing special symbol characters, this inserts the "^" escape
     * character to ensure the symbols are interpreted literally by the Windows shell.
     */
    static _getEscapedForWindowsShell(text) {
        const escapableCharRegExp = /[%\^&|<> ]/g;
        return text.replace(escapableCharRegExp, (value) => '^' + value);
    }
    /**
     * Checks for characters that are unsafe to pass to a Windows batch file
     * due to the way that cmd.exe implements escaping.
     */
    static _validateArgsForWindowsShell(args) {
        const specialCharRegExp = /[%\^&|<>\r\n]/g;
        for (const arg of args) {
            const match = arg.match(specialCharRegExp);
            if (match) {
                // NOTE: It is possible to escape some of these characters by prefixing them
                // with a caret (^), which allows these characters to be successfully passed
                // through to the batch file %1 variables.  But they will be expanded again
                // whenever they are used.  For example, NPM's binary wrapper batch files
                // use "%*" to pass their arguments to Node.exe, which causes them to be expanded
                // again.  Unfortunately the Cmd.exe batch language provides native escaping
                // function (that could be used to insert the carets again).
                //
                // We could work around that by adding double carets, but in general there
                // is no way to predict how many times the variable will get expanded.
                // Thus, there is no generally reliable way to pass these characters.
                throw new Error(`The command line argument ${JSON.stringify(arg)} contains a` +
                    ` special character ${JSON.stringify(match[0])} that cannot be escaped for the Windows shell`);
            }
        }
    }
}
exports.Executable = Executable;
//# sourceMappingURL=Executable.js.map

/***/ }),

/***/ 19334:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileSystem = void 0;
const nodeJsPath = __importStar(__webpack_require__(85622));
const fs = __importStar(__webpack_require__(35747));
const fsx = __importStar(__webpack_require__(5630));
const Text_1 = __webpack_require__(86879);
const MOVE_DEFAULT_OPTIONS = {
    overwrite: true,
    ensureFolderExists: false
};
const READ_FOLDER_DEFAULT_OPTIONS = {
    absolutePaths: false
};
const WRITE_FILE_DEFAULT_OPTIONS = {
    ensureFolderExists: false,
    convertLineEndings: undefined,
    encoding: "utf8" /* Utf8 */
};
const APPEND_TO_FILE_DEFAULT_OPTIONS = Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS);
const READ_FILE_DEFAULT_OPTIONS = {
    encoding: "utf8" /* Utf8 */,
    convertLineEndings: undefined
};
const COPY_FILE_DEFAULT_OPTIONS = {
    alreadyExistsBehavior: "overwrite" /* Overwrite */
};
const COPY_FILES_DEFAULT_OPTIONS = {
    alreadyExistsBehavior: "overwrite" /* Overwrite */
};
const DELETE_FILE_DEFAULT_OPTIONS = {
    throwIfNotExists: false
};
/**
 * The FileSystem API provides a complete set of recommended operations for interacting with the file system.
 *
 * @remarks
 * We recommend to use this instead of the native `fs` API, because `fs` is a minimal set of low-level
 * primitives that must be mapped for each supported operating system. The FileSystem API takes a
 * philosophical approach of providing "one obvious way" to do each operation. We also prefer synchronous
 * operations except in cases where there would be a clear performance benefit for using async, since synchronous
 * code is much easier to read and debug. Also, indiscriminate parallelism has been seen to actually worsen
 * performance, versus improving it.
 *
 * Note that in the documentation, we refer to "filesystem objects", this can be a
 * file, folder, symbolic link, hard link, directory junction, etc.
 *
 * @public
 */
class FileSystem {
    // ===============
    // COMMON OPERATIONS
    // ===============
    /**
     * Returns true if the path exists on disk.
     * Behind the scenes it uses `fs.existsSync()`.
     * @remarks
     * There is a debate about the fact that after `fs.existsSync()` returns true,
     * the file might be deleted before fs.readSync() is called, which would imply that everybody
     * should catch a `readSync()` exception, and nobody should ever use `fs.existsSync()`.
     * We find this to be unpersuasive, since "unexceptional exceptions" really hinder the
     * break-on-exception debugging experience. Also, throwing/catching is generally slow.
     * @param path - The absolute or relative path to the filesystem object.
     */
    static exists(path) {
        return FileSystem._wrapException(() => {
            return fsx.existsSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.exists}.
     */
    static async existsAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return new Promise((resolve) => {
                fsx.exists(path, resolve);
            });
        });
    }
    /**
     * Gets the statistics for a particular filesystem object.
     * If the path is a link, this function follows the link and returns statistics about the link target.
     * Behind the scenes it uses `fs.statSync()`.
     * @param path - The absolute or relative path to the filesystem object.
     */
    static getStatistics(path) {
        return FileSystem._wrapException(() => {
            return fsx.statSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.getStatistics}.
     */
    static async getStatisticsAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.stat(path);
        });
    }
    /**
     * Updates the accessed and modified timestamps of the filesystem object referenced by path.
     * Behind the scenes it uses `fs.utimesSync()`.
     * The caller should specify both times in the `times` parameter.
     * @param path - The path of the file that should be modified.
     * @param times - The times that the object should be updated to reflect.
     */
    static updateTimes(path, times) {
        return FileSystem._wrapException(() => {
            fsx.utimesSync(path, times.accessedTime, times.modifiedTime);
        });
    }
    /**
     * An async version of {@link FileSystem.updateTimes}.
     */
    static async updateTimesAsync(path, times) {
        await FileSystem._wrapExceptionAsync(() => {
            // This cast is needed because the fs-extra typings require both parameters
            // to have the same type (number or Date), whereas Node.js does not require that.
            return fsx.utimes(path, times.accessedTime, times.modifiedTime);
        });
    }
    /**
     * Changes the permissions (i.e. file mode bits) for a filesystem object.
     * Behind the scenes it uses `fs.chmodSync()`.
     * @param path - The absolute or relative path to the object that should be updated.
     * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum
     */
    static changePosixModeBits(path, mode) {
        FileSystem._wrapException(() => {
            fs.chmodSync(path, mode);
        });
    }
    /**
     * An async version of {@link FileSystem.changePosixModeBits}.
     */
    static async changePosixModeBitsAsync(path, mode) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.chmod(path, mode);
        });
    }
    /**
     * Retrieves the permissions (i.e. file mode bits) for a filesystem object.
     * Behind the scenes it uses `fs.chmodSync()`.
     * @param path - The absolute or relative path to the object that should be updated.
     *
     * @remarks
     * This calls {@link FileSystem.getStatistics} to get the POSIX mode bits.
     * If statistics in addition to the mode bits are needed, it is more efficient
     * to call {@link FileSystem.getStatistics} directly instead.
     */
    static getPosixModeBits(path) {
        return FileSystem._wrapException(() => {
            return FileSystem.getStatistics(path).mode;
        });
    }
    /**
     * An async version of {@link FileSystem.getPosixModeBits}.
     */
    static async getPosixModeBitsAsync(path) {
        return await FileSystem._wrapExceptionAsync(async () => {
            return (await FileSystem.getStatisticsAsync(path)).mode;
        });
    }
    /**
     * Returns a 10-character string representation of a PosixModeBits value similar to what
     * would be displayed by a command such as "ls -l" on a POSIX-like operating system.
     * @remarks
     * For example, `PosixModeBits.AllRead | PosixModeBits.AllWrite` would be formatted as "-rw-rw-rw-".
     * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum
     */
    static formatPosixModeBits(modeBits) {
        let result = '-'; // (later we may add support for additional states such as S_IFDIR or S_ISUID)
        result += modeBits & 256 /* UserRead */ ? 'r' : '-';
        result += modeBits & 128 /* UserWrite */ ? 'w' : '-';
        result += modeBits & 64 /* UserExecute */ ? 'x' : '-';
        result += modeBits & 32 /* GroupRead */ ? 'r' : '-';
        result += modeBits & 16 /* GroupWrite */ ? 'w' : '-';
        result += modeBits & 8 /* GroupExecute */ ? 'x' : '-';
        result += modeBits & 4 /* OthersRead */ ? 'r' : '-';
        result += modeBits & 2 /* OthersWrite */ ? 'w' : '-';
        result += modeBits & 1 /* OthersExecute */ ? 'x' : '-';
        return result;
    }
    /**
     * Moves a file. The folder must exist, unless the `ensureFolderExists` option is provided.
     * Behind the scenes it uses `fs-extra.moveSync()`
     */
    static move(options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, MOVE_DEFAULT_OPTIONS), options);
            try {
                fsx.moveSync(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(options.destinationPath);
                    FileSystem.ensureFolder(folderPath);
                    fsx.moveSync(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.move}.
     */
    static async moveAsync(options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, MOVE_DEFAULT_OPTIONS), options);
            try {
                await fsx.move(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(options.destinationPath);
                    await FileSystem.ensureFolderAsync(nodeJsPath.dirname(folderPath));
                    await fsx.move(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
                }
                else {
                    throw error;
                }
            }
        });
    }
    // ===============
    // FOLDER OPERATIONS
    // ===============
    /**
     * Recursively creates a folder at a given path.
     * Behind the scenes is uses `fs-extra.ensureDirSync()`.
     * @remarks
     * Throws an exception if anything in the folderPath is not a folder.
     * @param folderPath - The absolute or relative path of the folder which should be created.
     */
    static ensureFolder(folderPath) {
        FileSystem._wrapException(() => {
            fsx.ensureDirSync(folderPath);
        });
    }
    /**
     * An async version of {@link FileSystem.ensureFolder}.
     */
    static async ensureFolderAsync(folderPath) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.ensureDir(folderPath);
        });
    }
    /**
     * Reads the contents of the folder, not including "." or "..".
     * Behind the scenes it uses `fs.readdirSync()`.
     * @param folderPath - The absolute or relative path to the folder which should be read.
     * @param options - Optional settings that can change the behavior. Type: `IReadFolderOptions`
     */
    static readFolder(folderPath, options) {
        return FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, READ_FOLDER_DEFAULT_OPTIONS), options);
            // @todo: Update this to use Node 10's `withFileTypes: true` option when we drop support for Node 8
            const fileNames = fsx.readdirSync(folderPath);
            if (options.absolutePaths) {
                return fileNames.map((fileName) => nodeJsPath.resolve(folderPath, fileName));
            }
            else {
                return fileNames;
            }
        });
    }
    /**
     * An async version of {@link FileSystem.readFolder}.
     */
    static async readFolderAsync(folderPath, options) {
        return await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, READ_FOLDER_DEFAULT_OPTIONS), options);
            // @todo: Update this to use Node 10's `withFileTypes: true` option when we drop support for Node 8
            const fileNames = await fsx.readdir(folderPath);
            if (options.absolutePaths) {
                return fileNames.map((fileName) => nodeJsPath.resolve(folderPath, fileName));
            }
            else {
                return fileNames;
            }
        });
    }
    /**
     * Deletes a folder, including all of its contents.
     * Behind the scenes is uses `fs-extra.removeSync()`.
     * @remarks
     * Does not throw if the folderPath does not exist.
     * @param folderPath - The absolute or relative path to the folder which should be deleted.
     */
    static deleteFolder(folderPath) {
        FileSystem._wrapException(() => {
            fsx.removeSync(folderPath);
        });
    }
    /**
     * An async version of {@link FileSystem.deleteFolder}.
     */
    static async deleteFolderAsync(folderPath) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.remove(folderPath);
        });
    }
    /**
     * Deletes the content of a folder, but not the folder itself. Also ensures the folder exists.
     * Behind the scenes it uses `fs-extra.emptyDirSync()`.
     * @remarks
     * This is a workaround for a common race condition, where the virus scanner holds a lock on the folder
     * for a brief period after it was deleted, causing EBUSY errors for any code that tries to recreate the folder.
     * @param folderPath - The absolute or relative path to the folder which should have its contents deleted.
     */
    static ensureEmptyFolder(folderPath) {
        FileSystem._wrapException(() => {
            fsx.emptyDirSync(folderPath);
        });
    }
    /**
     * An async version of {@link FileSystem.ensureEmptyFolder}.
     */
    static async ensureEmptyFolderAsync(folderPath) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.emptyDir(folderPath);
        });
    }
    // ===============
    // FILE OPERATIONS
    // ===============
    /**
     * Writes a text string to a file on disk, overwriting the file if it already exists.
     * Behind the scenes it uses `fs.writeFileSync()`.
     * @remarks
     * Throws an error if the folder doesn't exist, unless ensureFolder=true.
     * @param filePath - The absolute or relative path of the file.
     * @param contents - The text that should be written to the file.
     * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`
     */
    static writeFile(filePath, contents, options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                fsx.writeFileSync(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    FileSystem.ensureFolder(folderPath);
                    fsx.writeFileSync(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.writeFile}.
     */
    static async writeFileAsync(filePath, contents, options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                await fsx.writeFile(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    await FileSystem.ensureFolderAsync(folderPath);
                    await fsx.writeFile(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * Writes a text string to a file on disk, appending to the file if it already exists.
     * Behind the scenes it uses `fs.appendFileSync()`.
     * @remarks
     * Throws an error if the folder doesn't exist, unless ensureFolder=true.
     * @param filePath - The absolute or relative path of the file.
     * @param contents - The text that should be written to the file.
     * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`
     */
    static appendToFile(filePath, contents, options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, APPEND_TO_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                fsx.appendFileSync(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    FileSystem.ensureFolder(folderPath);
                    fsx.appendFileSync(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.appendToFile}.
     */
    static async appendToFileAsync(filePath, contents, options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, APPEND_TO_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                await fsx.appendFile(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    await FileSystem.ensureFolderAsync(folderPath);
                    await fsx.appendFile(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * Reads the contents of a file into a string.
     * Behind the scenes it uses `fs.readFileSync()`.
     * @param filePath - The relative or absolute path to the file whose contents should be read.
     * @param options - Optional settings that can change the behavior. Type: `IReadFileOptions`
     */
    static readFile(filePath, options) {
        return FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, READ_FILE_DEFAULT_OPTIONS), options);
            let contents = FileSystem.readFileToBuffer(filePath).toString(options.encoding);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents, options.convertLineEndings);
            }
            return contents;
        });
    }
    /**
     * An async version of {@link FileSystem.readFile}.
     */
    static async readFileAsync(filePath, options) {
        return await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, READ_FILE_DEFAULT_OPTIONS), options);
            let contents = (await FileSystem.readFileToBufferAsync(filePath)).toString(options.encoding);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents, options.convertLineEndings);
            }
            return contents;
        });
    }
    /**
     * Reads the contents of a file into a buffer.
     * Behind the scenes is uses `fs.readFileSync()`.
     * @param filePath - The relative or absolute path to the file whose contents should be read.
     */
    static readFileToBuffer(filePath) {
        return FileSystem._wrapException(() => {
            return fsx.readFileSync(filePath);
        });
    }
    /**
     * An async version of {@link FileSystem.readFileToBuffer}.
     */
    static async readFileToBufferAsync(filePath) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.readFile(filePath);
        });
    }
    /**
     * Copies a single file from one location to another.
     * By default, destinationPath is overwritten if it already exists.
     *
     * @remarks
     * The `copyFile()` API cannot be used to copy folders.  It copies at most one file.
     * Use {@link FileSystem.copyFiles} if you need to recursively copy a tree of folders.
     *
     * The implementation is based on `copySync()` from the `fs-extra` package.
     */
    static copyFile(options) {
        options = Object.assign(Object.assign({}, COPY_FILE_DEFAULT_OPTIONS), options);
        if (FileSystem.getStatistics(options.sourcePath).isDirectory()) {
            throw new Error('The specified path refers to a folder; this operation expects a file object:\n' + options.sourcePath);
        }
        FileSystem._wrapException(() => {
            fsx.copySync(options.sourcePath, options.destinationPath, {
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */
            });
        });
    }
    /**
     * An async version of {@link FileSystem.copyFile}.
     */
    static async copyFileAsync(options) {
        options = Object.assign(Object.assign({}, COPY_FILE_DEFAULT_OPTIONS), options);
        if (FileSystem.getStatistics(options.sourcePath).isDirectory()) {
            throw new Error('The specified path refers to a folder; this operation expects a file object:\n' + options.sourcePath);
        }
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.copy(options.sourcePath, options.destinationPath, {
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */
            });
        });
    }
    /**
     * Copies a file or folder from one location to another, recursively copying any folder contents.
     * By default, destinationPath is overwritten if it already exists.
     *
     * @remarks
     * If you only intend to copy a single file, it is recommended to use {@link FileSystem.copyFile}
     * instead to more clearly communicate the intended operation.
     *
     * The implementation is based on `copySync()` from the `fs-extra` package.
     */
    static copyFiles(options) {
        options = Object.assign(Object.assign({}, COPY_FILES_DEFAULT_OPTIONS), options);
        FileSystem._wrapException(() => {
            fsx.copySync(options.sourcePath, options.destinationPath, {
                dereference: !!options.dereferenceSymlinks,
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */,
                preserveTimestamps: !!options.preserveTimestamps,
                filter: options.filter
            });
        });
    }
    /**
     * An async version of {@link FileSystem.copyFiles}.
     */
    static async copyFilesAsync(options) {
        options = Object.assign(Object.assign({}, COPY_FILES_DEFAULT_OPTIONS), options);
        await FileSystem._wrapExceptionAsync(async () => {
            fsx.copySync(options.sourcePath, options.destinationPath, {
                dereference: !!options.dereferenceSymlinks,
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */,
                preserveTimestamps: !!options.preserveTimestamps,
                filter: options.filter
            });
        });
    }
    /**
     * Deletes a file. Can optionally throw if the file doesn't exist.
     * Behind the scenes it uses `fs.unlinkSync()`.
     * @param filePath - The absolute or relative path to the file that should be deleted.
     * @param options - Optional settings that can change the behavior. Type: `IDeleteFileOptions`
     */
    static deleteFile(filePath, options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, DELETE_FILE_DEFAULT_OPTIONS), options);
            try {
                fsx.unlinkSync(filePath);
            }
            catch (error) {
                if (options.throwIfNotExists || !FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.deleteFile}.
     */
    static async deleteFileAsync(filePath, options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, DELETE_FILE_DEFAULT_OPTIONS), options);
            try {
                await fsx.unlink(filePath);
            }
            catch (error) {
                if (options.throwIfNotExists || !FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        });
    }
    // ===============
    // LINK OPERATIONS
    // ===============
    /**
     * Gets the statistics of a filesystem object. Does NOT follow the link to its target.
     * Behind the scenes it uses `fs.lstatSync()`.
     * @param path - The absolute or relative path to the filesystem object.
     */
    static getLinkStatistics(path) {
        return FileSystem._wrapException(() => {
            return fsx.lstatSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.getLinkStatistics}.
     */
    static async getLinkStatisticsAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.lstat(path);
        });
    }
    /**
     * If `path` refers to a symbolic link, this returns the path of the link target, which may be
     * an absolute or relative path.
     *
     * @remarks
     * If `path` refers to a filesystem object that is not a symbolic link, then an `ErrnoException` is thrown
     * with code 'UNKNOWN'.  If `path` does not exist, then an `ErrnoException` is thrown with code `ENOENT`.
     *
     * @param path - The absolute or relative path to the symbolic link.
     * @returns the path of the link target
     */
    static readLink(path) {
        return FileSystem._wrapException(() => {
            return fsx.readlinkSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.readLink}.
     */
    static async readLinkAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.readlink(path);
        });
    }
    /**
     * Creates an NTFS "directory junction" on Windows operating systems; for other operating systems, it
     * creates a regular symbolic link.  The link target must be a folder, not a file.
     * Behind the scenes it uses `fs.symlinkSync()`.
     *
     * @remarks
     * For security reasons, Windows operating systems by default require administrator elevation to create
     * symbolic links.  As a result, on Windows it's generally recommended for Node.js tools to use hard links
     * (for files) or NTFS directory junctions (for folders), since regular users are allowed to create them.
     * Hard links and junctions are less vulnerable to symlink attacks because they cannot reference a network share,
     * and their target must exist at the time of link creation.  Non-Windows operating systems generally don't
     * restrict symlink creation, and as such are more vulnerable to symlink attacks.  Note that Windows can be
     * configured to permit regular users to create symlinks, for example by enabling Windows 10 "developer mode."
     *
     * A directory junction requires the link source and target to both be located on local disk volumes;
     * if not, use a symbolic link instead.
     */
    static createSymbolicLinkJunction(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                // For directories, we use a Windows "junction".  On POSIX operating systems, this produces a regular symlink.
                return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'junction');
            }, options);
        });
    }
    /**
     * An async version of {@link FileSystem.createSymbolicLinkJunction}.
     */
    static async createSymbolicLinkJunctionAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                // For directories, we use a Windows "junction".  On POSIX operating systems, this produces a regular symlink.
                return fsx.symlink(options.linkTargetPath, options.newLinkPath, 'junction');
            }, options);
        });
    }
    /**
     * Creates a symbolic link to a file.  On Windows operating systems, this may require administrator elevation.
     * Behind the scenes it uses `fs.symlinkSync()`.
     *
     * @remarks
     * To avoid administrator elevation on Windows, use {@link FileSystem.createHardLink} instead.
     *
     * On Windows operating systems, the NTFS file system distinguishes file symlinks versus directory symlinks:
     * If the target is not the correct type, the symlink will be created successfully, but will fail to resolve.
     * Other operating systems do not make this distinction, in which case {@link FileSystem.createSymbolicLinkFile}
     * and {@link FileSystem.createSymbolicLinkFolder} can be used interchangeably, but doing so will make your
     * tool incompatible with Windows.
     */
    static createSymbolicLinkFile(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'file');
            }, options);
        });
    }
    /**
     * An async version of {@link FileSystem.createSymbolicLinkFile}.
     */
    static async createSymbolicLinkFileAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                return fsx.symlink(options.linkTargetPath, options.newLinkPath, 'file');
            }, options);
        });
    }
    /**
     * Creates a symbolic link to a folder.  On Windows operating systems, this may require administrator elevation.
     * Behind the scenes it uses `fs.symlinkSync()`.
     *
     * @remarks
     * To avoid administrator elevation on Windows, use {@link FileSystem.createSymbolicLinkJunction} instead.
     *
     * On Windows operating systems, the NTFS file system distinguishes file symlinks versus directory symlinks:
     * If the target is not the correct type, the symlink will be created successfully, but will fail to resolve.
     * Other operating systems do not make this distinction, in which case {@link FileSystem.createSymbolicLinkFile}
     * and {@link FileSystem.createSymbolicLinkFolder} can be used interchangeably, but doing so will make your
     * tool incompatible with Windows.
     */
    static createSymbolicLinkFolder(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'dir');
            }, options);
        });
    }
    /**
     * An async version of {@link FileSystem.createSymbolicLinkFolder}.
     */
    static async createSymbolicLinkFolderAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                return fsx.symlink(options.linkTargetPath, options.newLinkPath, 'dir');
            }, options);
        });
    }
    /**
     * Creates a hard link.  The link target must be a file, not a folder.
     * Behind the scenes it uses `fs.linkSync()`.
     *
     * @remarks
     * For security reasons, Windows operating systems by default require administrator elevation to create
     * symbolic links.  As a result, on Windows it's generally recommended for Node.js tools to use hard links
     * (for files) or NTFS directory junctions (for folders), since regular users are allowed to create them.
     * Hard links and junctions are less vulnerable to symlink attacks because they cannot reference a network share,
     * and their target must exist at the time of link creation.  Non-Windows operating systems generally don't
     * restrict symlink creation, and as such are more vulnerable to symlink attacks.  Note that Windows can be
     * configured to permit regular users to create symlinks, for example by enabling Windows 10 "developer mode."
     *
     * A hard link requires the link source and target to both be located on same disk volume;
     * if not, use a symbolic link instead.
     */
    static createHardLink(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                return fsx.linkSync(options.linkTargetPath, options.newLinkPath);
            }, Object.assign(Object.assign({}, options), { linkTargetMustExist: true }));
        });
    }
    /**
     * An async version of {@link FileSystem.createHardLink}.
     */
    static async createHardLinkAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                return fsx.link(options.linkTargetPath, options.newLinkPath);
            }, Object.assign(Object.assign({}, options), { linkTargetMustExist: true }));
        });
    }
    /**
     * Follows a link to its destination and returns the absolute path to the final target of the link.
     * Behind the scenes it uses `fs.realpathSync()`.
     * @param linkPath - The path to the link.
     */
    static getRealPath(linkPath) {
        return FileSystem._wrapException(() => {
            return fsx.realpathSync(linkPath);
        });
    }
    /**
     * An async version of {@link FileSystem.getRealPath}.
     */
    static async getRealPathAsync(linkPath) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.realpath(linkPath);
        });
    }
    // ===============
    // UTILITY FUNCTIONS
    // ===============
    /**
     * Returns true if the error object indicates the file or folder already exists (`EEXIST`).
     */
    static isExistError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'EEXIST';
    }
    /**
     * Returns true if the error object indicates the file or folder does not exist (`ENOENT` or `ENOTDIR`)
     */
    static isNotExistError(error) {
        return FileSystem.isFileDoesNotExistError(error) || FileSystem.isFolderDoesNotExistError(error);
    }
    /**
     * Returns true if the error object indicates the file does not exist (`ENOENT`).
     */
    static isFileDoesNotExistError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'ENOENT';
    }
    /**
     * Returns true if the error object indicates the folder does not exist (`ENOTDIR`).
     */
    static isFolderDoesNotExistError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'ENOTDIR';
    }
    /**
     * Returns true if the error object indicates that the `unlink` system call failed
     * due to a permissions issue (`EPERM`).
     */
    static isUnlinkNotPermittedError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'EPERM' && error.syscall === 'unlink';
    }
    /**
     * Detects if the provided error object is a `NodeJS.ErrnoException`
     */
    static isErrnoException(error) {
        const typedError = error;
        return (typeof typedError.code === 'string' &&
            typeof typedError.errno === 'number' &&
            typeof typedError.path === 'string' &&
            typeof typedError.syscall === 'string');
    }
    static _handleLink(linkFn, options) {
        try {
            linkFn();
        }
        catch (error) {
            if (FileSystem.isExistError(error)) {
                // Link exists, handle it
                switch (options.alreadyExistsBehavior) {
                    case "ignore" /* Ignore */:
                        break;
                    case "overwrite" /* Overwrite */:
                        // fsx.linkSync does not allow overwriting so we must manually delete. If it's
                        // a folder, it will throw an error.
                        this.deleteFile(options.newLinkPath);
                        linkFn();
                        break;
                    case "error" /* Error */:
                    default:
                        throw error;
                }
            }
            else {
                // When attempting to create a link in a directory that does not exist, an ENOENT
                // or ENOTDIR error is thrown, so we should ensure the directory exists before
                // retrying. There are also cases where the target file must exist, so validate in
                // those cases to avoid confusing the missing directory with the missing target file.
                if (FileSystem.isNotExistError(error) &&
                    (!options.linkTargetMustExist || FileSystem.exists(options.linkTargetPath))) {
                    this.ensureFolder(nodeJsPath.dirname(options.newLinkPath));
                    linkFn();
                }
                else {
                    throw error;
                }
            }
        }
    }
    static async _handleLinkAsync(linkFn, options) {
        try {
            await linkFn();
        }
        catch (error) {
            if (FileSystem.isExistError(error)) {
                // Link exists, handle it
                switch (options.alreadyExistsBehavior) {
                    case "ignore" /* Ignore */:
                        break;
                    case "overwrite" /* Overwrite */:
                        // fsx.linkSync does not allow overwriting so we must manually delete. If it's
                        // a folder, it will throw an error.
                        await this.deleteFileAsync(options.newLinkPath);
                        await linkFn();
                        break;
                    case "error" /* Error */:
                    default:
                        throw error;
                }
            }
            else {
                // When attempting to create a link in a directory that does not exist, an ENOENT
                // or ENOTDIR error is thrown, so we should ensure the directory exists before
                // retrying. There are also cases where the target file must exist, so validate in
                // those cases to avoid confusing the missing directory with the missing target file.
                if (FileSystem.isNotExistError(error) &&
                    (!options.linkTargetMustExist || (await FileSystem.existsAsync(options.linkTargetPath)))) {
                    await this.ensureFolderAsync(nodeJsPath.dirname(options.newLinkPath));
                    await linkFn();
                }
                else {
                    throw error;
                }
            }
        }
    }
    static _wrapException(fn) {
        try {
            return fn();
        }
        catch (error) {
            FileSystem._updateErrorMessage(error);
            throw error;
        }
    }
    static async _wrapExceptionAsync(fn) {
        try {
            return await fn();
        }
        catch (error) {
            FileSystem._updateErrorMessage(error);
            throw error;
        }
    }
    static _updateErrorMessage(error) {
        if (FileSystem.isErrnoException(error)) {
            if (FileSystem.isFileDoesNotExistError(error)) {
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `File does not exist: ${error.path}\n${error.message}`;
            }
            else if (FileSystem.isFolderDoesNotExistError(error)) {
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `Folder does not exist: ${error.path}\n${error.message}`;
            }
            else if (FileSystem.isExistError(error)) {
                // Oddly, the typing does not include the `dest` property even though the documentation
                // indicates it is there: https://nodejs.org/docs/latest-v10.x/api/errors.html#errors_error_dest
                const extendedError = error;
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `File or folder already exists: ${extendedError.dest}\n${error.message}`;
            }
            else if (FileSystem.isUnlinkNotPermittedError(error)) {
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `File or folder could not be deleted: ${error.path}\n${error.message}`;
            }
        }
    }
}
exports.FileSystem = FileSystem;
//# sourceMappingURL=FileSystem.js.map

/***/ }),

/***/ 62858:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileWriter = void 0;
const Import_1 = __webpack_require__(7598);
const fsx = Import_1.Import.lazy('fs-extra', require);
/**
 * API for interacting with file handles.
 * @public
 */
class FileWriter {
    constructor(fileDescriptor, filePath) {
        this._fileDescriptor = fileDescriptor;
        this.filePath = filePath;
    }
    /**
     * Opens a new file handle to the file at the specified path and given mode.
     * Behind the scenes it uses `fs.openSync()`.
     * The behaviour of this function is platform specific.
     * See: https://nodejs.org/docs/latest-v8.x/api/fs.html#fs_fs_open_path_flags_mode_callback
     * @param filePath - The absolute or relative path to the file handle that should be opened.
     * @param flags - The flags for opening the handle
     */
    static open(filePath, flags) {
        return new FileWriter(fsx.openSync(filePath, FileWriter._convertFlagsForNode(flags)), filePath);
    }
    /**
     * Helper function to convert the file writer array to a Node.js style string (e.g. "wx" or "a").
     * @param flags - The flags that should be converted.
     */
    static _convertFlagsForNode(flags) {
        flags = Object.assign({ append: false, exclusive: false }, flags);
        return [flags.append ? 'a' : 'w', flags.exclusive ? 'x' : ''].join('');
    }
    /**
     * Writes some text to the given file handle. Throws if the file handle has been closed.
     * Behind the scenes it uses `fs.writeSync()`.
     * @param text - The text to write to the file.
     */
    write(text) {
        if (!this._fileDescriptor) {
            throw new Error(`Cannot write to file, file descriptor has already been released.`);
        }
        fsx.writeSync(this._fileDescriptor, text);
    }
    /**
     * Closes the file handle permanently. No operations can be made on this file handle after calling this.
     * Behind the scenes it uses `fs.closeSync()` and releases the file descriptor to be re-used.
     *
     * @remarks
     * The `close()` method can be called more than once; additional calls are ignored.
     */
    close() {
        const fd = this._fileDescriptor;
        if (fd) {
            this._fileDescriptor = undefined;
            fsx.closeSync(fd);
        }
    }
}
exports.FileWriter = FileWriter;
//# sourceMappingURL=FileWriter.js.map

/***/ }),

/***/ 7598:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Import = void 0;
const path = __importStar(__webpack_require__(85622));
const importLazy = __webpack_require__(41239);
const Resolve = __importStar(__webpack_require__(47739));
const nodeModule = __webpack_require__(32282);
const PackageJsonLookup_1 = __webpack_require__(7379);
const FileSystem_1 = __webpack_require__(19334);
/**
 * Helpers for resolving and importing Node.js modules.
 * @public
 */
class Import {
    static get _builtInModules() {
        if (!Import.__builtInModules) {
            Import.__builtInModules = new Set(nodeModule.builtinModules);
        }
        return Import.__builtInModules;
    }
    /**
     * Provides a way to improve process startup times by lazy-loading imported modules.
     *
     * @remarks
     * This is a more structured wrapper for the {@link https://www.npmjs.com/package/import-lazy|import-lazy}
     * package.  It enables you to replace an import like this:
     *
     * ```ts
     * import * as example from 'example'; // <-- 100ms load time
     *
     * if (condition) {
     *   example.doSomething();
     * }
     * ```
     *
     * ...with a pattern like this:
     *
     * ```ts
     * const example: typeof import('example') = Import.lazy('example', require);
     *
     * if (condition) {
     *   example.doSomething(); // <-- 100ms load time occurs here, only if needed
     * }
     * ```
     *
     * The implementation relies on JavaScript's `Proxy` feature to intercept access to object members.  Thus
     * it will only work correctly with certain types of module exports.  If a particular export isn't well behaved,
     * you may need to find (or introduce) some other module in your dependency graph to apply the optimization to.
     *
     * Usage guidelines:
     *
     * - Always specify types using `typeof` as shown above.
     *
     * - Never apply lazy-loading in a way that would convert the module's type to `any`. Losing type safety
     *   seriously impacts the maintainability of the code base.
     *
     * - In cases where the non-runtime types are needed, import them separately using the `Types` suffix:
     *
     * ```ts
     * const example: typeof import('example') = Import.lazy('example', require);
     * import type * as exampleTypes from 'example';
     * ```
     *
     * - If the imported module confusingly has the same name as its export, then use the Module suffix:
     *
     * ```ts
     * const exampleModule: typeof import('../../logic/Example') = Import.lazy(
     *   '../../logic/Example', require);
     * import type * as exampleTypes from '../../logic/Example';
     * ```
     *
     * - If the exports cause a lot of awkwardness (e.g. too many expressions need to have `exampleModule.` inserted
     *   into them), or if some exports cannot be proxied (e.g. `Import.lazy('example', require)` returns a function
     *   signature), then do not lazy-load that module.  Instead, apply lazy-loading to some other module which is
     *   better behaved.
     *
     * - It's recommended to sort imports in a standard ordering:
     *
     * ```ts
     * // 1. external imports
     * import * as path from 'path';
     * import { Import, JsonFile, JsonObject } from '@rushstack/node-core-library';
     *
     * // 2. local imports
     * import { LocalFile } from './path/LocalFile';
     *
     * // 3. lazy-imports (which are technically variables, not imports)
     * const semver: typeof import('semver') = Import.lazy('semver', require);
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static lazy(moduleName, require) {
        const importLazyLocal = importLazy(require);
        return importLazyLocal(moduleName);
    }
    /**
     * This resolves a module path using similar logic as the Node.js `require.resolve()` API,
     * but supporting extra features such as specifying the base folder.
     *
     * @remarks
     * A module path is a text string that might appear in a statement such as
     * `import { X } from "____";` or `const x = require("___");`.  The implementation is based
     * on the popular `resolve` NPM package.
     *
     * Suppose `example` is an NPM package whose entry point is `lib/index.js`:
     * ```ts
     * // Returns "/path/to/project/node_modules/example/lib/index.js"
     * Import.resolveModule({ modulePath: 'example' });
     *
     * // Returns "/path/to/project/node_modules/example/lib/other.js"
     * Import.resolveModule({ modulePath: 'example/lib/other' });
     * ```
     * If you need to determine the containing package folder
     * (`/path/to/project/node_modules/example`), use {@link Import.resolvePackage} instead.
     *
     * @returns the absolute path of the resolved module.
     * If {@link IImportResolveOptions.includeSystemModules} is specified
     * and a system module is found, then its name is returned without any file path.
     */
    static resolveModule(options) {
        const { modulePath } = options;
        if (path.isAbsolute(modulePath)) {
            return modulePath;
        }
        const normalizedRootPath = FileSystem_1.FileSystem.getRealPath(options.baseFolderPath);
        if (modulePath.startsWith('.')) {
            // This looks like a conventional relative path
            return path.resolve(normalizedRootPath, modulePath);
        }
        if (options.includeSystemModules === true && Import._builtInModules.has(modulePath)) {
            return modulePath;
        }
        if (options.allowSelfReference === true) {
            const ownPackage = Import._getPackageName(options.baseFolderPath);
            if (ownPackage && modulePath.startsWith(ownPackage.packageName)) {
                const packagePath = modulePath.substr(ownPackage.packageName.length + 1);
                return path.resolve(ownPackage.packageRootPath, packagePath);
            }
        }
        try {
            return Resolve.sync(
            // Append a slash to the package name to ensure `resolve.sync` doesn't attempt to return a system package
            options.includeSystemModules !== true && modulePath.indexOf('/') === -1
                ? `${modulePath}/`
                : modulePath, {
                basedir: normalizedRootPath,
                preserveSymlinks: false
            });
        }
        catch (e) {
            throw new Error(`Cannot find module "${modulePath}" from "${options.baseFolderPath}".`);
        }
    }
    /**
     * Performs module resolution to determine the folder where a package is installed.
     *
     * @remarks
     * Suppose `example` is an NPM package whose entry point is `lib/index.js`:
     * ```ts
     * // Returns "/path/to/project/node_modules/example"
     * Import.resolvePackage({ packageName: 'example' });
     * ```
     *
     * If you need to resolve a module path, use {@link Import.resolveModule} instead:
     * ```ts
     * // Returns "/path/to/project/node_modules/example/lib/index.js"
     * Import.resolveModule({ modulePath: 'example' });
     * ```
     *
     * @returns the absolute path of the package folder.
     * If {@link IImportResolveOptions.includeSystemModules} is specified
     * and a system module is found, then its name is returned without any file path.
     */
    static resolvePackage(options) {
        const { packageName } = options;
        if (options.includeSystemModules && Import._builtInModules.has(packageName)) {
            return packageName;
        }
        const normalizedRootPath = FileSystem_1.FileSystem.getRealPath(options.baseFolderPath);
        if (options.allowSelfReference) {
            const ownPackage = Import._getPackageName(options.baseFolderPath);
            if (ownPackage && ownPackage.packageName === packageName) {
                return ownPackage.packageRootPath;
            }
        }
        try {
            const resolvedPath = Resolve.sync(packageName, {
                basedir: normalizedRootPath,
                preserveSymlinks: false,
                packageFilter: (pkg) => {
                    // Hardwire "main" to point to a file that is guaranteed to exist.
                    // This helps resolve packages such as @types/node that have no entry point.
                    // And then we can use path.dirname() below to locate the package folder,
                    // even if the real entry point was in an subfolder with arbitrary nesting.
                    pkg.main = 'package.json';
                    return pkg;
                }
            });
            const packagePath = path.dirname(resolvedPath);
            const packageJson = PackageJsonLookup_1.PackageJsonLookup.instance.loadPackageJson(path.join(packagePath, 'package.json'));
            if (packageJson.name === packageName) {
                return packagePath;
            }
            else {
                throw new Error();
            }
        }
        catch (e) {
            throw new Error(`Cannot find package "${packageName}" from "${options.baseFolderPath}".`);
        }
    }
    static _getPackageName(rootPath) {
        const packageJsonPath = PackageJsonLookup_1.PackageJsonLookup.instance.tryGetPackageJsonFilePathFor(rootPath);
        if (packageJsonPath) {
            const packageJson = PackageJsonLookup_1.PackageJsonLookup.instance.loadPackageJson(packageJsonPath);
            return {
                packageRootPath: path.dirname(packageJsonPath),
                packageName: packageJson.name
            };
        }
        else {
            return undefined;
        }
    }
}
exports.Import = Import;
//# sourceMappingURL=Import.js.map

/***/ }),

/***/ 74436:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InternalError = void 0;
/**
 * An `Error` subclass that should be thrown to report an unexpected state that may indicate a software defect.
 * An application may handle this error by instructing the end user to report an issue to the application maintainers.
 *
 * @remarks
 * Do not use this class unless you intend to solicit bug reports from end users.
 *
 * @public
 */
class InternalError extends Error {
    /**
     * Constructs a new instance of the {@link InternalError} class.
     *
     * @param message - A message describing the error.  This will be assigned to
     * {@link InternalError.unformattedMessage}.  The `Error.message` field will have additional boilerplate
     * explaining that the user has encountered a software defect.
     */
    constructor(message) {
        super(InternalError._formatMessage(message));
        // Manually set the prototype, as we can no longer extend built-in classes like Error, Array, Map, etc.
        // https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        //
        // Note: the prototype must also be set on any classes which extend this one
        this.__proto__ = InternalError.prototype; // eslint-disable-line @typescript-eslint/no-explicit-any
        this.unformattedMessage = message;
        if (InternalError.breakInDebugger) {
            // eslint-disable-next-line no-debugger
            debugger;
        }
    }
    static _formatMessage(unformattedMessage) {
        return (`Internal Error: ${unformattedMessage}\n\nYou have encountered a software defect. Please consider` +
            ` reporting the issue to the maintainers of this application.`);
    }
    /** @override */
    toString() {
        return this.message; // Avoid adding the "Error:" prefix
    }
}
exports.InternalError = InternalError;
/**
 * If true, a JavScript `debugger;` statement will be invoked whenever the `InternalError` constructor is called.
 *
 * @remarks
 * Generally applications should not be catching and ignoring an `InternalError`.  Instead, the error should
 * be reported and typically the application will terminate.  Thus, if `InternalError` is constructed, it's
 * almost always something we want to examine in a debugger.
 */
InternalError.breakInDebugger = true;
//# sourceMappingURL=InternalError.js.map

/***/ }),

/***/ 46484:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonFile = void 0;
const os = __importStar(__webpack_require__(12087));
const jju = __importStar(__webpack_require__(93304));
const Text_1 = __webpack_require__(86879);
const FileSystem_1 = __webpack_require__(19334);
const DEFAULT_ENCODING = 'utf8';
/**
 * Utilities for reading/writing JSON files.
 * @public
 */
class JsonFile {
    /**
     * Loads a JSON file.
     */
    static load(jsonFilename) {
        try {
            const contents = FileSystem_1.FileSystem.readFile(jsonFilename);
            return jju.parse(contents);
        }
        catch (error) {
            if (FileSystem_1.FileSystem.isNotExistError(error)) {
                throw error;
            }
            else {
                throw new Error(`Error reading "${JsonFile._formatPathForError(jsonFilename)}":` +
                    os.EOL +
                    `  ${error.message}`);
            }
        }
    }
    /**
     * An async version of {@link JsonFile.load}.
     */
    static async loadAsync(jsonFilename) {
        try {
            const contents = await FileSystem_1.FileSystem.readFileAsync(jsonFilename);
            return jju.parse(contents);
        }
        catch (error) {
            if (FileSystem_1.FileSystem.isNotExistError(error)) {
                throw error;
            }
            else {
                throw new Error(`Error reading "${JsonFile._formatPathForError(jsonFilename)}":` +
                    os.EOL +
                    `  ${error.message}`);
            }
        }
    }
    /**
     * Parses a JSON file's contents.
     */
    static parseString(jsonContents) {
        return jju.parse(jsonContents);
    }
    /**
     * Loads a JSON file and validate its schema.
     */
    static loadAndValidate(jsonFilename, jsonSchema, options) {
        const jsonObject = JsonFile.load(jsonFilename);
        jsonSchema.validateObject(jsonObject, jsonFilename, options);
        return jsonObject;
    }
    /**
     * An async version of {@link JsonFile.loadAndValidate}.
     */
    static async loadAndValidateAsync(jsonFilename, jsonSchema, options) {
        const jsonObject = await JsonFile.loadAsync(jsonFilename);
        jsonSchema.validateObject(jsonObject, jsonFilename, options);
        return jsonObject;
    }
    /**
     * Loads a JSON file and validate its schema, reporting errors using a callback
     * @remarks
     * See JsonSchema.validateObjectWithCallback() for more info.
     */
    static loadAndValidateWithCallback(jsonFilename, jsonSchema, errorCallback) {
        const jsonObject = JsonFile.load(jsonFilename);
        jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);
        return jsonObject;
    }
    /**
     * An async version of {@link JsonFile.loadAndValidateWithCallback}.
     */
    static async loadAndValidateWithCallbackAsync(jsonFilename, jsonSchema, errorCallback) {
        const jsonObject = await JsonFile.loadAsync(jsonFilename);
        jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);
        return jsonObject;
    }
    /**
     * Serializes the specified JSON object to a string buffer.
     * @param jsonObject - the object to be serialized
     * @param options - other settings that control serialization
     * @returns a JSON string, with newlines, and indented with two spaces
     */
    static stringify(jsonObject, options) {
        return JsonFile.updateString('', jsonObject, options);
    }
    /**
     * Serializes the specified JSON object to a string buffer.
     * @param jsonObject - the object to be serialized
     * @param options - other settings that control serialization
     * @returns a JSON string, with newlines, and indented with two spaces
     */
    static updateString(previousJson, newJsonObject, options) {
        if (!options) {
            options = {};
        }
        if (!options.ignoreUndefinedValues) {
            // Standard handling of `undefined` in JSON stringification is to discard the key.
            JsonFile.validateNoUndefinedMembers(newJsonObject);
        }
        let stringified;
        if (previousJson !== '') {
            // NOTE: We don't use mode=json here because comments aren't allowed by strict JSON
            stringified = jju.update(previousJson, newJsonObject, {
                mode: 'cjson',
                indent: 2
            });
        }
        else if (options.prettyFormatting) {
            stringified = jju.stringify(newJsonObject, {
                mode: 'json',
                indent: 2
            });
            if (options.headerComment !== undefined) {
                stringified = JsonFile._formatJsonHeaderComment(options.headerComment) + stringified;
            }
        }
        else {
            stringified = JSON.stringify(newJsonObject, undefined, 2);
            if (options.headerComment !== undefined) {
                stringified = JsonFile._formatJsonHeaderComment(options.headerComment) + stringified;
            }
        }
        // Add the trailing newline
        stringified = Text_1.Text.ensureTrailingNewline(stringified);
        if (options && options.newlineConversion) {
            stringified = Text_1.Text.convertTo(stringified, options.newlineConversion);
        }
        return stringified;
    }
    /**
     * Saves the file to disk.  Returns false if nothing was written due to options.onlyIfChanged.
     * @param jsonObject - the object to be saved
     * @param jsonFilename - the file path to write
     * @param options - other settings that control how the file is saved
     * @returns false if ISaveJsonFileOptions.onlyIfChanged didn't save anything; true otherwise
     */
    static save(jsonObject, jsonFilename, options) {
        if (!options) {
            options = {};
        }
        // Do we need to read the previous file contents?
        let oldBuffer = undefined;
        if (options.updateExistingFile || options.onlyIfChanged) {
            try {
                oldBuffer = FileSystem_1.FileSystem.readFileToBuffer(jsonFilename);
            }
            catch (error) {
                if (!FileSystem_1.FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        }
        let jsonToUpdate = '';
        if (options.updateExistingFile && oldBuffer) {
            jsonToUpdate = oldBuffer.toString(DEFAULT_ENCODING);
        }
        const newJson = JsonFile.updateString(jsonToUpdate, jsonObject, options);
        const newBuffer = Buffer.from(newJson, DEFAULT_ENCODING);
        if (options.onlyIfChanged) {
            // Has the file changed?
            if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {
                // Nothing has changed, so don't touch the file
                return false;
            }
        }
        FileSystem_1.FileSystem.writeFile(jsonFilename, newBuffer.toString(DEFAULT_ENCODING), {
            ensureFolderExists: options.ensureFolderExists
        });
        // TEST CODE: Used to verify that onlyIfChanged isn't broken by a hidden transformation during saving.
        /*
        const oldBuffer2: Buffer = FileSystem.readFileToBuffer(jsonFilename);
        if (Buffer.compare(buffer, oldBuffer2) !== 0) {
          console.log('new:' + buffer.toString('hex'));
          console.log('old:' + oldBuffer2.toString('hex'));
    
          throw new Error('onlyIfChanged logic is broken');
        }
        */
        return true;
    }
    /**
     * An async version of {@link JsonFile.save}.
     */
    static async saveAsync(jsonObject, jsonFilename, options) {
        if (!options) {
            options = {};
        }
        // Do we need to read the previous file contents?
        let oldBuffer = undefined;
        if (options.updateExistingFile || options.onlyIfChanged) {
            try {
                oldBuffer = await FileSystem_1.FileSystem.readFileToBufferAsync(jsonFilename);
            }
            catch (error) {
                if (!FileSystem_1.FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        }
        let jsonToUpdate = '';
        if (options.updateExistingFile && oldBuffer) {
            jsonToUpdate = oldBuffer.toString(DEFAULT_ENCODING);
        }
        const newJson = JsonFile.updateString(jsonToUpdate, jsonObject, options);
        const newBuffer = Buffer.from(newJson, DEFAULT_ENCODING);
        if (options.onlyIfChanged) {
            // Has the file changed?
            if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {
                // Nothing has changed, so don't touch the file
                return false;
            }
        }
        await FileSystem_1.FileSystem.writeFileAsync(jsonFilename, newBuffer.toString(DEFAULT_ENCODING), {
            ensureFolderExists: options.ensureFolderExists
        });
        // TEST CODE: Used to verify that onlyIfChanged isn't broken by a hidden transformation during saving.
        /*
        const oldBuffer2: Buffer = await FileSystem.readFileToBufferAsync(jsonFilename);
        if (Buffer.compare(buffer, oldBuffer2) !== 0) {
          console.log('new:' + buffer.toString('hex'));
          console.log('old:' + oldBuffer2.toString('hex'));
    
          throw new Error('onlyIfChanged logic is broken');
        }
        */
        return true;
    }
    /**
     * Used to validate a data structure before writing.  Reports an error if there
     * are any undefined members.
     */
    static validateNoUndefinedMembers(jsonObject) {
        return JsonFile._validateNoUndefinedMembers(jsonObject, []);
    }
    // Private implementation of validateNoUndefinedMembers()
    static _validateNoUndefinedMembers(jsonObject, keyPath) {
        if (!jsonObject) {
            return;
        }
        if (typeof jsonObject === 'object') {
            for (const key of Object.keys(jsonObject)) {
                keyPath.push(key);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const value = jsonObject[key];
                if (value === undefined) {
                    const fullPath = JsonFile._formatKeyPath(keyPath);
                    throw new Error(`The value for ${fullPath} is "undefined" and cannot be serialized as JSON`);
                }
                JsonFile._validateNoUndefinedMembers(value, keyPath);
                keyPath.pop();
            }
        }
    }
    // Given this input:    ['items', '4', 'syntax', 'parameters', 'string "with" symbols", 'type']
    // Return this string:  items[4].syntax.parameters["string \"with\" symbols"].type
    static _formatKeyPath(keyPath) {
        let result = '';
        for (const key of keyPath) {
            if (/^[0-9]+$/.test(key)) {
                // It's an integer, so display like this:  parent[123]
                result += `[${key}]`;
            }
            else if (/^[a-z_][a-z_0-9]*$/i.test(key)) {
                // It's an alphanumeric identifier, so display like this:  parent.name
                if (result) {
                    result += '.';
                }
                result += `${key}`;
            }
            else {
                // It's a freeform string, so display like this:  parent["A path: \"C:\\file\""]
                // Convert this:     A path: "C:\file"
                // To this:          A path: \"C:\\file\"
                const escapedKey = key
                    .replace(/[\\]/g, '\\\\') // escape backslashes
                    .replace(/["]/g, '\\'); // escape quotes
                result += `["${escapedKey}"]`;
            }
        }
        return result;
    }
    static _formatJsonHeaderComment(headerComment) {
        if (headerComment === '') {
            return '';
        }
        const lines = headerComment.split('\n');
        const result = [];
        for (const line of lines) {
            if (!/^\s*$/.test(line) && !/^\s*\/\//.test(line)) {
                throw new Error('The headerComment lines must be blank or start with the "//" prefix.\n' +
                    'Invalid line' +
                    JSON.stringify(line));
            }
            result.push(Text_1.Text.replaceAll(line, '\r', ''));
        }
        return lines.join('\n') + '\n';
    }
}
exports.JsonFile = JsonFile;
/**
 * @internal
 */
JsonFile._formatPathForError = (path) => path;
//# sourceMappingURL=JsonFile.js.map

/***/ }),

/***/ 61038:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonSchema = void 0;
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const JsonFile_1 = __webpack_require__(46484);
const FileSystem_1 = __webpack_require__(19334);
const Validator = __webpack_require__(59997);
/**
 * Represents a JSON schema that can be used to validate JSON data files loaded by the JsonFile class.
 * @remarks
 * The schema itself is normally loaded and compiled later, only if it is actually required to validate
 * an input.  To avoid schema errors at runtime, it's recommended to create a unit test that calls
 * JsonSchema.ensureCompiled() for each of your schema objects.
 *
 * @public
 */
class JsonSchema {
    constructor() {
        this._dependentSchemas = [];
        this._filename = '';
        this._validator = undefined;
        this._schemaObject = undefined;
    }
    /**
     * Registers a JsonSchema that will be loaded from a file on disk.
     * @remarks
     * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
     * until it the schema is actually used.
     */
    static fromFile(filename, options) {
        // This is a quick and inexpensive test to avoid the catch the most common errors early.
        // Full validation will happen later in JsonSchema.compile().
        if (!FileSystem_1.FileSystem.exists(filename)) {
            throw new Error('Schema file not found: ' + filename);
        }
        const schema = new JsonSchema();
        schema._filename = filename;
        if (options) {
            schema._dependentSchemas = options.dependentSchemas || [];
        }
        return schema;
    }
    /**
     * Registers a JsonSchema that will be loaded from a file on disk.
     * @remarks
     * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
     * until it the schema is actually used.
     */
    static fromLoadedObject(schemaObject) {
        const schema = new JsonSchema();
        schema._schemaObject = schemaObject;
        return schema;
    }
    static _collectDependentSchemas(collectedSchemas, dependentSchemas, seenObjects, seenIds) {
        for (const dependentSchema of dependentSchemas) {
            // It's okay for the same schema to appear multiple times in the tree, but we only process it once
            if (seenObjects.has(dependentSchema)) {
                continue;
            }
            seenObjects.add(dependentSchema);
            const schemaId = dependentSchema._ensureLoaded();
            if (schemaId === '') {
                throw new Error(`This schema ${dependentSchema.shortName} cannot be referenced` +
                    ' because is missing the "id" field');
            }
            if (seenIds.has(schemaId)) {
                throw new Error(`This schema ${dependentSchema.shortName} has the same "id" as another schema in this set`);
            }
            seenIds.add(schemaId);
            collectedSchemas.push(dependentSchema);
            JsonSchema._collectDependentSchemas(collectedSchemas, dependentSchema._dependentSchemas, seenObjects, seenIds);
        }
    }
    /**
     * Used to nicely format the ZSchema error tree.
     */
    static _formatErrorDetails(errorDetails) {
        return JsonSchema._formatErrorDetailsHelper(errorDetails, '', '');
    }
    /**
     * Used by _formatErrorDetails.
     */
    static _formatErrorDetailsHelper(errorDetails, indent, buffer) {
        for (const errorDetail of errorDetails) {
            buffer += os.EOL + indent + `Error: ${errorDetail.path}`;
            if (errorDetail.description) {
                const MAX_LENGTH = 40;
                let truncatedDescription = errorDetail.description.trim();
                if (truncatedDescription.length > MAX_LENGTH) {
                    truncatedDescription = truncatedDescription.substr(0, MAX_LENGTH - 3) + '...';
                }
                buffer += ` (${truncatedDescription})`;
            }
            buffer += os.EOL + indent + `       ${errorDetail.message}`;
            if (errorDetail.inner) {
                buffer = JsonSchema._formatErrorDetailsHelper(errorDetail.inner, indent + '  ', buffer);
            }
        }
        return buffer;
    }
    /**
     * Returns a short name for this schema, for use in error messages.
     * @remarks
     * If the schema was loaded from a file, then the base filename is used.  Otherwise, the "id"
     * field is used if available.
     */
    get shortName() {
        if (!this._filename) {
            if (this._schemaObject) {
                const schemaWithId = this._schemaObject;
                if (schemaWithId.id) {
                    return schemaWithId.id;
                }
            }
            return '(anonymous schema)';
        }
        else {
            return path.basename(this._filename);
        }
    }
    /**
     * If not already done, this loads the schema from disk and compiles it.
     * @remarks
     * Any dependencies will be compiled as well.
     */
    ensureCompiled() {
        this._ensureLoaded();
        if (!this._validator) {
            // Don't assign this to _validator until we're sure everything was successful
            const newValidator = new Validator({
                breakOnFirstError: false,
                noTypeless: true,
                noExtraKeywords: true
            });
            const anythingSchema = {
                type: ['array', 'boolean', 'integer', 'number', 'object', 'string']
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            newValidator.setRemoteReference('http://json-schema.org/draft-04/schema', anythingSchema);
            const collectedSchemas = [];
            const seenObjects = new Set();
            const seenIds = new Set();
            JsonSchema._collectDependentSchemas(collectedSchemas, this._dependentSchemas, seenObjects, seenIds);
            // Validate each schema in order.  We specifically do not supply them all together, because we want
            // to make sure that circular references will fail to validate.
            for (const collectedSchema of collectedSchemas) {
                if (!newValidator.validateSchema(collectedSchema._schemaObject)) {
                    throw new Error(`Failed to validate schema "${collectedSchema.shortName}":` +
                        os.EOL +
                        JsonSchema._formatErrorDetails(newValidator.getLastErrors()));
                }
            }
            this._validator = newValidator;
        }
    }
    /**
     * Validates the specified JSON object against this JSON schema.  If the validation fails,
     * an exception will be thrown.
     * @param jsonObject - The JSON data to be validated
     * @param filenameForErrors - The filename that the JSON data was available, or an empty string
     *    if not applicable
     * @param options - Other options that control the validation
     */
    validateObject(jsonObject, filenameForErrors, options) {
        this.validateObjectWithCallback(jsonObject, (errorInfo) => {
            const prefix = options && options.customErrorHeader ? options.customErrorHeader : 'JSON validation failed:';
            throw new Error(prefix + os.EOL + filenameForErrors + os.EOL + errorInfo.details);
        });
    }
    /**
     * Validates the specified JSON object against this JSON schema.  If the validation fails,
     * a callback is called for each validation error.
     */
    validateObjectWithCallback(jsonObject, errorCallback) {
        this.ensureCompiled();
        if (!this._validator.validate(jsonObject, this._schemaObject)) {
            const errorDetails = JsonSchema._formatErrorDetails(this._validator.getLastErrors());
            const args = {
                details: errorDetails
            };
            errorCallback(args);
        }
    }
    _ensureLoaded() {
        if (!this._schemaObject) {
            this._schemaObject = JsonFile_1.JsonFile.load(this._filename);
        }
        return this._schemaObject.id || '';
    }
}
exports.JsonSchema = JsonSchema;
//# sourceMappingURL=JsonSchema.js.map

/***/ }),

/***/ 69291:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LegacyAdapters = void 0;
const timsort_1 = __webpack_require__(46655);
const semver = __importStar(__webpack_require__(11383));
/**
 * Helper functions used when interacting with APIs that do not follow modern coding practices.
 * @public
 */
class LegacyAdapters {
    static convertCallbackToPromise(fn, arg1, arg2, arg3, arg4) {
        return new Promise((resolve, reject) => {
            const cb = (error, result) => {
                if (error) {
                    reject(LegacyAdapters.scrubError(error));
                }
                else {
                    resolve(result);
                }
            };
            try {
                if (arg1 !== undefined && arg2 !== undefined && arg3 !== undefined && arg4 !== undefined) {
                    fn(arg1, arg2, arg3, arg4, cb);
                }
                else if (arg1 !== undefined && arg2 !== undefined && arg3 !== undefined) {
                    fn(arg1, arg2, arg3, cb);
                }
                else if (arg1 !== undefined && arg2 !== undefined) {
                    fn(arg1, arg2, cb);
                }
                else if (arg1 !== undefined) {
                    fn(arg1, cb);
                }
                else {
                    fn(cb);
                }
            }
            catch (e) {
                reject(e);
            }
        });
    }
    /**
     * Normalizes an object into an `Error` object.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static scrubError(error) {
        if (error instanceof Error) {
            return error;
        }
        else if (typeof error === 'string') {
            return new Error(error);
        }
        else {
            const errorObject = new Error('An error occurred.');
            errorObject.errorData = error; // eslint-disable-line @typescript-eslint/no-explicit-any
            return errorObject;
        }
    }
    /**
     * Prior to Node 11.x, the `Array.sort()` algorithm is not guaranteed to be stable.
     * If you need a stable sort, you can use `sortStable()` as a workaround.
     *
     * @remarks
     * On NodeJS 11.x and later, this method simply calls the native `Array.sort()`.
     * For earlier versions, it uses an implementation of Timsort, which is the same algorithm used by modern NodeJS.
     */
    static sortStable(array, compare) {
        if (LegacyAdapters._useTimsort === undefined) {
            LegacyAdapters._useTimsort = semver.major(process.versions.node) < 11;
        }
        if (LegacyAdapters._useTimsort) {
            (0, timsort_1.sort)(array, compare);
        }
        else {
            Array.prototype.sort.call(array, compare);
        }
    }
}
exports.LegacyAdapters = LegacyAdapters;
LegacyAdapters._useTimsort = undefined;
//# sourceMappingURL=LegacyAdapters.js.map

/***/ }),

/***/ 9546:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LockFile = exports.getProcessStartTime = exports.getProcessStartTimeFromProcStat = void 0;
const path = __importStar(__webpack_require__(85622));
const child_process = __importStar(__webpack_require__(63129));
const FileSystem_1 = __webpack_require__(19334);
const FileWriter_1 = __webpack_require__(62858);
const Async_1 = __webpack_require__(18635);
/**
 * http://man7.org/linux/man-pages/man5/proc.5.html
 * (22) starttime  %llu
 * The time the process started after system boot. In kernels before Linux 2.6, this value was
 * expressed in jiffies. Since Linux 2.6, the value is expressed in clock ticks (divide by
 * sysconf(_SC_CLK_TCK)).
 * The format for this field was %lu before Linux 2.6.
 */
const procStatStartTimePos = 22;
/**
 * Parses the process start time from the contents of a linux /proc/[pid]/stat file.
 * @param stat - The contents of a linux /proc/[pid]/stat file.
 * @returns The process start time in jiffies, or undefined if stat has an unexpected format.
 */
function getProcessStartTimeFromProcStat(stat) {
    // Parse the value at position procStatStartTimePos.
    // We cannot just split stat on spaces, because value 2 may contain spaces.
    // For example, when running the following Shell commands:
    // > cp "$(which bash)" ./'bash 2)('
    // > ./'bash 2)(' -c 'OWNPID=$BASHPID;cat /proc/$OWNPID/stat'
    // 59389 (bash 2)() S 59358 59389 59358 34818 59389 4202496 329 0 0 0 0 0 0 0 20 0 1 0
    // > rm -rf ./'bash 2)('
    // The output shows a stat file such that value 2 contains spaces.
    // To still umambiguously parse such output we assume no values after the second ends with a right parenthesis...
    // trimRight to remove the trailing line terminator.
    let values = stat.trimRight().split(' ');
    let i = values.length - 1;
    while (i >= 0 &&
        // charAt returns an empty string if the index is out of bounds.
        values[i].charAt(values[i].length - 1) !== ')') {
        i -= 1;
    }
    // i is the index of the last part of the second value (but i need not be 1).
    if (i < 1) {
        // Format of stat has changed.
        return undefined;
    }
    const value2 = values.slice(1, i + 1).join(' ');
    values = [values[0], value2].concat(values.slice(i + 1));
    if (values.length < procStatStartTimePos) {
        // Older version of linux, or non-standard configuration of linux.
        return undefined;
    }
    const startTimeJiffies = values[procStatStartTimePos - 1];
    // In theory, the representations of start time returned by `cat /proc/[pid]/stat` and `ps -o lstart` can change
    // while the system is running, but we assume this does not happen.
    // So the caller can safely use this value as part of a unique process id (on the machine, without comparing
    // accross reboots).
    return startTimeJiffies;
}
exports.getProcessStartTimeFromProcStat = getProcessStartTimeFromProcStat;
/**
 * Helper function that is exported for unit tests only.
 * Returns undefined if the process doesn't exist with that pid.
 */
function getProcessStartTime(pid) {
    const pidString = pid.toString();
    if (pid < 0 || pidString.indexOf('e') >= 0 || pidString.indexOf('E') >= 0) {
        throw new Error(`"pid" is negative or too large`);
    }
    let args;
    if (process.platform === 'darwin') {
        args = [`-p ${pidString}`, '-o lstart'];
    }
    else if (process.platform === 'linux') {
        args = ['-p', pidString, '-o', 'lstart'];
    }
    else {
        throw new Error(`Unsupported system: ${process.platform}`);
    }
    const psResult = child_process.spawnSync('ps', args, {
        encoding: 'utf8'
    });
    const psStdout = psResult.stdout;
    // If no process with PID pid exists then the exit code is non-zero on linux but stdout is not empty.
    // But if no process exists we do not want to fall back on /proc/*/stat to determine the process
    // start time, so we we additionally test for !psStdout. NOTE: !psStdout evaluates to true if
    // zero bytes are written to stdout.
    if (psResult.status !== 0 && !psStdout && process.platform === 'linux') {
        // Try to read /proc/[pid]/stat and get the value at position procStatStartTimePos.
        let stat;
        try {
            stat = FileSystem_1.FileSystem.readFile(`/proc/${pidString}/stat`);
        }
        catch (error) {
            if (error.code !== 'ENOENT') {
                throw error;
            }
            // Either no process with PID pid exists, or this version/configuration of linux is non-standard.
            // We assume the former.
            return undefined;
        }
        if (stat !== undefined) {
            const startTimeJiffies = getProcessStartTimeFromProcStat(stat);
            if (startTimeJiffies === undefined) {
                throw new Error(`Could not retrieve the start time of process ${pidString} from the OS because the ` +
                    `contents of /proc/${pidString}/stat have an unexpected format`);
            }
            return startTimeJiffies;
        }
    }
    // there was an error executing ps (zero bytes were written to stdout).
    if (!psStdout) {
        throw new Error(`Unexpected output from "ps" command`);
    }
    const psSplit = psStdout.split('\n');
    // successfuly able to run "ps", but no process was found
    if (psSplit[1] === '') {
        return undefined;
    }
    if (psSplit[1]) {
        const trimmed = psSplit[1].trim();
        if (trimmed.length > 10) {
            return trimmed;
        }
    }
    throw new Error(`Unexpected output from the "ps" command`);
}
exports.getProcessStartTime = getProcessStartTime;
/**
 * The `LockFile` implements a file-based mutex for synchronizing access to a shared resource
 * between multiple Node.js processes.  It is not recommended for synchronization solely within
 * a single Node.js process.
 * @remarks
 * The implementation works on Windows, Mac, and Linux without requiring any native helpers.
 * On non-Windows systems, the algorithm requires access to the `ps` shell command.  On Linux,
 * it requires access the `/proc/${pidString}/stat` filesystem.
 * @public
 */
class LockFile {
    constructor(fileWriter, filePath, dirtyWhenAcquired) {
        this._fileWriter = fileWriter;
        this._filePath = filePath;
        this._dirtyWhenAcquired = dirtyWhenAcquired;
    }
    /**
     * Returns the path of the lockfile that will be created when a lock is successfully acquired.
     * @param resourceFolder - The folder where the lock file will be created
     * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
     *   the filename of the temporary file created to manage the lock.
     * @param pid - The PID for the current Node.js process (`process.pid`), which is used by the locking algorithm.
     */
    static getLockFilePath(resourceFolder, resourceName, pid = process.pid) {
        if (!resourceName.match(/^[a-zA-Z0-9][a-zA-Z0-9-.]+[a-zA-Z0-9]$/)) {
            throw new Error(`The resource name "${resourceName}" is invalid.` +
                ` It must be an alphanumberic string with only "-" or "." It must start with an alphanumeric character.`);
        }
        if (process.platform === 'win32') {
            return path.join(path.resolve(resourceFolder), `${resourceName}.lock`);
        }
        else if (process.platform === 'linux' || process.platform === 'darwin') {
            return path.join(path.resolve(resourceFolder), `${resourceName}#${pid}.lock`);
        }
        throw new Error(`File locking not implemented for platform: "${process.platform}"`);
    }
    /**
     * Attempts to create a lockfile with the given filePath.
     * @param resourceFolder - The folder where the lock file will be created
     * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
     *   the filename of the temporary file created to manage the lock.
     * @returns If successful, returns a `LockFile` instance.  If unable to get a lock, returns `undefined`.
     */
    static tryAcquire(resourceFolder, resourceName) {
        FileSystem_1.FileSystem.ensureFolder(resourceFolder);
        if (process.platform === 'win32') {
            return LockFile._tryAcquireWindows(resourceFolder, resourceName);
        }
        else if (process.platform === 'linux' || process.platform === 'darwin') {
            return LockFile._tryAcquireMacOrLinux(resourceFolder, resourceName);
        }
        throw new Error(`File locking not implemented for platform: "${process.platform}"`);
    }
    /**
     * Attempts to create the lockfile.  Will continue to loop at every 100ms until the lock becomes available
     * or the maxWaitMs is surpassed.
     *
     * @remarks
     * This function is subject to starvation, whereby it does not ensure that the process that has been
     * waiting the longest to acquire the lock will get it first. This means that a process could theoretically
     * wait for the lock forever, while other processes skipped it in line and acquired the lock first.
     *
     * @param resourceFolder - The folder where the lock file will be created
     * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
     *   the filename of the temporary file created to manage the lock.
     * @param maxWaitMs - The maximum number of milliseconds to wait for the lock before reporting an error
     */
    static acquire(resourceFolder, resourceName, maxWaitMs) {
        const interval = 100;
        const startTime = Date.now();
        const retryLoop = async () => {
            const lock = LockFile.tryAcquire(resourceFolder, resourceName);
            if (lock) {
                return lock;
            }
            if (maxWaitMs && Date.now() > startTime + maxWaitMs) {
                throw new Error(`Exceeded maximum wait time to acquire lock for resource "${resourceName}"`);
            }
            await Async_1.Async.sleep(interval);
            return retryLoop();
        };
        return retryLoop();
    }
    /**
     * Attempts to acquire the lock on a Linux or OSX machine
     */
    static _tryAcquireMacOrLinux(resourceFolder, resourceName) {
        let dirtyWhenAcquired = false;
        // get the current process' pid
        const pid = process.pid;
        const startTime = LockFile._getStartTime(pid);
        if (!startTime) {
            throw new Error(`Unable to calculate start time for current process.`);
        }
        const pidLockFilePath = LockFile.getLockFilePath(resourceFolder, resourceName);
        let lockFileHandle;
        let lockFile;
        try {
            // open in write mode since if this file exists, it cannot be from the current process
            // TODO: This will malfunction if the same process tries to acquire two locks on the same file.
            // We should ideally maintain a dictionary of normalized acquired filenames
            lockFileHandle = FileWriter_1.FileWriter.open(pidLockFilePath);
            lockFileHandle.write(startTime);
            const currentBirthTimeMs = FileSystem_1.FileSystem.getStatistics(pidLockFilePath).birthtime.getTime();
            let smallestBirthTimeMs = currentBirthTimeMs;
            let smallestBirthTimePid = pid.toString();
            // now, scan the directory for all lockfiles
            const files = FileSystem_1.FileSystem.readFolder(resourceFolder);
            // look for anything ending with # then numbers and ".lock"
            const lockFileRegExp = /^(.+)#([0-9]+)\.lock$/;
            let match;
            let otherPid;
            for (const fileInFolder of files) {
                if ((match = fileInFolder.match(lockFileRegExp)) &&
                    match[1] === resourceName &&
                    (otherPid = match[2]) !== pid.toString()) {
                    // we found at least one lockfile hanging around that isn't ours
                    const fileInFolderPath = path.join(resourceFolder, fileInFolder);
                    dirtyWhenAcquired = true;
                    // console.log(`FOUND OTHER LOCKFILE: ${otherPid}`);
                    const otherPidCurrentStartTime = LockFile._getStartTime(parseInt(otherPid, 10));
                    let otherPidOldStartTime;
                    let otherBirthtimeMs;
                    try {
                        otherPidOldStartTime = FileSystem_1.FileSystem.readFile(fileInFolderPath);
                        // check the timestamp of the file
                        otherBirthtimeMs = FileSystem_1.FileSystem.getStatistics(fileInFolderPath).birthtime.getTime();
                    }
                    catch (err) {
                        // this means the file is probably deleted already
                    }
                    // if the otherPidOldStartTime is invalid, then we should look at the timestamp,
                    // if this file was created after us, ignore it
                    // if it was created within 1 second before us, then it could be good, so we
                    //  will conservatively fail
                    // otherwise it is an old lock file and will be deleted
                    if (otherPidOldStartTime === '' && otherBirthtimeMs !== undefined) {
                        if (otherBirthtimeMs > currentBirthTimeMs) {
                            // ignore this file, he will be unable to get the lock since this process
                            // will hold it
                            // console.log(`Ignoring lock for pid ${otherPid} because its lockfile is newer than ours.`);
                            continue;
                        }
                        else if (otherBirthtimeMs - currentBirthTimeMs < 0 && // it was created before us AND
                            otherBirthtimeMs - currentBirthTimeMs > -1000) {
                            // it was created less than a second before
                            // conservatively be unable to keep the lock
                            return undefined;
                        }
                    }
                    // console.log(`Other pid ${otherPid} lockfile has start time: "${otherPidOldStartTime}"`);
                    // console.log(`Other pid ${otherPid} actually has start time: "${otherPidCurrentStartTime}"`);
                    // this means the process is no longer executing, delete the file
                    if (!otherPidCurrentStartTime || otherPidOldStartTime !== otherPidCurrentStartTime) {
                        // console.log(`Other pid ${otherPid} is no longer executing!`);
                        FileSystem_1.FileSystem.deleteFile(fileInFolderPath);
                        continue;
                    }
                    // console.log(`Pid ${otherPid} lockfile has birth time: ${otherBirthtimeMs}`);
                    // console.log(`Pid ${pid} lockfile has birth time: ${currentBirthTimeMs}`);
                    // this is a lockfile pointing at something valid
                    if (otherBirthtimeMs !== undefined && otherBirthtimeMs < smallestBirthTimeMs) {
                        smallestBirthTimeMs = otherBirthtimeMs;
                        smallestBirthTimePid = otherPid;
                    }
                }
            }
            if (smallestBirthTimePid !== pid.toString()) {
                // we do not have the lock
                return undefined;
            }
            // we have the lock!
            lockFile = new LockFile(lockFileHandle, pidLockFilePath, dirtyWhenAcquired);
            lockFileHandle = undefined; // we have handed the descriptor off to the instance
        }
        finally {
            if (lockFileHandle) {
                // ensure our lock is closed
                lockFileHandle.close();
                FileSystem_1.FileSystem.deleteFile(pidLockFilePath);
            }
        }
        return lockFile;
    }
    /**
     * Attempts to acquire the lock using Windows
     * This algorithm is much simpler since we can rely on the operating system
     */
    static _tryAcquireWindows(resourceFolder, resourceName) {
        const lockFilePath = LockFile.getLockFilePath(resourceFolder, resourceName);
        let dirtyWhenAcquired = false;
        let fileHandle;
        let lockFile;
        try {
            if (FileSystem_1.FileSystem.exists(lockFilePath)) {
                dirtyWhenAcquired = true;
                // If the lockfile is held by an process with an exclusive lock, then removing it will
                // silently fail. OpenSync() below will then fail and we will be unable to create a lock.
                // Otherwise, the lockfile is sitting on disk, but nothing is holding it, implying that
                // the last process to hold it died.
                FileSystem_1.FileSystem.deleteFile(lockFilePath);
            }
            try {
                // Attempt to open an exclusive lockfile
                fileHandle = FileWriter_1.FileWriter.open(lockFilePath, { exclusive: true });
            }
            catch (error) {
                // we tried to delete the lock, but something else is holding it,
                // (probably an active process), therefore we are unable to create a lock
                return undefined;
            }
            // Ensure we can hand off the file descriptor to the lockfile
            lockFile = new LockFile(fileHandle, lockFilePath, dirtyWhenAcquired);
            fileHandle = undefined;
        }
        finally {
            if (fileHandle) {
                fileHandle.close();
            }
        }
        return lockFile;
    }
    /**
     * Unlocks a file and removes it from disk.
     * This can only be called once.
     */
    release() {
        if (this.isReleased) {
            throw new Error(`The lock for file "${path.basename(this._filePath)}" has already been released.`);
        }
        this._fileWriter.close();
        FileSystem_1.FileSystem.deleteFile(this._filePath);
        this._fileWriter = undefined;
    }
    /**
     * Returns the initial state of the lock.
     * This can be used to detect if the previous process was terminated before releasing the resource.
     */
    get dirtyWhenAcquired() {
        return this._dirtyWhenAcquired;
    }
    /**
     * Returns the absolute path to the lockfile
     */
    get filePath() {
        return this._filePath;
    }
    /**
     * Returns true if this lock is currently being held.
     */
    get isReleased() {
        return this._fileWriter === undefined;
    }
}
exports.LockFile = LockFile;
LockFile._getStartTime = getProcessStartTime;
//# sourceMappingURL=LockFile.js.map

/***/ }),

/***/ 98810:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapExtensions = void 0;
/**
 * Helper functions for working with the `Map<K, V>` data type.
 *
 * @public
 */
class MapExtensions {
    /**
     * Adds all the (key, value) pairs from the source map into the target map.
     * @remarks
     * This function modifies targetMap.  Any existing keys will be overwritten.
     * @param targetMap - The map that entries will be added to
     * @param sourceMap - The map containing the entries to be added
     */
    static mergeFromMap(targetMap, sourceMap) {
        for (const pair of sourceMap.entries()) {
            targetMap.set(pair[0], pair[1]);
        }
    }
    /**
     * Converts a string-keyed map to an object.
     * @remarks
     * This function has the same effect as Object.fromEntries(map.entries())
     * in supported versions of Node (\>= 12.0.0).
     * @param map - The map that the object properties will be sourced from
     */
    static toObject(map) {
        const object = {};
        for (const [key, value] of map.entries()) {
            object[key] = value;
        }
        return object;
    }
}
exports.MapExtensions = MapExtensions;
//# sourceMappingURL=MapExtensions.js.map

/***/ }),

/***/ 7379:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageJsonLookup = void 0;
const path = __importStar(__webpack_require__(85622));
const JsonFile_1 = __webpack_require__(46484);
const FileSystem_1 = __webpack_require__(19334);
/**
 * This class provides methods for finding the nearest "package.json" for a folder
 * and retrieving the name of the package.  The results are cached.
 *
 * @public
 */
class PackageJsonLookup {
    constructor(parameters) {
        this._loadExtraFields = false;
        if (parameters) {
            if (parameters.loadExtraFields) {
                this._loadExtraFields = parameters.loadExtraFields;
            }
        }
        this.clearCache();
    }
    /**
     * A singleton instance of `PackageJsonLookup`, which is useful for short-lived processes
     * that can reasonably assume that the file system will not be modified after the cache
     * is populated.
     *
     * @remarks
     * For long-running processes that need to clear the cache at appropriate times,
     * it is recommended to create your own instance of `PackageJsonLookup` instead
     * of relying on this instance.
     */
    static get instance() {
        if (!PackageJsonLookup._instance) {
            PackageJsonLookup._instance = new PackageJsonLookup({ loadExtraFields: true });
        }
        return PackageJsonLookup._instance;
    }
    /**
     * A helper for loading the caller's own package.json file.
     *
     * @remarks
     *
     * This function provides a concise and efficient way for an NPM package to report metadata about itself.
     * For example, a tool might want to report its version.
     *
     * The `loadOwnPackageJson()` probes upwards from the caller's folder, expecting to find a package.json file,
     * which is assumed to be the caller's package.  The result is cached, under the assumption that a tool's
     * own package.json (and intermediary folders) will never change during the lifetime of the process.
     *
     * @example
     * ```ts
     * // Report the version of our NPM package
     * const myPackageVersion: string = PackageJsonLookup.loadOwnPackageJson(__dirname).version;
     * console.log(`Cool Tool - Version ${myPackageVersion}`);
     * ```
     *
     * @param dirnameOfCaller - The NodeJS `__dirname` macro for the caller.
     * @returns This function always returns a valid `IPackageJson` object.  If any problems are encountered during
     * loading, an exception will be thrown instead.
     */
    static loadOwnPackageJson(dirnameOfCaller) {
        const packageJson = PackageJsonLookup.instance.tryLoadPackageJsonFor(dirnameOfCaller);
        if (packageJson === undefined) {
            throw new Error(`PackageJsonLookup.loadOwnPackageJson() failed to find the caller's package.json.` +
                `  The __dirname was: ${dirnameOfCaller}`);
        }
        if (packageJson.version !== undefined) {
            return packageJson;
        }
        const errorPath = PackageJsonLookup.instance.tryGetPackageJsonFilePathFor(dirnameOfCaller) || 'package.json';
        throw new Error(`PackageJsonLookup.loadOwnPackageJson() failed because the "version" field is missing in` +
            ` ${errorPath}`);
    }
    /**
     * Clears the internal file cache.
     * @remarks
     * Call this method if changes have been made to the package.json files on disk.
     */
    clearCache() {
        this._packageFolderCache = new Map();
        this._packageJsonCache = new Map();
    }
    /**
     * Returns the absolute path of a folder containing a package.json file, by looking
     * upwards from the specified fileOrFolderPath.  If no package.json can be found,
     * undefined is returned.
     *
     * @remarks
     * The fileOrFolderPath is not required to actually exist on disk.
     * The fileOrFolderPath itself can be the return value, if it is a folder containing
     * a package.json file.
     * Both positive and negative lookup results are cached.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an absolute path to a folder containing a package.json file
     */
    tryGetPackageFolderFor(fileOrFolderPath) {
        // Convert it to an absolute path
        const resolvedFileOrFolderPath = path.resolve(fileOrFolderPath);
        // Optimistically hope that the starting string is already in the cache,
        // in which case we can avoid disk access entirely.
        //
        // (Two lookups are required, because get() cannot distinguish the undefined value
        // versus a missing key.)
        if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {
            return this._packageFolderCache.get(resolvedFileOrFolderPath);
        }
        // Now call the recursive part of the algorithm
        return this._tryGetPackageFolderFor(resolvedFileOrFolderPath);
    }
    /**
     * If the specified file or folder is part of a package, this returns the absolute path
     * to the associated package.json file.
     *
     * @remarks
     * The package folder is determined using the same algorithm
     * as {@link PackageJsonLookup.tryGetPackageFolderFor}.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an absolute path to * package.json file
     */
    tryGetPackageJsonFilePathFor(fileOrFolderPath) {
        const packageJsonFolder = this.tryGetPackageFolderFor(fileOrFolderPath);
        if (!packageJsonFolder) {
            return undefined;
        }
        return path.join(packageJsonFolder, "package.json" /* PackageJson */);
    }
    /**
     * If the specified file or folder is part of a package, this loads and returns the
     * associated package.json file.
     *
     * @remarks
     * The package folder is determined using the same algorithm
     * as {@link PackageJsonLookup.tryGetPackageFolderFor}.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an IPackageJson object, or undefined if the fileOrFolderPath does not
     * belong to a package
     */
    tryLoadPackageJsonFor(fileOrFolderPath) {
        const packageJsonFilePath = this.tryGetPackageJsonFilePathFor(fileOrFolderPath);
        if (!packageJsonFilePath) {
            return undefined;
        }
        return this.loadPackageJson(packageJsonFilePath);
    }
    /**
     * This function is similar to {@link PackageJsonLookup.tryLoadPackageJsonFor}, except that it does not report
     * an error if the `version` field is missing from the package.json file.
     */
    tryLoadNodePackageJsonFor(fileOrFolderPath) {
        const packageJsonFilePath = this.tryGetPackageJsonFilePathFor(fileOrFolderPath);
        if (!packageJsonFilePath) {
            return undefined;
        }
        return this.loadNodePackageJson(packageJsonFilePath);
    }
    /**
     * Loads the specified package.json file, if it is not already present in the cache.
     *
     * @remarks
     * Unless {@link IPackageJsonLookupParameters.loadExtraFields} was specified,
     * the returned IPackageJson object will contain a subset of essential fields.
     * The returned object should be considered to be immutable; the caller must never
     * modify it.
     *
     * @param jsonFilename - a relative or absolute path to a package.json file
     */
    loadPackageJson(jsonFilename) {
        const packageJson = this.loadNodePackageJson(jsonFilename);
        if (!packageJson.version) {
            throw new Error(`Error reading "${jsonFilename}":\n  The required field "version" was not found`);
        }
        return packageJson;
    }
    /**
     * This function is similar to {@link PackageJsonLookup.loadPackageJson}, except that it does not report an error
     * if the `version` field is missing from the package.json file.
     */
    loadNodePackageJson(jsonFilename) {
        if (!FileSystem_1.FileSystem.exists(jsonFilename)) {
            throw new Error(`Input file not found: ${jsonFilename}`);
        }
        // Since this will be a cache key, follow any symlinks and get an absolute path
        // to minimize duplication.  (Note that duplication can still occur due to e.g. character case.)
        const normalizedFilePath = FileSystem_1.FileSystem.getRealPath(jsonFilename);
        let packageJson = this._packageJsonCache.get(normalizedFilePath);
        if (!packageJson) {
            const loadedPackageJson = JsonFile_1.JsonFile.load(normalizedFilePath);
            // Make sure this is really a package.json file.  CommonJS has fairly strict requirements,
            // but NPM only requires "name" and "version"
            if (!loadedPackageJson.name) {
                throw new Error(`Error reading "${jsonFilename}":\n  The required field "name" was not found`);
            }
            if (this._loadExtraFields) {
                packageJson = loadedPackageJson;
            }
            else {
                packageJson = {};
                // Unless "loadExtraFields" was requested, copy over the essential fields only
                packageJson.bin = loadedPackageJson.bin;
                packageJson.dependencies = loadedPackageJson.dependencies;
                packageJson.description = loadedPackageJson.description;
                packageJson.devDependencies = loadedPackageJson.devDependencies;
                packageJson.homepage = loadedPackageJson.homepage;
                packageJson.license = loadedPackageJson.license;
                packageJson.main = loadedPackageJson.main;
                packageJson.name = loadedPackageJson.name;
                packageJson.optionalDependencies = loadedPackageJson.optionalDependencies;
                packageJson.peerDependencies = loadedPackageJson.peerDependencies;
                packageJson.private = loadedPackageJson.private;
                packageJson.scripts = loadedPackageJson.scripts;
                packageJson.typings = loadedPackageJson.typings || loadedPackageJson.types;
                packageJson.tsdocMetadata = loadedPackageJson.tsdocMetadata;
                packageJson.version = loadedPackageJson.version;
            }
            Object.freeze(packageJson);
            this._packageJsonCache.set(normalizedFilePath, packageJson);
        }
        return packageJson;
    }
    // Recursive part of the algorithm from tryGetPackageFolderFor()
    _tryGetPackageFolderFor(resolvedFileOrFolderPath) {
        // Two lookups are required, because get() cannot distinguish the undefined value
        // versus a missing key.
        if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {
            return this._packageFolderCache.get(resolvedFileOrFolderPath);
        }
        // Is resolvedFileOrFolderPath itself a folder with a package.json file?  If so, return it.
        if (FileSystem_1.FileSystem.exists(path.join(resolvedFileOrFolderPath, "package.json" /* PackageJson */))) {
            this._packageFolderCache.set(resolvedFileOrFolderPath, resolvedFileOrFolderPath);
            return resolvedFileOrFolderPath;
        }
        // Otherwise go up one level
        const parentFolder = path.dirname(resolvedFileOrFolderPath);
        if (!parentFolder || parentFolder === resolvedFileOrFolderPath) {
            // We reached the root directory without finding a package.json file,
            // so cache the negative result
            this._packageFolderCache.set(resolvedFileOrFolderPath, undefined);
            return undefined; // no match
        }
        // Recurse upwards, caching every step along the way
        const parentResult = this._tryGetPackageFolderFor(parentFolder);
        // Cache the parent's answer as well
        this._packageFolderCache.set(resolvedFileOrFolderPath, parentResult);
        return parentResult;
    }
}
exports.PackageJsonLookup = PackageJsonLookup;
//# sourceMappingURL=PackageJsonLookup.js.map

/***/ }),

/***/ 60341:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageName = exports.PackageNameParser = void 0;
/**
 * A configurable parser for validating and manipulating NPM package names such as `my-package` or `@scope/my-package`.
 *
 * @remarks
 * If you do not need to customize the parser configuration, it is recommended to use {@link PackageName}
 * which exposes these operations as a simple static class.
 *
 * @public
 */
class PackageNameParser {
    constructor(options = {}) {
        this._options = Object.assign({}, options);
    }
    /**
     * This attempts to parse a package name that may include a scope component.
     * The packageName must not be an empty string.
     * @remarks
     * This function will not throw an exception.
     *
     * @returns an {@link IParsedPackageNameOrError} structure whose `error` property will be
     * nonempty if the string could not be parsed.
     */
    tryParse(packageName) {
        const result = {
            scope: '',
            unscopedName: '',
            error: ''
        };
        let input = packageName;
        if (input === null || input === undefined) {
            result.error = 'The package name must not be null or undefined';
            return result;
        }
        // Rule from npmjs.com:
        // "The name must be less than or equal to 214 characters. This includes the scope for scoped packages."
        if (packageName.length > 214) {
            // Don't attempt to parse a ridiculously long input
            result.error = 'The package name cannot be longer than 214 characters';
            return result;
        }
        if (input[0] === '@') {
            const indexOfScopeSlash = input.indexOf('/');
            if (indexOfScopeSlash <= 0) {
                result.scope = input;
                result.error = `Error parsing "${packageName}": The scope must be followed by a slash`;
                return result;
            }
            // Extract the scope substring
            result.scope = input.substr(0, indexOfScopeSlash);
            input = input.substr(indexOfScopeSlash + 1);
        }
        result.unscopedName = input;
        if (result.scope === '@') {
            result.error = `Error parsing "${packageName}": The scope name cannot be empty`;
            return result;
        }
        if (result.unscopedName === '') {
            result.error = 'The package name must not be empty';
            return result;
        }
        // Rule from npmjs.com:
        // "The name can't start with a dot or an underscore."
        if (result.unscopedName[0] === '.' || result.unscopedName[0] === '_') {
            result.error = `The package name "${packageName}" starts with an invalid character`;
            return result;
        }
        // Convert "@scope/unscoped-name" --> "scopeunscoped-name"
        const nameWithoutScopeSymbols = (result.scope ? result.scope.slice(1, -1) : '') + result.unscopedName;
        if (!this._options.allowUpperCase) {
            // "New packages must not have uppercase letters in the name."
            // This can't be enforced because "old" packages are still actively maintained.
            // Example: https://www.npmjs.com/package/Base64
            // However it's pretty reasonable to require the scope to be lower case
            if (result.scope !== result.scope.toLowerCase()) {
                result.error = `The package scope "${result.scope}" must not contain upper case characters`;
                return result;
            }
        }
        // "The name ends up being part of a URL, an argument on the command line, and a folder name.
        // Therefore, the name can't contain any non-URL-safe characters"
        const match = nameWithoutScopeSymbols.match(PackageNameParser._invalidNameCharactersRegExp);
        if (match) {
            result.error = `The package name "${packageName}" contains an invalid character: "${match[0]}"`;
            return result;
        }
        return result;
    }
    /**
     * Same as {@link PackageName.tryParse}, except this throws an exception if the input
     * cannot be parsed.
     * @remarks
     * The packageName must not be an empty string.
     */
    parse(packageName) {
        const result = this.tryParse(packageName);
        if (result.error) {
            throw new Error(result.error);
        }
        return result;
    }
    /**
     * {@inheritDoc IParsedPackageName.scope}
     */
    getScope(packageName) {
        return this.parse(packageName).scope;
    }
    /**
     * {@inheritDoc IParsedPackageName.unscopedName}
     */
    getUnscopedName(packageName) {
        return this.parse(packageName).unscopedName;
    }
    /**
     * Returns true if the specified package name is valid, or false otherwise.
     * @remarks
     * This function will not throw an exception.
     */
    isValidName(packageName) {
        const result = this.tryParse(packageName);
        return !result.error;
    }
    /**
     * Throws an exception if the specified name is not a valid package name.
     * The packageName must not be an empty string.
     */
    validate(packageName) {
        this.parse(packageName);
    }
    /**
     * Combines an optional package scope with an unscoped root name.
     * @param scope - Must be either an empty string, or a scope name such as "\@example"
     * @param unscopedName - Must be a nonempty package name that does not contain a scope
     * @returns A full package name such as "\@example/some-library".
     */
    combineParts(scope, unscopedName) {
        if (scope !== '') {
            if (scope[0] !== '@') {
                throw new Error('The scope must start with an "@" character');
            }
        }
        if (scope.indexOf('/') >= 0) {
            throw new Error('The scope must not contain a "/" character');
        }
        if (unscopedName[0] === '@') {
            throw new Error('The unscopedName cannot start with an "@" character');
        }
        if (unscopedName.indexOf('/') >= 0) {
            throw new Error('The unscopedName must not contain a "/" character');
        }
        let result;
        if (scope === '') {
            result = unscopedName;
        }
        else {
            result = scope + '/' + unscopedName;
        }
        // Make sure the result is a valid package name
        this.validate(result);
        return result;
    }
}
exports.PackageNameParser = PackageNameParser;
// encodeURIComponent() escapes all characters except:  A-Z a-z 0-9 - _ . ! ~ * ' ( )
// However, these are disallowed because they are shell characters:       ! ~ * ' ( )
PackageNameParser._invalidNameCharactersRegExp = /[^A-Za-z0-9\-_\.]/;
/**
 * Provides basic operations for validating and manipulating NPM package names such as `my-package`
 * or `@scope/my-package`.
 *
 * @remarks
 * This is the default implementation of {@link PackageNameParser}, exposed as a convenient static class.
 * If you need to configure the parsing rules, use `PackageNameParser` instead.
 *
 * @public
 */
class PackageName {
    /** {@inheritDoc PackageNameParser.tryParse} */
    static tryParse(packageName) {
        return PackageName._parser.tryParse(packageName);
    }
    /** {@inheritDoc PackageNameParser.parse} */
    static parse(packageName) {
        return this._parser.parse(packageName);
    }
    /** {@inheritDoc PackageNameParser.getScope} */
    static getScope(packageName) {
        return this._parser.getScope(packageName);
    }
    /** {@inheritDoc PackageNameParser.getUnscopedName} */
    static getUnscopedName(packageName) {
        return this._parser.getUnscopedName(packageName);
    }
    /** {@inheritDoc PackageNameParser.isValidName} */
    static isValidName(packageName) {
        return this._parser.isValidName(packageName);
    }
    /** {@inheritDoc PackageNameParser.validate} */
    static validate(packageName) {
        return this._parser.validate(packageName);
    }
    /** {@inheritDoc PackageNameParser.combineParts} */
    static combineParts(scope, unscopedName) {
        return this._parser.combineParts(scope, unscopedName);
    }
}
exports.PackageName = PackageName;
PackageName._parser = new PackageNameParser();
//# sourceMappingURL=PackageName.js.map

/***/ }),

/***/ 74803:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Path = void 0;
const path = __importStar(__webpack_require__(85622));
/**
 * Common operations for manipulating file and directory paths.
 * @remarks
 * This API is intended to eventually be a complete replacement for the NodeJS "path" API.
 * @public
 */
class Path {
    /**
     * Returns true if "childPath" is located inside the "parentFolderPath" folder
     * or one of its child folders.  Note that "parentFolderPath" is not considered to be
     * under itself.  The "childPath" can refer to any type of file system object.
     *
     * @remarks
     * The indicated file/folder objects are not required to actually exist on disk.
     * For example, "parentFolderPath" is interpreted as a folder name even if it refers to a file.
     * If the paths are relative, they will first be resolved using path.resolve().
     */
    static isUnder(childPath, parentFolderPath) {
        // If childPath is under parentPath, then relativePath will be something like
        // "../.." or "..\\..", which consists entirely of periods and slashes.
        // (Note that something like "....t" is actually a valid filename, but "...." is not.)
        const relativePath = path.relative(childPath, parentFolderPath);
        return Path._relativePathRegex.test(relativePath);
    }
    /**
     * Returns true if "childPath" is equal to "parentFolderPath", or if it is inside that folder
     * or one of its children.  The "childPath" can refer to any type of file system object.
     *
     * @remarks
     * The indicated file/folder objects are not required to actually exist on disk.
     * For example, "parentFolderPath" is interpreted as a folder name even if it refers to a file.
     * If the paths are relative, they will first be resolved using path.resolve().
     */
    static isUnderOrEqual(childPath, parentFolderPath) {
        const relativePath = path.relative(childPath, parentFolderPath);
        return relativePath === '' || Path._relativePathRegex.test(relativePath);
    }
    /**
     * Returns true if `path1` and `path2` refer to the same underlying path.
     *
     * @remarks
     *
     * The comparison is performed using `path.relative()`.
     */
    static isEqual(path1, path2) {
        return path.relative(path1, path2) === '';
    }
    /**
     * Formats a path to look nice for reporting purposes.
     * @remarks
     * If `pathToConvert` is under the `baseFolder`, then it will be converted to a relative with the `./` prefix.
     * Otherwise, it will be converted to an absolute path.
     *
     * Backslashes will be converted to slashes, unless the path starts with an OS-specific string like `C:\`.
     */
    static formatConcisely(options) {
        // Same logic as Path.isUnderOrEqual()
        const relativePath = path.relative(options.pathToConvert, options.baseFolder);
        const isUnderOrEqual = relativePath === '' || Path._relativePathRegex.test(relativePath);
        if (isUnderOrEqual) {
            // Note that isUnderOrEqual()'s relativePath is the reverse direction
            return './' + Path.convertToSlashes(path.relative(options.baseFolder, options.pathToConvert));
        }
        const absolutePath = path.resolve(options.pathToConvert);
        return absolutePath;
    }
    /**
     * Replaces Windows-style backslashes with POSIX-style slashes.
     *
     * @remarks
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    static convertToSlashes(inputPath) {
        return inputPath.replace(/\\/g, '/');
    }
    /**
     * Replaces POSIX-style slashes with Windows-style backslashes
     *
     * @remarks
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    static convertToBackslashes(inputPath) {
        return inputPath.replace(/\//g, '\\');
    }
    /**
     * Returns true if the specified path is a relative path and does not use `..` to walk upwards.
     *
     * @example
     * ```ts
     * // These evaluate to true
     * isDownwardRelative('folder');
     * isDownwardRelative('file');
     * isDownwardRelative('folder/');
     * isDownwardRelative('./folder/');
     * isDownwardRelative('./folder/file');
     *
     * // These evaluate to false
     * isDownwardRelative('../folder');
     * isDownwardRelative('folder/../file');
     * isDownwardRelative('/folder/file');
     * ```
     */
    static isDownwardRelative(inputPath) {
        if (path.isAbsolute(inputPath)) {
            return false;
        }
        // Does it contain ".."
        if (Path._upwardPathSegmentRegex.test(inputPath)) {
            return false;
        }
        return true;
    }
}
exports.Path = Path;
// Matches a relative path consisting entirely of periods and slashes
// Example: ".", "..", "../..", etc
Path._relativePathRegex = /^[.\/\\]+$/;
// Matches a relative path segment that traverses upwards
// Example: "a/../b"
Path._upwardPathSegmentRegex = /([\/\\]|^)\.\.([\/\\]|$)/;
//# sourceMappingURL=Path.js.map

/***/ }),

/***/ 36871:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtectableMap = void 0;
const ProtectableMapView_1 = __webpack_require__(63941);
/**
 * The ProtectableMap provides an easy way for an API to expose a `Map<K, V>` property
 * while intercepting and validating any write operations that are performed by
 * consumers of the API.
 *
 * @remarks
 * The ProtectableMap itself is intended to be a private object that only its owner
 * can access directly.  Any operations performed directly on the ProtectableMap will
 * bypass the hooks and any validation they perform.  The public property that is exposed
 * to API consumers should return {@link ProtectableMap.protectedView} instead.
 *
 * For example, suppose you want to share your `Map<string, number>` data structure,
 * but you want to enforce that the key must always be an upper case string:
 * You could use the onSet() hook to validate the keys and throw an exception
 * if the key is not uppercase.
 *
 * @public
 */
class ProtectableMap {
    constructor(parameters) {
        this._protectedView = new ProtectableMapView_1.ProtectableMapView(this, parameters);
    }
    /**
     * The owner of the protectable map should return this object via its public API.
     */
    get protectedView() {
        return this._protectedView;
    }
    // ---------------------------------------------------------------------------
    // lib.es2015.collections contract - write operations
    /**
     * Removes all entries from the map.
     * This operation does NOT invoke the ProtectableMap onClear() hook.
     */
    clear() {
        this._protectedView._clearUnprotected();
    }
    /**
     * Removes the specified key from the map.
     * This operation does NOT invoke the ProtectableMap onDelete() hook.
     */
    delete(key) {
        return this._protectedView._deleteUnprotected(key);
    }
    /**
     * Sets a value for the specified key.
     * This operation does NOT invoke the ProtectableMap onSet() hook.
     */
    set(key, value) {
        this._protectedView._setUnprotected(key, value);
        return this;
    }
    // ---------------------------------------------------------------------------
    // lib.es2015.collections contract - read operations
    /**
     * Performs an operation for each (key, value) entries in the map.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    forEach(callbackfn, thisArg) {
        this._protectedView.forEach(callbackfn);
    }
    /**
     * Retrieves the value for the specified key.
     * @returns undefined if the value is undefined OR if the key is missing;
     * otherwise returns the value associated with the key.
     */
    get(key) {
        return this._protectedView.get(key);
    }
    /**
     * Returns true if the specified key belongs to the map.
     */
    has(key) {
        return this._protectedView.has(key);
    }
    /**
     * Returns the number of (key, value) entries in the map.
     */
    get size() {
        return this._protectedView.size;
    }
}
exports.ProtectableMap = ProtectableMap;
//# sourceMappingURL=ProtectableMap.js.map

/***/ }),

/***/ 63941:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtectableMapView = void 0;
/**
 * The internal wrapper used by ProtectableMap.  It extends the real `Map<K, V>` base class,
 * but hooks the destructive operations (clear/delete/set) to give the owner a chance
 * to block them.
 *
 * NOTE: This is not a public API.
 */
class ProtectableMapView extends Map {
    constructor(owner, parameters) {
        super();
        this._owner = owner;
        this._parameters = parameters;
    }
    clear() {
        // override
        if (this._parameters.onClear) {
            this._parameters.onClear(this._owner);
        }
        super.clear();
    }
    delete(key) {
        // override
        if (this._parameters.onDelete) {
            this._parameters.onDelete(this._owner, key);
        }
        return super.delete(key);
    }
    set(key, value) {
        // override
        let modifiedValue = value;
        if (this._parameters.onSet) {
            modifiedValue = this._parameters.onSet(this._owner, key, modifiedValue);
        }
        super.set(key, modifiedValue);
        return this;
    }
    // INTERNAL USAGE ONLY
    _clearUnprotected() {
        super.clear();
    }
    // INTERNAL USAGE ONLY
    _deleteUnprotected(key) {
        return super.delete(key);
    }
    // INTERNAL USAGE ONLY
    _setUnprotected(key, value) {
        super.set(key, value);
    }
}
exports.ProtectableMapView = ProtectableMapView;
//# sourceMappingURL=ProtectableMapView.js.map

/***/ }),

/***/ 58749:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sort = void 0;
const LegacyAdapters_1 = __webpack_require__(69291);
/**
 * Operations for sorting collections.
 *
 * @remarks
 * NOTE: Prior to Node 11.x, the `Array.sort()` algorithm is not guaranteed to be stable.  For maximum
 * compatibility, consider using {@link LegacyAdapters.sortStable} instead of `Array.sort()`.
 *
 * @public
 */
class Sort {
    /**
     * Compares `x` and `y` using the JavaScript `>` and `<` operators.  This function is suitable for usage as
     * the callback for `array.sort()`.
     *
     * @remarks
     *
     * The JavaScript ordering is generalized so that `undefined` \< `null` \< all other values.
     *
     * @returns -1 if `x` is smaller than `y`, 1 if `x` is greater than `y`, or 0 if the values are equal.
     *
     * @example
     *
     * ```ts
     * let array: number[] = [3, 6, 2];
     * array.sort(Sort.compareByValue);  // [2, 3, 6]
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static compareByValue(x, y) {
        if (x === y) {
            return 0;
        }
        // Undefined is smaller than anything else
        if (x === undefined) {
            return -1;
        }
        if (y === undefined) {
            return 1;
        }
        // Null is smaller than anything except undefined
        if (x === null) {
            return -1;
        }
        if (y === null) {
            return 1;
        }
        // These comparisons always return false if either of the arguments is "undefined".
        // These comparisons return nonsense for "null" (true for "null > -1", but false for "null < 0" and "null > 0")
        if (x < y) {
            return -1;
        }
        if (x > y) {
            return 1;
        }
        return 0;
    }
    /**
     * Sorts the array according to a key which is obtained from the array elements.
     * The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let array: string[] = [ 'aaa', 'bb', 'c' ];
     * Sort.sortBy(array, x => x.length);  // [ 'c', 'bb', 'aaa' ]
     * ```
     */
    static sortBy(array, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    keySelector, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    comparer = Sort.compareByValue) {
        LegacyAdapters_1.LegacyAdapters.sortStable(array, (x, y) => comparer(keySelector(x), keySelector(y)));
    }
    /**
     * Returns true if the array is already sorted.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static isSorted(array, comparer = Sort.compareByValue) {
        let previous = undefined;
        for (const element of array) {
            if (comparer(previous, element) > 0) {
                return false;
            }
            previous = element;
        }
        return true;
    }
    /**
     * Returns true if the array is already sorted by the specified key.
     *
     * @example
     *
     * ```ts
     * let array: string[] = [ 'a', 'bb', 'ccc' ];
     * Sort.isSortedBy(array, x => x.length); // true
     * ```
     */
    static isSortedBy(array, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    keySelector, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    comparer = Sort.compareByValue) {
        let previousKey = undefined;
        for (const element of array) {
            const key = keySelector(element);
            if (comparer(previousKey, key) > 0) {
                return false;
            }
            previousKey = key;
        }
        return true;
    }
    /**
     * Sorts the entries in a Map object according to the map keys.
     * The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let map: Map<string, number> = new Map<string, number>();
     * map.set('zebra', 1);
     * map.set('goose', 2);
     * map.set('aardvark', 3);
     * Sort.sortMapKeys(map);
     * console.log(JSON.stringify(Array.from(map.keys()))); // ["aardvark","goose","zebra"]
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static sortMapKeys(map, keyComparer = Sort.compareByValue) {
        const pairs = Array.from(map.entries());
        // Sorting a map is expensive, so first check whether it's already sorted.
        if (Sort.isSortedBy(pairs, (x) => x[0], keyComparer)) {
            return;
        }
        Sort.sortBy(pairs, (x) => x[0], keyComparer);
        map.clear();
        for (const pair of pairs) {
            map.set(pair[0], pair[1]);
        }
    }
    /**
     * Sorts the entries in a Set object according to the specified keys.
     * The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let set: Set<string> = new Set<string>();
     * set.add('aaa');
     * set.add('bb');
     * set.add('c');
     * Sort.sortSetBy(set, x => x.length);
     * console.log(Array.from(set)); // ['c', 'bb', 'aaa']
     * ```
     */
    static sortSetBy(set, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    keySelector, keyComparer = Sort.compareByValue) {
        const array = Array.from(set);
        // Sorting a set is expensive, so first check whether it's already sorted.
        if (Sort.isSortedBy(array, keySelector, keyComparer)) {
            return;
        }
        LegacyAdapters_1.LegacyAdapters.sortStable(array, (x, y) => keyComparer(keySelector(x), keySelector(y)));
        set.clear();
        for (const item of array) {
            set.add(item);
        }
    }
    /**
     * Sorts the entries in a Set object.  The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let set: Set<string> = new Set<string>();
     * set.add('zebra');
     * set.add('goose');
     * set.add('aardvark');
     * Sort.sortSet(set);
     * console.log(Array.from(set)); // ['aardvark', 'goose', 'zebra']
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static sortSet(set, comparer = Sort.compareByValue) {
        const array = Array.from(set);
        // Sorting a set is expensive, so first check whether it's already sorted.
        if (Sort.isSorted(array, comparer)) {
            return;
        }
        LegacyAdapters_1.LegacyAdapters.sortStable(array, (x, y) => comparer(x, y));
        set.clear();
        for (const item of array) {
            set.add(item);
        }
    }
}
exports.Sort = Sort;
//# sourceMappingURL=Sort.js.map

/***/ }),

/***/ 73994:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringBuilder = void 0;
/**
 * This class allows a large text string to be constructed incrementally by appending small chunks.  The final
 * string can be obtained by calling StringBuilder.toString().
 *
 * @remarks
 * A naive approach might use the `+=` operator to append strings:  This would have the downside of copying
 * the entire string each time a chunk is appended, resulting in `O(n^2)` bytes of memory being allocated
 * (and later freed by the garbage  collector), and many of the allocations could be very large objects.
 * StringBuilder avoids this overhead by accumulating the chunks in an array, and efficiently joining them
 * when `getText()` is finally called.
 *
 * @public
 */
class StringBuilder {
    constructor() {
        this._chunks = [];
    }
    /** {@inheritDoc IStringBuilder.append} */
    append(text) {
        this._chunks.push(text);
    }
    /** {@inheritDoc IStringBuilder.toString} */
    toString() {
        if (this._chunks.length === 0) {
            return '';
        }
        if (this._chunks.length > 1) {
            const joined = this._chunks.join('');
            this._chunks.length = 1;
            this._chunks[0] = joined;
        }
        return this._chunks[0];
    }
}
exports.StringBuilder = StringBuilder;
//# sourceMappingURL=StringBuilder.js.map

/***/ }),

/***/ 82940:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnsiEscape = void 0;
const Colors_1 = __webpack_require__(81382);
/**
 * Operations for working with text strings that contain
 * {@link https://en.wikipedia.org/wiki/ANSI_escape_code | ANSI escape codes}.
 * The most commonly used escape codes set the foreground/background color for console output.
 * @public
 */
class AnsiEscape {
    /**
     * Returns the input text with all ANSI escape codes removed.  For example, this is useful when saving
     * colorized console output to a log file.
     */
    static removeCodes(text) {
        // eslint-disable-next-line no-control-regex
        return text.replace(AnsiEscape._csiRegExp, '');
    }
    /**
     * Replaces ANSI escape codes with human-readable tokens.  This is useful for unit tests
     * that compare text strings in test assertions or snapshot files.
     */
    static formatForTests(text, options) {
        if (!options) {
            options = {};
        }
        let result = text.replace(AnsiEscape._csiRegExp, (capture, csiCode) => {
            // If it is an SGR code, then try to show a friendly token
            const match = csiCode.match(AnsiEscape._sgrRegExp);
            if (match) {
                const sgrParameter = parseInt(match[1]);
                const sgrParameterName = AnsiEscape._tryGetSgrFriendlyName(sgrParameter);
                if (sgrParameterName) {
                    // Example: "[black-bg]"
                    return `[${sgrParameterName}]`;
                }
            }
            // Otherwise show the raw code, but without the "[" from the CSI prefix
            // Example: "[31m]"
            return `[${csiCode}]`;
        });
        if (options.encodeNewlines) {
            result = result
                .replace(AnsiEscape._backslashNRegExp, '[n]')
                .replace(AnsiEscape._backslashRRegExp, `[r]`);
        }
        return result;
    }
    // Returns a human-readable token representing an SGR parameter, or undefined for parameter that is not well-known.
    // The SGR parameter numbers are documented in this table:
    // https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_parameters
    static _tryGetSgrFriendlyName(sgiParameter) {
        switch (sgiParameter) {
            case Colors_1.ConsoleColorCodes.BlackForeground:
                return 'black';
            case Colors_1.ConsoleColorCodes.RedForeground:
                return 'red';
            case Colors_1.ConsoleColorCodes.GreenForeground:
                return 'green';
            case Colors_1.ConsoleColorCodes.YellowForeground:
                return 'yellow';
            case Colors_1.ConsoleColorCodes.BlueForeground:
                return 'blue';
            case Colors_1.ConsoleColorCodes.MagentaForeground:
                return 'magenta';
            case Colors_1.ConsoleColorCodes.CyanForeground:
                return 'cyan';
            case Colors_1.ConsoleColorCodes.WhiteForeground:
                return 'white';
            case Colors_1.ConsoleColorCodes.GrayForeground:
                return 'gray';
            case Colors_1.ConsoleColorCodes.DefaultForeground:
                return 'default';
            case Colors_1.ConsoleColorCodes.BlackBackground:
                return 'black-bg';
            case Colors_1.ConsoleColorCodes.RedBackground:
                return 'red-bg';
            case Colors_1.ConsoleColorCodes.GreenBackground:
                return 'green-bg';
            case Colors_1.ConsoleColorCodes.YellowBackground:
                return 'yellow-bg';
            case Colors_1.ConsoleColorCodes.BlueBackground:
                return 'blue-bg';
            case Colors_1.ConsoleColorCodes.MagentaBackground:
                return 'magenta-bg';
            case Colors_1.ConsoleColorCodes.CyanBackground:
                return 'cyan-bg';
            case Colors_1.ConsoleColorCodes.WhiteBackground:
                return 'white-bg';
            case Colors_1.ConsoleColorCodes.GrayBackground:
                return 'gray-bg';
            case Colors_1.ConsoleColorCodes.DefaultBackground:
                return 'default-bg';
            case Colors_1.ConsoleColorCodes.Bold:
                return 'bold';
            case Colors_1.ConsoleColorCodes.Dim:
                return 'dim';
            case Colors_1.ConsoleColorCodes.NormalColorOrIntensity:
                return 'normal';
            case Colors_1.ConsoleColorCodes.Underline:
                return 'underline';
            case Colors_1.ConsoleColorCodes.UnderlineOff:
                return 'underline-off';
            case Colors_1.ConsoleColorCodes.Blink:
                return 'blink';
            case Colors_1.ConsoleColorCodes.BlinkOff:
                return 'blink-off';
            case Colors_1.ConsoleColorCodes.InvertColor:
                return 'invert';
            case Colors_1.ConsoleColorCodes.InvertColorOff:
                return 'invert-off';
            case Colors_1.ConsoleColorCodes.Hidden:
                return 'hidden';
            case Colors_1.ConsoleColorCodes.HiddenOff:
                return 'hidden-off';
            default:
                return undefined;
        }
    }
}
exports.AnsiEscape = AnsiEscape;
// For now, we only care about the Control Sequence Introducer (CSI) commands which always start with "[".
// eslint-disable-next-line no-control-regex
AnsiEscape._csiRegExp = /\x1b\[([\x30-\x3f]*[\x20-\x2f]*[\x40-\x7e])/gu;
// Text coloring is performed using Select Graphic Rendition (SGR) codes, which come after the
// CSI introducer "ESC [".  The SGR sequence is a number followed by "m".
AnsiEscape._sgrRegExp = /([0-9]+)m/u;
AnsiEscape._backslashNRegExp = /\n/g;
AnsiEscape._backslashRRegExp = /\r/g;
//# sourceMappingURL=AnsiEscape.js.map

/***/ }),

/***/ 81382:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Colors = exports.ConsoleColorCodes = exports.TextAttribute = exports.ColorValue = exports.eolSequence = void 0;
exports.eolSequence = {
    isEol: true
};
/**
 * Colors used with {@link IColorableSequence}.
 * @beta
 */
var ColorValue;
(function (ColorValue) {
    ColorValue[ColorValue["Black"] = 0] = "Black";
    ColorValue[ColorValue["Red"] = 1] = "Red";
    ColorValue[ColorValue["Green"] = 2] = "Green";
    ColorValue[ColorValue["Yellow"] = 3] = "Yellow";
    ColorValue[ColorValue["Blue"] = 4] = "Blue";
    ColorValue[ColorValue["Magenta"] = 5] = "Magenta";
    ColorValue[ColorValue["Cyan"] = 6] = "Cyan";
    ColorValue[ColorValue["White"] = 7] = "White";
    ColorValue[ColorValue["Gray"] = 8] = "Gray";
})(ColorValue = exports.ColorValue || (exports.ColorValue = {}));
/**
 * Text styles used with {@link IColorableSequence}.
 * @beta
 */
var TextAttribute;
(function (TextAttribute) {
    TextAttribute[TextAttribute["Bold"] = 0] = "Bold";
    TextAttribute[TextAttribute["Dim"] = 1] = "Dim";
    TextAttribute[TextAttribute["Underline"] = 2] = "Underline";
    TextAttribute[TextAttribute["Blink"] = 3] = "Blink";
    TextAttribute[TextAttribute["InvertColor"] = 4] = "InvertColor";
    TextAttribute[TextAttribute["Hidden"] = 5] = "Hidden";
})(TextAttribute = exports.TextAttribute || (exports.TextAttribute = {}));
var ConsoleColorCodes;
(function (ConsoleColorCodes) {
    ConsoleColorCodes[ConsoleColorCodes["BlackForeground"] = 30] = "BlackForeground";
    ConsoleColorCodes[ConsoleColorCodes["RedForeground"] = 31] = "RedForeground";
    ConsoleColorCodes[ConsoleColorCodes["GreenForeground"] = 32] = "GreenForeground";
    ConsoleColorCodes[ConsoleColorCodes["YellowForeground"] = 33] = "YellowForeground";
    ConsoleColorCodes[ConsoleColorCodes["BlueForeground"] = 34] = "BlueForeground";
    ConsoleColorCodes[ConsoleColorCodes["MagentaForeground"] = 35] = "MagentaForeground";
    ConsoleColorCodes[ConsoleColorCodes["CyanForeground"] = 36] = "CyanForeground";
    ConsoleColorCodes[ConsoleColorCodes["WhiteForeground"] = 37] = "WhiteForeground";
    ConsoleColorCodes[ConsoleColorCodes["GrayForeground"] = 90] = "GrayForeground";
    ConsoleColorCodes[ConsoleColorCodes["DefaultForeground"] = 39] = "DefaultForeground";
    ConsoleColorCodes[ConsoleColorCodes["BlackBackground"] = 40] = "BlackBackground";
    ConsoleColorCodes[ConsoleColorCodes["RedBackground"] = 41] = "RedBackground";
    ConsoleColorCodes[ConsoleColorCodes["GreenBackground"] = 42] = "GreenBackground";
    ConsoleColorCodes[ConsoleColorCodes["YellowBackground"] = 43] = "YellowBackground";
    ConsoleColorCodes[ConsoleColorCodes["BlueBackground"] = 44] = "BlueBackground";
    ConsoleColorCodes[ConsoleColorCodes["MagentaBackground"] = 45] = "MagentaBackground";
    ConsoleColorCodes[ConsoleColorCodes["CyanBackground"] = 46] = "CyanBackground";
    ConsoleColorCodes[ConsoleColorCodes["WhiteBackground"] = 47] = "WhiteBackground";
    ConsoleColorCodes[ConsoleColorCodes["GrayBackground"] = 100] = "GrayBackground";
    ConsoleColorCodes[ConsoleColorCodes["DefaultBackground"] = 49] = "DefaultBackground";
    ConsoleColorCodes[ConsoleColorCodes["Bold"] = 1] = "Bold";
    // On Linux, the "BoldOff" code instead causes the text to be double-underlined:
    // https://en.wikipedia.org/wiki/Talk:ANSI_escape_code#SGR_21%E2%80%94%60Bold_off%60_not_widely_supported
    // Use "NormalColorOrIntensity" instead
    // BoldOff = 21,
    ConsoleColorCodes[ConsoleColorCodes["Dim"] = 2] = "Dim";
    ConsoleColorCodes[ConsoleColorCodes["NormalColorOrIntensity"] = 22] = "NormalColorOrIntensity";
    ConsoleColorCodes[ConsoleColorCodes["Underline"] = 4] = "Underline";
    ConsoleColorCodes[ConsoleColorCodes["UnderlineOff"] = 24] = "UnderlineOff";
    ConsoleColorCodes[ConsoleColorCodes["Blink"] = 5] = "Blink";
    ConsoleColorCodes[ConsoleColorCodes["BlinkOff"] = 25] = "BlinkOff";
    ConsoleColorCodes[ConsoleColorCodes["InvertColor"] = 7] = "InvertColor";
    ConsoleColorCodes[ConsoleColorCodes["InvertColorOff"] = 27] = "InvertColorOff";
    ConsoleColorCodes[ConsoleColorCodes["Hidden"] = 8] = "Hidden";
    ConsoleColorCodes[ConsoleColorCodes["HiddenOff"] = 28] = "HiddenOff";
})(ConsoleColorCodes = exports.ConsoleColorCodes || (exports.ConsoleColorCodes = {}));
/**
 * The static functions on this class are used to produce colored text
 * for use with the node-core-library terminal.
 *
 * @example
 * terminal.writeLine(Colors.green('Green Text!'), ' ', Colors.blue('Blue Text!'));
 *
 * @beta
 */
class Colors {
    static black(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Black });
    }
    static red(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Red });
    }
    static green(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Green });
    }
    static yellow(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Yellow });
    }
    static blue(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Blue });
    }
    static magenta(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Magenta });
    }
    static cyan(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Cyan });
    }
    static white(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.White });
    }
    static gray(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Gray });
    }
    static blackBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Black });
    }
    static redBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Red });
    }
    static greenBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Green });
    }
    static yellowBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Yellow });
    }
    static blueBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Blue });
    }
    static magentaBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Magenta });
    }
    static cyanBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Cyan });
    }
    static whiteBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.White });
    }
    static grayBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Gray });
    }
    static bold(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Bold);
    }
    static dim(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Dim);
    }
    static underline(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Underline);
    }
    static blink(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Blink);
    }
    static invertColor(text) {
        return Colors._applyTextAttribute(text, TextAttribute.InvertColor);
    }
    static hidden(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Hidden);
    }
    /**
     * If called with a string, returns the string wrapped in a {@link IColorableSequence}.
     * If called with a {@link IColorableSequence}, returns the {@link IColorableSequence}.
     *
     * @internal
     */
    static _normalizeStringOrColorableSequence(value) {
        if (typeof value === 'string') {
            return {
                text: value
            };
        }
        else {
            return value;
        }
    }
    static _applyTextAttribute(text, attribute) {
        const sequence = Colors._normalizeStringOrColorableSequence(text);
        if (!sequence.textAttributes) {
            sequence.textAttributes = [];
        }
        sequence.textAttributes.push(attribute);
        return sequence;
    }
}
exports.Colors = Colors;
//# sourceMappingURL=Colors.js.map

/***/ }),

/***/ 94946:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsoleTerminalProvider = void 0;
const os_1 = __webpack_require__(12087);
const safe_1 = __webpack_require__(41997);
const ITerminalProvider_1 = __webpack_require__(20449);
/**
 * Terminal provider that prints to STDOUT (for log- and verbose-level messages) and
 * STDERR (for warning- and error-level messsages).
 *
 * @beta
 */
class ConsoleTerminalProvider {
    constructor(options = {}) {
        /**
         * If true, verbose-level messages should be written to the console.
         */
        this.verboseEnabled = false;
        /**
         * If true, debug-level messages should be written to the console.
         */
        this.debugEnabled = false;
        this.verboseEnabled = !!options.verboseEnabled;
        this.debugEnabled = !!options.debugEnabled;
    }
    /**
     * {@inheritDoc ITerminalProvider.write}
     */
    write(data, severity) {
        switch (severity) {
            case ITerminalProvider_1.TerminalProviderSeverity.warning:
            case ITerminalProvider_1.TerminalProviderSeverity.error: {
                process.stderr.write(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.verbose: {
                if (this.verboseEnabled) {
                    process.stdout.write(data);
                }
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.debug: {
                if (this.debugEnabled) {
                    process.stdout.write(data);
                }
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.log:
            default: {
                process.stdout.write(data);
                break;
            }
        }
    }
    /**
     * {@inheritDoc ITerminalProvider.eolCharacter}
     */
    get eolCharacter() {
        return os_1.EOL;
    }
    /**
     * {@inheritDoc ITerminalProvider.supportsColor}
     */
    get supportsColor() {
        return safe_1.enabled;
    }
}
exports.ConsoleTerminalProvider = ConsoleTerminalProvider;
//# sourceMappingURL=ConsoleTerminalProvider.js.map

/***/ }),

/***/ 20449:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TerminalProviderSeverity = void 0;
/**
 * Similar to many popular logging packages, terminal providers support a range of message
 * severities. These severities have built-in formatting defaults in the Terminal object
 * (warnings are yellow, errors are red, etc.).
 *
 * Terminal providers may choose to suppress certain messages based on their severity,
 * or to route some messages to other providers or not based on severity.
 *
 *   Severity  | Purpose
 *   --------- | -------
 *   error     | Build errors and fatal issues
 *   warning   | Not necessarily fatal, but indicate a problem the user should fix
 *   log       | Informational messages
 *   verbose   | Additional information that may not always be necessary
 *   debug     | Highest detail level, best used for troubleshooting information
 *
 * @beta
 */
var TerminalProviderSeverity;
(function (TerminalProviderSeverity) {
    TerminalProviderSeverity[TerminalProviderSeverity["log"] = 0] = "log";
    TerminalProviderSeverity[TerminalProviderSeverity["warning"] = 1] = "warning";
    TerminalProviderSeverity[TerminalProviderSeverity["error"] = 2] = "error";
    TerminalProviderSeverity[TerminalProviderSeverity["verbose"] = 3] = "verbose";
    TerminalProviderSeverity[TerminalProviderSeverity["debug"] = 4] = "debug";
})(TerminalProviderSeverity = exports.TerminalProviderSeverity || (exports.TerminalProviderSeverity = {}));
//# sourceMappingURL=ITerminalProvider.js.map

/***/ }),

/***/ 41403:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringBufferTerminalProvider = void 0;
const ITerminalProvider_1 = __webpack_require__(20449);
const StringBuilder_1 = __webpack_require__(73994);
const Text_1 = __webpack_require__(86879);
const AnsiEscape_1 = __webpack_require__(82940);
/**
 * Terminal provider that stores written data in buffers separated by severity.
 * This terminal provider is designed to be used when code that prints to a terminal
 * is being unit tested.
 *
 * @beta
 */
class StringBufferTerminalProvider {
    constructor(supportsColor = false) {
        this._standardBuffer = new StringBuilder_1.StringBuilder();
        this._verboseBuffer = new StringBuilder_1.StringBuilder();
        this._debugBuffer = new StringBuilder_1.StringBuilder();
        this._warningBuffer = new StringBuilder_1.StringBuilder();
        this._errorBuffer = new StringBuilder_1.StringBuilder();
        this._supportsColor = supportsColor;
    }
    /**
     * {@inheritDoc ITerminalProvider.write}
     */
    write(data, severity) {
        switch (severity) {
            case ITerminalProvider_1.TerminalProviderSeverity.warning: {
                this._warningBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.error: {
                this._errorBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.verbose: {
                this._verboseBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.debug: {
                this._debugBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.log:
            default: {
                this._standardBuffer.append(data);
                break;
            }
        }
    }
    /**
     * {@inheritDoc ITerminalProvider.eolCharacter}
     */
    get eolCharacter() {
        return '[n]';
    }
    /**
     * {@inheritDoc ITerminalProvider.supportsColor}
     */
    get supportsColor() {
        return this._supportsColor;
    }
    /**
     * Get everything that has been written at log-level severity.
     */
    getOutput(options) {
        return this._normalizeOutput(this._standardBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at verbose-level severity.
     */
    getVerbose(options) {
        return this._normalizeOutput(this._verboseBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at debug-level severity.
     */
    getDebugOutput(options) {
        return this._normalizeOutput(this._debugBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at error-level severity.
     */
    getErrorOutput(options) {
        return this._normalizeOutput(this._errorBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at warning-level severity.
     */
    getWarningOutput(options) {
        return this._normalizeOutput(this._warningBuffer.toString(), options);
    }
    _normalizeOutput(s, options) {
        options = Object.assign({ normalizeSpecialCharacters: true }, (options || {}));
        s = Text_1.Text.convertToLf(s);
        if (options.normalizeSpecialCharacters) {
            return AnsiEscape_1.AnsiEscape.formatForTests(s, { encodeNewlines: true });
        }
        else {
            return s;
        }
    }
}
exports.StringBufferTerminalProvider = StringBufferTerminalProvider;
//# sourceMappingURL=StringBufferTerminalProvider.js.map

/***/ }),

/***/ 85673:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Terminal = void 0;
const ITerminalProvider_1 = __webpack_require__(20449);
const Colors_1 = __webpack_require__(81382);
/**
 * This class facilitates writing to a console.
 *
 * @beta
 */
class Terminal {
    constructor(provider) {
        this._providers = new Set();
        this._providers.add(provider);
    }
    /**
     * {@inheritdoc ITerminal.registerProvider}
     */
    registerProvider(provider) {
        this._providers.add(provider);
    }
    /**
     * {@inheritdoc ITerminal.unregisterProvider}
     */
    unregisterProvider(provider) {
        if (this._providers.has(provider)) {
            this._providers.delete(provider);
        }
    }
    /**
     * {@inheritdoc ITerminal.write}
     */
    write(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.log);
    }
    /**
     * {@inheritdoc ITerminal.writeLine}
     */
    writeLine(...messageParts) {
        this.write(...messageParts, Colors_1.eolSequence);
    }
    /**
     * {@inheritdoc ITerminal.writeWarning}
     */
    writeWarning(...messageParts) {
        this._writeSegmentsToProviders(messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Yellow }))), ITerminalProvider_1.TerminalProviderSeverity.warning);
    }
    /**
     * {@inheritdoc ITerminal.writeWarningLine}
     */
    writeWarningLine(...messageParts) {
        this._writeSegmentsToProviders([
            ...messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Yellow }))),
            Colors_1.eolSequence
        ], ITerminalProvider_1.TerminalProviderSeverity.warning);
    }
    /**
     * {@inheritdoc ITerminal.writeError}
     */
    writeError(...messageParts) {
        this._writeSegmentsToProviders(messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Red }))), ITerminalProvider_1.TerminalProviderSeverity.error);
    }
    /**
     * {@inheritdoc ITerminal.writeErrorLine}
     */
    writeErrorLine(...messageParts) {
        this._writeSegmentsToProviders([
            ...messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Red }))),
            Colors_1.eolSequence
        ], ITerminalProvider_1.TerminalProviderSeverity.error);
    }
    /**
     * {@inheritdoc ITerminal.writeVerbose}
     */
    writeVerbose(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.verbose);
    }
    /**
     * {@inheritdoc ITerminal.writeVerboseLine}
     */
    writeVerboseLine(...messageParts) {
        this.writeVerbose(...messageParts, Colors_1.eolSequence);
    }
    /**
     * {@inheritdoc ITerminal.writeDebug}
     */
    writeDebug(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.debug);
    }
    /**
     * {@inheritdoc ITerminal.writeDebugLine}
     */
    writeDebugLine(...messageParts) {
        this.writeDebug(...messageParts, Colors_1.eolSequence);
    }
    _writeSegmentsToProviders(segments, severity) {
        const withColorText = {};
        const withoutColorText = {};
        let withColorLines;
        let withoutColorLines;
        this._providers.forEach((provider) => {
            const eol = provider.eolCharacter;
            let textToWrite;
            if (provider.supportsColor) {
                if (!withColorLines) {
                    withColorLines = this._serializeFormattableTextSegments(segments, true);
                }
                if (!withColorText[eol]) {
                    withColorText[eol] = withColorLines.join(eol);
                }
                textToWrite = withColorText[eol];
            }
            else {
                if (!withoutColorLines) {
                    withoutColorLines = this._serializeFormattableTextSegments(segments, false);
                }
                if (!withoutColorText[eol]) {
                    withoutColorText[eol] = withoutColorLines.join(eol);
                }
                textToWrite = withoutColorText[eol];
            }
            provider.write(textToWrite, severity);
        });
    }
    _serializeFormattableTextSegments(segments, withColor) {
        const lines = [];
        let segmentsToJoin = [];
        let lastSegmentWasEol = false;
        for (let i = 0; i < segments.length; i++) {
            const segment = Colors_1.Colors._normalizeStringOrColorableSequence(segments[i]);
            lastSegmentWasEol = !!segment.isEol;
            if (lastSegmentWasEol) {
                lines.push(segmentsToJoin.join(''));
                segmentsToJoin = [];
            }
            else {
                if (withColor) {
                    const startColorCodes = [];
                    const endColorCodes = [];
                    switch (segment.foregroundColor) {
                        case Colors_1.ColorValue.Black: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlackForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Red: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.RedForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Green: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GreenForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Yellow: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.YellowForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Blue: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlueForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Magenta: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.MagentaForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Cyan: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.CyanForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.White: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.WhiteForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Gray: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GrayForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                    }
                    switch (segment.backgroundColor) {
                        case Colors_1.ColorValue.Black: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlackBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Red: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.RedBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Green: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GreenBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Yellow: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.YellowBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Blue: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlueBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Magenta: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.MagentaBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Cyan: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.CyanBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.White: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.WhiteBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Gray: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GrayBackground);
                            endColorCodes.push(49);
                            break;
                        }
                    }
                    if (segment.textAttributes) {
                        for (const textAttribute of segment.textAttributes) {
                            switch (textAttribute) {
                                case Colors_1.TextAttribute.Bold: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Bold);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.NormalColorOrIntensity);
                                    break;
                                }
                                case Colors_1.TextAttribute.Dim: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Dim);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.NormalColorOrIntensity);
                                    break;
                                }
                                case Colors_1.TextAttribute.Underline: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Underline);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.UnderlineOff);
                                    break;
                                }
                                case Colors_1.TextAttribute.Blink: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Blink);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.BlinkOff);
                                    break;
                                }
                                case Colors_1.TextAttribute.InvertColor: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.InvertColor);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.InvertColorOff);
                                    break;
                                }
                                case Colors_1.TextAttribute.Hidden: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Hidden);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.HiddenOff);
                                    break;
                                }
                            }
                        }
                    }
                    for (let j = 0; j < startColorCodes.length; j++) {
                        const code = startColorCodes[j];
                        segmentsToJoin.push(...['\u001b[', code.toString(), 'm']);
                    }
                    segmentsToJoin.push(segment.text);
                    for (let j = endColorCodes.length - 1; j >= 0; j--) {
                        const code = endColorCodes[j];
                        segmentsToJoin.push(...['\u001b[', code.toString(), 'm']);
                    }
                }
                else {
                    segmentsToJoin.push(segment.text);
                }
            }
        }
        if (segmentsToJoin.length > 0) {
            lines.push(segmentsToJoin.join(''));
        }
        if (lastSegmentWasEol) {
            lines.push('');
        }
        return lines;
    }
}
exports.Terminal = Terminal;
//# sourceMappingURL=Terminal.js.map

/***/ }),

/***/ 86879:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Text = void 0;
const os = __importStar(__webpack_require__(12087));
/**
 * Operations for working with strings that contain text.
 *
 * @remarks
 * The utilities provided by this class are intended to be simple, small, and very
 * broadly applicable.
 *
 * @public
 */
class Text {
    /**
     * Returns the same thing as targetString.replace(searchValue, replaceValue), except that
     * all matches are replaced, rather than just the first match.
     * @param input         - The string to be modified
     * @param searchValue   - The value to search for
     * @param replaceValue  - The replacement text
     */
    static replaceAll(input, searchValue, replaceValue) {
        return input.split(searchValue).join(replaceValue);
    }
    /**
     * Converts all newlines in the provided string to use Windows-style CRLF end of line characters.
     */
    static convertToCrLf(input) {
        return input.replace(Text._newLineRegEx, '\r\n');
    }
    /**
     * Converts all newlines in the provided string to use POSIX-style LF end of line characters.
     *
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    static convertToLf(input) {
        return input.replace(Text._newLineRegEx, '\n');
    }
    /**
     * Converts all newlines in the provided string to use the specified newline type.
     */
    static convertTo(input, newlineKind) {
        return input.replace(Text._newLineRegEx, Text.getNewline(newlineKind));
    }
    /**
     * Returns the newline character sequence for the specified `NewlineKind`.
     */
    static getNewline(newlineKind) {
        switch (newlineKind) {
            case "\r\n" /* CrLf */:
                return '\r\n';
            case "\n" /* Lf */:
                return '\n';
            case "os" /* OsDefault */:
                return os.EOL;
            default:
                throw new Error('Unsupported newline kind');
        }
    }
    /**
     * Append characters to the end of a string to ensure the result has a minimum length.
     * @remarks
     * If the string length already exceeds the minimum length, then the string is unchanged.
     * The string is not truncated.
     */
    static padEnd(s, minimumLength, paddingCharacter = ' ') {
        if (paddingCharacter.length !== 1) {
            throw new Error('The paddingCharacter parameter must be a single character.');
        }
        if (s.length < minimumLength) {
            const paddingArray = new Array(minimumLength - s.length);
            paddingArray.unshift(s);
            return paddingArray.join(paddingCharacter);
        }
        else {
            return s;
        }
    }
    /**
     * Append characters to the start of a string to ensure the result has a minimum length.
     * @remarks
     * If the string length already exceeds the minimum length, then the string is unchanged.
     * The string is not truncated.
     */
    static padStart(s, minimumLength, paddingCharacter = ' ') {
        if (paddingCharacter.length !== 1) {
            throw new Error('The paddingCharacter parameter must be a single character.');
        }
        if (s.length < minimumLength) {
            const paddingArray = new Array(minimumLength - s.length);
            paddingArray.push(s);
            return paddingArray.join(paddingCharacter);
        }
        else {
            return s;
        }
    }
    /**
     * If the string is longer than maximumLength characters, truncate it to that length
     * using "..." to indicate the truncation.
     *
     * @remarks
     * For example truncateWithEllipsis('1234578', 5) would produce '12...'.
     */
    static truncateWithEllipsis(s, maximumLength) {
        if (maximumLength < 0) {
            throw new Error('The maximumLength cannot be a negative number');
        }
        if (s.length <= maximumLength) {
            return s;
        }
        if (s.length <= 3) {
            return s.substring(0, maximumLength);
        }
        return s.substring(0, maximumLength - 3) + '...';
    }
    /**
     * Returns the input string with a trailing `\n` character appended, if not already present.
     */
    static ensureTrailingNewline(s, newlineKind = "\n" /* Lf */) {
        // Is there already a newline?
        if (Text._newLineAtEndRegEx.test(s)) {
            return s; // yes, no change
        }
        return s + newlineKind; // no, add it
    }
}
exports.Text = Text;
Text._newLineRegEx = /\r\n|\n\r|\r|\n/g;
Text._newLineAtEndRegEx = /(\r\n|\n\r|\r|\n)$/;
//# sourceMappingURL=Text.js.map

/***/ }),

/***/ 76778:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeUuid = void 0;
const InternalError_1 = __webpack_require__(74436);
const classPrototypeUuidSymbol = Symbol.for('TypeUuid.classPrototypeUuid');
/**
 * Provides a version-independent implementation of the JavaScript `instanceof` operator.
 *
 * @remarks
 * The JavaScript `instanceof` operator normally only identifies objects from a particular library instance.
 * For example, suppose the NPM package `example-lib` has two published versions 1.2.0 and 1.3.0, and
 * it exports a class called `A`.  Suppose some code consumes version `1.3.0` of the library, but it receives
 * an object that was constructed using version `1.2.0`.  In this situation `a instanceof A` will return `false`,
 * even though `a` is an instance of `A`.  The reason is that there are two prototypes for `A`; one for each
 * version.
 *
 * The `TypeUuid` facility provides a way to make `a instanceof A` return true for both prototypes of `A`,
 * by instead using a universally unique identifier (UUID) to detect object instances.
 *
 * You can use `Symbol.hasInstance` to enable the system `instanceof` operator to recognize type UUID equivalence:
 * ```ts
 * const uuidWidget: string = '9c340ef0-d29f-4e2e-a09f-42bacc59024b';
 * class Widget {
 *   public static [Symbol.hasInstance](instance: object): boolean {
 *     return TypeUuid.isInstanceOf(instance, uuidWidget);
 *   }
 * }
 * ```
 * // Example usage:
 * ```ts
 * import { Widget as Widget1 } from 'v1-of-library';
 * import { Widget as Widget2 } from 'v2-of-library';
 * const widget = new Widget2();
 * console.log(widget instanceof Widget1); // prints true
 * ```
 *
 * @public
 */
class TypeUuid {
    /**
     * Registers a JavaScript class as having a type identified by the specified UUID.
     * @privateRemarks
     * We cannot use a construct signature for `targetClass` because it may be an abstract class.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static registerClass(targetClass, typeUuid) {
        if (typeof targetClass !== 'function') {
            throw new Error('The targetClass parameter must be a JavaScript class');
        }
        if (!TypeUuid._uuidRegExp.test(typeUuid)) {
            throw new Error(`The type UUID must be specified as lowercase hexadecimal with dashes: "${typeUuid}"`);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const targetClassPrototype = targetClass.prototype;
        if (Object.hasOwnProperty.call(targetClassPrototype, classPrototypeUuidSymbol)) {
            const existingUuid = targetClassPrototype[classPrototypeUuidSymbol];
            throw new InternalError_1.InternalError(`Cannot register the target class ${targetClass.name || ''} typeUuid=${typeUuid}` +
                ` because it was already registered with typeUuid=${existingUuid}`);
        }
        targetClassPrototype[classPrototypeUuidSymbol] = typeUuid;
    }
    /**
     * Returns true if the `targetObject` is an instance of a JavaScript class that was previously
     * registered using the specified `typeUuid`.  Base classes are also considered.
     */
    static isInstanceOf(targetObject, typeUuid) {
        if (targetObject === undefined || targetObject === null) {
            return false;
        }
        let objectPrototype = Object.getPrototypeOf(targetObject);
        while (objectPrototype !== undefined && objectPrototype !== null) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const registeredUuid = objectPrototype[classPrototypeUuidSymbol];
            if (registeredUuid === typeUuid) {
                return true;
            }
            // Walk upwards an examine base class prototypes
            objectPrototype = Object.getPrototypeOf(objectPrototype);
        }
        return false;
    }
}
exports.TypeUuid = TypeUuid;
TypeUuid._uuidRegExp = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
//# sourceMappingURL=TypeUuid.js.map

/***/ }),

/***/ 67607:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeUuid = exports.StringBufferTerminalProvider = exports.ConsoleTerminalProvider = exports.TerminalProviderSeverity = exports.TextAttribute = exports.ColorValue = exports.Colors = exports.Terminal = exports.StringBuilder = exports.LegacyAdapters = exports.FileWriter = exports.FileSystem = exports.Sort = exports.Text = exports.Path = exports.PackageNameParser = exports.PackageName = exports.PackageJsonLookup = exports.ProtectableMap = exports.MapExtensions = exports.LockFile = exports.JsonSchema = exports.JsonFile = exports.InternalError = exports.Import = exports.Executable = exports.EnvironmentMap = exports.Enum = exports.Async = exports.AnsiEscape = exports.AlreadyReportedError = void 0;
/**
 * Core libraries that every NodeJS toolchain project should use.
 *
 * @packageDocumentation
 */
var AlreadyReportedError_1 = __webpack_require__(30390);
Object.defineProperty(exports, "AlreadyReportedError", ({ enumerable: true, get: function () { return AlreadyReportedError_1.AlreadyReportedError; } }));
var AnsiEscape_1 = __webpack_require__(82940);
Object.defineProperty(exports, "AnsiEscape", ({ enumerable: true, get: function () { return AnsiEscape_1.AnsiEscape; } }));
var Async_1 = __webpack_require__(18635);
Object.defineProperty(exports, "Async", ({ enumerable: true, get: function () { return Async_1.Async; } }));
var Enum_1 = __webpack_require__(86312);
Object.defineProperty(exports, "Enum", ({ enumerable: true, get: function () { return Enum_1.Enum; } }));
var EnvironmentMap_1 = __webpack_require__(17291);
Object.defineProperty(exports, "EnvironmentMap", ({ enumerable: true, get: function () { return EnvironmentMap_1.EnvironmentMap; } }));
var Executable_1 = __webpack_require__(26266);
Object.defineProperty(exports, "Executable", ({ enumerable: true, get: function () { return Executable_1.Executable; } }));
var Import_1 = __webpack_require__(7598);
Object.defineProperty(exports, "Import", ({ enumerable: true, get: function () { return Import_1.Import; } }));
var InternalError_1 = __webpack_require__(74436);
Object.defineProperty(exports, "InternalError", ({ enumerable: true, get: function () { return InternalError_1.InternalError; } }));
var JsonFile_1 = __webpack_require__(46484);
Object.defineProperty(exports, "JsonFile", ({ enumerable: true, get: function () { return JsonFile_1.JsonFile; } }));
var JsonSchema_1 = __webpack_require__(61038);
Object.defineProperty(exports, "JsonSchema", ({ enumerable: true, get: function () { return JsonSchema_1.JsonSchema; } }));
var LockFile_1 = __webpack_require__(9546);
Object.defineProperty(exports, "LockFile", ({ enumerable: true, get: function () { return LockFile_1.LockFile; } }));
var MapExtensions_1 = __webpack_require__(98810);
Object.defineProperty(exports, "MapExtensions", ({ enumerable: true, get: function () { return MapExtensions_1.MapExtensions; } }));
var ProtectableMap_1 = __webpack_require__(36871);
Object.defineProperty(exports, "ProtectableMap", ({ enumerable: true, get: function () { return ProtectableMap_1.ProtectableMap; } }));
var PackageJsonLookup_1 = __webpack_require__(7379);
Object.defineProperty(exports, "PackageJsonLookup", ({ enumerable: true, get: function () { return PackageJsonLookup_1.PackageJsonLookup; } }));
var PackageName_1 = __webpack_require__(60341);
Object.defineProperty(exports, "PackageName", ({ enumerable: true, get: function () { return PackageName_1.PackageName; } }));
Object.defineProperty(exports, "PackageNameParser", ({ enumerable: true, get: function () { return PackageName_1.PackageNameParser; } }));
var Path_1 = __webpack_require__(74803);
Object.defineProperty(exports, "Path", ({ enumerable: true, get: function () { return Path_1.Path; } }));
var Text_1 = __webpack_require__(86879);
Object.defineProperty(exports, "Text", ({ enumerable: true, get: function () { return Text_1.Text; } }));
var Sort_1 = __webpack_require__(58749);
Object.defineProperty(exports, "Sort", ({ enumerable: true, get: function () { return Sort_1.Sort; } }));
var FileSystem_1 = __webpack_require__(19334);
Object.defineProperty(exports, "FileSystem", ({ enumerable: true, get: function () { return FileSystem_1.FileSystem; } }));
var FileWriter_1 = __webpack_require__(62858);
Object.defineProperty(exports, "FileWriter", ({ enumerable: true, get: function () { return FileWriter_1.FileWriter; } }));
var LegacyAdapters_1 = __webpack_require__(69291);
Object.defineProperty(exports, "LegacyAdapters", ({ enumerable: true, get: function () { return LegacyAdapters_1.LegacyAdapters; } }));
var StringBuilder_1 = __webpack_require__(73994);
Object.defineProperty(exports, "StringBuilder", ({ enumerable: true, get: function () { return StringBuilder_1.StringBuilder; } }));
var Terminal_1 = __webpack_require__(85673);
Object.defineProperty(exports, "Terminal", ({ enumerable: true, get: function () { return Terminal_1.Terminal; } }));
var Colors_1 = __webpack_require__(81382);
Object.defineProperty(exports, "Colors", ({ enumerable: true, get: function () { return Colors_1.Colors; } }));
Object.defineProperty(exports, "ColorValue", ({ enumerable: true, get: function () { return Colors_1.ColorValue; } }));
Object.defineProperty(exports, "TextAttribute", ({ enumerable: true, get: function () { return Colors_1.TextAttribute; } }));
var ITerminalProvider_1 = __webpack_require__(20449);
Object.defineProperty(exports, "TerminalProviderSeverity", ({ enumerable: true, get: function () { return ITerminalProvider_1.TerminalProviderSeverity; } }));
var ConsoleTerminalProvider_1 = __webpack_require__(94946);
Object.defineProperty(exports, "ConsoleTerminalProvider", ({ enumerable: true, get: function () { return ConsoleTerminalProvider_1.ConsoleTerminalProvider; } }));
var StringBufferTerminalProvider_1 = __webpack_require__(41403);
Object.defineProperty(exports, "StringBufferTerminalProvider", ({ enumerable: true, get: function () { return StringBufferTerminalProvider_1.StringBufferTerminalProvider; } }));
var TypeUuid_1 = __webpack_require__(76778);
Object.defineProperty(exports, "TypeUuid", ({ enumerable: true, get: function () { return TypeUuid_1.TypeUuid; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 47739:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var async = __webpack_require__(45200);
async.core = __webpack_require__(53218);
async.isCore = __webpack_require__(49024);
async.sync = __webpack_require__(33032);

module.exports = async;


/***/ }),

/***/ 45200:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(35747);
var path = __webpack_require__(85622);
var caller = __webpack_require__(17738);
var nodeModulesPaths = __webpack_require__(79711);
var normalizeOptions = __webpack_require__(95883);
var isCore = __webpack_require__(49024);

var realpathFS = fs.realpath && typeof fs.realpath.native === 'function' ? fs.realpath.native : fs.realpath;

var defaultIsFile = function isFile(file, cb) {
    fs.stat(file, function (err, stat) {
        if (!err) {
            return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};

var defaultIsDir = function isDirectory(dir, cb) {
    fs.stat(dir, function (err, stat) {
        if (!err) {
            return cb(null, stat.isDirectory());
        }
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};

var defaultRealpath = function realpath(x, cb) {
    realpathFS(x, function (realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== 'ENOENT') cb(realpathErr);
        else cb(null, realpathErr ? x : realPath);
    });
};

var maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
    } else {
        cb(null, x);
    }
};

var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
};

module.exports = function resolve(x, options, callback) {
    var cb = callback;
    var opts = options;
    if (typeof options === 'function') {
        cb = opts;
        opts = {};
    }
    if (typeof x !== 'string') {
        var err = new TypeError('Path must be a string.');
        return process.nextTick(function () {
            cb(err);
        });
    }

    opts = normalizeOptions(x, opts);

    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile = opts.readFile || fs.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var packageIterator = opts.packageIterator;

    var extensions = opts.extensions || ['.js'];
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || [];

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = path.resolve(basedir);

    maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function (err, realStart) {
            if (err) cb(err);
            else init(realStart);
        }
    );

    var res;
    function init(basedir) {
        if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
            res = path.resolve(basedir, x);
            if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
            if ((/\/$/).test(x) && res === basedir) {
                loadAsDirectory(res, opts.package, onfile);
            } else loadAsFile(res, opts.package, onfile);
        } else if (isCore(x)) {
            return cb(null, x);
        } else loadNodeModules(x, basedir, function (err, n, pkg) {
            if (err) cb(err);
            else if (n) {
                return maybeRealpath(realpath, n, opts, function (err, realN) {
                    if (err) {
                        cb(err);
                    } else {
                        cb(null, realN, pkg);
                    }
                });
            } else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
            }
        });
    }

    function onfile(err, m, pkg) {
        if (err) cb(err);
        else if (m) cb(null, m, pkg);
        else loadAsDirectory(res, function (err, d, pkg) {
            if (err) cb(err);
            else if (d) {
                maybeRealpath(realpath, d, opts, function (err, realD) {
                    if (err) {
                        cb(err);
                    } else {
                        cb(null, realD, pkg);
                    }
                });
            } else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
            }
        });
    }

    function loadAsFile(x, thePackage, callback) {
        var loadAsFilePackage = thePackage;
        var cb = callback;
        if (typeof loadAsFilePackage === 'function') {
            cb = loadAsFilePackage;
            loadAsFilePackage = undefined;
        }

        var exts = [''].concat(extensions);
        load(exts, x, loadAsFilePackage);

        function load(exts, x, loadPackage) {
            if (exts.length === 0) return cb(null, undefined, loadPackage);
            var file = x + exts[0];

            var pkg = loadPackage;
            if (pkg) onpkg(null, pkg);
            else loadpkg(path.dirname(file), onpkg);

            function onpkg(err, pkg_, dir) {
                pkg = pkg_;
                if (err) return cb(err);
                if (dir && pkg && opts.pathFilter) {
                    var rfile = path.relative(dir, file);
                    var rel = rfile.slice(0, rfile.length - exts[0].length);
                    var r = opts.pathFilter(pkg, x, rel);
                    if (r) return load(
                        [''].concat(extensions.slice()),
                        path.resolve(dir, r),
                        pkg
                    );
                }
                isFile(file, onex);
            }
            function onex(err, ex) {
                if (err) return cb(err);
                if (ex) return cb(null, file, pkg);
                load(exts.slice(1), x, pkg);
            }
        }
    }

    function loadpkg(dir, cb) {
        if (dir === '' || dir === '/') return cb(null);
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
            return cb(null);
        }
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return cb(null);

        maybeRealpath(realpath, dir, opts, function (unwrapErr, pkgdir) {
            if (unwrapErr) return loadpkg(path.dirname(dir), cb);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) {
                // on err, ex is false
                if (!ex) return loadpkg(path.dirname(dir), cb);

                readFile(pkgfile, function (err, body) {
                    if (err) cb(err);
                    try { var pkg = JSON.parse(body); } catch (jsonErr) {}

                    if (pkg && opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }
                    cb(null, pkg, dir);
                });
            });
        });
    }

    function loadAsDirectory(x, loadAsDirectoryPackage, callback) {
        var cb = callback;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === 'function') {
            cb = fpkg;
            fpkg = opts.package;
        }

        maybeRealpath(realpath, x, opts, function (unwrapErr, pkgdir) {
            if (unwrapErr) return cb(unwrapErr);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) {
                if (err) return cb(err);
                if (!ex) return loadAsFile(path.join(x, 'index'), fpkg, cb);

                readFile(pkgfile, function (err, body) {
                    if (err) return cb(err);
                    try {
                        var pkg = JSON.parse(body);
                    } catch (jsonErr) {}

                    if (pkg && opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }

                    if (pkg && pkg.main) {
                        if (typeof pkg.main !== 'string') {
                            var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');
                            mainError.code = 'INVALID_PACKAGE_MAIN';
                            return cb(mainError);
                        }
                        if (pkg.main === '.' || pkg.main === './') {
                            pkg.main = 'index';
                        }
                        loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {
                            if (err) return cb(err);
                            if (m) return cb(null, m, pkg);
                            if (!pkg) return loadAsFile(path.join(x, 'index'), pkg, cb);

                            var dir = path.resolve(x, pkg.main);
                            loadAsDirectory(dir, pkg, function (err, n, pkg) {
                                if (err) return cb(err);
                                if (n) return cb(null, n, pkg);
                                loadAsFile(path.join(x, 'index'), pkg, cb);
                            });
                        });
                        return;
                    }

                    loadAsFile(path.join(x, '/index'), pkg, cb);
                });
            });
        });
    }

    function processDirs(cb, dirs) {
        if (dirs.length === 0) return cb(null, undefined);
        var dir = dirs[0];

        isDirectory(path.dirname(dir), isdir);

        function isdir(err, isdir) {
            if (err) return cb(err);
            if (!isdir) return processDirs(cb, dirs.slice(1));
            loadAsFile(dir, opts.package, onfile);
        }

        function onfile(err, m, pkg) {
            if (err) return cb(err);
            if (m) return cb(null, m, pkg);
            loadAsDirectory(dir, opts.package, ondir);
        }

        function ondir(err, n, pkg) {
            if (err) return cb(err);
            if (n) return cb(null, n, pkg);
            processDirs(cb, dirs.slice(1));
        }
    }
    function loadNodeModules(x, start, cb) {
        var thunk = function () { return getPackageCandidates(x, start, opts); };
        processDirs(
            cb,
            packageIterator ? packageIterator(x, start, thunk, opts) : thunk()
        );
    }
};


/***/ }),

/***/ 17738:
/***/ ((module) => {

module.exports = function () {
    // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function (_, stack) { return stack; };
    var stack = (new Error()).stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
};


/***/ }),

/***/ 53218:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var current = (process.versions && process.versions.node && process.versions.node.split('.')) || [];

function specifierIncluded(specifier) {
    var parts = specifier.split(' ');
    var op = parts.length > 1 ? parts[0] : '=';
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');

    for (var i = 0; i < 3; ++i) {
        var cur = Number(current[i] || 0);
        var ver = Number(versionParts[i] || 0);
        if (cur === ver) {
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        }
        if (op === '<') {
            return cur < ver;
        } else if (op === '>=') {
            return cur >= ver;
        } else {
            return false;
        }
    }
    return op === '>=';
}

function matchesRange(range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) { return false; }
    for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(specifiers[i])) { return false; }
    }
    return true;
}

function versionIncluded(specifierValue) {
    if (typeof specifierValue === 'boolean') { return specifierValue; }
    if (specifierValue && typeof specifierValue === 'object') {
        for (var i = 0; i < specifierValue.length; ++i) {
            if (matchesRange(specifierValue[i])) { return true; }
        }
        return false;
    }
    return matchesRange(specifierValue);
}

var data = __webpack_require__(9816);

var core = {};
for (var mod in data) { // eslint-disable-line no-restricted-syntax
    if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core[mod] = versionIncluded(data[mod]);
    }
}
module.exports = core;


/***/ }),

/***/ 49024:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var core = __webpack_require__(53218);

module.exports = function isCore(x) {
    return Object.prototype.hasOwnProperty.call(core, x);
};


/***/ }),

/***/ 79711:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var path = __webpack_require__(85622);
var parse = path.parse || __webpack_require__(5980);

var getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {
    var prefix = '/';
    if ((/^([A-Za-z]:)/).test(absoluteStart)) {
        prefix = '';
    } else if ((/^\\\\/).test(absoluteStart)) {
        prefix = '\\\\';
    }

    var paths = [absoluteStart];
    var parsed = parse(absoluteStart);
    while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
    }

    return paths.reduce(function (dirs, aPath) {
        return dirs.concat(modules.map(function (moduleDir) {
            return path.resolve(prefix, aPath, moduleDir);
        }));
    }, []);
};

module.exports = function nodeModulesPaths(start, opts, request) {
    var modules = opts && opts.moduleDirectory
        ? [].concat(opts.moduleDirectory)
        : ['node_modules'];

    if (opts && typeof opts.paths === 'function') {
        return opts.paths(
            request,
            start,
            function () { return getNodeModulesDirs(start, modules); },
            opts
        );
    }

    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
};


/***/ }),

/***/ 95883:
/***/ ((module) => {

module.exports = function (x, opts) {
    /**
     * This file is purposefully a passthrough. It's expected that third-party
     * environments will override it at runtime in order to inject special logic
     * into `resolve` (by manipulating the options). One such example is the PnP
     * code path in Yarn.
     */

    return opts || {};
};


/***/ }),

/***/ 33032:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCore = __webpack_require__(49024);
var fs = __webpack_require__(35747);
var path = __webpack_require__(85622);
var caller = __webpack_require__(17738);
var nodeModulesPaths = __webpack_require__(79711);
var normalizeOptions = __webpack_require__(95883);

var realpathFS = fs.realpathSync && typeof fs.realpathSync.native === 'function' ? fs.realpathSync.native : fs.realpathSync;

var defaultIsFile = function isFile(file) {
    try {
        var stat = fs.statSync(file);
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return stat.isFile() || stat.isFIFO();
};

var defaultIsDir = function isDirectory(dir) {
    try {
        var stat = fs.statSync(dir);
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return stat.isDirectory();
};

var defaultRealpathSync = function realpathSync(x) {
    try {
        return realpathFS(x);
    } catch (realpathErr) {
        if (realpathErr.code !== 'ENOENT') {
            throw realpathErr;
        }
    }
    return x;
};

var maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {
    if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
    }
    return x;
};

var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
};

module.exports = function resolveSync(x, options) {
    if (typeof x !== 'string') {
        throw new TypeError('Path must be a string.');
    }
    var opts = normalizeOptions(x, options);

    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var packageIterator = opts.packageIterator;

    var extensions = opts.extensions || ['.js'];
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || [];

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);

    if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
        var res = path.resolve(absoluteStart, x);
        if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m) return maybeRealpathSync(realpathSync, m, opts);
    } else if (isCore(x)) {
        return x;
    } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n) return maybeRealpathSync(realpathSync, n, opts);
    }

    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;

    function loadAsFileSync(x) {
        var pkg = loadpkg(path.dirname(x));

        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
            var rfile = path.relative(pkg.dir, x);
            var r = opts.pathFilter(pkg.pkg, x, rfile);
            if (r) {
                x = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign
            }
        }

        if (isFile(x)) {
            return x;
        }

        for (var i = 0; i < extensions.length; i++) {
            var file = x + extensions[i];
            if (isFile(file)) {
                return file;
            }
        }
    }

    function loadpkg(dir) {
        if (dir === '' || dir === '/') return;
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
            return;
        }
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return;

        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), 'package.json');

        if (!isFile(pkgfile)) {
            return loadpkg(path.dirname(dir));
        }

        var body = readFileSync(pkgfile);

        try {
            var pkg = JSON.parse(body);
        } catch (jsonErr) {}

        if (pkg && opts.packageFilter) {
            // v2 will pass pkgfile
            pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment
        }

        return { pkg: pkg, dir: dir };
    }

    function loadAsDirectorySync(x) {
        var pkgfile = path.join(maybeRealpathSync(realpathSync, x, opts), '/package.json');
        if (isFile(pkgfile)) {
            try {
                var body = readFileSync(pkgfile, 'UTF8');
                var pkg = JSON.parse(body);
            } catch (e) {}

            if (pkg && opts.packageFilter) {
                // v2 will pass pkgfile
                pkg = opts.packageFilter(pkg, /*pkgfile,*/ x); // eslint-disable-line spaced-comment
            }

            if (pkg && pkg.main) {
                if (typeof pkg.main !== 'string') {
                    var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');
                    mainError.code = 'INVALID_PACKAGE_MAIN';
                    throw mainError;
                }
                if (pkg.main === '.' || pkg.main === './') {
                    pkg.main = 'index';
                }
                try {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                    var n = loadAsDirectorySync(path.resolve(x, pkg.main));
                    if (n) return n;
                } catch (e) {}
            }
        }

        return loadAsFileSync(path.join(x, '/index'));
    }

    function loadNodeModulesSync(x, start) {
        var thunk = function () { return getPackageCandidates(x, start, opts); };
        var dirs = packageIterator ? packageIterator(x, start, thunk, opts) : thunk();

        for (var i = 0; i < dirs.length; i++) {
            var dir = dirs[i];
            if (isDirectory(path.dirname(dir))) {
                var m = loadAsFileSync(dir);
                if (m) return m;
                var n = loadAsDirectorySync(dir);
                if (n) return n;
            }
        }
    }
};


/***/ }),

/***/ 85884:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPackageDeps = exports.gitStatus = exports.gitLsTree = exports.getGitHashForFiles = exports.parseGitStatus = exports.parseGitLsTree = exports.parseGitFilename = void 0;
const path = __importStar(__webpack_require__(85622));
const node_core_library_1 = __webpack_require__(38437);
/**
 * Parses a quoted filename sourced from the output of the "git status" command.
 *
 * Paths with non-standard characters will be enclosed with double-quotes, and non-standard
 * characters will be backslash escaped (ex. double-quotes, non-ASCII characters). The
 * escaped chars can be included in one of two ways:
 * - backslash-escaped chars (ex. \")
 * - octal encoded chars (ex. \347)
 *
 * See documentation: https://git-scm.com/docs/git-status
 */
function parseGitFilename(filename) {
    // If there are no double-quotes around the string, then there are no escaped characters
    // to decode, so just return
    if (!filename.match(/^".+"$/)) {
        return filename;
    }
    // Need to hex encode '%' since we will be decoding the converted octal values from hex
    filename = filename.replace(/%/g, '%25');
    // Replace all instances of octal literals with percent-encoded hex (ex. '\347\275\221' -> '%E7%BD%91').
    // This is done because the octal literals represent UTF-8 bytes, and by converting them to percent-encoded
    // hex, we can use decodeURIComponent to get the Unicode chars.
    filename = filename.replace(/(?:\\(\d{1,3}))/g, (match, ...[octalValue, index, source]) => {
        // We need to make sure that the backslash is intended to escape the octal value. To do this, walk
        // backwards from the match to ensure that it's already escaped.
        const trailingBackslashes = source
            .slice(0, index)
            .match(/\\*$/);
        return trailingBackslashes && trailingBackslashes.length > 0 && trailingBackslashes[0].length % 2 === 0
            ? `%${parseInt(octalValue, 8).toString(16)}`
            : match;
    });
    // Finally, decode the filename and unescape the escaped UTF-8 chars
    return JSON.parse(decodeURIComponent(filename));
}
exports.parseGitFilename = parseGitFilename;
/**
 * Parses the output of the "git ls-tree" command
 */
function parseGitLsTree(output) {
    const changes = new Map();
    if (output) {
        // A line is expected to look like:
        // 100644 blob 3451bccdc831cb43d7a70ed8e628dcf9c7f888c8    src/typings/tsd.d.ts
        // 160000 commit c5880bf5b0c6c1f2e2c43c95beeb8f0a808e8bac  rushstack
        const gitRegex = /([0-9]{6})\s(blob|commit)\s([a-f0-9]{40})\s*(.*)/;
        // Note: The output of git ls-tree uses \n newlines regardless of OS.
        const outputLines = output.trim().split('\n');
        for (const line of outputLines) {
            if (line) {
                // Take everything after the "100644 blob", which is just the hash and filename
                const matches = line.match(gitRegex);
                if (matches && matches[3] && matches[4]) {
                    const hash = matches[3];
                    const filename = parseGitFilename(matches[4]);
                    changes.set(filename, hash);
                }
                else {
                    throw new Error(`Cannot parse git ls-tree input: "${line}"`);
                }
            }
        }
    }
    return changes;
}
exports.parseGitLsTree = parseGitLsTree;
/**
 * Parses the output of the "git status" command
 */
function parseGitStatus(output, packagePath) {
    const changes = new Map();
    /*
     * Typically, output will look something like:
     * M temp_modules/rush-package-deps-hash/package.json
     * D package-deps-hash/src/index.ts
     */
    // If there was an issue with `git ls-tree`, or there are no current changes, processOutputBlocks[1]
    // will be empty or undefined
    if (!output) {
        return changes;
    }
    // Note: The output of git hash-object uses \n newlines regardless of OS.
    const outputLines = output.trim().split('\n');
    for (const line of outputLines) {
        /*
         * changeType is in the format of "XY" where "X" is the status of the file in the index and "Y" is the status of
         * the file in the working tree. Some example statuses:
         *   - 'D' == deletion
         *   - 'M' == modification
         *   - 'A' == addition
         *   - '??' == untracked
         *   - 'R' == rename
         *   - 'RM' == rename with modifications
         *   - '[MARC]D' == deleted in work tree
         * Full list of examples: https://git-scm.com/docs/git-status#_short_format
         */
        const match = line.match(/("(\\"|[^"])+")|(\S+\s*)/g);
        if (match && match.length > 1) {
            const [changeType, ...filenameMatches] = match;
            // We always care about the last filename in the filenames array. In the case of non-rename changes,
            // the filenames array only contains one file, so we can join all segments that were split on spaces.
            // In the case of rename changes, the last item in the array is the path to the file in the working tree,
            // which is the only one that we care about. It is also surrounded by double-quotes if spaces are
            // included, so no need to worry about joining different segments
            let lastFilename = changeType.startsWith('R')
                ? filenameMatches[filenameMatches.length - 1]
                : filenameMatches.join('');
            lastFilename = parseGitFilename(lastFilename);
            changes.set(lastFilename, changeType.trimRight());
        }
    }
    return changes;
}
exports.parseGitStatus = parseGitStatus;
/**
 * Takes a list of files and returns the current git hashes for them
 *
 * @public
 */
function getGitHashForFiles(filesToHash, packagePath, gitPath) {
    const changes = new Map();
    if (filesToHash.length) {
        // Use --stdin-paths arg to pass the list of files to git in order to avoid issues with
        // command length
        const result = node_core_library_1.Executable.spawnSync(gitPath || 'git', ['hash-object', '--stdin-paths'], { input: filesToHash.map((x) => path.resolve(packagePath, x)).join('\n') });
        if (result.status !== 0) {
            throw new Error(`git hash-object exited with status ${result.status}: ${result.stderr}`);
        }
        const hashStdout = result.stdout.trim();
        // The result of "git hash-object" will be a list of file hashes delimited by newlines
        const hashes = hashStdout.split('\n');
        if (hashes.length !== filesToHash.length) {
            throw new Error(`Passed ${filesToHash.length} file paths to Git to hash, but received ${hashes.length} hashes.`);
        }
        for (let i = 0; i < hashes.length; i++) {
            const hash = hashes[i];
            const filePath = filesToHash[i];
            changes.set(filePath, hash);
        }
    }
    return changes;
}
exports.getGitHashForFiles = getGitHashForFiles;
/**
 * Executes "git ls-tree" in a folder
 */
function gitLsTree(path, gitPath) {
    const result = node_core_library_1.Executable.spawnSync(gitPath || 'git', ['ls-tree', 'HEAD', '-r'], {
        currentWorkingDirectory: path
    });
    if (result.status !== 0) {
        throw new Error(`git ls-tree exited with status ${result.status}: ${result.stderr}`);
    }
    return result.stdout;
}
exports.gitLsTree = gitLsTree;
/**
 * Executes "git status" in a folder
 */
function gitStatus(path, gitPath) {
    /**
     * -s - Short format. Will be printed as 'XY PATH' or 'XY ORIG_PATH -> PATH'. Paths with non-standard
     *      characters will be escaped using double-quotes, and non-standard characters will be backslash
     *      escaped (ex. spaces, tabs, double-quotes)
     * -u - Untracked files are included
     *
     * See documentation here: https://git-scm.com/docs/git-status
     */
    const result = node_core_library_1.Executable.spawnSync(gitPath || 'git', ['status', '-s', '-u', '.'], {
        currentWorkingDirectory: path
    });
    if (result.status !== 0) {
        throw new Error(`git status exited with status ${result.status}: ${result.stderr}`);
    }
    return result.stdout;
}
exports.gitStatus = gitStatus;
/**
 * Builds an object containing hashes for the files under the specified `packagePath` folder.
 * @param packagePath - The folder path to derive the package dependencies from. This is typically the folder
 *                      containing package.json.  If omitted, the default value is the current working directory.
 * @param excludedPaths - An optional array of file path exclusions. If a file should be omitted from the list
 *                         of dependencies, use this to exclude it.
 * @returns the package-deps.json file content
 *
 * @public
 */
function getPackageDeps(packagePath = process.cwd(), excludedPaths, gitPath) {
    const gitLsOutput = gitLsTree(packagePath, gitPath);
    // Add all the checked in hashes
    const result = parseGitLsTree(gitLsOutput);
    // Remove excluded paths
    if (excludedPaths) {
        for (const excludedPath of excludedPaths) {
            result.delete(excludedPath);
        }
    }
    // Update the checked in hashes with the current repo status
    const gitStatusOutput = gitStatus(packagePath, gitPath);
    const currentlyChangedFiles = parseGitStatus(gitStatusOutput, packagePath);
    const filesToHash = [];
    const excludedPathSet = new Set(excludedPaths);
    for (const [filename, changeType] of currentlyChangedFiles) {
        // See comments inside parseGitStatus() for more information
        if (changeType === 'D' || (changeType.length === 2 && changeType.charAt(1) === 'D')) {
            result.delete(filename);
        }
        else {
            if (!excludedPathSet.has(filename)) {
                filesToHash.push(filename);
            }
        }
    }
    const currentlyChangedFileHashes = getGitHashForFiles(filesToHash, packagePath, gitPath);
    for (const [filename, hash] of currentlyChangedFileHashes) {
        result.set(filename, hash);
    }
    return result;
}
exports.getPackageDeps = getPackageDeps;
//# sourceMappingURL=getPackageDeps.js.map

/***/ }),

/***/ 45329:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getGitHashForFiles = exports.getPackageDeps = void 0;
/**
 * This package builds a JSON object containing the git hashes of all files used to produce a given NPM package.
 * The {@link https://rushjs.io/ | Rush} tool uses this library to implement incremental build detection.
 *
 * @remarks
 *
 * For more info, please see the package {@link https://www.npmjs.com/package/@rushstack/package-deps-hash
 * | README}.
 *
 * @packageDocumentation
 */
var getPackageDeps_1 = __webpack_require__(85884);
Object.defineProperty(exports, "getPackageDeps", ({ enumerable: true, get: function () { return getPackageDeps_1.getPackageDeps; } }));
Object.defineProperty(exports, "getGitHashForFiles", ({ enumerable: true, get: function () { return getPackageDeps_1.getGitHashForFiles; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 82856:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AlreadyReportedError = void 0;
const TypeUuid_1 = __webpack_require__(11727);
const uuidAlreadyReportedError = 'f26b0640-a49b-49d1-9ead-1a516d5920c7';
/**
 * This exception can be thrown to indicate that an operation failed and an error message has already
 * been reported appropriately. Thus, the catch handler does not have responsibility for reporting
 * the error.
 *
 * @remarks
 * For example, suppose a tool writes interactive output to `console.log()`.  When an exception is thrown,
 * the `catch` handler will typically provide simplistic reporting such as this:
 *
 * ```ts
 * catch (error) {
 *   console.log("ERROR: " + error.message);
 * }
 * ```
 *
 * Suppose that the code performing the operation normally prints rich output to the console.  It may be able to
 * present an error message more nicely (for example, as part of a table, or structured log format).  Throwing
 * `AlreadyReportedError` provides a way to use exception handling to abort the operation, but instruct the `catch`
 * handler not to print an error a second time:
 *
 * ```ts
 * catch (error) {
 *   if (error instanceof AlreadyReportedError) {
 *     return;
 *   }
 *   console.log("ERROR: " + error.message);
 * }
 * ```
 *
 * @public
 */
class AlreadyReportedError extends Error {
    constructor() {
        super('An error occurred.');
        // Manually set the prototype, as we can no longer extend built-in classes like Error, Array, Map, etc
        // [https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work](https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work)
        //
        // Note: the prototype must also be set on any classes which extend this one
        this.__proto__ = AlreadyReportedError.prototype; // eslint-disable-line @typescript-eslint/no-explicit-any
    }
    static [Symbol.hasInstance](instance) {
        return TypeUuid_1.TypeUuid.isInstanceOf(instance, uuidAlreadyReportedError);
    }
}
exports.AlreadyReportedError = AlreadyReportedError;
TypeUuid_1.TypeUuid.registerClass(AlreadyReportedError, uuidAlreadyReportedError);
//# sourceMappingURL=AlreadyReportedError.js.map

/***/ }),

/***/ 50054:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Async = void 0;
/**
 * Utilities for parallel asynchronous operations, for use with the system `Promise` APIs.
 *
 * @beta
 */
class Async {
    /**
     * Given an input array and a `callback` function, invoke the callback to start a
     * promise for each element in the array.  Returns an array containing the results.
     *
     * @remarks
     * This API is similar to the system `Array#map`, except that the loop is asynchronous,
     * and the maximum number of concurrent promises can be throttled
     * using {@link IAsyncParallelismOptions.concurrency}.
     *
     * If `callback` throws a synchronous exception, or if it returns a promise that rejects,
     * then the loop stops immediately.  Any remaining array items will be skipped, and
     * overall operation will reject with the first error that was encountered.
     *
     * @param iterable - the array of inputs for the callback function
     * @param callback - a function that starts an asynchronous promise for an element
     *   from the array
     * @param options - options for customizing the control flow
     * @returns an array containing the result for each callback, in the same order
     *   as the original input `array`
     */
    static async mapAsync(iterable, callback, options) {
        const result = [];
        await Async.forEachAsync(iterable, async (item, arrayIndex) => {
            result[arrayIndex] = await callback(item, arrayIndex);
        }, options);
        return result;
    }
    /**
     * Given an input array and a `callback` function, invoke the callback to start a
     * promise for each element in the array.
     *
     * @remarks
     * This API is similar to the system `Array#forEach`, except that the loop is asynchronous,
     * and the maximum number of concurrent promises can be throttled
     * using {@link IAsyncParallelismOptions.concurrency}.
     *
     * If `callback` throws a synchronous exception, or if it returns a promise that rejects,
     * then the loop stops immediately.  Any remaining array items will be skipped, and
     * overall operation will reject with the first error that was encountered.
     *
     * @param iterable - the array of inputs for the callback function
     * @param callback - a function that starts an asynchronous promise for an element
     *   from the array
     * @param options - options for customizing the control flow
     */
    static async forEachAsync(iterable, callback, options) {
        await new Promise((resolve, reject) => {
            const concurrency = (options === null || options === void 0 ? void 0 : options.concurrency) && options.concurrency > 0 ? options.concurrency : Infinity;
            let operationsInProgress = 0;
            const iterator = (iterable[Symbol.iterator] ||
                iterable[Symbol.asyncIterator]).call(iterable);
            let arrayIndex = 0;
            let iteratorIsComplete = false;
            let promiseHasResolvedOrRejected = false;
            async function queueOperationsAsync() {
                while (operationsInProgress < concurrency && !iteratorIsComplete && !promiseHasResolvedOrRejected) {
                    const currentIteratorResult = await iterator.next();
                    // eslint-disable-next-line require-atomic-updates
                    iteratorIsComplete = !!currentIteratorResult.done;
                    if (!iteratorIsComplete) {
                        operationsInProgress++;
                        Promise.resolve(callback(currentIteratorResult.value, arrayIndex++))
                            .then(async () => {
                            operationsInProgress--;
                            await onOperationCompletionAsync();
                        })
                            .catch((error) => {
                            promiseHasResolvedOrRejected = true;
                            reject(error);
                        });
                    }
                }
                if (iteratorIsComplete) {
                    await onOperationCompletionAsync();
                }
            }
            async function onOperationCompletionAsync() {
                if (!promiseHasResolvedOrRejected) {
                    if (operationsInProgress === 0 && iteratorIsComplete) {
                        promiseHasResolvedOrRejected = true;
                        resolve();
                    }
                    else if (!iteratorIsComplete) {
                        await queueOperationsAsync();
                    }
                }
            }
            queueOperationsAsync().catch((error) => {
                promiseHasResolvedOrRejected = true;
                reject(error);
            });
        });
    }
    /**
     * Return a promise that resolves after the specified number of milliseconds.
     */
    static async sleep(ms) {
        await new Promise((resolve) => {
            setTimeout(resolve, ms);
        });
    }
}
exports.Async = Async;
//# sourceMappingURL=Async.js.map

/***/ }),

/***/ 48839:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Enum = void 0;
/**
 * A helper for looking up TypeScript `enum` keys/values.
 *
 * @remarks
 * TypeScript enums implement a lookup table for mapping between their keys and values:
 *
 * ```ts
 * enum Colors {
 *   Red = 1
 * }
 *
 * // Prints "Red"
 * console.log(Colors[1]);
 *
 * // Prints "1"
 * console.log(Colors["Red]);
 * ```
 *
 * However the compiler's "noImplicitAny" validation has trouble with these mappings, because
 * there are so many possible types for the map elements:
 *
 * ```ts
 * function f(s: string): Colors | undefined {
 *   // (TS 7015) Element implicitly has an 'any' type because
 *   // index expression is not of type 'number'.
 *   return Colors[s];
 * }
 * ```
 *
 * The `Enum` helper provides a more specific, strongly typed way to access members:
 *
 * ```ts
 * function f(s: string): Colors | undefined {
 *   return Enum.tryGetValueByKey(Colors, s);
 * }
 * ```
 *
 * @public
 */
class Enum {
    constructor() { }
    /**
     * Returns an enum value, given its key. Returns `undefined` if no matching key is found.
     *
     * @example
     *
     * Example usage:
     * ```ts
     * enum Colors {
     *   Red = 1
     * }
     *
     * // Prints "1"
     * console.log(Enum.tryGetValueByKey(Colors, "Red"));
     *
     * // Prints "undefined"
     * console.log(Enum.tryGetValueByKey(Colors, "Black"));
     * ```
     */
    static tryGetValueByKey(enumObject, key) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return enumObject[key];
    }
    /**
     * This API is similar to {@link Enum.tryGetValueByKey}, except that it throws an exception
     * if the key is undefined.
     */
    static getValueByKey(enumObject, key) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const result = enumObject[key];
        if (result === undefined) {
            throw new Error(`The lookup key ${JSON.stringify(key)} is not defined`);
        }
        return result;
    }
    /**
     * Returns an enum string key, given its numeric value.  Returns `undefined` if no matching value
     * is found.
     *
     * @remarks
     * The TypeScript compiler only creates a reverse mapping for enum members whose value is numeric.
     * For example:
     *
     * ```ts
     * enum E {
     *   A = 1,
     *   B = 'c'
     * }
     *
     * // Prints "A"
     * console.log(E[1]);
     *
     * // Prints "undefined"
     * console.log(E["c"]);
     * ```
     *
     * @example
     *
     * Example usage:
     * ```ts
     * enum Colors {
     *   Red = 1,
     *   Blue = 'blue'
     * }
     *
     * // Prints "Red"
     * console.log(Enum.tryGetKeyByNumber(Colors, 1));
     *
     * // Prints "undefined"
     * console.log(Enum.tryGetKeyByNumber(Colors, -1));
     * ```
     */
    static tryGetKeyByNumber(enumObject, value) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return enumObject[value];
    }
    /**
     * This API is similar to {@link Enum.tryGetKeyByNumber}, except that it throws an exception
     * if the key is undefined.
     */
    static getKeyByNumber(enumObject, value) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const result = enumObject[value];
        if (result === undefined) {
            throw new Error(`The value ${value} does not exist in the mapping`);
        }
        return result;
    }
}
exports.Enum = Enum;
//# sourceMappingURL=Enum.js.map

/***/ }),

/***/ 88935:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnvironmentMap = void 0;
const process_1 = __importDefault(__webpack_require__(61765));
const InternalError_1 = __webpack_require__(28630);
/**
 * A map data structure that stores process environment variables.  On Windows
 * operating system, the variable names are case-insensitive.
 * @public
 */
class EnvironmentMap {
    constructor(environmentObject = {}) {
        this._map = new Map();
        // This property helps catch a mistake where an instance of `EnvironmentMap` is accidentally passed to
        // a function that expects a `Record<string, string>` (as would be used with the `process.env` API).
        // The property getter will throw an exception if that function tries to enumerate the object values.
        Object.defineProperty(this, '_sanityCheck', {
            enumerable: true,
            get: function () {
                throw new InternalError_1.InternalError('Attempt to read EnvironmentMap class as an object');
            }
        });
        this.caseSensitive = process_1.default.platform !== 'win32';
        this.mergeFromObject(environmentObject);
    }
    /**
     * Clears all entries, resulting in an empty map.
     */
    clear() {
        this._map.clear();
    }
    /**
     * Assigns the variable to the specified value.  A previous value will be overwritten.
     *
     * @remarks
     * The value can be an empty string.  To completely remove the entry, use
     * {@link EnvironmentMap.unset} instead.
     */
    set(name, value) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        this._map.set(key, { name: name, value });
    }
    /**
     * Removes the key from the map, if present.
     */
    unset(name) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        this._map.delete(key);
    }
    /**
     * Returns the value of the specified variable, or `undefined` if the map does not contain that name.
     */
    get(name) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        const entry = this._map.get(key);
        if (entry === undefined) {
            return undefined;
        }
        return entry.value;
    }
    /**
     * Returns the map keys, which are environment variable names.
     */
    names() {
        return this._map.keys();
    }
    /**
     * Returns the map entries.
     */
    entries() {
        return this._map.values();
    }
    /**
     * Adds each entry from `environmentMap` to this map.
     */
    mergeFrom(environmentMap) {
        for (const entry of environmentMap.entries()) {
            this.set(entry.name, entry.value);
        }
    }
    /**
     * Merges entries from a plain JavaScript object, such as would be used with the `process.env` API.
     */
    mergeFromObject(environmentObject = {}) {
        for (const [name, value] of Object.entries(environmentObject)) {
            if (value !== undefined) {
                this.set(name, value);
            }
        }
    }
    /**
     * Returns the keys as a plain JavaScript object similar to the object returned by the `process.env` API.
     */
    toObject() {
        const result = {};
        for (const entry of this.entries()) {
            result[entry.name] = entry.value;
        }
        return result;
    }
}
exports.EnvironmentMap = EnvironmentMap;
//# sourceMappingURL=EnvironmentMap.js.map

/***/ }),

/***/ 74652:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Executable = void 0;
const child_process = __importStar(__webpack_require__(63129));
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const EnvironmentMap_1 = __webpack_require__(88935);
const FileSystem_1 = __webpack_require__(57422);
/**
 * The Executable class provides a safe, portable, recommended solution for tools that need
 * to launch child processes.
 *
 * @remarks
 * The NodeJS child_process API provides a solution for launching child processes, however
 * its design encourages reliance on the operating system shell for certain features.
 * Invoking the OS shell is not safe, not portable, and generally not recommended:
 *
 * - Different shells have different behavior and command-line syntax, and which shell you
 *   will get with NodeJS is unpredictable.  There is no universal shell guaranteed to be
 *   available on all platforms.
 *
 * - If a command parameter contains symbol characters, a shell may interpret them, which
 *   can introduce a security vulnerability
 *
 * - Each shell has different rules for escaping these symbols.  On Windows, the default
 *   shell is incapable of escaping certain character sequences.
 *
 * The Executable API provides a pure JavaScript implementation of primitive shell-like
 * functionality for searching the default PATH, appending default file extensions on Windows,
 * and executing a file that may contain a POSIX shebang.  This primitive functionality
 * is sufficient (and recommended) for most tooling scenarios.
 *
 * If you need additional shell features such as wildcard globbing, environment variable
 * expansion, piping, or built-in commands, then we recommend to use the `@microsoft/rushell`
 * library instead.  Rushell is a pure JavaScript shell with a standard syntax that is
 * guaranteed to work consistently across all platforms.
 *
 * @public
 */
class Executable {
    /**
     * Synchronously create a child process and optionally capture its output.
     *
     * @remarks
     * This function is similar to child_process.spawnSync().  The main differences are:
     *
     * - It does not invoke the OS shell unless the executable file is a shell script.
     * - Command-line arguments containing special characters are more accurately passed
     *   through to the child process.
     * - If the filename is missing a path, then the shell's default PATH will be searched.
     * - If the filename is missing a file extension, then Windows default file extensions
     *   will be searched.
     *
     * @param filename - The name of the executable file.  This string must not contain any
     * command-line arguments.  If the name contains any path delimiters, then the shell's
     * default PATH will not be searched.
     * @param args - The command-line arguments to be passed to the process.
     * @param options - Additional options
     * @returns the same data type as returned by the NodeJS child_process.spawnSync() API
     *
     * @privateRemarks
     *
     * NOTE: The NodeJS spawnSync() returns SpawnSyncReturns<string> or SpawnSyncReturns<Buffer>
     * polymorphically based on the options.encoding parameter value.  This is a fairly confusing
     * design.  In most cases, developers want string with the default encoding.  If/when someone
     * wants binary output or a non-default text encoding, we will introduce a separate API function
     * with a name like "spawnWithBufferSync".
     */
    static spawnSync(filename, args, options) {
        if (!options) {
            options = {};
        }
        const context = Executable._getExecutableContext(options);
        const resolvedPath = Executable._tryResolve(filename, options, context);
        if (!resolvedPath) {
            throw new Error(`The executable file was not found: "${filename}"`);
        }
        const spawnOptions = {
            cwd: context.currentWorkingDirectory,
            env: context.environmentMap.toObject(),
            input: options.input,
            stdio: options.stdio,
            timeout: options.timeoutMs,
            maxBuffer: options.maxBuffer,
            // Contrary to what the NodeJS typings imply, we must explicitly specify "utf8" here
            // if we want the result to be SpawnSyncReturns<string> instead of SpawnSyncReturns<Buffer>.
            encoding: 'utf8',
            // NOTE: This is always false, because Rushell will be recommended instead of relying on the OS shell.
            shell: false
        };
        const normalizedCommandLine = Executable._buildCommandLineFixup(resolvedPath, args, context);
        return child_process.spawnSync(normalizedCommandLine.path, normalizedCommandLine.args, spawnOptions);
    }
    /**
     * Start a child process.
     *
     * @remarks
     * This function is similar to child_process.spawn().  The main differences are:
     *
     * - It does not invoke the OS shell unless the executable file is a shell script.
     * - Command-line arguments containing special characters are more accurately passed
     *   through to the child process.
     * - If the filename is missing a path, then the shell's default PATH will be searched.
     * - If the filename is missing a file extension, then Windows default file extensions
     *   will be searched.
     *
     * This command is asynchronous, but it does not return a `Promise`.  Instead it returns
     * a Node.js `ChildProcess` supporting event notifications.
     *
     * @param filename - The name of the executable file.  This string must not contain any
     * command-line arguments.  If the name contains any path delimiters, then the shell's
     * default PATH will not be searched.
     * @param args - The command-line arguments to be passed to the process.
     * @param options - Additional options
     * @returns the same data type as returned by the NodeJS child_process.spawnSync() API
     */
    static spawn(filename, args, options) {
        if (!options) {
            options = {};
        }
        const context = Executable._getExecutableContext(options);
        const resolvedPath = Executable._tryResolve(filename, options, context);
        if (!resolvedPath) {
            throw new Error(`The executable file was not found: "${filename}"`);
        }
        const spawnOptions = {
            cwd: context.currentWorkingDirectory,
            env: context.environmentMap.toObject(),
            stdio: options.stdio,
            // NOTE: This is always false, because Rushell will be recommended instead of relying on the OS shell.
            shell: false
        };
        const normalizedCommandLine = Executable._buildCommandLineFixup(resolvedPath, args, context);
        return child_process.spawn(normalizedCommandLine.path, normalizedCommandLine.args, spawnOptions);
    }
    // PROBLEM: Given an "args" array of strings that may contain special characters (e.g. spaces,
    // backslashes, quotes), ensure that these strings pass through to the child process's ARGV array
    // without anything getting corrupted along the way.
    //
    // On Unix you just pass the array to spawnSync().  But on Windows, this is a very complex problem:
    // - The Win32 CreateProcess() API expects the args to be encoded as a single text string
    // - The decoding of this string is up to the application (not the OS), and there are 3 different
    //   algorithms in common usage:  the cmd.exe shell, the Microsoft CRT library init code, and
    //   the Win32 CommandLineToArgvW()
    // - The encodings are counterintuitive and have lots of special cases
    // - NodeJS spawnSync() tries do the encoding without knowing which decoder will be used
    //
    // See these articles for a full analysis:
    // http://www.windowsinspired.com/understanding-the-command-line-string-and-arguments-received-by-a-windows-program/
    // http://www.windowsinspired.com/how-a-windows-programs-splits-its-command-line-into-individual-arguments/
    static _buildCommandLineFixup(resolvedPath, args, context) {
        const fileExtension = path.extname(resolvedPath);
        if (os.platform() === 'win32') {
            // Do we need a custom handler for this file type?
            switch (fileExtension.toUpperCase()) {
                case '.EXE':
                case '.COM':
                    // okay to execute directly
                    break;
                case '.BAT':
                case '.CMD': {
                    Executable._validateArgsForWindowsShell(args);
                    // These file types must be invoked via the Windows shell
                    let shellPath = context.environmentMap.get('COMSPEC');
                    if (!shellPath || !Executable._canExecute(shellPath, context)) {
                        shellPath = Executable.tryResolve('cmd.exe');
                    }
                    if (!shellPath) {
                        throw new Error(`Unable to execute "${path.basename(resolvedPath)}" ` +
                            `because CMD.exe was not found in the PATH`);
                    }
                    const shellArgs = [];
                    // /D: Disable execution of AutoRun commands when starting the new shell context
                    shellArgs.push('/d');
                    // /S: Disable Cmd.exe's parsing of double-quote characters inside the command-line
                    shellArgs.push('/s');
                    // /C: Execute the following command and then exit immediately
                    shellArgs.push('/c');
                    // If the path contains special charactrers (e.g. spaces), escape them so that
                    // they don't get interpreted by the shell
                    shellArgs.push(Executable._getEscapedForWindowsShell(resolvedPath));
                    shellArgs.push(...args);
                    return { path: shellPath, args: shellArgs };
                }
                default:
                    throw new Error(`Cannot execute "${path.basename(resolvedPath)}" because the file type is not supported`);
            }
        }
        return {
            path: resolvedPath,
            args: args
        };
    }
    /**
     * Given a filename, this determines the absolute path of the executable file that would
     * be executed by a shell:
     *
     * - If the filename is missing a path, then the shell's default PATH will be searched.
     * - If the filename is missing a file extension, then Windows default file extensions
     *   will be searched.
     *
     * @remarks
     *
     * @param filename - The name of the executable file.  This string must not contain any
     * command-line arguments.  If the name contains any path delimiters, then the shell's
     * default PATH will not be searched.
     * @param options - optional other parameters
     * @returns the absolute path of the executable, or undefined if it was not found
     */
    static tryResolve(filename, options) {
        return Executable._tryResolve(filename, options || {}, Executable._getExecutableContext(options));
    }
    static _tryResolve(filename, options, context) {
        // NOTE: Since "filename" cannot contain command-line arguments, the "/" here
        // must be interpreted as a path delimiter
        const hasPathSeparators = filename.indexOf('/') >= 0 || (os.platform() === 'win32' && filename.indexOf('\\') >= 0);
        // Are there any path separators?
        if (hasPathSeparators) {
            // If so, then don't search the PATH.  Just resolve relative to the current working directory
            const resolvedPath = path.resolve(context.currentWorkingDirectory, filename);
            return Executable._tryResolveFileExtension(resolvedPath, context);
        }
        else {
            // Otherwise if it's a bare name, then try everything in the shell PATH
            const pathsToSearch = Executable._getSearchFolders(context);
            for (const pathToSearch of pathsToSearch) {
                const resolvedPath = path.join(pathToSearch, filename);
                const result = Executable._tryResolveFileExtension(resolvedPath, context);
                if (result) {
                    return result;
                }
            }
            // No match was found
            return undefined;
        }
    }
    static _tryResolveFileExtension(resolvedPath, context) {
        if (Executable._canExecute(resolvedPath, context)) {
            return resolvedPath;
        }
        // Try the default file extensions
        for (const shellExtension of context.windowsExecutableExtensions) {
            const resolvedNameWithExtension = resolvedPath + shellExtension;
            if (Executable._canExecute(resolvedNameWithExtension, context)) {
                return resolvedNameWithExtension;
            }
        }
        return undefined;
    }
    static _buildEnvironmentMap(options) {
        const environmentMap = new EnvironmentMap_1.EnvironmentMap();
        if (options.environment !== undefined && options.environmentMap !== undefined) {
            throw new Error('IExecutableResolveOptions.environment and IExecutableResolveOptions.environmentMap' +
                ' cannot both be specified');
        }
        if (options.environment !== undefined) {
            environmentMap.mergeFromObject(options.environment);
        }
        else if (options.environmentMap !== undefined) {
            environmentMap.mergeFrom(options.environmentMap);
        }
        else {
            environmentMap.mergeFromObject(process.env);
        }
        return environmentMap;
    }
    /**
     * This is used when searching the shell PATH for an executable, to determine
     * whether a match should be skipped or not.  If it returns true, this does not
     * guarantee that the file can be successfully executed.
     */
    static _canExecute(filePath, context) {
        if (!FileSystem_1.FileSystem.exists(filePath)) {
            return false;
        }
        if (os.platform() === 'win32') {
            // NOTE: For Windows, we don't validate that the file extension appears in PATHEXT.
            // That environment variable determines which extensions can be appended if the
            // extension is missing, but it does not affect whether a file may be executed or not.
            // Windows does have a (seldom used) ACL that can be used to deny execution permissions
            // for a file, but NodeJS doesn't expose that API, so we don't bother checking it.
            // However, Windows *does* require that the file has some kind of file extension
            if (path.extname(filePath) === '') {
                return false;
            }
        }
        else {
            // For Unix, check whether any of the POSIX execute bits are set
            try {
                // eslint-disable-next-line no-bitwise
                if ((FileSystem_1.FileSystem.getPosixModeBits(filePath) & 73 /* AllExecute */) === 0) {
                    return false; // not executable
                }
            }
            catch (error) {
                // If we have trouble accessing the file, ignore the error and consider it "not executable"
                // since that's what a shell would do
            }
        }
        return true;
    }
    /**
     * Returns the list of folders where we will search for an executable,
     * based on the PATH environment variable.
     */
    static _getSearchFolders(context) {
        const pathList = context.environmentMap.get('PATH') || '';
        const folders = [];
        // Avoid processing duplicates
        const seenPaths = new Set();
        // NOTE: Cmd.exe on Windows always searches the current working directory first.
        // PowerShell and Unix shells do NOT do that, because it's a security concern.
        // We follow their behavior.
        for (const splitPath of pathList.split(path.delimiter)) {
            const trimmedPath = splitPath.trim();
            if (trimmedPath !== '') {
                if (!seenPaths.has(trimmedPath)) {
                    // Fun fact: If you put relative paths in your PATH environment variable,
                    // all shells will dynamically match them against the current working directory.
                    // This is a terrible design, and in practice nobody does that, but it is supported...
                    // so we allow it here.
                    const resolvedPath = path.resolve(context.currentWorkingDirectory, trimmedPath);
                    if (!seenPaths.has(resolvedPath)) {
                        if (FileSystem_1.FileSystem.exists(resolvedPath)) {
                            folders.push(resolvedPath);
                        }
                        seenPaths.add(resolvedPath);
                    }
                    seenPaths.add(trimmedPath);
                }
            }
        }
        return folders;
    }
    static _getExecutableContext(options) {
        if (!options) {
            options = {};
        }
        const environment = Executable._buildEnvironmentMap(options);
        let currentWorkingDirectory;
        if (options.currentWorkingDirectory) {
            currentWorkingDirectory = path.resolve(options.currentWorkingDirectory);
        }
        else {
            currentWorkingDirectory = process.cwd();
        }
        const windowsExecutableExtensions = [];
        if (os.platform() === 'win32') {
            const pathExtVariable = environment.get('PATHEXT') || '';
            for (const splitValue of pathExtVariable.split(';')) {
                const trimmed = splitValue.trim().toLowerCase();
                // Ignore malformed extensions
                if (/^\.[a-z0-9\.]*[a-z0-9]$/i.test(trimmed)) {
                    // Don't add the same extension twice
                    if (windowsExecutableExtensions.indexOf(trimmed) < 0) {
                        windowsExecutableExtensions.push(trimmed);
                    }
                }
            }
        }
        return {
            environmentMap: environment,
            currentWorkingDirectory,
            windowsExecutableExtensions
        };
    }
    /**
     * Given an input string containing special symbol characters, this inserts the "^" escape
     * character to ensure the symbols are interpreted literally by the Windows shell.
     */
    static _getEscapedForWindowsShell(text) {
        const escapableCharRegExp = /[%\^&|<> ]/g;
        return text.replace(escapableCharRegExp, (value) => '^' + value);
    }
    /**
     * Checks for characters that are unsafe to pass to a Windows batch file
     * due to the way that cmd.exe implements escaping.
     */
    static _validateArgsForWindowsShell(args) {
        const specialCharRegExp = /[%\^&|<>\r\n]/g;
        for (const arg of args) {
            const match = arg.match(specialCharRegExp);
            if (match) {
                // NOTE: It is possible to escape some of these characters by prefixing them
                // with a caret (^), which allows these characters to be successfully passed
                // through to the batch file %1 variables.  But they will be expanded again
                // whenever they are used.  For example, NPM's binary wrapper batch files
                // use "%*" to pass their arguments to Node.exe, which causes them to be expanded
                // again.  Unfortunately the Cmd.exe batch language provides native escaping
                // function (that could be used to insert the carets again).
                //
                // We could work around that by adding double carets, but in general there
                // is no way to predict how many times the variable will get expanded.
                // Thus, there is no generally reliable way to pass these characters.
                throw new Error(`The command line argument ${JSON.stringify(arg)} contains a` +
                    ` special character ${JSON.stringify(match[0])} that cannot be escaped for the Windows shell`);
            }
        }
    }
}
exports.Executable = Executable;
//# sourceMappingURL=Executable.js.map

/***/ }),

/***/ 57422:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileSystem = void 0;
const nodeJsPath = __importStar(__webpack_require__(85622));
const fs = __importStar(__webpack_require__(35747));
const fsx = __importStar(__webpack_require__(5630));
const Text_1 = __webpack_require__(77087);
const MOVE_DEFAULT_OPTIONS = {
    overwrite: true,
    ensureFolderExists: false
};
const READ_FOLDER_DEFAULT_OPTIONS = {
    absolutePaths: false
};
const WRITE_FILE_DEFAULT_OPTIONS = {
    ensureFolderExists: false,
    convertLineEndings: undefined,
    encoding: "utf8" /* Utf8 */
};
const APPEND_TO_FILE_DEFAULT_OPTIONS = Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS);
const READ_FILE_DEFAULT_OPTIONS = {
    encoding: "utf8" /* Utf8 */,
    convertLineEndings: undefined
};
const COPY_FILE_DEFAULT_OPTIONS = {
    alreadyExistsBehavior: "overwrite" /* Overwrite */
};
const COPY_FILES_DEFAULT_OPTIONS = {
    alreadyExistsBehavior: "overwrite" /* Overwrite */
};
const DELETE_FILE_DEFAULT_OPTIONS = {
    throwIfNotExists: false
};
/**
 * The FileSystem API provides a complete set of recommended operations for interacting with the file system.
 *
 * @remarks
 * We recommend to use this instead of the native `fs` API, because `fs` is a minimal set of low-level
 * primitives that must be mapped for each supported operating system. The FileSystem API takes a
 * philosophical approach of providing "one obvious way" to do each operation. We also prefer synchronous
 * operations except in cases where there would be a clear performance benefit for using async, since synchronous
 * code is much easier to read and debug. Also, indiscriminate parallelism has been seen to actually worsen
 * performance, versus improving it.
 *
 * Note that in the documentation, we refer to "filesystem objects", this can be a
 * file, folder, symbolic link, hard link, directory junction, etc.
 *
 * @public
 */
class FileSystem {
    // ===============
    // COMMON OPERATIONS
    // ===============
    /**
     * Returns true if the path exists on disk.
     * Behind the scenes it uses `fs.existsSync()`.
     * @remarks
     * There is a debate about the fact that after `fs.existsSync()` returns true,
     * the file might be deleted before fs.readSync() is called, which would imply that everybody
     * should catch a `readSync()` exception, and nobody should ever use `fs.existsSync()`.
     * We find this to be unpersuasive, since "unexceptional exceptions" really hinder the
     * break-on-exception debugging experience. Also, throwing/catching is generally slow.
     * @param path - The absolute or relative path to the filesystem object.
     */
    static exists(path) {
        return FileSystem._wrapException(() => {
            return fsx.existsSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.exists}.
     */
    static async existsAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return new Promise((resolve) => {
                fsx.exists(path, resolve);
            });
        });
    }
    /**
     * Gets the statistics for a particular filesystem object.
     * If the path is a link, this function follows the link and returns statistics about the link target.
     * Behind the scenes it uses `fs.statSync()`.
     * @param path - The absolute or relative path to the filesystem object.
     */
    static getStatistics(path) {
        return FileSystem._wrapException(() => {
            return fsx.statSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.getStatistics}.
     */
    static async getStatisticsAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.stat(path);
        });
    }
    /**
     * Updates the accessed and modified timestamps of the filesystem object referenced by path.
     * Behind the scenes it uses `fs.utimesSync()`.
     * The caller should specify both times in the `times` parameter.
     * @param path - The path of the file that should be modified.
     * @param times - The times that the object should be updated to reflect.
     */
    static updateTimes(path, times) {
        return FileSystem._wrapException(() => {
            fsx.utimesSync(path, times.accessedTime, times.modifiedTime);
        });
    }
    /**
     * An async version of {@link FileSystem.updateTimes}.
     */
    static async updateTimesAsync(path, times) {
        await FileSystem._wrapExceptionAsync(() => {
            // This cast is needed because the fs-extra typings require both parameters
            // to have the same type (number or Date), whereas Node.js does not require that.
            return fsx.utimes(path, times.accessedTime, times.modifiedTime);
        });
    }
    /**
     * Changes the permissions (i.e. file mode bits) for a filesystem object.
     * Behind the scenes it uses `fs.chmodSync()`.
     * @param path - The absolute or relative path to the object that should be updated.
     * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum
     */
    static changePosixModeBits(path, mode) {
        FileSystem._wrapException(() => {
            fs.chmodSync(path, mode);
        });
    }
    /**
     * An async version of {@link FileSystem.changePosixModeBits}.
     */
    static async changePosixModeBitsAsync(path, mode) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.chmod(path, mode);
        });
    }
    /**
     * Retrieves the permissions (i.e. file mode bits) for a filesystem object.
     * Behind the scenes it uses `fs.chmodSync()`.
     * @param path - The absolute or relative path to the object that should be updated.
     *
     * @remarks
     * This calls {@link FileSystem.getStatistics} to get the POSIX mode bits.
     * If statistics in addition to the mode bits are needed, it is more efficient
     * to call {@link FileSystem.getStatistics} directly instead.
     */
    static getPosixModeBits(path) {
        return FileSystem._wrapException(() => {
            return FileSystem.getStatistics(path).mode;
        });
    }
    /**
     * An async version of {@link FileSystem.getPosixModeBits}.
     */
    static async getPosixModeBitsAsync(path) {
        return await FileSystem._wrapExceptionAsync(async () => {
            return (await FileSystem.getStatisticsAsync(path)).mode;
        });
    }
    /**
     * Returns a 10-character string representation of a PosixModeBits value similar to what
     * would be displayed by a command such as "ls -l" on a POSIX-like operating system.
     * @remarks
     * For example, `PosixModeBits.AllRead | PosixModeBits.AllWrite` would be formatted as "-rw-rw-rw-".
     * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum
     */
    static formatPosixModeBits(modeBits) {
        let result = '-'; // (later we may add support for additional states such as S_IFDIR or S_ISUID)
        result += modeBits & 256 /* UserRead */ ? 'r' : '-';
        result += modeBits & 128 /* UserWrite */ ? 'w' : '-';
        result += modeBits & 64 /* UserExecute */ ? 'x' : '-';
        result += modeBits & 32 /* GroupRead */ ? 'r' : '-';
        result += modeBits & 16 /* GroupWrite */ ? 'w' : '-';
        result += modeBits & 8 /* GroupExecute */ ? 'x' : '-';
        result += modeBits & 4 /* OthersRead */ ? 'r' : '-';
        result += modeBits & 2 /* OthersWrite */ ? 'w' : '-';
        result += modeBits & 1 /* OthersExecute */ ? 'x' : '-';
        return result;
    }
    /**
     * Moves a file. The folder must exist, unless the `ensureFolderExists` option is provided.
     * Behind the scenes it uses `fs-extra.moveSync()`
     */
    static move(options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, MOVE_DEFAULT_OPTIONS), options);
            try {
                fsx.moveSync(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(options.destinationPath);
                    FileSystem.ensureFolder(folderPath);
                    fsx.moveSync(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.move}.
     */
    static async moveAsync(options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, MOVE_DEFAULT_OPTIONS), options);
            try {
                await fsx.move(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(options.destinationPath);
                    await FileSystem.ensureFolderAsync(nodeJsPath.dirname(folderPath));
                    await fsx.move(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
                }
                else {
                    throw error;
                }
            }
        });
    }
    // ===============
    // FOLDER OPERATIONS
    // ===============
    /**
     * Recursively creates a folder at a given path.
     * Behind the scenes is uses `fs-extra.ensureDirSync()`.
     * @remarks
     * Throws an exception if anything in the folderPath is not a folder.
     * @param folderPath - The absolute or relative path of the folder which should be created.
     */
    static ensureFolder(folderPath) {
        FileSystem._wrapException(() => {
            fsx.ensureDirSync(folderPath);
        });
    }
    /**
     * An async version of {@link FileSystem.ensureFolder}.
     */
    static async ensureFolderAsync(folderPath) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.ensureDir(folderPath);
        });
    }
    /**
     * Reads the contents of the folder, not including "." or "..".
     * Behind the scenes it uses `fs.readdirSync()`.
     * @param folderPath - The absolute or relative path to the folder which should be read.
     * @param options - Optional settings that can change the behavior. Type: `IReadFolderOptions`
     */
    static readFolder(folderPath, options) {
        return FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, READ_FOLDER_DEFAULT_OPTIONS), options);
            // @todo: Update this to use Node 10's `withFileTypes: true` option when we drop support for Node 8
            const fileNames = fsx.readdirSync(folderPath);
            if (options.absolutePaths) {
                return fileNames.map((fileName) => nodeJsPath.resolve(folderPath, fileName));
            }
            else {
                return fileNames;
            }
        });
    }
    /**
     * An async version of {@link FileSystem.readFolder}.
     */
    static async readFolderAsync(folderPath, options) {
        return await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, READ_FOLDER_DEFAULT_OPTIONS), options);
            // @todo: Update this to use Node 10's `withFileTypes: true` option when we drop support for Node 8
            const fileNames = await fsx.readdir(folderPath);
            if (options.absolutePaths) {
                return fileNames.map((fileName) => nodeJsPath.resolve(folderPath, fileName));
            }
            else {
                return fileNames;
            }
        });
    }
    /**
     * Deletes a folder, including all of its contents.
     * Behind the scenes is uses `fs-extra.removeSync()`.
     * @remarks
     * Does not throw if the folderPath does not exist.
     * @param folderPath - The absolute or relative path to the folder which should be deleted.
     */
    static deleteFolder(folderPath) {
        FileSystem._wrapException(() => {
            fsx.removeSync(folderPath);
        });
    }
    /**
     * An async version of {@link FileSystem.deleteFolder}.
     */
    static async deleteFolderAsync(folderPath) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.remove(folderPath);
        });
    }
    /**
     * Deletes the content of a folder, but not the folder itself. Also ensures the folder exists.
     * Behind the scenes it uses `fs-extra.emptyDirSync()`.
     * @remarks
     * This is a workaround for a common race condition, where the virus scanner holds a lock on the folder
     * for a brief period after it was deleted, causing EBUSY errors for any code that tries to recreate the folder.
     * @param folderPath - The absolute or relative path to the folder which should have its contents deleted.
     */
    static ensureEmptyFolder(folderPath) {
        FileSystem._wrapException(() => {
            fsx.emptyDirSync(folderPath);
        });
    }
    /**
     * An async version of {@link FileSystem.ensureEmptyFolder}.
     */
    static async ensureEmptyFolderAsync(folderPath) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.emptyDir(folderPath);
        });
    }
    // ===============
    // FILE OPERATIONS
    // ===============
    /**
     * Writes a text string to a file on disk, overwriting the file if it already exists.
     * Behind the scenes it uses `fs.writeFileSync()`.
     * @remarks
     * Throws an error if the folder doesn't exist, unless ensureFolder=true.
     * @param filePath - The absolute or relative path of the file.
     * @param contents - The text that should be written to the file.
     * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`
     */
    static writeFile(filePath, contents, options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                fsx.writeFileSync(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    FileSystem.ensureFolder(folderPath);
                    fsx.writeFileSync(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.writeFile}.
     */
    static async writeFileAsync(filePath, contents, options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                await fsx.writeFile(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    await FileSystem.ensureFolderAsync(folderPath);
                    await fsx.writeFile(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * Writes a text string to a file on disk, appending to the file if it already exists.
     * Behind the scenes it uses `fs.appendFileSync()`.
     * @remarks
     * Throws an error if the folder doesn't exist, unless ensureFolder=true.
     * @param filePath - The absolute or relative path of the file.
     * @param contents - The text that should be written to the file.
     * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`
     */
    static appendToFile(filePath, contents, options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, APPEND_TO_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                fsx.appendFileSync(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    FileSystem.ensureFolder(folderPath);
                    fsx.appendFileSync(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.appendToFile}.
     */
    static async appendToFileAsync(filePath, contents, options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, APPEND_TO_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                await fsx.appendFile(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    await FileSystem.ensureFolderAsync(folderPath);
                    await fsx.appendFile(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * Reads the contents of a file into a string.
     * Behind the scenes it uses `fs.readFileSync()`.
     * @param filePath - The relative or absolute path to the file whose contents should be read.
     * @param options - Optional settings that can change the behavior. Type: `IReadFileOptions`
     */
    static readFile(filePath, options) {
        return FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, READ_FILE_DEFAULT_OPTIONS), options);
            let contents = FileSystem.readFileToBuffer(filePath).toString(options.encoding);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents, options.convertLineEndings);
            }
            return contents;
        });
    }
    /**
     * An async version of {@link FileSystem.readFile}.
     */
    static async readFileAsync(filePath, options) {
        return await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, READ_FILE_DEFAULT_OPTIONS), options);
            let contents = (await FileSystem.readFileToBufferAsync(filePath)).toString(options.encoding);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents, options.convertLineEndings);
            }
            return contents;
        });
    }
    /**
     * Reads the contents of a file into a buffer.
     * Behind the scenes is uses `fs.readFileSync()`.
     * @param filePath - The relative or absolute path to the file whose contents should be read.
     */
    static readFileToBuffer(filePath) {
        return FileSystem._wrapException(() => {
            return fsx.readFileSync(filePath);
        });
    }
    /**
     * An async version of {@link FileSystem.readFileToBuffer}.
     */
    static async readFileToBufferAsync(filePath) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.readFile(filePath);
        });
    }
    /**
     * Copies a single file from one location to another.
     * By default, destinationPath is overwritten if it already exists.
     *
     * @remarks
     * The `copyFile()` API cannot be used to copy folders.  It copies at most one file.
     * Use {@link FileSystem.copyFiles} if you need to recursively copy a tree of folders.
     *
     * The implementation is based on `copySync()` from the `fs-extra` package.
     */
    static copyFile(options) {
        options = Object.assign(Object.assign({}, COPY_FILE_DEFAULT_OPTIONS), options);
        if (FileSystem.getStatistics(options.sourcePath).isDirectory()) {
            throw new Error('The specified path refers to a folder; this operation expects a file object:\n' + options.sourcePath);
        }
        FileSystem._wrapException(() => {
            fsx.copySync(options.sourcePath, options.destinationPath, {
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */
            });
        });
    }
    /**
     * An async version of {@link FileSystem.copyFile}.
     */
    static async copyFileAsync(options) {
        options = Object.assign(Object.assign({}, COPY_FILE_DEFAULT_OPTIONS), options);
        if (FileSystem.getStatistics(options.sourcePath).isDirectory()) {
            throw new Error('The specified path refers to a folder; this operation expects a file object:\n' + options.sourcePath);
        }
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.copy(options.sourcePath, options.destinationPath, {
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */
            });
        });
    }
    /**
     * Copies a file or folder from one location to another, recursively copying any folder contents.
     * By default, destinationPath is overwritten if it already exists.
     *
     * @remarks
     * If you only intend to copy a single file, it is recommended to use {@link FileSystem.copyFile}
     * instead to more clearly communicate the intended operation.
     *
     * The implementation is based on `copySync()` from the `fs-extra` package.
     */
    static copyFiles(options) {
        options = Object.assign(Object.assign({}, COPY_FILES_DEFAULT_OPTIONS), options);
        FileSystem._wrapException(() => {
            fsx.copySync(options.sourcePath, options.destinationPath, {
                dereference: !!options.dereferenceSymlinks,
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */,
                preserveTimestamps: !!options.preserveTimestamps,
                filter: options.filter
            });
        });
    }
    /**
     * An async version of {@link FileSystem.copyFiles}.
     */
    static async copyFilesAsync(options) {
        options = Object.assign(Object.assign({}, COPY_FILES_DEFAULT_OPTIONS), options);
        await FileSystem._wrapExceptionAsync(async () => {
            fsx.copySync(options.sourcePath, options.destinationPath, {
                dereference: !!options.dereferenceSymlinks,
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */,
                preserveTimestamps: !!options.preserveTimestamps,
                filter: options.filter
            });
        });
    }
    /**
     * Deletes a file. Can optionally throw if the file doesn't exist.
     * Behind the scenes it uses `fs.unlinkSync()`.
     * @param filePath - The absolute or relative path to the file that should be deleted.
     * @param options - Optional settings that can change the behavior. Type: `IDeleteFileOptions`
     */
    static deleteFile(filePath, options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, DELETE_FILE_DEFAULT_OPTIONS), options);
            try {
                fsx.unlinkSync(filePath);
            }
            catch (error) {
                if (options.throwIfNotExists || !FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.deleteFile}.
     */
    static async deleteFileAsync(filePath, options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, DELETE_FILE_DEFAULT_OPTIONS), options);
            try {
                await fsx.unlink(filePath);
            }
            catch (error) {
                if (options.throwIfNotExists || !FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        });
    }
    // ===============
    // LINK OPERATIONS
    // ===============
    /**
     * Gets the statistics of a filesystem object. Does NOT follow the link to its target.
     * Behind the scenes it uses `fs.lstatSync()`.
     * @param path - The absolute or relative path to the filesystem object.
     */
    static getLinkStatistics(path) {
        return FileSystem._wrapException(() => {
            return fsx.lstatSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.getLinkStatistics}.
     */
    static async getLinkStatisticsAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.lstat(path);
        });
    }
    /**
     * If `path` refers to a symbolic link, this returns the path of the link target, which may be
     * an absolute or relative path.
     *
     * @remarks
     * If `path` refers to a filesystem object that is not a symbolic link, then an `ErrnoException` is thrown
     * with code 'UNKNOWN'.  If `path` does not exist, then an `ErrnoException` is thrown with code `ENOENT`.
     *
     * @param path - The absolute or relative path to the symbolic link.
     * @returns the path of the link target
     */
    static readLink(path) {
        return FileSystem._wrapException(() => {
            return fsx.readlinkSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.readLink}.
     */
    static async readLinkAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.readlink(path);
        });
    }
    /**
     * Creates an NTFS "directory junction" on Windows operating systems; for other operating systems, it
     * creates a regular symbolic link.  The link target must be a folder, not a file.
     * Behind the scenes it uses `fs.symlinkSync()`.
     *
     * @remarks
     * For security reasons, Windows operating systems by default require administrator elevation to create
     * symbolic links.  As a result, on Windows it's generally recommended for Node.js tools to use hard links
     * (for files) or NTFS directory junctions (for folders), since regular users are allowed to create them.
     * Hard links and junctions are less vulnerable to symlink attacks because they cannot reference a network share,
     * and their target must exist at the time of link creation.  Non-Windows operating systems generally don't
     * restrict symlink creation, and as such are more vulnerable to symlink attacks.  Note that Windows can be
     * configured to permit regular users to create symlinks, for example by enabling Windows 10 "developer mode."
     *
     * A directory junction requires the link source and target to both be located on local disk volumes;
     * if not, use a symbolic link instead.
     */
    static createSymbolicLinkJunction(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                // For directories, we use a Windows "junction".  On POSIX operating systems, this produces a regular symlink.
                return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'junction');
            }, options);
        });
    }
    /**
     * An async version of {@link FileSystem.createSymbolicLinkJunction}.
     */
    static async createSymbolicLinkJunctionAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                // For directories, we use a Windows "junction".  On POSIX operating systems, this produces a regular symlink.
                return fsx.symlink(options.linkTargetPath, options.newLinkPath, 'junction');
            }, options);
        });
    }
    /**
     * Creates a symbolic link to a file.  On Windows operating systems, this may require administrator elevation.
     * Behind the scenes it uses `fs.symlinkSync()`.
     *
     * @remarks
     * To avoid administrator elevation on Windows, use {@link FileSystem.createHardLink} instead.
     *
     * On Windows operating systems, the NTFS file system distinguishes file symlinks versus directory symlinks:
     * If the target is not the correct type, the symlink will be created successfully, but will fail to resolve.
     * Other operating systems do not make this distinction, in which case {@link FileSystem.createSymbolicLinkFile}
     * and {@link FileSystem.createSymbolicLinkFolder} can be used interchangeably, but doing so will make your
     * tool incompatible with Windows.
     */
    static createSymbolicLinkFile(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'file');
            }, options);
        });
    }
    /**
     * An async version of {@link FileSystem.createSymbolicLinkFile}.
     */
    static async createSymbolicLinkFileAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                return fsx.symlink(options.linkTargetPath, options.newLinkPath, 'file');
            }, options);
        });
    }
    /**
     * Creates a symbolic link to a folder.  On Windows operating systems, this may require administrator elevation.
     * Behind the scenes it uses `fs.symlinkSync()`.
     *
     * @remarks
     * To avoid administrator elevation on Windows, use {@link FileSystem.createSymbolicLinkJunction} instead.
     *
     * On Windows operating systems, the NTFS file system distinguishes file symlinks versus directory symlinks:
     * If the target is not the correct type, the symlink will be created successfully, but will fail to resolve.
     * Other operating systems do not make this distinction, in which case {@link FileSystem.createSymbolicLinkFile}
     * and {@link FileSystem.createSymbolicLinkFolder} can be used interchangeably, but doing so will make your
     * tool incompatible with Windows.
     */
    static createSymbolicLinkFolder(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'dir');
            }, options);
        });
    }
    /**
     * An async version of {@link FileSystem.createSymbolicLinkFolder}.
     */
    static async createSymbolicLinkFolderAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                return fsx.symlink(options.linkTargetPath, options.newLinkPath, 'dir');
            }, options);
        });
    }
    /**
     * Creates a hard link.  The link target must be a file, not a folder.
     * Behind the scenes it uses `fs.linkSync()`.
     *
     * @remarks
     * For security reasons, Windows operating systems by default require administrator elevation to create
     * symbolic links.  As a result, on Windows it's generally recommended for Node.js tools to use hard links
     * (for files) or NTFS directory junctions (for folders), since regular users are allowed to create them.
     * Hard links and junctions are less vulnerable to symlink attacks because they cannot reference a network share,
     * and their target must exist at the time of link creation.  Non-Windows operating systems generally don't
     * restrict symlink creation, and as such are more vulnerable to symlink attacks.  Note that Windows can be
     * configured to permit regular users to create symlinks, for example by enabling Windows 10 "developer mode."
     *
     * A hard link requires the link source and target to both be located on same disk volume;
     * if not, use a symbolic link instead.
     */
    static createHardLink(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                return fsx.linkSync(options.linkTargetPath, options.newLinkPath);
            }, Object.assign(Object.assign({}, options), { linkTargetMustExist: true }));
        });
    }
    /**
     * An async version of {@link FileSystem.createHardLink}.
     */
    static async createHardLinkAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                return fsx.link(options.linkTargetPath, options.newLinkPath);
            }, Object.assign(Object.assign({}, options), { linkTargetMustExist: true }));
        });
    }
    /**
     * Follows a link to its destination and returns the absolute path to the final target of the link.
     * Behind the scenes it uses `fs.realpathSync()`.
     * @param linkPath - The path to the link.
     */
    static getRealPath(linkPath) {
        return FileSystem._wrapException(() => {
            return fsx.realpathSync(linkPath);
        });
    }
    /**
     * An async version of {@link FileSystem.getRealPath}.
     */
    static async getRealPathAsync(linkPath) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.realpath(linkPath);
        });
    }
    // ===============
    // UTILITY FUNCTIONS
    // ===============
    /**
     * Returns true if the error object indicates the file or folder already exists (`EEXIST`).
     */
    static isExistError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'EEXIST';
    }
    /**
     * Returns true if the error object indicates the file or folder does not exist (`ENOENT` or `ENOTDIR`)
     */
    static isNotExistError(error) {
        return FileSystem.isFileDoesNotExistError(error) || FileSystem.isFolderDoesNotExistError(error);
    }
    /**
     * Returns true if the error object indicates the file does not exist (`ENOENT`).
     */
    static isFileDoesNotExistError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'ENOENT';
    }
    /**
     * Returns true if the error object indicates the folder does not exist (`ENOTDIR`).
     */
    static isFolderDoesNotExistError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'ENOTDIR';
    }
    /**
     * Returns true if the error object indicates that the `unlink` system call failed
     * due to a permissions issue (`EPERM`).
     */
    static isUnlinkNotPermittedError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'EPERM' && error.syscall === 'unlink';
    }
    /**
     * Detects if the provided error object is a `NodeJS.ErrnoException`
     */
    static isErrnoException(error) {
        const typedError = error;
        return (typeof typedError.code === 'string' &&
            typeof typedError.errno === 'number' &&
            typeof typedError.path === 'string' &&
            typeof typedError.syscall === 'string');
    }
    static _handleLink(linkFn, options) {
        try {
            linkFn();
        }
        catch (error) {
            if (FileSystem.isExistError(error)) {
                // Link exists, handle it
                switch (options.alreadyExistsBehavior) {
                    case "ignore" /* Ignore */:
                        break;
                    case "overwrite" /* Overwrite */:
                        // fsx.linkSync does not allow overwriting so we must manually delete. If it's
                        // a folder, it will throw an error.
                        this.deleteFile(options.newLinkPath);
                        linkFn();
                        break;
                    case "error" /* Error */:
                    default:
                        throw error;
                }
            }
            else {
                // When attempting to create a link in a directory that does not exist, an ENOENT
                // or ENOTDIR error is thrown, so we should ensure the directory exists before
                // retrying. There are also cases where the target file must exist, so validate in
                // those cases to avoid confusing the missing directory with the missing target file.
                if (FileSystem.isNotExistError(error) &&
                    (!options.linkTargetMustExist || FileSystem.exists(options.linkTargetPath))) {
                    this.ensureFolder(nodeJsPath.dirname(options.newLinkPath));
                    linkFn();
                }
                else {
                    throw error;
                }
            }
        }
    }
    static async _handleLinkAsync(linkFn, options) {
        try {
            await linkFn();
        }
        catch (error) {
            if (FileSystem.isExistError(error)) {
                // Link exists, handle it
                switch (options.alreadyExistsBehavior) {
                    case "ignore" /* Ignore */:
                        break;
                    case "overwrite" /* Overwrite */:
                        // fsx.linkSync does not allow overwriting so we must manually delete. If it's
                        // a folder, it will throw an error.
                        await this.deleteFileAsync(options.newLinkPath);
                        await linkFn();
                        break;
                    case "error" /* Error */:
                    default:
                        throw error;
                }
            }
            else {
                // When attempting to create a link in a directory that does not exist, an ENOENT
                // or ENOTDIR error is thrown, so we should ensure the directory exists before
                // retrying. There are also cases where the target file must exist, so validate in
                // those cases to avoid confusing the missing directory with the missing target file.
                if (FileSystem.isNotExistError(error) &&
                    (!options.linkTargetMustExist || (await FileSystem.existsAsync(options.linkTargetPath)))) {
                    await this.ensureFolderAsync(nodeJsPath.dirname(options.newLinkPath));
                    await linkFn();
                }
                else {
                    throw error;
                }
            }
        }
    }
    static _wrapException(fn) {
        try {
            return fn();
        }
        catch (error) {
            FileSystem._updateErrorMessage(error);
            throw error;
        }
    }
    static async _wrapExceptionAsync(fn) {
        try {
            return await fn();
        }
        catch (error) {
            FileSystem._updateErrorMessage(error);
            throw error;
        }
    }
    static _updateErrorMessage(error) {
        if (FileSystem.isErrnoException(error)) {
            if (FileSystem.isFileDoesNotExistError(error)) {
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `File does not exist: ${error.path}\n${error.message}`;
            }
            else if (FileSystem.isFolderDoesNotExistError(error)) {
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `Folder does not exist: ${error.path}\n${error.message}`;
            }
            else if (FileSystem.isExistError(error)) {
                // Oddly, the typing does not include the `dest` property even though the documentation
                // indicates it is there: https://nodejs.org/docs/latest-v10.x/api/errors.html#errors_error_dest
                const extendedError = error;
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `File or folder already exists: ${extendedError.dest}\n${error.message}`;
            }
            else if (FileSystem.isUnlinkNotPermittedError(error)) {
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `File or folder could not be deleted: ${error.path}\n${error.message}`;
            }
        }
    }
}
exports.FileSystem = FileSystem;
//# sourceMappingURL=FileSystem.js.map

/***/ }),

/***/ 71135:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileWriter = void 0;
const Import_1 = __webpack_require__(61503);
const fsx = Import_1.Import.lazy('fs-extra', require);
/**
 * API for interacting with file handles.
 * @public
 */
class FileWriter {
    constructor(fileDescriptor, filePath) {
        this._fileDescriptor = fileDescriptor;
        this.filePath = filePath;
    }
    /**
     * Opens a new file handle to the file at the specified path and given mode.
     * Behind the scenes it uses `fs.openSync()`.
     * The behaviour of this function is platform specific.
     * See: https://nodejs.org/docs/latest-v8.x/api/fs.html#fs_fs_open_path_flags_mode_callback
     * @param filePath - The absolute or relative path to the file handle that should be opened.
     * @param flags - The flags for opening the handle
     */
    static open(filePath, flags) {
        return new FileWriter(fsx.openSync(filePath, FileWriter._convertFlagsForNode(flags)), filePath);
    }
    /**
     * Helper function to convert the file writer array to a Node.js style string (e.g. "wx" or "a").
     * @param flags - The flags that should be converted.
     */
    static _convertFlagsForNode(flags) {
        flags = Object.assign({ append: false, exclusive: false }, flags);
        return [flags.append ? 'a' : 'w', flags.exclusive ? 'x' : ''].join('');
    }
    /**
     * Writes some text to the given file handle. Throws if the file handle has been closed.
     * Behind the scenes it uses `fs.writeSync()`.
     * @param text - The text to write to the file.
     */
    write(text) {
        if (!this._fileDescriptor) {
            throw new Error(`Cannot write to file, file descriptor has already been released.`);
        }
        fsx.writeSync(this._fileDescriptor, text);
    }
    /**
     * Closes the file handle permanently. No operations can be made on this file handle after calling this.
     * Behind the scenes it uses `fs.closeSync()` and releases the file descriptor to be re-used.
     *
     * @remarks
     * The `close()` method can be called more than once; additional calls are ignored.
     */
    close() {
        const fd = this._fileDescriptor;
        if (fd) {
            this._fileDescriptor = undefined;
            fsx.closeSync(fd);
        }
    }
}
exports.FileWriter = FileWriter;
//# sourceMappingURL=FileWriter.js.map

/***/ }),

/***/ 61503:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Import = void 0;
const path = __importStar(__webpack_require__(85622));
const importLazy = __webpack_require__(41239);
const Resolve = __importStar(__webpack_require__(32374));
const nodeModule = __webpack_require__(32282);
const PackageJsonLookup_1 = __webpack_require__(42172);
const FileSystem_1 = __webpack_require__(57422);
/**
 * Helpers for resolving and importing Node.js modules.
 * @public
 */
class Import {
    static get _builtInModules() {
        if (!Import.__builtInModules) {
            Import.__builtInModules = new Set(nodeModule.builtinModules);
        }
        return Import.__builtInModules;
    }
    /**
     * Provides a way to improve process startup times by lazy-loading imported modules.
     *
     * @remarks
     * This is a more structured wrapper for the {@link https://www.npmjs.com/package/import-lazy|import-lazy}
     * package.  It enables you to replace an import like this:
     *
     * ```ts
     * import * as example from 'example'; // <-- 100ms load time
     *
     * if (condition) {
     *   example.doSomething();
     * }
     * ```
     *
     * ...with a pattern like this:
     *
     * ```ts
     * const example: typeof import('example') = Import.lazy('example', require);
     *
     * if (condition) {
     *   example.doSomething(); // <-- 100ms load time occurs here, only if needed
     * }
     * ```
     *
     * The implementation relies on JavaScript's `Proxy` feature to intercept access to object members.  Thus
     * it will only work correctly with certain types of module exports.  If a particular export isn't well behaved,
     * you may need to find (or introduce) some other module in your dependency graph to apply the optimization to.
     *
     * Usage guidelines:
     *
     * - Always specify types using `typeof` as shown above.
     *
     * - Never apply lazy-loading in a way that would convert the module's type to `any`. Losing type safety
     *   seriously impacts the maintainability of the code base.
     *
     * - In cases where the non-runtime types are needed, import them separately using the `Types` suffix:
     *
     * ```ts
     * const example: typeof import('example') = Import.lazy('example', require);
     * import type * as exampleTypes from 'example';
     * ```
     *
     * - If the imported module confusingly has the same name as its export, then use the Module suffix:
     *
     * ```ts
     * const exampleModule: typeof import('../../logic/Example') = Import.lazy(
     *   '../../logic/Example', require);
     * import type * as exampleTypes from '../../logic/Example';
     * ```
     *
     * - If the exports cause a lot of awkwardness (e.g. too many expressions need to have `exampleModule.` inserted
     *   into them), or if some exports cannot be proxied (e.g. `Import.lazy('example', require)` returns a function
     *   signature), then do not lazy-load that module.  Instead, apply lazy-loading to some other module which is
     *   better behaved.
     *
     * - It's recommended to sort imports in a standard ordering:
     *
     * ```ts
     * // 1. external imports
     * import * as path from 'path';
     * import { Import, JsonFile, JsonObject } from '@rushstack/node-core-library';
     *
     * // 2. local imports
     * import { LocalFile } from './path/LocalFile';
     *
     * // 3. lazy-imports (which are technically variables, not imports)
     * const semver: typeof import('semver') = Import.lazy('semver', require);
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static lazy(moduleName, require) {
        const importLazyLocal = importLazy(require);
        return importLazyLocal(moduleName);
    }
    /**
     * This resolves a module path using similar logic as the Node.js `require.resolve()` API,
     * but supporting extra features such as specifying the base folder.
     *
     * @remarks
     * A module path is a text string that might appear in a statement such as
     * `import { X } from "____";` or `const x = require("___");`.  The implementation is based
     * on the popular `resolve` NPM package.
     *
     * Suppose `example` is an NPM package whose entry point is `lib/index.js`:
     * ```ts
     * // Returns "/path/to/project/node_modules/example/lib/index.js"
     * Import.resolveModule({ modulePath: 'example' });
     *
     * // Returns "/path/to/project/node_modules/example/lib/other.js"
     * Import.resolveModule({ modulePath: 'example/lib/other' });
     * ```
     * If you need to determine the containing package folder
     * (`/path/to/project/node_modules/example`), use {@link Import.resolvePackage} instead.
     *
     * @returns the absolute path of the resolved module.
     * If {@link IImportResolveOptions.includeSystemModules} is specified
     * and a system module is found, then its name is returned without any file path.
     */
    static resolveModule(options) {
        const { modulePath } = options;
        if (path.isAbsolute(modulePath)) {
            return modulePath;
        }
        const normalizedRootPath = FileSystem_1.FileSystem.getRealPath(options.baseFolderPath);
        if (modulePath.startsWith('.')) {
            // This looks like a conventional relative path
            return path.resolve(normalizedRootPath, modulePath);
        }
        if (options.includeSystemModules === true && Import._builtInModules.has(modulePath)) {
            return modulePath;
        }
        if (options.allowSelfReference === true) {
            const ownPackage = Import._getPackageName(options.baseFolderPath);
            if (ownPackage && modulePath.startsWith(ownPackage.packageName)) {
                const packagePath = modulePath.substr(ownPackage.packageName.length + 1);
                return path.resolve(ownPackage.packageRootPath, packagePath);
            }
        }
        try {
            return Resolve.sync(
            // Append a slash to the package name to ensure `resolve.sync` doesn't attempt to return a system package
            options.includeSystemModules !== true && modulePath.indexOf('/') === -1
                ? `${modulePath}/`
                : modulePath, {
                basedir: normalizedRootPath,
                preserveSymlinks: false
            });
        }
        catch (e) {
            throw new Error(`Cannot find module "${modulePath}" from "${options.baseFolderPath}".`);
        }
    }
    /**
     * Performs module resolution to determine the folder where a package is installed.
     *
     * @remarks
     * Suppose `example` is an NPM package whose entry point is `lib/index.js`:
     * ```ts
     * // Returns "/path/to/project/node_modules/example"
     * Import.resolvePackage({ packageName: 'example' });
     * ```
     *
     * If you need to resolve a module path, use {@link Import.resolveModule} instead:
     * ```ts
     * // Returns "/path/to/project/node_modules/example/lib/index.js"
     * Import.resolveModule({ modulePath: 'example' });
     * ```
     *
     * @returns the absolute path of the package folder.
     * If {@link IImportResolveOptions.includeSystemModules} is specified
     * and a system module is found, then its name is returned without any file path.
     */
    static resolvePackage(options) {
        const { packageName } = options;
        if (options.includeSystemModules && Import._builtInModules.has(packageName)) {
            return packageName;
        }
        const normalizedRootPath = FileSystem_1.FileSystem.getRealPath(options.baseFolderPath);
        if (options.allowSelfReference) {
            const ownPackage = Import._getPackageName(options.baseFolderPath);
            if (ownPackage && ownPackage.packageName === packageName) {
                return ownPackage.packageRootPath;
            }
        }
        try {
            const resolvedPath = Resolve.sync(packageName, {
                basedir: normalizedRootPath,
                preserveSymlinks: false,
                packageFilter: (pkg) => {
                    // Hardwire "main" to point to a file that is guaranteed to exist.
                    // This helps resolve packages such as @types/node that have no entry point.
                    // And then we can use path.dirname() below to locate the package folder,
                    // even if the real entry point was in an subfolder with arbitrary nesting.
                    pkg.main = 'package.json';
                    return pkg;
                }
            });
            const packagePath = path.dirname(resolvedPath);
            const packageJson = PackageJsonLookup_1.PackageJsonLookup.instance.loadPackageJson(path.join(packagePath, 'package.json'));
            if (packageJson.name === packageName) {
                return packagePath;
            }
            else {
                throw new Error();
            }
        }
        catch (e) {
            throw new Error(`Cannot find package "${packageName}" from "${options.baseFolderPath}".`);
        }
    }
    static _getPackageName(rootPath) {
        const packageJsonPath = PackageJsonLookup_1.PackageJsonLookup.instance.tryGetPackageJsonFilePathFor(rootPath);
        if (packageJsonPath) {
            const packageJson = PackageJsonLookup_1.PackageJsonLookup.instance.loadPackageJson(packageJsonPath);
            return {
                packageRootPath: path.dirname(packageJsonPath),
                packageName: packageJson.name
            };
        }
        else {
            return undefined;
        }
    }
}
exports.Import = Import;
//# sourceMappingURL=Import.js.map

/***/ }),

/***/ 28630:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InternalError = void 0;
/**
 * An `Error` subclass that should be thrown to report an unexpected state that may indicate a software defect.
 * An application may handle this error by instructing the end user to report an issue to the application maintainers.
 *
 * @remarks
 * Do not use this class unless you intend to solicit bug reports from end users.
 *
 * @public
 */
class InternalError extends Error {
    /**
     * Constructs a new instance of the {@link InternalError} class.
     *
     * @param message - A message describing the error.  This will be assigned to
     * {@link InternalError.unformattedMessage}.  The `Error.message` field will have additional boilerplate
     * explaining that the user has encountered a software defect.
     */
    constructor(message) {
        super(InternalError._formatMessage(message));
        // Manually set the prototype, as we can no longer extend built-in classes like Error, Array, Map, etc.
        // https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        //
        // Note: the prototype must also be set on any classes which extend this one
        this.__proto__ = InternalError.prototype; // eslint-disable-line @typescript-eslint/no-explicit-any
        this.unformattedMessage = message;
        if (InternalError.breakInDebugger) {
            // eslint-disable-next-line no-debugger
            debugger;
        }
    }
    static _formatMessage(unformattedMessage) {
        return (`Internal Error: ${unformattedMessage}\n\nYou have encountered a software defect. Please consider` +
            ` reporting the issue to the maintainers of this application.`);
    }
    /** @override */
    toString() {
        return this.message; // Avoid adding the "Error:" prefix
    }
}
exports.InternalError = InternalError;
/**
 * If true, a JavScript `debugger;` statement will be invoked whenever the `InternalError` constructor is called.
 *
 * @remarks
 * Generally applications should not be catching and ignoring an `InternalError`.  Instead, the error should
 * be reported and typically the application will terminate.  Thus, if `InternalError` is constructed, it's
 * almost always something we want to examine in a debugger.
 */
InternalError.breakInDebugger = true;
//# sourceMappingURL=InternalError.js.map

/***/ }),

/***/ 17058:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonFile = void 0;
const os = __importStar(__webpack_require__(12087));
const jju = __importStar(__webpack_require__(93304));
const Text_1 = __webpack_require__(77087);
const FileSystem_1 = __webpack_require__(57422);
const DEFAULT_ENCODING = 'utf8';
/**
 * Utilities for reading/writing JSON files.
 * @public
 */
class JsonFile {
    /**
     * Loads a JSON file.
     */
    static load(jsonFilename) {
        try {
            const contents = FileSystem_1.FileSystem.readFile(jsonFilename);
            return jju.parse(contents);
        }
        catch (error) {
            if (FileSystem_1.FileSystem.isNotExistError(error)) {
                throw error;
            }
            else {
                throw new Error(`Error reading "${JsonFile._formatPathForError(jsonFilename)}":` +
                    os.EOL +
                    `  ${error.message}`);
            }
        }
    }
    /**
     * An async version of {@link JsonFile.load}.
     */
    static async loadAsync(jsonFilename) {
        try {
            const contents = await FileSystem_1.FileSystem.readFileAsync(jsonFilename);
            return jju.parse(contents);
        }
        catch (error) {
            if (FileSystem_1.FileSystem.isNotExistError(error)) {
                throw error;
            }
            else {
                throw new Error(`Error reading "${JsonFile._formatPathForError(jsonFilename)}":` +
                    os.EOL +
                    `  ${error.message}`);
            }
        }
    }
    /**
     * Parses a JSON file's contents.
     */
    static parseString(jsonContents) {
        return jju.parse(jsonContents);
    }
    /**
     * Loads a JSON file and validate its schema.
     */
    static loadAndValidate(jsonFilename, jsonSchema, options) {
        const jsonObject = JsonFile.load(jsonFilename);
        jsonSchema.validateObject(jsonObject, jsonFilename, options);
        return jsonObject;
    }
    /**
     * An async version of {@link JsonFile.loadAndValidate}.
     */
    static async loadAndValidateAsync(jsonFilename, jsonSchema, options) {
        const jsonObject = await JsonFile.loadAsync(jsonFilename);
        jsonSchema.validateObject(jsonObject, jsonFilename, options);
        return jsonObject;
    }
    /**
     * Loads a JSON file and validate its schema, reporting errors using a callback
     * @remarks
     * See JsonSchema.validateObjectWithCallback() for more info.
     */
    static loadAndValidateWithCallback(jsonFilename, jsonSchema, errorCallback) {
        const jsonObject = JsonFile.load(jsonFilename);
        jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);
        return jsonObject;
    }
    /**
     * An async version of {@link JsonFile.loadAndValidateWithCallback}.
     */
    static async loadAndValidateWithCallbackAsync(jsonFilename, jsonSchema, errorCallback) {
        const jsonObject = await JsonFile.loadAsync(jsonFilename);
        jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);
        return jsonObject;
    }
    /**
     * Serializes the specified JSON object to a string buffer.
     * @param jsonObject - the object to be serialized
     * @param options - other settings that control serialization
     * @returns a JSON string, with newlines, and indented with two spaces
     */
    static stringify(jsonObject, options) {
        return JsonFile.updateString('', jsonObject, options);
    }
    /**
     * Serializes the specified JSON object to a string buffer.
     * @param jsonObject - the object to be serialized
     * @param options - other settings that control serialization
     * @returns a JSON string, with newlines, and indented with two spaces
     */
    static updateString(previousJson, newJsonObject, options) {
        if (!options) {
            options = {};
        }
        if (!options.ignoreUndefinedValues) {
            // Standard handling of `undefined` in JSON stringification is to discard the key.
            JsonFile.validateNoUndefinedMembers(newJsonObject);
        }
        let stringified;
        if (previousJson !== '') {
            // NOTE: We don't use mode=json here because comments aren't allowed by strict JSON
            stringified = jju.update(previousJson, newJsonObject, {
                mode: 'cjson',
                indent: 2
            });
        }
        else if (options.prettyFormatting) {
            stringified = jju.stringify(newJsonObject, {
                mode: 'json',
                indent: 2
            });
            if (options.headerComment !== undefined) {
                stringified = JsonFile._formatJsonHeaderComment(options.headerComment) + stringified;
            }
        }
        else {
            stringified = JSON.stringify(newJsonObject, undefined, 2);
            if (options.headerComment !== undefined) {
                stringified = JsonFile._formatJsonHeaderComment(options.headerComment) + stringified;
            }
        }
        // Add the trailing newline
        stringified = Text_1.Text.ensureTrailingNewline(stringified);
        if (options && options.newlineConversion) {
            stringified = Text_1.Text.convertTo(stringified, options.newlineConversion);
        }
        return stringified;
    }
    /**
     * Saves the file to disk.  Returns false if nothing was written due to options.onlyIfChanged.
     * @param jsonObject - the object to be saved
     * @param jsonFilename - the file path to write
     * @param options - other settings that control how the file is saved
     * @returns false if ISaveJsonFileOptions.onlyIfChanged didn't save anything; true otherwise
     */
    static save(jsonObject, jsonFilename, options) {
        if (!options) {
            options = {};
        }
        // Do we need to read the previous file contents?
        let oldBuffer = undefined;
        if (options.updateExistingFile || options.onlyIfChanged) {
            try {
                oldBuffer = FileSystem_1.FileSystem.readFileToBuffer(jsonFilename);
            }
            catch (error) {
                if (!FileSystem_1.FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        }
        let jsonToUpdate = '';
        if (options.updateExistingFile && oldBuffer) {
            jsonToUpdate = oldBuffer.toString(DEFAULT_ENCODING);
        }
        const newJson = JsonFile.updateString(jsonToUpdate, jsonObject, options);
        const newBuffer = Buffer.from(newJson, DEFAULT_ENCODING);
        if (options.onlyIfChanged) {
            // Has the file changed?
            if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {
                // Nothing has changed, so don't touch the file
                return false;
            }
        }
        FileSystem_1.FileSystem.writeFile(jsonFilename, newBuffer.toString(DEFAULT_ENCODING), {
            ensureFolderExists: options.ensureFolderExists
        });
        // TEST CODE: Used to verify that onlyIfChanged isn't broken by a hidden transformation during saving.
        /*
        const oldBuffer2: Buffer = FileSystem.readFileToBuffer(jsonFilename);
        if (Buffer.compare(buffer, oldBuffer2) !== 0) {
          console.log('new:' + buffer.toString('hex'));
          console.log('old:' + oldBuffer2.toString('hex'));
    
          throw new Error('onlyIfChanged logic is broken');
        }
        */
        return true;
    }
    /**
     * An async version of {@link JsonFile.save}.
     */
    static async saveAsync(jsonObject, jsonFilename, options) {
        if (!options) {
            options = {};
        }
        // Do we need to read the previous file contents?
        let oldBuffer = undefined;
        if (options.updateExistingFile || options.onlyIfChanged) {
            try {
                oldBuffer = await FileSystem_1.FileSystem.readFileToBufferAsync(jsonFilename);
            }
            catch (error) {
                if (!FileSystem_1.FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        }
        let jsonToUpdate = '';
        if (options.updateExistingFile && oldBuffer) {
            jsonToUpdate = oldBuffer.toString(DEFAULT_ENCODING);
        }
        const newJson = JsonFile.updateString(jsonToUpdate, jsonObject, options);
        const newBuffer = Buffer.from(newJson, DEFAULT_ENCODING);
        if (options.onlyIfChanged) {
            // Has the file changed?
            if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {
                // Nothing has changed, so don't touch the file
                return false;
            }
        }
        await FileSystem_1.FileSystem.writeFileAsync(jsonFilename, newBuffer.toString(DEFAULT_ENCODING), {
            ensureFolderExists: options.ensureFolderExists
        });
        // TEST CODE: Used to verify that onlyIfChanged isn't broken by a hidden transformation during saving.
        /*
        const oldBuffer2: Buffer = await FileSystem.readFileToBufferAsync(jsonFilename);
        if (Buffer.compare(buffer, oldBuffer2) !== 0) {
          console.log('new:' + buffer.toString('hex'));
          console.log('old:' + oldBuffer2.toString('hex'));
    
          throw new Error('onlyIfChanged logic is broken');
        }
        */
        return true;
    }
    /**
     * Used to validate a data structure before writing.  Reports an error if there
     * are any undefined members.
     */
    static validateNoUndefinedMembers(jsonObject) {
        return JsonFile._validateNoUndefinedMembers(jsonObject, []);
    }
    // Private implementation of validateNoUndefinedMembers()
    static _validateNoUndefinedMembers(jsonObject, keyPath) {
        if (!jsonObject) {
            return;
        }
        if (typeof jsonObject === 'object') {
            for (const key of Object.keys(jsonObject)) {
                keyPath.push(key);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const value = jsonObject[key];
                if (value === undefined) {
                    const fullPath = JsonFile._formatKeyPath(keyPath);
                    throw new Error(`The value for ${fullPath} is "undefined" and cannot be serialized as JSON`);
                }
                JsonFile._validateNoUndefinedMembers(value, keyPath);
                keyPath.pop();
            }
        }
    }
    // Given this input:    ['items', '4', 'syntax', 'parameters', 'string "with" symbols", 'type']
    // Return this string:  items[4].syntax.parameters["string \"with\" symbols"].type
    static _formatKeyPath(keyPath) {
        let result = '';
        for (const key of keyPath) {
            if (/^[0-9]+$/.test(key)) {
                // It's an integer, so display like this:  parent[123]
                result += `[${key}]`;
            }
            else if (/^[a-z_][a-z_0-9]*$/i.test(key)) {
                // It's an alphanumeric identifier, so display like this:  parent.name
                if (result) {
                    result += '.';
                }
                result += `${key}`;
            }
            else {
                // It's a freeform string, so display like this:  parent["A path: \"C:\\file\""]
                // Convert this:     A path: "C:\file"
                // To this:          A path: \"C:\\file\"
                const escapedKey = key
                    .replace(/[\\]/g, '\\\\') // escape backslashes
                    .replace(/["]/g, '\\'); // escape quotes
                result += `["${escapedKey}"]`;
            }
        }
        return result;
    }
    static _formatJsonHeaderComment(headerComment) {
        if (headerComment === '') {
            return '';
        }
        const lines = headerComment.split('\n');
        const result = [];
        for (const line of lines) {
            if (!/^\s*$/.test(line) && !/^\s*\/\//.test(line)) {
                throw new Error('The headerComment lines must be blank or start with the "//" prefix.\n' +
                    'Invalid line' +
                    JSON.stringify(line));
            }
            result.push(Text_1.Text.replaceAll(line, '\r', ''));
        }
        return lines.join('\n') + '\n';
    }
}
exports.JsonFile = JsonFile;
/**
 * @internal
 */
JsonFile._formatPathForError = (path) => path;
//# sourceMappingURL=JsonFile.js.map

/***/ }),

/***/ 10158:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonSchema = void 0;
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const JsonFile_1 = __webpack_require__(17058);
const FileSystem_1 = __webpack_require__(57422);
const Validator = __webpack_require__(59997);
/**
 * Represents a JSON schema that can be used to validate JSON data files loaded by the JsonFile class.
 * @remarks
 * The schema itself is normally loaded and compiled later, only if it is actually required to validate
 * an input.  To avoid schema errors at runtime, it's recommended to create a unit test that calls
 * JsonSchema.ensureCompiled() for each of your schema objects.
 *
 * @public
 */
class JsonSchema {
    constructor() {
        this._dependentSchemas = [];
        this._filename = '';
        this._validator = undefined;
        this._schemaObject = undefined;
    }
    /**
     * Registers a JsonSchema that will be loaded from a file on disk.
     * @remarks
     * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
     * until it the schema is actually used.
     */
    static fromFile(filename, options) {
        // This is a quick and inexpensive test to avoid the catch the most common errors early.
        // Full validation will happen later in JsonSchema.compile().
        if (!FileSystem_1.FileSystem.exists(filename)) {
            throw new Error('Schema file not found: ' + filename);
        }
        const schema = new JsonSchema();
        schema._filename = filename;
        if (options) {
            schema._dependentSchemas = options.dependentSchemas || [];
        }
        return schema;
    }
    /**
     * Registers a JsonSchema that will be loaded from a file on disk.
     * @remarks
     * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
     * until it the schema is actually used.
     */
    static fromLoadedObject(schemaObject) {
        const schema = new JsonSchema();
        schema._schemaObject = schemaObject;
        return schema;
    }
    static _collectDependentSchemas(collectedSchemas, dependentSchemas, seenObjects, seenIds) {
        for (const dependentSchema of dependentSchemas) {
            // It's okay for the same schema to appear multiple times in the tree, but we only process it once
            if (seenObjects.has(dependentSchema)) {
                continue;
            }
            seenObjects.add(dependentSchema);
            const schemaId = dependentSchema._ensureLoaded();
            if (schemaId === '') {
                throw new Error(`This schema ${dependentSchema.shortName} cannot be referenced` +
                    ' because is missing the "id" field');
            }
            if (seenIds.has(schemaId)) {
                throw new Error(`This schema ${dependentSchema.shortName} has the same "id" as another schema in this set`);
            }
            seenIds.add(schemaId);
            collectedSchemas.push(dependentSchema);
            JsonSchema._collectDependentSchemas(collectedSchemas, dependentSchema._dependentSchemas, seenObjects, seenIds);
        }
    }
    /**
     * Used to nicely format the ZSchema error tree.
     */
    static _formatErrorDetails(errorDetails) {
        return JsonSchema._formatErrorDetailsHelper(errorDetails, '', '');
    }
    /**
     * Used by _formatErrorDetails.
     */
    static _formatErrorDetailsHelper(errorDetails, indent, buffer) {
        for (const errorDetail of errorDetails) {
            buffer += os.EOL + indent + `Error: ${errorDetail.path}`;
            if (errorDetail.description) {
                const MAX_LENGTH = 40;
                let truncatedDescription = errorDetail.description.trim();
                if (truncatedDescription.length > MAX_LENGTH) {
                    truncatedDescription = truncatedDescription.substr(0, MAX_LENGTH - 3) + '...';
                }
                buffer += ` (${truncatedDescription})`;
            }
            buffer += os.EOL + indent + `       ${errorDetail.message}`;
            if (errorDetail.inner) {
                buffer = JsonSchema._formatErrorDetailsHelper(errorDetail.inner, indent + '  ', buffer);
            }
        }
        return buffer;
    }
    /**
     * Returns a short name for this schema, for use in error messages.
     * @remarks
     * If the schema was loaded from a file, then the base filename is used.  Otherwise, the "id"
     * field is used if available.
     */
    get shortName() {
        if (!this._filename) {
            if (this._schemaObject) {
                const schemaWithId = this._schemaObject;
                if (schemaWithId.id) {
                    return schemaWithId.id;
                }
            }
            return '(anonymous schema)';
        }
        else {
            return path.basename(this._filename);
        }
    }
    /**
     * If not already done, this loads the schema from disk and compiles it.
     * @remarks
     * Any dependencies will be compiled as well.
     */
    ensureCompiled() {
        this._ensureLoaded();
        if (!this._validator) {
            // Don't assign this to _validator until we're sure everything was successful
            const newValidator = new Validator({
                breakOnFirstError: false,
                noTypeless: true,
                noExtraKeywords: true
            });
            const anythingSchema = {
                type: ['array', 'boolean', 'integer', 'number', 'object', 'string']
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            newValidator.setRemoteReference('http://json-schema.org/draft-04/schema', anythingSchema);
            const collectedSchemas = [];
            const seenObjects = new Set();
            const seenIds = new Set();
            JsonSchema._collectDependentSchemas(collectedSchemas, this._dependentSchemas, seenObjects, seenIds);
            // Validate each schema in order.  We specifically do not supply them all together, because we want
            // to make sure that circular references will fail to validate.
            for (const collectedSchema of collectedSchemas) {
                if (!newValidator.validateSchema(collectedSchema._schemaObject)) {
                    throw new Error(`Failed to validate schema "${collectedSchema.shortName}":` +
                        os.EOL +
                        JsonSchema._formatErrorDetails(newValidator.getLastErrors()));
                }
            }
            this._validator = newValidator;
        }
    }
    /**
     * Validates the specified JSON object against this JSON schema.  If the validation fails,
     * an exception will be thrown.
     * @param jsonObject - The JSON data to be validated
     * @param filenameForErrors - The filename that the JSON data was available, or an empty string
     *    if not applicable
     * @param options - Other options that control the validation
     */
    validateObject(jsonObject, filenameForErrors, options) {
        this.validateObjectWithCallback(jsonObject, (errorInfo) => {
            const prefix = options && options.customErrorHeader ? options.customErrorHeader : 'JSON validation failed:';
            throw new Error(prefix + os.EOL + filenameForErrors + os.EOL + errorInfo.details);
        });
    }
    /**
     * Validates the specified JSON object against this JSON schema.  If the validation fails,
     * a callback is called for each validation error.
     */
    validateObjectWithCallback(jsonObject, errorCallback) {
        this.ensureCompiled();
        if (!this._validator.validate(jsonObject, this._schemaObject)) {
            const errorDetails = JsonSchema._formatErrorDetails(this._validator.getLastErrors());
            const args = {
                details: errorDetails
            };
            errorCallback(args);
        }
    }
    _ensureLoaded() {
        if (!this._schemaObject) {
            this._schemaObject = JsonFile_1.JsonFile.load(this._filename);
        }
        return this._schemaObject.id || '';
    }
}
exports.JsonSchema = JsonSchema;
//# sourceMappingURL=JsonSchema.js.map

/***/ }),

/***/ 53457:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LegacyAdapters = void 0;
const timsort_1 = __webpack_require__(46655);
const semver = __importStar(__webpack_require__(11383));
/**
 * Helper functions used when interacting with APIs that do not follow modern coding practices.
 * @public
 */
class LegacyAdapters {
    static convertCallbackToPromise(fn, arg1, arg2, arg3, arg4) {
        return new Promise((resolve, reject) => {
            const cb = (error, result) => {
                if (error) {
                    reject(LegacyAdapters.scrubError(error));
                }
                else {
                    resolve(result);
                }
            };
            try {
                if (arg1 !== undefined && arg2 !== undefined && arg3 !== undefined && arg4 !== undefined) {
                    fn(arg1, arg2, arg3, arg4, cb);
                }
                else if (arg1 !== undefined && arg2 !== undefined && arg3 !== undefined) {
                    fn(arg1, arg2, arg3, cb);
                }
                else if (arg1 !== undefined && arg2 !== undefined) {
                    fn(arg1, arg2, cb);
                }
                else if (arg1 !== undefined) {
                    fn(arg1, cb);
                }
                else {
                    fn(cb);
                }
            }
            catch (e) {
                reject(e);
            }
        });
    }
    /**
     * Normalizes an object into an `Error` object.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static scrubError(error) {
        if (error instanceof Error) {
            return error;
        }
        else if (typeof error === 'string') {
            return new Error(error);
        }
        else {
            const errorObject = new Error('An error occurred.');
            errorObject.errorData = error; // eslint-disable-line @typescript-eslint/no-explicit-any
            return errorObject;
        }
    }
    /**
     * Prior to Node 11.x, the `Array.sort()` algorithm is not guaranteed to be stable.
     * If you need a stable sort, you can use `sortStable()` as a workaround.
     *
     * @remarks
     * On NodeJS 11.x and later, this method simply calls the native `Array.sort()`.
     * For earlier versions, it uses an implementation of Timsort, which is the same algorithm used by modern NodeJS.
     */
    static sortStable(array, compare) {
        if (LegacyAdapters._useTimsort === undefined) {
            LegacyAdapters._useTimsort = semver.major(process.versions.node) < 11;
        }
        if (LegacyAdapters._useTimsort) {
            (0, timsort_1.sort)(array, compare);
        }
        else {
            Array.prototype.sort.call(array, compare);
        }
    }
}
exports.LegacyAdapters = LegacyAdapters;
LegacyAdapters._useTimsort = undefined;
//# sourceMappingURL=LegacyAdapters.js.map

/***/ }),

/***/ 46186:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LockFile = exports.getProcessStartTime = exports.getProcessStartTimeFromProcStat = void 0;
const path = __importStar(__webpack_require__(85622));
const child_process = __importStar(__webpack_require__(63129));
const FileSystem_1 = __webpack_require__(57422);
const FileWriter_1 = __webpack_require__(71135);
const Async_1 = __webpack_require__(50054);
/**
 * http://man7.org/linux/man-pages/man5/proc.5.html
 * (22) starttime  %llu
 * The time the process started after system boot. In kernels before Linux 2.6, this value was
 * expressed in jiffies. Since Linux 2.6, the value is expressed in clock ticks (divide by
 * sysconf(_SC_CLK_TCK)).
 * The format for this field was %lu before Linux 2.6.
 */
const procStatStartTimePos = 22;
/**
 * Parses the process start time from the contents of a linux /proc/[pid]/stat file.
 * @param stat - The contents of a linux /proc/[pid]/stat file.
 * @returns The process start time in jiffies, or undefined if stat has an unexpected format.
 */
function getProcessStartTimeFromProcStat(stat) {
    // Parse the value at position procStatStartTimePos.
    // We cannot just split stat on spaces, because value 2 may contain spaces.
    // For example, when running the following Shell commands:
    // > cp "$(which bash)" ./'bash 2)('
    // > ./'bash 2)(' -c 'OWNPID=$BASHPID;cat /proc/$OWNPID/stat'
    // 59389 (bash 2)() S 59358 59389 59358 34818 59389 4202496 329 0 0 0 0 0 0 0 20 0 1 0
    // > rm -rf ./'bash 2)('
    // The output shows a stat file such that value 2 contains spaces.
    // To still umambiguously parse such output we assume no values after the second ends with a right parenthesis...
    // trimRight to remove the trailing line terminator.
    let values = stat.trimRight().split(' ');
    let i = values.length - 1;
    while (i >= 0 &&
        // charAt returns an empty string if the index is out of bounds.
        values[i].charAt(values[i].length - 1) !== ')') {
        i -= 1;
    }
    // i is the index of the last part of the second value (but i need not be 1).
    if (i < 1) {
        // Format of stat has changed.
        return undefined;
    }
    const value2 = values.slice(1, i + 1).join(' ');
    values = [values[0], value2].concat(values.slice(i + 1));
    if (values.length < procStatStartTimePos) {
        // Older version of linux, or non-standard configuration of linux.
        return undefined;
    }
    const startTimeJiffies = values[procStatStartTimePos - 1];
    // In theory, the representations of start time returned by `cat /proc/[pid]/stat` and `ps -o lstart` can change
    // while the system is running, but we assume this does not happen.
    // So the caller can safely use this value as part of a unique process id (on the machine, without comparing
    // accross reboots).
    return startTimeJiffies;
}
exports.getProcessStartTimeFromProcStat = getProcessStartTimeFromProcStat;
/**
 * Helper function that is exported for unit tests only.
 * Returns undefined if the process doesn't exist with that pid.
 */
function getProcessStartTime(pid) {
    const pidString = pid.toString();
    if (pid < 0 || pidString.indexOf('e') >= 0 || pidString.indexOf('E') >= 0) {
        throw new Error(`"pid" is negative or too large`);
    }
    let args;
    if (process.platform === 'darwin') {
        args = [`-p ${pidString}`, '-o lstart'];
    }
    else if (process.platform === 'linux') {
        args = ['-p', pidString, '-o', 'lstart'];
    }
    else {
        throw new Error(`Unsupported system: ${process.platform}`);
    }
    const psResult = child_process.spawnSync('ps', args, {
        encoding: 'utf8'
    });
    const psStdout = psResult.stdout;
    // If no process with PID pid exists then the exit code is non-zero on linux but stdout is not empty.
    // But if no process exists we do not want to fall back on /proc/*/stat to determine the process
    // start time, so we we additionally test for !psStdout. NOTE: !psStdout evaluates to true if
    // zero bytes are written to stdout.
    if (psResult.status !== 0 && !psStdout && process.platform === 'linux') {
        // Try to read /proc/[pid]/stat and get the value at position procStatStartTimePos.
        let stat;
        try {
            stat = FileSystem_1.FileSystem.readFile(`/proc/${pidString}/stat`);
        }
        catch (error) {
            if (error.code !== 'ENOENT') {
                throw error;
            }
            // Either no process with PID pid exists, or this version/configuration of linux is non-standard.
            // We assume the former.
            return undefined;
        }
        if (stat !== undefined) {
            const startTimeJiffies = getProcessStartTimeFromProcStat(stat);
            if (startTimeJiffies === undefined) {
                throw new Error(`Could not retrieve the start time of process ${pidString} from the OS because the ` +
                    `contents of /proc/${pidString}/stat have an unexpected format`);
            }
            return startTimeJiffies;
        }
    }
    // there was an error executing ps (zero bytes were written to stdout).
    if (!psStdout) {
        throw new Error(`Unexpected output from "ps" command`);
    }
    const psSplit = psStdout.split('\n');
    // successfuly able to run "ps", but no process was found
    if (psSplit[1] === '') {
        return undefined;
    }
    if (psSplit[1]) {
        const trimmed = psSplit[1].trim();
        if (trimmed.length > 10) {
            return trimmed;
        }
    }
    throw new Error(`Unexpected output from the "ps" command`);
}
exports.getProcessStartTime = getProcessStartTime;
/**
 * The `LockFile` implements a file-based mutex for synchronizing access to a shared resource
 * between multiple Node.js processes.  It is not recommended for synchronization solely within
 * a single Node.js process.
 * @remarks
 * The implementation works on Windows, Mac, and Linux without requiring any native helpers.
 * On non-Windows systems, the algorithm requires access to the `ps` shell command.  On Linux,
 * it requires access the `/proc/${pidString}/stat` filesystem.
 * @public
 */
class LockFile {
    constructor(fileWriter, filePath, dirtyWhenAcquired) {
        this._fileWriter = fileWriter;
        this._filePath = filePath;
        this._dirtyWhenAcquired = dirtyWhenAcquired;
    }
    /**
     * Returns the path of the lockfile that will be created when a lock is successfully acquired.
     * @param resourceFolder - The folder where the lock file will be created
     * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
     *   the filename of the temporary file created to manage the lock.
     * @param pid - The PID for the current Node.js process (`process.pid`), which is used by the locking algorithm.
     */
    static getLockFilePath(resourceFolder, resourceName, pid = process.pid) {
        if (!resourceName.match(/^[a-zA-Z0-9][a-zA-Z0-9-.]+[a-zA-Z0-9]$/)) {
            throw new Error(`The resource name "${resourceName}" is invalid.` +
                ` It must be an alphanumberic string with only "-" or "." It must start with an alphanumeric character.`);
        }
        if (process.platform === 'win32') {
            return path.join(path.resolve(resourceFolder), `${resourceName}.lock`);
        }
        else if (process.platform === 'linux' || process.platform === 'darwin') {
            return path.join(path.resolve(resourceFolder), `${resourceName}#${pid}.lock`);
        }
        throw new Error(`File locking not implemented for platform: "${process.platform}"`);
    }
    /**
     * Attempts to create a lockfile with the given filePath.
     * @param resourceFolder - The folder where the lock file will be created
     * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
     *   the filename of the temporary file created to manage the lock.
     * @returns If successful, returns a `LockFile` instance.  If unable to get a lock, returns `undefined`.
     */
    static tryAcquire(resourceFolder, resourceName) {
        FileSystem_1.FileSystem.ensureFolder(resourceFolder);
        if (process.platform === 'win32') {
            return LockFile._tryAcquireWindows(resourceFolder, resourceName);
        }
        else if (process.platform === 'linux' || process.platform === 'darwin') {
            return LockFile._tryAcquireMacOrLinux(resourceFolder, resourceName);
        }
        throw new Error(`File locking not implemented for platform: "${process.platform}"`);
    }
    /**
     * Attempts to create the lockfile.  Will continue to loop at every 100ms until the lock becomes available
     * or the maxWaitMs is surpassed.
     *
     * @remarks
     * This function is subject to starvation, whereby it does not ensure that the process that has been
     * waiting the longest to acquire the lock will get it first. This means that a process could theoretically
     * wait for the lock forever, while other processes skipped it in line and acquired the lock first.
     *
     * @param resourceFolder - The folder where the lock file will be created
     * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
     *   the filename of the temporary file created to manage the lock.
     * @param maxWaitMs - The maximum number of milliseconds to wait for the lock before reporting an error
     */
    static acquire(resourceFolder, resourceName, maxWaitMs) {
        const interval = 100;
        const startTime = Date.now();
        const retryLoop = async () => {
            const lock = LockFile.tryAcquire(resourceFolder, resourceName);
            if (lock) {
                return lock;
            }
            if (maxWaitMs && Date.now() > startTime + maxWaitMs) {
                throw new Error(`Exceeded maximum wait time to acquire lock for resource "${resourceName}"`);
            }
            await Async_1.Async.sleep(interval);
            return retryLoop();
        };
        return retryLoop();
    }
    /**
     * Attempts to acquire the lock on a Linux or OSX machine
     */
    static _tryAcquireMacOrLinux(resourceFolder, resourceName) {
        let dirtyWhenAcquired = false;
        // get the current process' pid
        const pid = process.pid;
        const startTime = LockFile._getStartTime(pid);
        if (!startTime) {
            throw new Error(`Unable to calculate start time for current process.`);
        }
        const pidLockFilePath = LockFile.getLockFilePath(resourceFolder, resourceName);
        let lockFileHandle;
        let lockFile;
        try {
            // open in write mode since if this file exists, it cannot be from the current process
            // TODO: This will malfunction if the same process tries to acquire two locks on the same file.
            // We should ideally maintain a dictionary of normalized acquired filenames
            lockFileHandle = FileWriter_1.FileWriter.open(pidLockFilePath);
            lockFileHandle.write(startTime);
            const currentBirthTimeMs = FileSystem_1.FileSystem.getStatistics(pidLockFilePath).birthtime.getTime();
            let smallestBirthTimeMs = currentBirthTimeMs;
            let smallestBirthTimePid = pid.toString();
            // now, scan the directory for all lockfiles
            const files = FileSystem_1.FileSystem.readFolder(resourceFolder);
            // look for anything ending with # then numbers and ".lock"
            const lockFileRegExp = /^(.+)#([0-9]+)\.lock$/;
            let match;
            let otherPid;
            for (const fileInFolder of files) {
                if ((match = fileInFolder.match(lockFileRegExp)) &&
                    match[1] === resourceName &&
                    (otherPid = match[2]) !== pid.toString()) {
                    // we found at least one lockfile hanging around that isn't ours
                    const fileInFolderPath = path.join(resourceFolder, fileInFolder);
                    dirtyWhenAcquired = true;
                    // console.log(`FOUND OTHER LOCKFILE: ${otherPid}`);
                    const otherPidCurrentStartTime = LockFile._getStartTime(parseInt(otherPid, 10));
                    let otherPidOldStartTime;
                    let otherBirthtimeMs;
                    try {
                        otherPidOldStartTime = FileSystem_1.FileSystem.readFile(fileInFolderPath);
                        // check the timestamp of the file
                        otherBirthtimeMs = FileSystem_1.FileSystem.getStatistics(fileInFolderPath).birthtime.getTime();
                    }
                    catch (err) {
                        // this means the file is probably deleted already
                    }
                    // if the otherPidOldStartTime is invalid, then we should look at the timestamp,
                    // if this file was created after us, ignore it
                    // if it was created within 1 second before us, then it could be good, so we
                    //  will conservatively fail
                    // otherwise it is an old lock file and will be deleted
                    if (otherPidOldStartTime === '' && otherBirthtimeMs !== undefined) {
                        if (otherBirthtimeMs > currentBirthTimeMs) {
                            // ignore this file, he will be unable to get the lock since this process
                            // will hold it
                            // console.log(`Ignoring lock for pid ${otherPid} because its lockfile is newer than ours.`);
                            continue;
                        }
                        else if (otherBirthtimeMs - currentBirthTimeMs < 0 && // it was created before us AND
                            otherBirthtimeMs - currentBirthTimeMs > -1000) {
                            // it was created less than a second before
                            // conservatively be unable to keep the lock
                            return undefined;
                        }
                    }
                    // console.log(`Other pid ${otherPid} lockfile has start time: "${otherPidOldStartTime}"`);
                    // console.log(`Other pid ${otherPid} actually has start time: "${otherPidCurrentStartTime}"`);
                    // this means the process is no longer executing, delete the file
                    if (!otherPidCurrentStartTime || otherPidOldStartTime !== otherPidCurrentStartTime) {
                        // console.log(`Other pid ${otherPid} is no longer executing!`);
                        FileSystem_1.FileSystem.deleteFile(fileInFolderPath);
                        continue;
                    }
                    // console.log(`Pid ${otherPid} lockfile has birth time: ${otherBirthtimeMs}`);
                    // console.log(`Pid ${pid} lockfile has birth time: ${currentBirthTimeMs}`);
                    // this is a lockfile pointing at something valid
                    if (otherBirthtimeMs !== undefined && otherBirthtimeMs < smallestBirthTimeMs) {
                        smallestBirthTimeMs = otherBirthtimeMs;
                        smallestBirthTimePid = otherPid;
                    }
                }
            }
            if (smallestBirthTimePid !== pid.toString()) {
                // we do not have the lock
                return undefined;
            }
            // we have the lock!
            lockFile = new LockFile(lockFileHandle, pidLockFilePath, dirtyWhenAcquired);
            lockFileHandle = undefined; // we have handed the descriptor off to the instance
        }
        finally {
            if (lockFileHandle) {
                // ensure our lock is closed
                lockFileHandle.close();
                FileSystem_1.FileSystem.deleteFile(pidLockFilePath);
            }
        }
        return lockFile;
    }
    /**
     * Attempts to acquire the lock using Windows
     * This algorithm is much simpler since we can rely on the operating system
     */
    static _tryAcquireWindows(resourceFolder, resourceName) {
        const lockFilePath = LockFile.getLockFilePath(resourceFolder, resourceName);
        let dirtyWhenAcquired = false;
        let fileHandle;
        let lockFile;
        try {
            if (FileSystem_1.FileSystem.exists(lockFilePath)) {
                dirtyWhenAcquired = true;
                // If the lockfile is held by an process with an exclusive lock, then removing it will
                // silently fail. OpenSync() below will then fail and we will be unable to create a lock.
                // Otherwise, the lockfile is sitting on disk, but nothing is holding it, implying that
                // the last process to hold it died.
                FileSystem_1.FileSystem.deleteFile(lockFilePath);
            }
            try {
                // Attempt to open an exclusive lockfile
                fileHandle = FileWriter_1.FileWriter.open(lockFilePath, { exclusive: true });
            }
            catch (error) {
                // we tried to delete the lock, but something else is holding it,
                // (probably an active process), therefore we are unable to create a lock
                return undefined;
            }
            // Ensure we can hand off the file descriptor to the lockfile
            lockFile = new LockFile(fileHandle, lockFilePath, dirtyWhenAcquired);
            fileHandle = undefined;
        }
        finally {
            if (fileHandle) {
                fileHandle.close();
            }
        }
        return lockFile;
    }
    /**
     * Unlocks a file and removes it from disk.
     * This can only be called once.
     */
    release() {
        if (this.isReleased) {
            throw new Error(`The lock for file "${path.basename(this._filePath)}" has already been released.`);
        }
        this._fileWriter.close();
        FileSystem_1.FileSystem.deleteFile(this._filePath);
        this._fileWriter = undefined;
    }
    /**
     * Returns the initial state of the lock.
     * This can be used to detect if the previous process was terminated before releasing the resource.
     */
    get dirtyWhenAcquired() {
        return this._dirtyWhenAcquired;
    }
    /**
     * Returns the absolute path to the lockfile
     */
    get filePath() {
        return this._filePath;
    }
    /**
     * Returns true if this lock is currently being held.
     */
    get isReleased() {
        return this._fileWriter === undefined;
    }
}
exports.LockFile = LockFile;
LockFile._getStartTime = getProcessStartTime;
//# sourceMappingURL=LockFile.js.map

/***/ }),

/***/ 59442:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapExtensions = void 0;
/**
 * Helper functions for working with the `Map<K, V>` data type.
 *
 * @public
 */
class MapExtensions {
    /**
     * Adds all the (key, value) pairs from the source map into the target map.
     * @remarks
     * This function modifies targetMap.  Any existing keys will be overwritten.
     * @param targetMap - The map that entries will be added to
     * @param sourceMap - The map containing the entries to be added
     */
    static mergeFromMap(targetMap, sourceMap) {
        for (const pair of sourceMap.entries()) {
            targetMap.set(pair[0], pair[1]);
        }
    }
    /**
     * Converts a string-keyed map to an object.
     * @remarks
     * This function has the same effect as Object.fromEntries(map.entries())
     * in supported versions of Node (\>= 12.0.0).
     * @param map - The map that the object properties will be sourced from
     */
    static toObject(map) {
        const object = {};
        for (const [key, value] of map.entries()) {
            object[key] = value;
        }
        return object;
    }
}
exports.MapExtensions = MapExtensions;
//# sourceMappingURL=MapExtensions.js.map

/***/ }),

/***/ 42172:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageJsonLookup = void 0;
const path = __importStar(__webpack_require__(85622));
const JsonFile_1 = __webpack_require__(17058);
const FileSystem_1 = __webpack_require__(57422);
/**
 * This class provides methods for finding the nearest "package.json" for a folder
 * and retrieving the name of the package.  The results are cached.
 *
 * @public
 */
class PackageJsonLookup {
    constructor(parameters) {
        this._loadExtraFields = false;
        if (parameters) {
            if (parameters.loadExtraFields) {
                this._loadExtraFields = parameters.loadExtraFields;
            }
        }
        this.clearCache();
    }
    /**
     * A singleton instance of `PackageJsonLookup`, which is useful for short-lived processes
     * that can reasonably assume that the file system will not be modified after the cache
     * is populated.
     *
     * @remarks
     * For long-running processes that need to clear the cache at appropriate times,
     * it is recommended to create your own instance of `PackageJsonLookup` instead
     * of relying on this instance.
     */
    static get instance() {
        if (!PackageJsonLookup._instance) {
            PackageJsonLookup._instance = new PackageJsonLookup({ loadExtraFields: true });
        }
        return PackageJsonLookup._instance;
    }
    /**
     * A helper for loading the caller's own package.json file.
     *
     * @remarks
     *
     * This function provides a concise and efficient way for an NPM package to report metadata about itself.
     * For example, a tool might want to report its version.
     *
     * The `loadOwnPackageJson()` probes upwards from the caller's folder, expecting to find a package.json file,
     * which is assumed to be the caller's package.  The result is cached, under the assumption that a tool's
     * own package.json (and intermediary folders) will never change during the lifetime of the process.
     *
     * @example
     * ```ts
     * // Report the version of our NPM package
     * const myPackageVersion: string = PackageJsonLookup.loadOwnPackageJson(__dirname).version;
     * console.log(`Cool Tool - Version ${myPackageVersion}`);
     * ```
     *
     * @param dirnameOfCaller - The NodeJS `__dirname` macro for the caller.
     * @returns This function always returns a valid `IPackageJson` object.  If any problems are encountered during
     * loading, an exception will be thrown instead.
     */
    static loadOwnPackageJson(dirnameOfCaller) {
        const packageJson = PackageJsonLookup.instance.tryLoadPackageJsonFor(dirnameOfCaller);
        if (packageJson === undefined) {
            throw new Error(`PackageJsonLookup.loadOwnPackageJson() failed to find the caller's package.json.` +
                `  The __dirname was: ${dirnameOfCaller}`);
        }
        if (packageJson.version !== undefined) {
            return packageJson;
        }
        const errorPath = PackageJsonLookup.instance.tryGetPackageJsonFilePathFor(dirnameOfCaller) || 'package.json';
        throw new Error(`PackageJsonLookup.loadOwnPackageJson() failed because the "version" field is missing in` +
            ` ${errorPath}`);
    }
    /**
     * Clears the internal file cache.
     * @remarks
     * Call this method if changes have been made to the package.json files on disk.
     */
    clearCache() {
        this._packageFolderCache = new Map();
        this._packageJsonCache = new Map();
    }
    /**
     * Returns the absolute path of a folder containing a package.json file, by looking
     * upwards from the specified fileOrFolderPath.  If no package.json can be found,
     * undefined is returned.
     *
     * @remarks
     * The fileOrFolderPath is not required to actually exist on disk.
     * The fileOrFolderPath itself can be the return value, if it is a folder containing
     * a package.json file.
     * Both positive and negative lookup results are cached.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an absolute path to a folder containing a package.json file
     */
    tryGetPackageFolderFor(fileOrFolderPath) {
        // Convert it to an absolute path
        const resolvedFileOrFolderPath = path.resolve(fileOrFolderPath);
        // Optimistically hope that the starting string is already in the cache,
        // in which case we can avoid disk access entirely.
        //
        // (Two lookups are required, because get() cannot distinguish the undefined value
        // versus a missing key.)
        if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {
            return this._packageFolderCache.get(resolvedFileOrFolderPath);
        }
        // Now call the recursive part of the algorithm
        return this._tryGetPackageFolderFor(resolvedFileOrFolderPath);
    }
    /**
     * If the specified file or folder is part of a package, this returns the absolute path
     * to the associated package.json file.
     *
     * @remarks
     * The package folder is determined using the same algorithm
     * as {@link PackageJsonLookup.tryGetPackageFolderFor}.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an absolute path to * package.json file
     */
    tryGetPackageJsonFilePathFor(fileOrFolderPath) {
        const packageJsonFolder = this.tryGetPackageFolderFor(fileOrFolderPath);
        if (!packageJsonFolder) {
            return undefined;
        }
        return path.join(packageJsonFolder, "package.json" /* PackageJson */);
    }
    /**
     * If the specified file or folder is part of a package, this loads and returns the
     * associated package.json file.
     *
     * @remarks
     * The package folder is determined using the same algorithm
     * as {@link PackageJsonLookup.tryGetPackageFolderFor}.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an IPackageJson object, or undefined if the fileOrFolderPath does not
     * belong to a package
     */
    tryLoadPackageJsonFor(fileOrFolderPath) {
        const packageJsonFilePath = this.tryGetPackageJsonFilePathFor(fileOrFolderPath);
        if (!packageJsonFilePath) {
            return undefined;
        }
        return this.loadPackageJson(packageJsonFilePath);
    }
    /**
     * This function is similar to {@link PackageJsonLookup.tryLoadPackageJsonFor}, except that it does not report
     * an error if the `version` field is missing from the package.json file.
     */
    tryLoadNodePackageJsonFor(fileOrFolderPath) {
        const packageJsonFilePath = this.tryGetPackageJsonFilePathFor(fileOrFolderPath);
        if (!packageJsonFilePath) {
            return undefined;
        }
        return this.loadNodePackageJson(packageJsonFilePath);
    }
    /**
     * Loads the specified package.json file, if it is not already present in the cache.
     *
     * @remarks
     * Unless {@link IPackageJsonLookupParameters.loadExtraFields} was specified,
     * the returned IPackageJson object will contain a subset of essential fields.
     * The returned object should be considered to be immutable; the caller must never
     * modify it.
     *
     * @param jsonFilename - a relative or absolute path to a package.json file
     */
    loadPackageJson(jsonFilename) {
        const packageJson = this.loadNodePackageJson(jsonFilename);
        if (!packageJson.version) {
            throw new Error(`Error reading "${jsonFilename}":\n  The required field "version" was not found`);
        }
        return packageJson;
    }
    /**
     * This function is similar to {@link PackageJsonLookup.loadPackageJson}, except that it does not report an error
     * if the `version` field is missing from the package.json file.
     */
    loadNodePackageJson(jsonFilename) {
        if (!FileSystem_1.FileSystem.exists(jsonFilename)) {
            throw new Error(`Input file not found: ${jsonFilename}`);
        }
        // Since this will be a cache key, follow any symlinks and get an absolute path
        // to minimize duplication.  (Note that duplication can still occur due to e.g. character case.)
        const normalizedFilePath = FileSystem_1.FileSystem.getRealPath(jsonFilename);
        let packageJson = this._packageJsonCache.get(normalizedFilePath);
        if (!packageJson) {
            const loadedPackageJson = JsonFile_1.JsonFile.load(normalizedFilePath);
            // Make sure this is really a package.json file.  CommonJS has fairly strict requirements,
            // but NPM only requires "name" and "version"
            if (!loadedPackageJson.name) {
                throw new Error(`Error reading "${jsonFilename}":\n  The required field "name" was not found`);
            }
            if (this._loadExtraFields) {
                packageJson = loadedPackageJson;
            }
            else {
                packageJson = {};
                // Unless "loadExtraFields" was requested, copy over the essential fields only
                packageJson.bin = loadedPackageJson.bin;
                packageJson.dependencies = loadedPackageJson.dependencies;
                packageJson.description = loadedPackageJson.description;
                packageJson.devDependencies = loadedPackageJson.devDependencies;
                packageJson.homepage = loadedPackageJson.homepage;
                packageJson.license = loadedPackageJson.license;
                packageJson.main = loadedPackageJson.main;
                packageJson.name = loadedPackageJson.name;
                packageJson.optionalDependencies = loadedPackageJson.optionalDependencies;
                packageJson.peerDependencies = loadedPackageJson.peerDependencies;
                packageJson.private = loadedPackageJson.private;
                packageJson.scripts = loadedPackageJson.scripts;
                packageJson.typings = loadedPackageJson.typings || loadedPackageJson.types;
                packageJson.tsdocMetadata = loadedPackageJson.tsdocMetadata;
                packageJson.version = loadedPackageJson.version;
            }
            Object.freeze(packageJson);
            this._packageJsonCache.set(normalizedFilePath, packageJson);
        }
        return packageJson;
    }
    // Recursive part of the algorithm from tryGetPackageFolderFor()
    _tryGetPackageFolderFor(resolvedFileOrFolderPath) {
        // Two lookups are required, because get() cannot distinguish the undefined value
        // versus a missing key.
        if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {
            return this._packageFolderCache.get(resolvedFileOrFolderPath);
        }
        // Is resolvedFileOrFolderPath itself a folder with a package.json file?  If so, return it.
        if (FileSystem_1.FileSystem.exists(path.join(resolvedFileOrFolderPath, "package.json" /* PackageJson */))) {
            this._packageFolderCache.set(resolvedFileOrFolderPath, resolvedFileOrFolderPath);
            return resolvedFileOrFolderPath;
        }
        // Otherwise go up one level
        const parentFolder = path.dirname(resolvedFileOrFolderPath);
        if (!parentFolder || parentFolder === resolvedFileOrFolderPath) {
            // We reached the root directory without finding a package.json file,
            // so cache the negative result
            this._packageFolderCache.set(resolvedFileOrFolderPath, undefined);
            return undefined; // no match
        }
        // Recurse upwards, caching every step along the way
        const parentResult = this._tryGetPackageFolderFor(parentFolder);
        // Cache the parent's answer as well
        this._packageFolderCache.set(resolvedFileOrFolderPath, parentResult);
        return parentResult;
    }
}
exports.PackageJsonLookup = PackageJsonLookup;
//# sourceMappingURL=PackageJsonLookup.js.map

/***/ }),

/***/ 42901:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageName = exports.PackageNameParser = void 0;
/**
 * A configurable parser for validating and manipulating NPM package names such as `my-package` or `@scope/my-package`.
 *
 * @remarks
 * If you do not need to customize the parser configuration, it is recommended to use {@link PackageName}
 * which exposes these operations as a simple static class.
 *
 * @public
 */
class PackageNameParser {
    constructor(options = {}) {
        this._options = Object.assign({}, options);
    }
    /**
     * This attempts to parse a package name that may include a scope component.
     * The packageName must not be an empty string.
     * @remarks
     * This function will not throw an exception.
     *
     * @returns an {@link IParsedPackageNameOrError} structure whose `error` property will be
     * nonempty if the string could not be parsed.
     */
    tryParse(packageName) {
        const result = {
            scope: '',
            unscopedName: '',
            error: ''
        };
        let input = packageName;
        if (input === null || input === undefined) {
            result.error = 'The package name must not be null or undefined';
            return result;
        }
        // Rule from npmjs.com:
        // "The name must be less than or equal to 214 characters. This includes the scope for scoped packages."
        if (packageName.length > 214) {
            // Don't attempt to parse a ridiculously long input
            result.error = 'The package name cannot be longer than 214 characters';
            return result;
        }
        if (input[0] === '@') {
            const indexOfScopeSlash = input.indexOf('/');
            if (indexOfScopeSlash <= 0) {
                result.scope = input;
                result.error = `Error parsing "${packageName}": The scope must be followed by a slash`;
                return result;
            }
            // Extract the scope substring
            result.scope = input.substr(0, indexOfScopeSlash);
            input = input.substr(indexOfScopeSlash + 1);
        }
        result.unscopedName = input;
        if (result.scope === '@') {
            result.error = `Error parsing "${packageName}": The scope name cannot be empty`;
            return result;
        }
        if (result.unscopedName === '') {
            result.error = 'The package name must not be empty';
            return result;
        }
        // Rule from npmjs.com:
        // "The name can't start with a dot or an underscore."
        if (result.unscopedName[0] === '.' || result.unscopedName[0] === '_') {
            result.error = `The package name "${packageName}" starts with an invalid character`;
            return result;
        }
        // Convert "@scope/unscoped-name" --> "scopeunscoped-name"
        const nameWithoutScopeSymbols = (result.scope ? result.scope.slice(1, -1) : '') + result.unscopedName;
        if (!this._options.allowUpperCase) {
            // "New packages must not have uppercase letters in the name."
            // This can't be enforced because "old" packages are still actively maintained.
            // Example: https://www.npmjs.com/package/Base64
            // However it's pretty reasonable to require the scope to be lower case
            if (result.scope !== result.scope.toLowerCase()) {
                result.error = `The package scope "${result.scope}" must not contain upper case characters`;
                return result;
            }
        }
        // "The name ends up being part of a URL, an argument on the command line, and a folder name.
        // Therefore, the name can't contain any non-URL-safe characters"
        const match = nameWithoutScopeSymbols.match(PackageNameParser._invalidNameCharactersRegExp);
        if (match) {
            result.error = `The package name "${packageName}" contains an invalid character: "${match[0]}"`;
            return result;
        }
        return result;
    }
    /**
     * Same as {@link PackageName.tryParse}, except this throws an exception if the input
     * cannot be parsed.
     * @remarks
     * The packageName must not be an empty string.
     */
    parse(packageName) {
        const result = this.tryParse(packageName);
        if (result.error) {
            throw new Error(result.error);
        }
        return result;
    }
    /**
     * {@inheritDoc IParsedPackageName.scope}
     */
    getScope(packageName) {
        return this.parse(packageName).scope;
    }
    /**
     * {@inheritDoc IParsedPackageName.unscopedName}
     */
    getUnscopedName(packageName) {
        return this.parse(packageName).unscopedName;
    }
    /**
     * Returns true if the specified package name is valid, or false otherwise.
     * @remarks
     * This function will not throw an exception.
     */
    isValidName(packageName) {
        const result = this.tryParse(packageName);
        return !result.error;
    }
    /**
     * Throws an exception if the specified name is not a valid package name.
     * The packageName must not be an empty string.
     */
    validate(packageName) {
        this.parse(packageName);
    }
    /**
     * Combines an optional package scope with an unscoped root name.
     * @param scope - Must be either an empty string, or a scope name such as "\@example"
     * @param unscopedName - Must be a nonempty package name that does not contain a scope
     * @returns A full package name such as "\@example/some-library".
     */
    combineParts(scope, unscopedName) {
        if (scope !== '') {
            if (scope[0] !== '@') {
                throw new Error('The scope must start with an "@" character');
            }
        }
        if (scope.indexOf('/') >= 0) {
            throw new Error('The scope must not contain a "/" character');
        }
        if (unscopedName[0] === '@') {
            throw new Error('The unscopedName cannot start with an "@" character');
        }
        if (unscopedName.indexOf('/') >= 0) {
            throw new Error('The unscopedName must not contain a "/" character');
        }
        let result;
        if (scope === '') {
            result = unscopedName;
        }
        else {
            result = scope + '/' + unscopedName;
        }
        // Make sure the result is a valid package name
        this.validate(result);
        return result;
    }
}
exports.PackageNameParser = PackageNameParser;
// encodeURIComponent() escapes all characters except:  A-Z a-z 0-9 - _ . ! ~ * ' ( )
// However, these are disallowed because they are shell characters:       ! ~ * ' ( )
PackageNameParser._invalidNameCharactersRegExp = /[^A-Za-z0-9\-_\.]/;
/**
 * Provides basic operations for validating and manipulating NPM package names such as `my-package`
 * or `@scope/my-package`.
 *
 * @remarks
 * This is the default implementation of {@link PackageNameParser}, exposed as a convenient static class.
 * If you need to configure the parsing rules, use `PackageNameParser` instead.
 *
 * @public
 */
class PackageName {
    /** {@inheritDoc PackageNameParser.tryParse} */
    static tryParse(packageName) {
        return PackageName._parser.tryParse(packageName);
    }
    /** {@inheritDoc PackageNameParser.parse} */
    static parse(packageName) {
        return this._parser.parse(packageName);
    }
    /** {@inheritDoc PackageNameParser.getScope} */
    static getScope(packageName) {
        return this._parser.getScope(packageName);
    }
    /** {@inheritDoc PackageNameParser.getUnscopedName} */
    static getUnscopedName(packageName) {
        return this._parser.getUnscopedName(packageName);
    }
    /** {@inheritDoc PackageNameParser.isValidName} */
    static isValidName(packageName) {
        return this._parser.isValidName(packageName);
    }
    /** {@inheritDoc PackageNameParser.validate} */
    static validate(packageName) {
        return this._parser.validate(packageName);
    }
    /** {@inheritDoc PackageNameParser.combineParts} */
    static combineParts(scope, unscopedName) {
        return this._parser.combineParts(scope, unscopedName);
    }
}
exports.PackageName = PackageName;
PackageName._parser = new PackageNameParser();
//# sourceMappingURL=PackageName.js.map

/***/ }),

/***/ 8972:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Path = void 0;
const path = __importStar(__webpack_require__(85622));
const Text_1 = __webpack_require__(77087);
/**
 * Common operations for manipulating file and directory paths.
 * @remarks
 * This API is intended to eventually be a complete replacement for the NodeJS "path" API.
 * @public
 */
class Path {
    /**
     * Returns true if "childPath" is located inside the "parentFolderPath" folder
     * or one of its child folders.  Note that "parentFolderPath" is not considered to be
     * under itself.  The "childPath" can refer to any type of file system object.
     *
     * @remarks
     * The indicated file/folder objects are not required to actually exist on disk.
     * For example, "parentFolderPath" is interpreted as a folder name even if it refers to a file.
     * If the paths are relative, they will first be resolved using path.resolve().
     */
    static isUnder(childPath, parentFolderPath) {
        // If childPath is under parentPath, then relativePath will be something like
        // "../.." or "..\\..", which consists entirely of periods and slashes.
        // (Note that something like "....t" is actually a valid filename, but "...." is not.)
        const relativePath = path.relative(childPath, parentFolderPath);
        return Path._relativePathRegex.test(relativePath);
    }
    /**
     * Returns true if "childPath" is equal to "parentFolderPath", or if it is inside that folder
     * or one of its children.  The "childPath" can refer to any type of file system object.
     *
     * @remarks
     * The indicated file/folder objects are not required to actually exist on disk.
     * For example, "parentFolderPath" is interpreted as a folder name even if it refers to a file.
     * If the paths are relative, they will first be resolved using path.resolve().
     */
    static isUnderOrEqual(childPath, parentFolderPath) {
        const relativePath = path.relative(childPath, parentFolderPath);
        return relativePath === '' || Path._relativePathRegex.test(relativePath);
    }
    /**
     * Returns true if `path1` and `path2` refer to the same underlying path.
     *
     * @remarks
     *
     * The comparison is performed using `path.relative()`.
     */
    static isEqual(path1, path2) {
        return path.relative(path1, path2) === '';
    }
    /**
     * Formats a path to look nice for reporting purposes.
     * @remarks
     * If `pathToConvert` is under the `baseFolder`, then it will be converted to a relative with the `./` prefix.
     * Otherwise, it will be converted to an absolute path.
     *
     * Backslashes will be converted to slashes, unless the path starts with an OS-specific string like `C:\`.
     */
    static formatConcisely(options) {
        // Same logic as Path.isUnderOrEqual()
        const relativePath = path.relative(options.pathToConvert, options.baseFolder);
        const isUnderOrEqual = relativePath === '' || Path._relativePathRegex.test(relativePath);
        if (isUnderOrEqual) {
            // Note that isUnderOrEqual()'s relativePath is the reverse direction
            return './' + Path.convertToSlashes(path.relative(options.baseFolder, options.pathToConvert));
        }
        const absolutePath = path.resolve(options.pathToConvert);
        return absolutePath;
    }
    /**
     * Replaces Windows-style backslashes with POSIX-style slashes.
     *
     * @remarks
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    static convertToSlashes(inputPath) {
        return Text_1.Text.replaceAll(inputPath, '\\', '/');
    }
    /**
     * Replaces POSIX-style slashes with Windows-style backslashes
     *
     * @remarks
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    static convertToBackslashes(inputPath) {
        return Text_1.Text.replaceAll(inputPath, '/', '\\');
    }
    /**
     * Returns true if the specified path is a relative path and does not use `..` to walk upwards.
     *
     * @example
     * ```ts
     * // These evaluate to true
     * isDownwardRelative('folder');
     * isDownwardRelative('file');
     * isDownwardRelative('folder/');
     * isDownwardRelative('./folder/');
     * isDownwardRelative('./folder/file');
     *
     * // These evaluate to false
     * isDownwardRelative('../folder');
     * isDownwardRelative('folder/../file');
     * isDownwardRelative('/folder/file');
     * ```
     */
    static isDownwardRelative(inputPath) {
        if (path.isAbsolute(inputPath)) {
            return false;
        }
        // Does it contain ".."
        if (Path._upwardPathSegmentRegex.test(inputPath)) {
            return false;
        }
        return true;
    }
}
exports.Path = Path;
// Matches a relative path consisting entirely of periods and slashes
// Example: ".", "..", "../..", etc
Path._relativePathRegex = /^[.\/\\]+$/;
// Matches a relative path segment that traverses upwards
// Example: "a/../b"
Path._upwardPathSegmentRegex = /([\/\\]|^)\.\.([\/\\]|$)/;
//# sourceMappingURL=Path.js.map

/***/ }),

/***/ 56337:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtectableMap = void 0;
const ProtectableMapView_1 = __webpack_require__(36727);
/**
 * The ProtectableMap provides an easy way for an API to expose a `Map<K, V>` property
 * while intercepting and validating any write operations that are performed by
 * consumers of the API.
 *
 * @remarks
 * The ProtectableMap itself is intended to be a private object that only its owner
 * can access directly.  Any operations performed directly on the ProtectableMap will
 * bypass the hooks and any validation they perform.  The public property that is exposed
 * to API consumers should return {@link ProtectableMap.protectedView} instead.
 *
 * For example, suppose you want to share your `Map<string, number>` data structure,
 * but you want to enforce that the key must always be an upper case string:
 * You could use the onSet() hook to validate the keys and throw an exception
 * if the key is not uppercase.
 *
 * @public
 */
class ProtectableMap {
    constructor(parameters) {
        this._protectedView = new ProtectableMapView_1.ProtectableMapView(this, parameters);
    }
    /**
     * The owner of the protectable map should return this object via its public API.
     */
    get protectedView() {
        return this._protectedView;
    }
    // ---------------------------------------------------------------------------
    // lib.es2015.collections contract - write operations
    /**
     * Removes all entries from the map.
     * This operation does NOT invoke the ProtectableMap onClear() hook.
     */
    clear() {
        this._protectedView._clearUnprotected();
    }
    /**
     * Removes the specified key from the map.
     * This operation does NOT invoke the ProtectableMap onDelete() hook.
     */
    delete(key) {
        return this._protectedView._deleteUnprotected(key);
    }
    /**
     * Sets a value for the specified key.
     * This operation does NOT invoke the ProtectableMap onSet() hook.
     */
    set(key, value) {
        this._protectedView._setUnprotected(key, value);
        return this;
    }
    // ---------------------------------------------------------------------------
    // lib.es2015.collections contract - read operations
    /**
     * Performs an operation for each (key, value) entries in the map.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    forEach(callbackfn, thisArg) {
        this._protectedView.forEach(callbackfn);
    }
    /**
     * Retrieves the value for the specified key.
     * @returns undefined if the value is undefined OR if the key is missing;
     * otherwise returns the value associated with the key.
     */
    get(key) {
        return this._protectedView.get(key);
    }
    /**
     * Returns true if the specified key belongs to the map.
     */
    has(key) {
        return this._protectedView.has(key);
    }
    /**
     * Returns the number of (key, value) entries in the map.
     */
    get size() {
        return this._protectedView.size;
    }
}
exports.ProtectableMap = ProtectableMap;
//# sourceMappingURL=ProtectableMap.js.map

/***/ }),

/***/ 36727:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtectableMapView = void 0;
/**
 * The internal wrapper used by ProtectableMap.  It extends the real `Map<K, V>` base class,
 * but hooks the destructive operations (clear/delete/set) to give the owner a chance
 * to block them.
 *
 * NOTE: This is not a public API.
 */
class ProtectableMapView extends Map {
    constructor(owner, parameters) {
        super();
        this._owner = owner;
        this._parameters = parameters;
    }
    clear() {
        // override
        if (this._parameters.onClear) {
            this._parameters.onClear(this._owner);
        }
        super.clear();
    }
    delete(key) {
        // override
        if (this._parameters.onDelete) {
            this._parameters.onDelete(this._owner, key);
        }
        return super.delete(key);
    }
    set(key, value) {
        // override
        let modifiedValue = value;
        if (this._parameters.onSet) {
            modifiedValue = this._parameters.onSet(this._owner, key, modifiedValue);
        }
        super.set(key, modifiedValue);
        return this;
    }
    // INTERNAL USAGE ONLY
    _clearUnprotected() {
        super.clear();
    }
    // INTERNAL USAGE ONLY
    _deleteUnprotected(key) {
        return super.delete(key);
    }
    // INTERNAL USAGE ONLY
    _setUnprotected(key, value) {
        super.set(key, value);
    }
}
exports.ProtectableMapView = ProtectableMapView;
//# sourceMappingURL=ProtectableMapView.js.map

/***/ }),

/***/ 58890:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sort = void 0;
const LegacyAdapters_1 = __webpack_require__(53457);
/**
 * Operations for sorting collections.
 *
 * @remarks
 * NOTE: Prior to Node 11.x, the `Array.sort()` algorithm is not guaranteed to be stable.  For maximum
 * compatibility, consider using {@link LegacyAdapters.sortStable} instead of `Array.sort()`.
 *
 * @public
 */
class Sort {
    /**
     * Compares `x` and `y` using the JavaScript `>` and `<` operators.  This function is suitable for usage as
     * the callback for `array.sort()`.
     *
     * @remarks
     *
     * The JavaScript ordering is generalized so that `undefined` \< `null` \< all other values.
     *
     * @returns -1 if `x` is smaller than `y`, 1 if `x` is greater than `y`, or 0 if the values are equal.
     *
     * @example
     *
     * ```ts
     * let array: number[] = [3, 6, 2];
     * array.sort(Sort.compareByValue);  // [2, 3, 6]
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static compareByValue(x, y) {
        if (x === y) {
            return 0;
        }
        // Undefined is smaller than anything else
        if (x === undefined) {
            return -1;
        }
        if (y === undefined) {
            return 1;
        }
        // Null is smaller than anything except undefined
        if (x === null) {
            return -1;
        }
        if (y === null) {
            return 1;
        }
        // These comparisons always return false if either of the arguments is "undefined".
        // These comparisons return nonsense for "null" (true for "null > -1", but false for "null < 0" and "null > 0")
        if (x < y) {
            return -1;
        }
        if (x > y) {
            return 1;
        }
        return 0;
    }
    /**
     * Sorts the array according to a key which is obtained from the array elements.
     * The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let array: string[] = [ 'aaa', 'bb', 'c' ];
     * Sort.sortBy(array, x => x.length);  // [ 'c', 'bb', 'aaa' ]
     * ```
     */
    static sortBy(array, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    keySelector, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    comparer = Sort.compareByValue) {
        LegacyAdapters_1.LegacyAdapters.sortStable(array, (x, y) => comparer(keySelector(x), keySelector(y)));
    }
    /**
     * Returns true if the array is already sorted.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static isSorted(array, comparer = Sort.compareByValue) {
        let previous = undefined;
        for (const element of array) {
            if (comparer(previous, element) > 0) {
                return false;
            }
            previous = element;
        }
        return true;
    }
    /**
     * Returns true if the array is already sorted by the specified key.
     *
     * @example
     *
     * ```ts
     * let array: string[] = [ 'a', 'bb', 'ccc' ];
     * Sort.isSortedBy(array, x => x.length); // true
     * ```
     */
    static isSortedBy(array, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    keySelector, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    comparer = Sort.compareByValue) {
        let previousKey = undefined;
        for (const element of array) {
            const key = keySelector(element);
            if (comparer(previousKey, key) > 0) {
                return false;
            }
            previousKey = key;
        }
        return true;
    }
    /**
     * Sorts the entries in a Map object according to the map keys.
     * The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let map: Map<string, number> = new Map<string, number>();
     * map.set('zebra', 1);
     * map.set('goose', 2);
     * map.set('aardvark', 3);
     * Sort.sortMapKeys(map);
     * console.log(JSON.stringify(Array.from(map.keys()))); // ["aardvark","goose","zebra"]
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static sortMapKeys(map, keyComparer = Sort.compareByValue) {
        const pairs = Array.from(map.entries());
        // Sorting a map is expensive, so first check whether it's already sorted.
        if (Sort.isSortedBy(pairs, (x) => x[0], keyComparer)) {
            return;
        }
        Sort.sortBy(pairs, (x) => x[0], keyComparer);
        map.clear();
        for (const pair of pairs) {
            map.set(pair[0], pair[1]);
        }
    }
    /**
     * Sorts the entries in a Set object according to the specified keys.
     * The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let set: Set<string> = new Set<string>();
     * set.add('aaa');
     * set.add('bb');
     * set.add('c');
     * Sort.sortSetBy(set, x => x.length);
     * console.log(Array.from(set)); // ['c', 'bb', 'aaa']
     * ```
     */
    static sortSetBy(set, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    keySelector, keyComparer = Sort.compareByValue) {
        const array = Array.from(set);
        // Sorting a set is expensive, so first check whether it's already sorted.
        if (Sort.isSortedBy(array, keySelector, keyComparer)) {
            return;
        }
        LegacyAdapters_1.LegacyAdapters.sortStable(array, (x, y) => keyComparer(keySelector(x), keySelector(y)));
        set.clear();
        for (const item of array) {
            set.add(item);
        }
    }
    /**
     * Sorts the entries in a Set object.  The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let set: Set<string> = new Set<string>();
     * set.add('zebra');
     * set.add('goose');
     * set.add('aardvark');
     * Sort.sortSet(set);
     * console.log(Array.from(set)); // ['aardvark', 'goose', 'zebra']
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static sortSet(set, comparer = Sort.compareByValue) {
        const array = Array.from(set);
        // Sorting a set is expensive, so first check whether it's already sorted.
        if (Sort.isSorted(array, comparer)) {
            return;
        }
        LegacyAdapters_1.LegacyAdapters.sortStable(array, (x, y) => comparer(x, y));
        set.clear();
        for (const item of array) {
            set.add(item);
        }
    }
}
exports.Sort = Sort;
//# sourceMappingURL=Sort.js.map

/***/ }),

/***/ 30244:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringBuilder = void 0;
/**
 * This class allows a large text string to be constructed incrementally by appending small chunks.  The final
 * string can be obtained by calling StringBuilder.toString().
 *
 * @remarks
 * A naive approach might use the `+=` operator to append strings:  This would have the downside of copying
 * the entire string each time a chunk is appended, resulting in `O(n^2)` bytes of memory being allocated
 * (and later freed by the garbage  collector), and many of the allocations could be very large objects.
 * StringBuilder avoids this overhead by accumulating the chunks in an array, and efficiently joining them
 * when `getText()` is finally called.
 *
 * @public
 */
class StringBuilder {
    constructor() {
        this._chunks = [];
    }
    /** {@inheritDoc IStringBuilder.append} */
    append(text) {
        this._chunks.push(text);
    }
    /** {@inheritDoc IStringBuilder.toString} */
    toString() {
        if (this._chunks.length === 0) {
            return '';
        }
        if (this._chunks.length > 1) {
            const joined = this._chunks.join('');
            this._chunks.length = 1;
            this._chunks[0] = joined;
        }
        return this._chunks[0];
    }
}
exports.StringBuilder = StringBuilder;
//# sourceMappingURL=StringBuilder.js.map

/***/ }),

/***/ 28533:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnsiEscape = void 0;
const Colors_1 = __webpack_require__(9017);
/**
 * Operations for working with text strings that contain
 * {@link https://en.wikipedia.org/wiki/ANSI_escape_code | ANSI escape codes}.
 * The most commonly used escape codes set the foreground/background color for console output.
 * @public
 */
class AnsiEscape {
    /**
     * Returns the input text with all ANSI escape codes removed.  For example, this is useful when saving
     * colorized console output to a log file.
     */
    static removeCodes(text) {
        // eslint-disable-next-line no-control-regex
        return text.replace(AnsiEscape._csiRegExp, '');
    }
    /**
     * Replaces ANSI escape codes with human-readable tokens.  This is useful for unit tests
     * that compare text strings in test assertions or snapshot files.
     */
    static formatForTests(text, options) {
        if (!options) {
            options = {};
        }
        let result = text.replace(AnsiEscape._csiRegExp, (capture, csiCode) => {
            // If it is an SGR code, then try to show a friendly token
            const match = csiCode.match(AnsiEscape._sgrRegExp);
            if (match) {
                const sgrParameter = parseInt(match[1]);
                const sgrParameterName = AnsiEscape._tryGetSgrFriendlyName(sgrParameter);
                if (sgrParameterName) {
                    // Example: "[black-bg]"
                    return `[${sgrParameterName}]`;
                }
            }
            // Otherwise show the raw code, but without the "[" from the CSI prefix
            // Example: "[31m]"
            return `[${csiCode}]`;
        });
        if (options.encodeNewlines) {
            result = result
                .replace(AnsiEscape._backslashNRegExp, '[n]')
                .replace(AnsiEscape._backslashRRegExp, `[r]`);
        }
        return result;
    }
    // Returns a human-readable token representing an SGR parameter, or undefined for parameter that is not well-known.
    // The SGR parameter numbers are documented in this table:
    // https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_parameters
    static _tryGetSgrFriendlyName(sgiParameter) {
        switch (sgiParameter) {
            case Colors_1.ConsoleColorCodes.BlackForeground:
                return 'black';
            case Colors_1.ConsoleColorCodes.RedForeground:
                return 'red';
            case Colors_1.ConsoleColorCodes.GreenForeground:
                return 'green';
            case Colors_1.ConsoleColorCodes.YellowForeground:
                return 'yellow';
            case Colors_1.ConsoleColorCodes.BlueForeground:
                return 'blue';
            case Colors_1.ConsoleColorCodes.MagentaForeground:
                return 'magenta';
            case Colors_1.ConsoleColorCodes.CyanForeground:
                return 'cyan';
            case Colors_1.ConsoleColorCodes.WhiteForeground:
                return 'white';
            case Colors_1.ConsoleColorCodes.GrayForeground:
                return 'gray';
            case Colors_1.ConsoleColorCodes.DefaultForeground:
                return 'default';
            case Colors_1.ConsoleColorCodes.BlackBackground:
                return 'black-bg';
            case Colors_1.ConsoleColorCodes.RedBackground:
                return 'red-bg';
            case Colors_1.ConsoleColorCodes.GreenBackground:
                return 'green-bg';
            case Colors_1.ConsoleColorCodes.YellowBackground:
                return 'yellow-bg';
            case Colors_1.ConsoleColorCodes.BlueBackground:
                return 'blue-bg';
            case Colors_1.ConsoleColorCodes.MagentaBackground:
                return 'magenta-bg';
            case Colors_1.ConsoleColorCodes.CyanBackground:
                return 'cyan-bg';
            case Colors_1.ConsoleColorCodes.WhiteBackground:
                return 'white-bg';
            case Colors_1.ConsoleColorCodes.GrayBackground:
                return 'gray-bg';
            case Colors_1.ConsoleColorCodes.DefaultBackground:
                return 'default-bg';
            case Colors_1.ConsoleColorCodes.Bold:
                return 'bold';
            case Colors_1.ConsoleColorCodes.Dim:
                return 'dim';
            case Colors_1.ConsoleColorCodes.NormalColorOrIntensity:
                return 'normal';
            case Colors_1.ConsoleColorCodes.Underline:
                return 'underline';
            case Colors_1.ConsoleColorCodes.UnderlineOff:
                return 'underline-off';
            case Colors_1.ConsoleColorCodes.Blink:
                return 'blink';
            case Colors_1.ConsoleColorCodes.BlinkOff:
                return 'blink-off';
            case Colors_1.ConsoleColorCodes.InvertColor:
                return 'invert';
            case Colors_1.ConsoleColorCodes.InvertColorOff:
                return 'invert-off';
            case Colors_1.ConsoleColorCodes.Hidden:
                return 'hidden';
            case Colors_1.ConsoleColorCodes.HiddenOff:
                return 'hidden-off';
            default:
                return undefined;
        }
    }
}
exports.AnsiEscape = AnsiEscape;
// For now, we only care about the Control Sequence Introducer (CSI) commands which always start with "[".
// eslint-disable-next-line no-control-regex
AnsiEscape._csiRegExp = /\x1b\[([\x30-\x3f]*[\x20-\x2f]*[\x40-\x7e])/gu;
// Text coloring is performed using Select Graphic Rendition (SGR) codes, which come after the
// CSI introducer "ESC [".  The SGR sequence is a number followed by "m".
AnsiEscape._sgrRegExp = /([0-9]+)m/u;
AnsiEscape._backslashNRegExp = /\n/g;
AnsiEscape._backslashRRegExp = /\r/g;
//# sourceMappingURL=AnsiEscape.js.map

/***/ }),

/***/ 9017:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Colors = exports.ConsoleColorCodes = exports.TextAttribute = exports.ColorValue = exports.eolSequence = void 0;
exports.eolSequence = {
    isEol: true
};
/**
 * Colors used with {@link IColorableSequence}.
 * @beta
 */
var ColorValue;
(function (ColorValue) {
    ColorValue[ColorValue["Black"] = 0] = "Black";
    ColorValue[ColorValue["Red"] = 1] = "Red";
    ColorValue[ColorValue["Green"] = 2] = "Green";
    ColorValue[ColorValue["Yellow"] = 3] = "Yellow";
    ColorValue[ColorValue["Blue"] = 4] = "Blue";
    ColorValue[ColorValue["Magenta"] = 5] = "Magenta";
    ColorValue[ColorValue["Cyan"] = 6] = "Cyan";
    ColorValue[ColorValue["White"] = 7] = "White";
    ColorValue[ColorValue["Gray"] = 8] = "Gray";
})(ColorValue = exports.ColorValue || (exports.ColorValue = {}));
/**
 * Text styles used with {@link IColorableSequence}.
 * @beta
 */
var TextAttribute;
(function (TextAttribute) {
    TextAttribute[TextAttribute["Bold"] = 0] = "Bold";
    TextAttribute[TextAttribute["Dim"] = 1] = "Dim";
    TextAttribute[TextAttribute["Underline"] = 2] = "Underline";
    TextAttribute[TextAttribute["Blink"] = 3] = "Blink";
    TextAttribute[TextAttribute["InvertColor"] = 4] = "InvertColor";
    TextAttribute[TextAttribute["Hidden"] = 5] = "Hidden";
})(TextAttribute = exports.TextAttribute || (exports.TextAttribute = {}));
var ConsoleColorCodes;
(function (ConsoleColorCodes) {
    ConsoleColorCodes[ConsoleColorCodes["BlackForeground"] = 30] = "BlackForeground";
    ConsoleColorCodes[ConsoleColorCodes["RedForeground"] = 31] = "RedForeground";
    ConsoleColorCodes[ConsoleColorCodes["GreenForeground"] = 32] = "GreenForeground";
    ConsoleColorCodes[ConsoleColorCodes["YellowForeground"] = 33] = "YellowForeground";
    ConsoleColorCodes[ConsoleColorCodes["BlueForeground"] = 34] = "BlueForeground";
    ConsoleColorCodes[ConsoleColorCodes["MagentaForeground"] = 35] = "MagentaForeground";
    ConsoleColorCodes[ConsoleColorCodes["CyanForeground"] = 36] = "CyanForeground";
    ConsoleColorCodes[ConsoleColorCodes["WhiteForeground"] = 37] = "WhiteForeground";
    ConsoleColorCodes[ConsoleColorCodes["GrayForeground"] = 90] = "GrayForeground";
    ConsoleColorCodes[ConsoleColorCodes["DefaultForeground"] = 39] = "DefaultForeground";
    ConsoleColorCodes[ConsoleColorCodes["BlackBackground"] = 40] = "BlackBackground";
    ConsoleColorCodes[ConsoleColorCodes["RedBackground"] = 41] = "RedBackground";
    ConsoleColorCodes[ConsoleColorCodes["GreenBackground"] = 42] = "GreenBackground";
    ConsoleColorCodes[ConsoleColorCodes["YellowBackground"] = 43] = "YellowBackground";
    ConsoleColorCodes[ConsoleColorCodes["BlueBackground"] = 44] = "BlueBackground";
    ConsoleColorCodes[ConsoleColorCodes["MagentaBackground"] = 45] = "MagentaBackground";
    ConsoleColorCodes[ConsoleColorCodes["CyanBackground"] = 46] = "CyanBackground";
    ConsoleColorCodes[ConsoleColorCodes["WhiteBackground"] = 47] = "WhiteBackground";
    ConsoleColorCodes[ConsoleColorCodes["GrayBackground"] = 100] = "GrayBackground";
    ConsoleColorCodes[ConsoleColorCodes["DefaultBackground"] = 49] = "DefaultBackground";
    ConsoleColorCodes[ConsoleColorCodes["Bold"] = 1] = "Bold";
    // On Linux, the "BoldOff" code instead causes the text to be double-underlined:
    // https://en.wikipedia.org/wiki/Talk:ANSI_escape_code#SGR_21%E2%80%94%60Bold_off%60_not_widely_supported
    // Use "NormalColorOrIntensity" instead
    // BoldOff = 21,
    ConsoleColorCodes[ConsoleColorCodes["Dim"] = 2] = "Dim";
    ConsoleColorCodes[ConsoleColorCodes["NormalColorOrIntensity"] = 22] = "NormalColorOrIntensity";
    ConsoleColorCodes[ConsoleColorCodes["Underline"] = 4] = "Underline";
    ConsoleColorCodes[ConsoleColorCodes["UnderlineOff"] = 24] = "UnderlineOff";
    ConsoleColorCodes[ConsoleColorCodes["Blink"] = 5] = "Blink";
    ConsoleColorCodes[ConsoleColorCodes["BlinkOff"] = 25] = "BlinkOff";
    ConsoleColorCodes[ConsoleColorCodes["InvertColor"] = 7] = "InvertColor";
    ConsoleColorCodes[ConsoleColorCodes["InvertColorOff"] = 27] = "InvertColorOff";
    ConsoleColorCodes[ConsoleColorCodes["Hidden"] = 8] = "Hidden";
    ConsoleColorCodes[ConsoleColorCodes["HiddenOff"] = 28] = "HiddenOff";
})(ConsoleColorCodes = exports.ConsoleColorCodes || (exports.ConsoleColorCodes = {}));
/**
 * The static functions on this class are used to produce colored text
 * for use with the node-core-library terminal.
 *
 * @example
 * terminal.writeLine(Colors.green('Green Text!'), ' ', Colors.blue('Blue Text!'));
 *
 * @beta
 */
class Colors {
    static black(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Black });
    }
    static red(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Red });
    }
    static green(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Green });
    }
    static yellow(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Yellow });
    }
    static blue(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Blue });
    }
    static magenta(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Magenta });
    }
    static cyan(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Cyan });
    }
    static white(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.White });
    }
    static gray(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Gray });
    }
    static blackBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Black });
    }
    static redBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Red });
    }
    static greenBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Green });
    }
    static yellowBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Yellow });
    }
    static blueBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Blue });
    }
    static magentaBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Magenta });
    }
    static cyanBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Cyan });
    }
    static whiteBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.White });
    }
    static grayBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Gray });
    }
    static bold(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Bold);
    }
    static dim(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Dim);
    }
    static underline(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Underline);
    }
    static blink(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Blink);
    }
    static invertColor(text) {
        return Colors._applyTextAttribute(text, TextAttribute.InvertColor);
    }
    static hidden(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Hidden);
    }
    /**
     * If called with a string, returns the string wrapped in a {@link IColorableSequence}.
     * If called with a {@link IColorableSequence}, returns the {@link IColorableSequence}.
     *
     * @internal
     */
    static _normalizeStringOrColorableSequence(value) {
        if (typeof value === 'string') {
            return {
                text: value
            };
        }
        else {
            return value;
        }
    }
    static _applyTextAttribute(text, attribute) {
        const sequence = Colors._normalizeStringOrColorableSequence(text);
        if (!sequence.textAttributes) {
            sequence.textAttributes = [];
        }
        sequence.textAttributes.push(attribute);
        return sequence;
    }
}
exports.Colors = Colors;
//# sourceMappingURL=Colors.js.map

/***/ }),

/***/ 65831:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsoleTerminalProvider = void 0;
const os_1 = __webpack_require__(12087);
const safe_1 = __webpack_require__(41997);
const ITerminalProvider_1 = __webpack_require__(24334);
/**
 * Terminal provider that prints to STDOUT (for log- and verbose-level messages) and
 * STDERR (for warning- and error-level messsages).
 *
 * @beta
 */
class ConsoleTerminalProvider {
    constructor(options = {}) {
        /**
         * If true, verbose-level messages should be written to the console.
         */
        this.verboseEnabled = false;
        /**
         * If true, debug-level messages should be written to the console.
         */
        this.debugEnabled = false;
        this.verboseEnabled = !!options.verboseEnabled;
        this.debugEnabled = !!options.debugEnabled;
    }
    /**
     * {@inheritDoc ITerminalProvider.write}
     */
    write(data, severity) {
        switch (severity) {
            case ITerminalProvider_1.TerminalProviderSeverity.warning:
            case ITerminalProvider_1.TerminalProviderSeverity.error: {
                process.stderr.write(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.verbose: {
                if (this.verboseEnabled) {
                    process.stdout.write(data);
                }
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.debug: {
                if (this.debugEnabled) {
                    process.stdout.write(data);
                }
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.log:
            default: {
                process.stdout.write(data);
                break;
            }
        }
    }
    /**
     * {@inheritDoc ITerminalProvider.eolCharacter}
     */
    get eolCharacter() {
        return os_1.EOL;
    }
    /**
     * {@inheritDoc ITerminalProvider.supportsColor}
     */
    get supportsColor() {
        return safe_1.enabled;
    }
}
exports.ConsoleTerminalProvider = ConsoleTerminalProvider;
//# sourceMappingURL=ConsoleTerminalProvider.js.map

/***/ }),

/***/ 24334:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TerminalProviderSeverity = void 0;
/**
 * Similar to many popular logging packages, terminal providers support a range of message
 * severities. These severities have built-in formatting defaults in the Terminal object
 * (warnings are yellow, errors are red, etc.).
 *
 * Terminal providers may choose to suppress certain messages based on their severity,
 * or to route some messages to other providers or not based on severity.
 *
 *   Severity  | Purpose
 *   --------- | -------
 *   error     | Build errors and fatal issues
 *   warning   | Not necessarily fatal, but indicate a problem the user should fix
 *   log       | Informational messages
 *   verbose   | Additional information that may not always be necessary
 *   debug     | Highest detail level, best used for troubleshooting information
 *
 * @beta
 */
var TerminalProviderSeverity;
(function (TerminalProviderSeverity) {
    TerminalProviderSeverity[TerminalProviderSeverity["log"] = 0] = "log";
    TerminalProviderSeverity[TerminalProviderSeverity["warning"] = 1] = "warning";
    TerminalProviderSeverity[TerminalProviderSeverity["error"] = 2] = "error";
    TerminalProviderSeverity[TerminalProviderSeverity["verbose"] = 3] = "verbose";
    TerminalProviderSeverity[TerminalProviderSeverity["debug"] = 4] = "debug";
})(TerminalProviderSeverity = exports.TerminalProviderSeverity || (exports.TerminalProviderSeverity = {}));
//# sourceMappingURL=ITerminalProvider.js.map

/***/ }),

/***/ 53912:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringBufferTerminalProvider = void 0;
const ITerminalProvider_1 = __webpack_require__(24334);
const StringBuilder_1 = __webpack_require__(30244);
const Text_1 = __webpack_require__(77087);
const AnsiEscape_1 = __webpack_require__(28533);
/**
 * Terminal provider that stores written data in buffers separated by severity.
 * This terminal provider is designed to be used when code that prints to a terminal
 * is being unit tested.
 *
 * @beta
 */
class StringBufferTerminalProvider {
    constructor(supportsColor = false) {
        this._standardBuffer = new StringBuilder_1.StringBuilder();
        this._verboseBuffer = new StringBuilder_1.StringBuilder();
        this._debugBuffer = new StringBuilder_1.StringBuilder();
        this._warningBuffer = new StringBuilder_1.StringBuilder();
        this._errorBuffer = new StringBuilder_1.StringBuilder();
        this._supportsColor = supportsColor;
    }
    /**
     * {@inheritDoc ITerminalProvider.write}
     */
    write(data, severity) {
        switch (severity) {
            case ITerminalProvider_1.TerminalProviderSeverity.warning: {
                this._warningBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.error: {
                this._errorBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.verbose: {
                this._verboseBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.debug: {
                this._debugBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.log:
            default: {
                this._standardBuffer.append(data);
                break;
            }
        }
    }
    /**
     * {@inheritDoc ITerminalProvider.eolCharacter}
     */
    get eolCharacter() {
        return '[n]';
    }
    /**
     * {@inheritDoc ITerminalProvider.supportsColor}
     */
    get supportsColor() {
        return this._supportsColor;
    }
    /**
     * Get everything that has been written at log-level severity.
     */
    getOutput(options) {
        return this._normalizeOutput(this._standardBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at verbose-level severity.
     */
    getVerbose(options) {
        return this._normalizeOutput(this._verboseBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at debug-level severity.
     */
    getDebugOutput(options) {
        return this._normalizeOutput(this._debugBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at error-level severity.
     */
    getErrorOutput(options) {
        return this._normalizeOutput(this._errorBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at warning-level severity.
     */
    getWarningOutput(options) {
        return this._normalizeOutput(this._warningBuffer.toString(), options);
    }
    _normalizeOutput(s, options) {
        options = Object.assign({ normalizeSpecialCharacters: true }, (options || {}));
        s = Text_1.Text.convertToLf(s);
        if (options.normalizeSpecialCharacters) {
            return AnsiEscape_1.AnsiEscape.formatForTests(s, { encodeNewlines: true });
        }
        else {
            return s;
        }
    }
}
exports.StringBufferTerminalProvider = StringBufferTerminalProvider;
//# sourceMappingURL=StringBufferTerminalProvider.js.map

/***/ }),

/***/ 99443:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Terminal = void 0;
const ITerminalProvider_1 = __webpack_require__(24334);
const Colors_1 = __webpack_require__(9017);
/**
 * This class facilitates writing to a console.
 *
 * @beta
 */
class Terminal {
    constructor(provider) {
        this._providers = new Set();
        this._providers.add(provider);
    }
    /**
     * {@inheritdoc ITerminal.registerProvider}
     */
    registerProvider(provider) {
        this._providers.add(provider);
    }
    /**
     * {@inheritdoc ITerminal.unregisterProvider}
     */
    unregisterProvider(provider) {
        if (this._providers.has(provider)) {
            this._providers.delete(provider);
        }
    }
    /**
     * {@inheritdoc ITerminal.write}
     */
    write(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.log);
    }
    /**
     * {@inheritdoc ITerminal.writeLine}
     */
    writeLine(...messageParts) {
        this.write(...messageParts, Colors_1.eolSequence);
    }
    /**
     * {@inheritdoc ITerminal.writeWarning}
     */
    writeWarning(...messageParts) {
        this._writeSegmentsToProviders(messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Yellow }))), ITerminalProvider_1.TerminalProviderSeverity.warning);
    }
    /**
     * {@inheritdoc ITerminal.writeWarningLine}
     */
    writeWarningLine(...messageParts) {
        this._writeSegmentsToProviders([
            ...messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Yellow }))),
            Colors_1.eolSequence
        ], ITerminalProvider_1.TerminalProviderSeverity.warning);
    }
    /**
     * {@inheritdoc ITerminal.writeError}
     */
    writeError(...messageParts) {
        this._writeSegmentsToProviders(messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Red }))), ITerminalProvider_1.TerminalProviderSeverity.error);
    }
    /**
     * {@inheritdoc ITerminal.writeErrorLine}
     */
    writeErrorLine(...messageParts) {
        this._writeSegmentsToProviders([
            ...messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Red }))),
            Colors_1.eolSequence
        ], ITerminalProvider_1.TerminalProviderSeverity.error);
    }
    /**
     * {@inheritdoc ITerminal.writeVerbose}
     */
    writeVerbose(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.verbose);
    }
    /**
     * {@inheritdoc ITerminal.writeVerboseLine}
     */
    writeVerboseLine(...messageParts) {
        this.writeVerbose(...messageParts, Colors_1.eolSequence);
    }
    /**
     * {@inheritdoc ITerminal.writeDebug}
     */
    writeDebug(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.debug);
    }
    /**
     * {@inheritdoc ITerminal.writeDebugLine}
     */
    writeDebugLine(...messageParts) {
        this.writeDebug(...messageParts, Colors_1.eolSequence);
    }
    _writeSegmentsToProviders(segments, severity) {
        const withColorText = {};
        const withoutColorText = {};
        let withColorLines;
        let withoutColorLines;
        this._providers.forEach((provider) => {
            const eol = provider.eolCharacter;
            let textToWrite;
            if (provider.supportsColor) {
                if (!withColorLines) {
                    withColorLines = this._serializeFormattableTextSegments(segments, true);
                }
                if (!withColorText[eol]) {
                    withColorText[eol] = withColorLines.join(eol);
                }
                textToWrite = withColorText[eol];
            }
            else {
                if (!withoutColorLines) {
                    withoutColorLines = this._serializeFormattableTextSegments(segments, false);
                }
                if (!withoutColorText[eol]) {
                    withoutColorText[eol] = withoutColorLines.join(eol);
                }
                textToWrite = withoutColorText[eol];
            }
            provider.write(textToWrite, severity);
        });
    }
    _serializeFormattableTextSegments(segments, withColor) {
        const lines = [];
        let segmentsToJoin = [];
        let lastSegmentWasEol = false;
        for (let i = 0; i < segments.length; i++) {
            const segment = Colors_1.Colors._normalizeStringOrColorableSequence(segments[i]);
            lastSegmentWasEol = !!segment.isEol;
            if (lastSegmentWasEol) {
                lines.push(segmentsToJoin.join(''));
                segmentsToJoin = [];
            }
            else {
                if (withColor) {
                    const startColorCodes = [];
                    const endColorCodes = [];
                    switch (segment.foregroundColor) {
                        case Colors_1.ColorValue.Black: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlackForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Red: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.RedForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Green: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GreenForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Yellow: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.YellowForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Blue: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlueForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Magenta: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.MagentaForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Cyan: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.CyanForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.White: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.WhiteForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Gray: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GrayForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                    }
                    switch (segment.backgroundColor) {
                        case Colors_1.ColorValue.Black: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlackBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Red: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.RedBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Green: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GreenBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Yellow: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.YellowBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Blue: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlueBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Magenta: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.MagentaBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Cyan: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.CyanBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.White: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.WhiteBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Gray: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GrayBackground);
                            endColorCodes.push(49);
                            break;
                        }
                    }
                    if (segment.textAttributes) {
                        for (const textAttribute of segment.textAttributes) {
                            switch (textAttribute) {
                                case Colors_1.TextAttribute.Bold: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Bold);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.NormalColorOrIntensity);
                                    break;
                                }
                                case Colors_1.TextAttribute.Dim: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Dim);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.NormalColorOrIntensity);
                                    break;
                                }
                                case Colors_1.TextAttribute.Underline: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Underline);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.UnderlineOff);
                                    break;
                                }
                                case Colors_1.TextAttribute.Blink: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Blink);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.BlinkOff);
                                    break;
                                }
                                case Colors_1.TextAttribute.InvertColor: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.InvertColor);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.InvertColorOff);
                                    break;
                                }
                                case Colors_1.TextAttribute.Hidden: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Hidden);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.HiddenOff);
                                    break;
                                }
                            }
                        }
                    }
                    for (let j = 0; j < startColorCodes.length; j++) {
                        const code = startColorCodes[j];
                        segmentsToJoin.push(...['\u001b[', code.toString(), 'm']);
                    }
                    segmentsToJoin.push(segment.text);
                    for (let j = endColorCodes.length - 1; j >= 0; j--) {
                        const code = endColorCodes[j];
                        segmentsToJoin.push(...['\u001b[', code.toString(), 'm']);
                    }
                }
                else {
                    segmentsToJoin.push(segment.text);
                }
            }
        }
        if (segmentsToJoin.length > 0) {
            lines.push(segmentsToJoin.join(''));
        }
        if (lastSegmentWasEol) {
            lines.push('');
        }
        return lines;
    }
}
exports.Terminal = Terminal;
//# sourceMappingURL=Terminal.js.map

/***/ }),

/***/ 77087:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Text = void 0;
const os = __importStar(__webpack_require__(12087));
/**
 * Operations for working with strings that contain text.
 *
 * @remarks
 * The utilities provided by this class are intended to be simple, small, and very
 * broadly applicable.
 *
 * @public
 */
class Text {
    /**
     * Returns the same thing as targetString.replace(searchValue, replaceValue), except that
     * all matches are replaced, rather than just the first match.
     * @param input         - The string to be modified
     * @param searchValue   - The value to search for
     * @param replaceValue  - The replacement text
     */
    static replaceAll(input, searchValue, replaceValue) {
        return input.split(searchValue).join(replaceValue);
    }
    /**
     * Converts all newlines in the provided string to use Windows-style CRLF end of line characters.
     */
    static convertToCrLf(input) {
        return input.replace(Text._newLineRegEx, '\r\n');
    }
    /**
     * Converts all newlines in the provided string to use POSIX-style LF end of line characters.
     *
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    static convertToLf(input) {
        return input.replace(Text._newLineRegEx, '\n');
    }
    /**
     * Converts all newlines in the provided string to use the specified newline type.
     */
    static convertTo(input, newlineKind) {
        return input.replace(Text._newLineRegEx, Text.getNewline(newlineKind));
    }
    /**
     * Returns the newline character sequence for the specified `NewlineKind`.
     */
    static getNewline(newlineKind) {
        switch (newlineKind) {
            case "\r\n" /* CrLf */:
                return '\r\n';
            case "\n" /* Lf */:
                return '\n';
            case "os" /* OsDefault */:
                return os.EOL;
            default:
                throw new Error('Unsupported newline kind');
        }
    }
    /**
     * Append characters to the end of a string to ensure the result has a minimum length.
     * @remarks
     * If the string length already exceeds the minimum length, then the string is unchanged.
     * The string is not truncated.
     */
    static padEnd(s, minimumLength, paddingCharacter = ' ') {
        if (paddingCharacter.length !== 1) {
            throw new Error('The paddingCharacter parameter must be a single character.');
        }
        if (s.length < minimumLength) {
            const paddingArray = new Array(minimumLength - s.length);
            paddingArray.unshift(s);
            return paddingArray.join(paddingCharacter);
        }
        else {
            return s;
        }
    }
    /**
     * Append characters to the start of a string to ensure the result has a minimum length.
     * @remarks
     * If the string length already exceeds the minimum length, then the string is unchanged.
     * The string is not truncated.
     */
    static padStart(s, minimumLength, paddingCharacter = ' ') {
        if (paddingCharacter.length !== 1) {
            throw new Error('The paddingCharacter parameter must be a single character.');
        }
        if (s.length < minimumLength) {
            const paddingArray = new Array(minimumLength - s.length);
            paddingArray.push(s);
            return paddingArray.join(paddingCharacter);
        }
        else {
            return s;
        }
    }
    /**
     * If the string is longer than maximumLength characters, truncate it to that length
     * using "..." to indicate the truncation.
     *
     * @remarks
     * For example truncateWithEllipsis('1234578', 5) would produce '12...'.
     */
    static truncateWithEllipsis(s, maximumLength) {
        if (maximumLength < 0) {
            throw new Error('The maximumLength cannot be a negative number');
        }
        if (s.length <= maximumLength) {
            return s;
        }
        if (s.length <= 3) {
            return s.substring(0, maximumLength);
        }
        return s.substring(0, maximumLength - 3) + '...';
    }
    /**
     * Returns the input string with a trailing `\n` character appended, if not already present.
     */
    static ensureTrailingNewline(s, newlineKind = "\n" /* Lf */) {
        // Is there already a newline?
        if (Text._newLineAtEndRegEx.test(s)) {
            return s; // yes, no change
        }
        return s + newlineKind; // no, add it
    }
}
exports.Text = Text;
Text._newLineRegEx = /\r\n|\n\r|\r|\n/g;
Text._newLineAtEndRegEx = /(\r\n|\n\r|\r|\n)$/;
//# sourceMappingURL=Text.js.map

/***/ }),

/***/ 11727:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeUuid = void 0;
const InternalError_1 = __webpack_require__(28630);
const classPrototypeUuidSymbol = Symbol.for('TypeUuid.classPrototypeUuid');
/**
 * Provides a version-independent implementation of the JavaScript `instanceof` operator.
 *
 * @remarks
 * The JavaScript `instanceof` operator normally only identifies objects from a particular library instance.
 * For example, suppose the NPM package `example-lib` has two published versions 1.2.0 and 1.3.0, and
 * it exports a class called `A`.  Suppose some code consumes version `1.3.0` of the library, but it receives
 * an object that was constructed using version `1.2.0`.  In this situation `a instanceof A` will return `false`,
 * even though `a` is an instance of `A`.  The reason is that there are two prototypes for `A`; one for each
 * version.
 *
 * The `TypeUuid` facility provides a way to make `a instanceof A` return true for both prototypes of `A`,
 * by instead using a universally unique identifier (UUID) to detect object instances.
 *
 * You can use `Symbol.hasInstance` to enable the system `instanceof` operator to recognize type UUID equivalence:
 * ```ts
 * const uuidWidget: string = '9c340ef0-d29f-4e2e-a09f-42bacc59024b';
 * class Widget {
 *   public static [Symbol.hasInstance](instance: object): boolean {
 *     return TypeUuid.isInstanceOf(instance, uuidWidget);
 *   }
 * }
 * ```
 * // Example usage:
 * ```ts
 * import { Widget as Widget1 } from 'v1-of-library';
 * import { Widget as Widget2 } from 'v2-of-library';
 * const widget = new Widget2();
 * console.log(widget instanceof Widget1); // prints true
 * ```
 *
 * @public
 */
class TypeUuid {
    /**
     * Registers a JavaScript class as having a type identified by the specified UUID.
     * @privateRemarks
     * We cannot use a construct signature for `targetClass` because it may be an abstract class.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static registerClass(targetClass, typeUuid) {
        if (typeof targetClass !== 'function') {
            throw new Error('The targetClass parameter must be a JavaScript class');
        }
        if (!TypeUuid._uuidRegExp.test(typeUuid)) {
            throw new Error(`The type UUID must be specified as lowercase hexadecimal with dashes: "${typeUuid}"`);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const targetClassPrototype = targetClass.prototype;
        if (Object.hasOwnProperty.call(targetClassPrototype, classPrototypeUuidSymbol)) {
            const existingUuid = targetClassPrototype[classPrototypeUuidSymbol];
            throw new InternalError_1.InternalError(`Cannot register the target class ${targetClass.name || ''} typeUuid=${typeUuid}` +
                ` because it was already registered with typeUuid=${existingUuid}`);
        }
        targetClassPrototype[classPrototypeUuidSymbol] = typeUuid;
    }
    /**
     * Returns true if the `targetObject` is an instance of a JavaScript class that was previously
     * registered using the specified `typeUuid`.  Base classes are also considered.
     */
    static isInstanceOf(targetObject, typeUuid) {
        if (targetObject === undefined || targetObject === null) {
            return false;
        }
        let objectPrototype = Object.getPrototypeOf(targetObject);
        while (objectPrototype !== undefined && objectPrototype !== null) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const registeredUuid = objectPrototype[classPrototypeUuidSymbol];
            if (registeredUuid === typeUuid) {
                return true;
            }
            // Walk upwards an examine base class prototypes
            objectPrototype = Object.getPrototypeOf(objectPrototype);
        }
        return false;
    }
}
exports.TypeUuid = TypeUuid;
TypeUuid._uuidRegExp = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
//# sourceMappingURL=TypeUuid.js.map

/***/ }),

/***/ 38437:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeUuid = exports.StringBufferTerminalProvider = exports.ConsoleTerminalProvider = exports.TerminalProviderSeverity = exports.TextAttribute = exports.ColorValue = exports.Colors = exports.Terminal = exports.StringBuilder = exports.LegacyAdapters = exports.FileWriter = exports.FileSystem = exports.Sort = exports.Text = exports.Path = exports.PackageNameParser = exports.PackageName = exports.PackageJsonLookup = exports.ProtectableMap = exports.MapExtensions = exports.LockFile = exports.JsonSchema = exports.JsonFile = exports.InternalError = exports.Import = exports.Executable = exports.EnvironmentMap = exports.Enum = exports.Async = exports.AnsiEscape = exports.AlreadyReportedError = void 0;
/**
 * Core libraries that every NodeJS toolchain project should use.
 *
 * @packageDocumentation
 */
var AlreadyReportedError_1 = __webpack_require__(82856);
Object.defineProperty(exports, "AlreadyReportedError", ({ enumerable: true, get: function () { return AlreadyReportedError_1.AlreadyReportedError; } }));
var AnsiEscape_1 = __webpack_require__(28533);
Object.defineProperty(exports, "AnsiEscape", ({ enumerable: true, get: function () { return AnsiEscape_1.AnsiEscape; } }));
var Async_1 = __webpack_require__(50054);
Object.defineProperty(exports, "Async", ({ enumerable: true, get: function () { return Async_1.Async; } }));
var Enum_1 = __webpack_require__(48839);
Object.defineProperty(exports, "Enum", ({ enumerable: true, get: function () { return Enum_1.Enum; } }));
var EnvironmentMap_1 = __webpack_require__(88935);
Object.defineProperty(exports, "EnvironmentMap", ({ enumerable: true, get: function () { return EnvironmentMap_1.EnvironmentMap; } }));
var Executable_1 = __webpack_require__(74652);
Object.defineProperty(exports, "Executable", ({ enumerable: true, get: function () { return Executable_1.Executable; } }));
var Import_1 = __webpack_require__(61503);
Object.defineProperty(exports, "Import", ({ enumerable: true, get: function () { return Import_1.Import; } }));
var InternalError_1 = __webpack_require__(28630);
Object.defineProperty(exports, "InternalError", ({ enumerable: true, get: function () { return InternalError_1.InternalError; } }));
var JsonFile_1 = __webpack_require__(17058);
Object.defineProperty(exports, "JsonFile", ({ enumerable: true, get: function () { return JsonFile_1.JsonFile; } }));
var JsonSchema_1 = __webpack_require__(10158);
Object.defineProperty(exports, "JsonSchema", ({ enumerable: true, get: function () { return JsonSchema_1.JsonSchema; } }));
var LockFile_1 = __webpack_require__(46186);
Object.defineProperty(exports, "LockFile", ({ enumerable: true, get: function () { return LockFile_1.LockFile; } }));
var MapExtensions_1 = __webpack_require__(59442);
Object.defineProperty(exports, "MapExtensions", ({ enumerable: true, get: function () { return MapExtensions_1.MapExtensions; } }));
var ProtectableMap_1 = __webpack_require__(56337);
Object.defineProperty(exports, "ProtectableMap", ({ enumerable: true, get: function () { return ProtectableMap_1.ProtectableMap; } }));
var PackageJsonLookup_1 = __webpack_require__(42172);
Object.defineProperty(exports, "PackageJsonLookup", ({ enumerable: true, get: function () { return PackageJsonLookup_1.PackageJsonLookup; } }));
var PackageName_1 = __webpack_require__(42901);
Object.defineProperty(exports, "PackageName", ({ enumerable: true, get: function () { return PackageName_1.PackageName; } }));
Object.defineProperty(exports, "PackageNameParser", ({ enumerable: true, get: function () { return PackageName_1.PackageNameParser; } }));
var Path_1 = __webpack_require__(8972);
Object.defineProperty(exports, "Path", ({ enumerable: true, get: function () { return Path_1.Path; } }));
var Text_1 = __webpack_require__(77087);
Object.defineProperty(exports, "Text", ({ enumerable: true, get: function () { return Text_1.Text; } }));
var Sort_1 = __webpack_require__(58890);
Object.defineProperty(exports, "Sort", ({ enumerable: true, get: function () { return Sort_1.Sort; } }));
var FileSystem_1 = __webpack_require__(57422);
Object.defineProperty(exports, "FileSystem", ({ enumerable: true, get: function () { return FileSystem_1.FileSystem; } }));
var FileWriter_1 = __webpack_require__(71135);
Object.defineProperty(exports, "FileWriter", ({ enumerable: true, get: function () { return FileWriter_1.FileWriter; } }));
var LegacyAdapters_1 = __webpack_require__(53457);
Object.defineProperty(exports, "LegacyAdapters", ({ enumerable: true, get: function () { return LegacyAdapters_1.LegacyAdapters; } }));
var StringBuilder_1 = __webpack_require__(30244);
Object.defineProperty(exports, "StringBuilder", ({ enumerable: true, get: function () { return StringBuilder_1.StringBuilder; } }));
var Terminal_1 = __webpack_require__(99443);
Object.defineProperty(exports, "Terminal", ({ enumerable: true, get: function () { return Terminal_1.Terminal; } }));
var Colors_1 = __webpack_require__(9017);
Object.defineProperty(exports, "Colors", ({ enumerable: true, get: function () { return Colors_1.Colors; } }));
Object.defineProperty(exports, "ColorValue", ({ enumerable: true, get: function () { return Colors_1.ColorValue; } }));
Object.defineProperty(exports, "TextAttribute", ({ enumerable: true, get: function () { return Colors_1.TextAttribute; } }));
var ITerminalProvider_1 = __webpack_require__(24334);
Object.defineProperty(exports, "TerminalProviderSeverity", ({ enumerable: true, get: function () { return ITerminalProvider_1.TerminalProviderSeverity; } }));
var ConsoleTerminalProvider_1 = __webpack_require__(65831);
Object.defineProperty(exports, "ConsoleTerminalProvider", ({ enumerable: true, get: function () { return ConsoleTerminalProvider_1.ConsoleTerminalProvider; } }));
var StringBufferTerminalProvider_1 = __webpack_require__(53912);
Object.defineProperty(exports, "StringBufferTerminalProvider", ({ enumerable: true, get: function () { return StringBufferTerminalProvider_1.StringBufferTerminalProvider; } }));
var TypeUuid_1 = __webpack_require__(11727);
Object.defineProperty(exports, "TypeUuid", ({ enumerable: true, get: function () { return TypeUuid_1.TypeUuid; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 32374:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var async = __webpack_require__(39143);
async.core = __webpack_require__(74965);
async.isCore = __webpack_require__(60028);
async.sync = __webpack_require__(72260);

module.exports = async;


/***/ }),

/***/ 39143:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(35747);
var path = __webpack_require__(85622);
var caller = __webpack_require__(40750);
var nodeModulesPaths = __webpack_require__(25645);
var normalizeOptions = __webpack_require__(54464);
var isCore = __webpack_require__(60028);

var realpathFS = fs.realpath && typeof fs.realpath.native === 'function' ? fs.realpath.native : fs.realpath;

var defaultIsFile = function isFile(file, cb) {
    fs.stat(file, function (err, stat) {
        if (!err) {
            return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};

var defaultIsDir = function isDirectory(dir, cb) {
    fs.stat(dir, function (err, stat) {
        if (!err) {
            return cb(null, stat.isDirectory());
        }
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};

var defaultRealpath = function realpath(x, cb) {
    realpathFS(x, function (realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== 'ENOENT') cb(realpathErr);
        else cb(null, realpathErr ? x : realPath);
    });
};

var maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
    } else {
        cb(null, x);
    }
};

var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
};

module.exports = function resolve(x, options, callback) {
    var cb = callback;
    var opts = options;
    if (typeof options === 'function') {
        cb = opts;
        opts = {};
    }
    if (typeof x !== 'string') {
        var err = new TypeError('Path must be a string.');
        return process.nextTick(function () {
            cb(err);
        });
    }

    opts = normalizeOptions(x, opts);

    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile = opts.readFile || fs.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var packageIterator = opts.packageIterator;

    var extensions = opts.extensions || ['.js'];
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || [];

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = path.resolve(basedir);

    maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function (err, realStart) {
            if (err) cb(err);
            else init(realStart);
        }
    );

    var res;
    function init(basedir) {
        if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
            res = path.resolve(basedir, x);
            if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
            if ((/\/$/).test(x) && res === basedir) {
                loadAsDirectory(res, opts.package, onfile);
            } else loadAsFile(res, opts.package, onfile);
        } else if (isCore(x)) {
            return cb(null, x);
        } else loadNodeModules(x, basedir, function (err, n, pkg) {
            if (err) cb(err);
            else if (n) {
                return maybeRealpath(realpath, n, opts, function (err, realN) {
                    if (err) {
                        cb(err);
                    } else {
                        cb(null, realN, pkg);
                    }
                });
            } else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
            }
        });
    }

    function onfile(err, m, pkg) {
        if (err) cb(err);
        else if (m) cb(null, m, pkg);
        else loadAsDirectory(res, function (err, d, pkg) {
            if (err) cb(err);
            else if (d) {
                maybeRealpath(realpath, d, opts, function (err, realD) {
                    if (err) {
                        cb(err);
                    } else {
                        cb(null, realD, pkg);
                    }
                });
            } else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
            }
        });
    }

    function loadAsFile(x, thePackage, callback) {
        var loadAsFilePackage = thePackage;
        var cb = callback;
        if (typeof loadAsFilePackage === 'function') {
            cb = loadAsFilePackage;
            loadAsFilePackage = undefined;
        }

        var exts = [''].concat(extensions);
        load(exts, x, loadAsFilePackage);

        function load(exts, x, loadPackage) {
            if (exts.length === 0) return cb(null, undefined, loadPackage);
            var file = x + exts[0];

            var pkg = loadPackage;
            if (pkg) onpkg(null, pkg);
            else loadpkg(path.dirname(file), onpkg);

            function onpkg(err, pkg_, dir) {
                pkg = pkg_;
                if (err) return cb(err);
                if (dir && pkg && opts.pathFilter) {
                    var rfile = path.relative(dir, file);
                    var rel = rfile.slice(0, rfile.length - exts[0].length);
                    var r = opts.pathFilter(pkg, x, rel);
                    if (r) return load(
                        [''].concat(extensions.slice()),
                        path.resolve(dir, r),
                        pkg
                    );
                }
                isFile(file, onex);
            }
            function onex(err, ex) {
                if (err) return cb(err);
                if (ex) return cb(null, file, pkg);
                load(exts.slice(1), x, pkg);
            }
        }
    }

    function loadpkg(dir, cb) {
        if (dir === '' || dir === '/') return cb(null);
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
            return cb(null);
        }
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return cb(null);

        maybeRealpath(realpath, dir, opts, function (unwrapErr, pkgdir) {
            if (unwrapErr) return loadpkg(path.dirname(dir), cb);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) {
                // on err, ex is false
                if (!ex) return loadpkg(path.dirname(dir), cb);

                readFile(pkgfile, function (err, body) {
                    if (err) cb(err);
                    try { var pkg = JSON.parse(body); } catch (jsonErr) {}

                    if (pkg && opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }
                    cb(null, pkg, dir);
                });
            });
        });
    }

    function loadAsDirectory(x, loadAsDirectoryPackage, callback) {
        var cb = callback;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === 'function') {
            cb = fpkg;
            fpkg = opts.package;
        }

        maybeRealpath(realpath, x, opts, function (unwrapErr, pkgdir) {
            if (unwrapErr) return cb(unwrapErr);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) {
                if (err) return cb(err);
                if (!ex) return loadAsFile(path.join(x, 'index'), fpkg, cb);

                readFile(pkgfile, function (err, body) {
                    if (err) return cb(err);
                    try {
                        var pkg = JSON.parse(body);
                    } catch (jsonErr) {}

                    if (pkg && opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }

                    if (pkg && pkg.main) {
                        if (typeof pkg.main !== 'string') {
                            var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');
                            mainError.code = 'INVALID_PACKAGE_MAIN';
                            return cb(mainError);
                        }
                        if (pkg.main === '.' || pkg.main === './') {
                            pkg.main = 'index';
                        }
                        loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {
                            if (err) return cb(err);
                            if (m) return cb(null, m, pkg);
                            if (!pkg) return loadAsFile(path.join(x, 'index'), pkg, cb);

                            var dir = path.resolve(x, pkg.main);
                            loadAsDirectory(dir, pkg, function (err, n, pkg) {
                                if (err) return cb(err);
                                if (n) return cb(null, n, pkg);
                                loadAsFile(path.join(x, 'index'), pkg, cb);
                            });
                        });
                        return;
                    }

                    loadAsFile(path.join(x, '/index'), pkg, cb);
                });
            });
        });
    }

    function processDirs(cb, dirs) {
        if (dirs.length === 0) return cb(null, undefined);
        var dir = dirs[0];

        isDirectory(path.dirname(dir), isdir);

        function isdir(err, isdir) {
            if (err) return cb(err);
            if (!isdir) return processDirs(cb, dirs.slice(1));
            loadAsFile(dir, opts.package, onfile);
        }

        function onfile(err, m, pkg) {
            if (err) return cb(err);
            if (m) return cb(null, m, pkg);
            loadAsDirectory(dir, opts.package, ondir);
        }

        function ondir(err, n, pkg) {
            if (err) return cb(err);
            if (n) return cb(null, n, pkg);
            processDirs(cb, dirs.slice(1));
        }
    }
    function loadNodeModules(x, start, cb) {
        var thunk = function () { return getPackageCandidates(x, start, opts); };
        processDirs(
            cb,
            packageIterator ? packageIterator(x, start, thunk, opts) : thunk()
        );
    }
};


/***/ }),

/***/ 40750:
/***/ ((module) => {

module.exports = function () {
    // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function (_, stack) { return stack; };
    var stack = (new Error()).stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
};


/***/ }),

/***/ 74965:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var current = (process.versions && process.versions.node && process.versions.node.split('.')) || [];

function specifierIncluded(specifier) {
    var parts = specifier.split(' ');
    var op = parts.length > 1 ? parts[0] : '=';
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');

    for (var i = 0; i < 3; ++i) {
        var cur = Number(current[i] || 0);
        var ver = Number(versionParts[i] || 0);
        if (cur === ver) {
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        }
        if (op === '<') {
            return cur < ver;
        } else if (op === '>=') {
            return cur >= ver;
        } else {
            return false;
        }
    }
    return op === '>=';
}

function matchesRange(range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) { return false; }
    for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(specifiers[i])) { return false; }
    }
    return true;
}

function versionIncluded(specifierValue) {
    if (typeof specifierValue === 'boolean') { return specifierValue; }
    if (specifierValue && typeof specifierValue === 'object') {
        for (var i = 0; i < specifierValue.length; ++i) {
            if (matchesRange(specifierValue[i])) { return true; }
        }
        return false;
    }
    return matchesRange(specifierValue);
}

var data = __webpack_require__(86255);

var core = {};
for (var mod in data) { // eslint-disable-line no-restricted-syntax
    if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core[mod] = versionIncluded(data[mod]);
    }
}
module.exports = core;


/***/ }),

/***/ 60028:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var core = __webpack_require__(74965);

module.exports = function isCore(x) {
    return Object.prototype.hasOwnProperty.call(core, x);
};


/***/ }),

/***/ 25645:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var path = __webpack_require__(85622);
var parse = path.parse || __webpack_require__(5980);

var getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {
    var prefix = '/';
    if ((/^([A-Za-z]:)/).test(absoluteStart)) {
        prefix = '';
    } else if ((/^\\\\/).test(absoluteStart)) {
        prefix = '\\\\';
    }

    var paths = [absoluteStart];
    var parsed = parse(absoluteStart);
    while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
    }

    return paths.reduce(function (dirs, aPath) {
        return dirs.concat(modules.map(function (moduleDir) {
            return path.resolve(prefix, aPath, moduleDir);
        }));
    }, []);
};

module.exports = function nodeModulesPaths(start, opts, request) {
    var modules = opts && opts.moduleDirectory
        ? [].concat(opts.moduleDirectory)
        : ['node_modules'];

    if (opts && typeof opts.paths === 'function') {
        return opts.paths(
            request,
            start,
            function () { return getNodeModulesDirs(start, modules); },
            opts
        );
    }

    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
};


/***/ }),

/***/ 54464:
/***/ ((module) => {

module.exports = function (x, opts) {
    /**
     * This file is purposefully a passthrough. It's expected that third-party
     * environments will override it at runtime in order to inject special logic
     * into `resolve` (by manipulating the options). One such example is the PnP
     * code path in Yarn.
     */

    return opts || {};
};


/***/ }),

/***/ 72260:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCore = __webpack_require__(60028);
var fs = __webpack_require__(35747);
var path = __webpack_require__(85622);
var caller = __webpack_require__(40750);
var nodeModulesPaths = __webpack_require__(25645);
var normalizeOptions = __webpack_require__(54464);

var realpathFS = fs.realpathSync && typeof fs.realpathSync.native === 'function' ? fs.realpathSync.native : fs.realpathSync;

var defaultIsFile = function isFile(file) {
    try {
        var stat = fs.statSync(file);
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return stat.isFile() || stat.isFIFO();
};

var defaultIsDir = function isDirectory(dir) {
    try {
        var stat = fs.statSync(dir);
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return stat.isDirectory();
};

var defaultRealpathSync = function realpathSync(x) {
    try {
        return realpathFS(x);
    } catch (realpathErr) {
        if (realpathErr.code !== 'ENOENT') {
            throw realpathErr;
        }
    }
    return x;
};

var maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {
    if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
    }
    return x;
};

var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
};

module.exports = function resolveSync(x, options) {
    if (typeof x !== 'string') {
        throw new TypeError('Path must be a string.');
    }
    var opts = normalizeOptions(x, options);

    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var packageIterator = opts.packageIterator;

    var extensions = opts.extensions || ['.js'];
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || [];

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);

    if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
        var res = path.resolve(absoluteStart, x);
        if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m) return maybeRealpathSync(realpathSync, m, opts);
    } else if (isCore(x)) {
        return x;
    } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n) return maybeRealpathSync(realpathSync, n, opts);
    }

    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;

    function loadAsFileSync(x) {
        var pkg = loadpkg(path.dirname(x));

        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
            var rfile = path.relative(pkg.dir, x);
            var r = opts.pathFilter(pkg.pkg, x, rfile);
            if (r) {
                x = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign
            }
        }

        if (isFile(x)) {
            return x;
        }

        for (var i = 0; i < extensions.length; i++) {
            var file = x + extensions[i];
            if (isFile(file)) {
                return file;
            }
        }
    }

    function loadpkg(dir) {
        if (dir === '' || dir === '/') return;
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
            return;
        }
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return;

        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), 'package.json');

        if (!isFile(pkgfile)) {
            return loadpkg(path.dirname(dir));
        }

        var body = readFileSync(pkgfile);

        try {
            var pkg = JSON.parse(body);
        } catch (jsonErr) {}

        if (pkg && opts.packageFilter) {
            // v2 will pass pkgfile
            pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment
        }

        return { pkg: pkg, dir: dir };
    }

    function loadAsDirectorySync(x) {
        var pkgfile = path.join(maybeRealpathSync(realpathSync, x, opts), '/package.json');
        if (isFile(pkgfile)) {
            try {
                var body = readFileSync(pkgfile, 'UTF8');
                var pkg = JSON.parse(body);
            } catch (e) {}

            if (pkg && opts.packageFilter) {
                // v2 will pass pkgfile
                pkg = opts.packageFilter(pkg, /*pkgfile,*/ x); // eslint-disable-line spaced-comment
            }

            if (pkg && pkg.main) {
                if (typeof pkg.main !== 'string') {
                    var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');
                    mainError.code = 'INVALID_PACKAGE_MAIN';
                    throw mainError;
                }
                if (pkg.main === '.' || pkg.main === './') {
                    pkg.main = 'index';
                }
                try {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                    var n = loadAsDirectorySync(path.resolve(x, pkg.main));
                    if (n) return n;
                } catch (e) {}
            }
        }

        return loadAsFileSync(path.join(x, '/index'));
    }

    function loadNodeModulesSync(x, start) {
        var thunk = function () { return getPackageCandidates(x, start, opts); };
        var dirs = packageIterator ? packageIterator(x, start, thunk, opts) : thunk();

        for (var i = 0; i < dirs.length; i++) {
            var dir = dirs[i];
            if (isDirectory(path.dirname(dir))) {
                var m = loadAsFileSync(dir);
                if (m) return m;
                var n = loadAsDirectorySync(dir);
                if (n) return n;
            }
        }
    }
};


/***/ }),

/***/ 84785:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Helpers = void 0;
const path = __importStar(__webpack_require__(85622));
const fs = __importStar(__webpack_require__(35747));
const resolve_1 = __importDefault(__webpack_require__(94931));
// These helpers avoid taking dependencies on other NPM packages
class Helpers {
    static async nodeResolveAsync(id, opts) {
        return await new Promise((resolve, reject) => {
            (0, resolve_1.default)(id, opts, (error, result) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            });
        });
    }
    static async fsExistsAsync(path) {
        return await new Promise((resolve) => {
            fs.exists(path, (exists) => {
                resolve(exists);
            });
        });
    }
    // Based on Path.isDownwardRelative() from @rushstack/node-core-library
    static isDownwardRelative(inputPath) {
        if (path.isAbsolute(inputPath)) {
            return false;
        }
        // Does it contain ".."
        if (Helpers._upwardPathSegmentRegex.test(inputPath)) {
            return false;
        }
        return true;
    }
}
exports.Helpers = Helpers;
// Based on Path.isDownwardRelative() from @rushstack/node-core-library
Helpers._upwardPathSegmentRegex = /([\/\\]|^)\.\.([\/\\]|$)/;
//# sourceMappingURL=Helpers.js.map

/***/ }),

/***/ 85970:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RigConfig = void 0;
const path = __importStar(__webpack_require__(85622));
const fs = __importStar(__webpack_require__(35747));
const nodeResolve = __importStar(__webpack_require__(94931));
const strip_json_comments_1 = __importDefault(__webpack_require__(42562));
const Helpers_1 = __webpack_require__(84785);
/**
 * This is the main API for loading the `config/rig.json` file format.
 *
 * @public
 */
class RigConfig {
    constructor(options) {
        const { projectFolderPath, rigFound, filePath, rigPackageName, rigProfile = 'default' } = options;
        this.projectFolderOriginalPath = projectFolderPath;
        this.projectFolderPath = path.resolve(projectFolderPath);
        this.rigFound = rigFound;
        this.filePath = filePath;
        this.rigPackageName = rigPackageName;
        this.rigProfile = rigProfile;
        if (this.rigFound) {
            this.relativeProfileFolderPath = 'profiles/' + this.rigProfile;
        }
        else {
            this.relativeProfileFolderPath = '';
        }
    }
    /**
     * The JSON contents of the {@link RigConfig.jsonSchemaPath} file.
     *
     * @remarks
     * The JSON object will be lazily loaded when this property getter is accessed, and the result
     * will be cached.
     * Accessing this property may make a synchronous filesystem call.
     */
    static get jsonSchemaObject() {
        if (RigConfig._jsonSchemaObject === undefined) {
            const jsonSchemaContent = fs.readFileSync(RigConfig.jsonSchemaPath).toString();
            RigConfig._jsonSchemaObject = JSON.parse(jsonSchemaContent);
        }
        return RigConfig._jsonSchemaObject;
    }
    /**
     * Use this method to load the `config/rig.json` file for a given project.
     *
     * @remarks
     * If the file cannot be found, an empty `RigConfig` object will be returned with {@link RigConfig.rigFound}
     * equal to `false`.
     */
    static loadForProjectFolder(options) {
        const { overrideRigJsonObject, projectFolderPath } = options;
        const fromCache = !options.bypassCache && !overrideRigJsonObject
            ? RigConfig._configCache.get(projectFolderPath)
            : undefined;
        if (fromCache) {
            return fromCache;
        }
        const rigConfigFilePath = path.join(projectFolderPath, 'config/rig.json');
        let config;
        let json = overrideRigJsonObject;
        try {
            if (!json) {
                const rigConfigFileContent = fs.readFileSync(rigConfigFilePath).toString();
                json = JSON.parse((0, strip_json_comments_1.default)(rigConfigFileContent));
            }
            RigConfig._validateSchema(json);
        }
        catch (error) {
            config = RigConfig._handleConfigError(error, projectFolderPath, rigConfigFilePath);
        }
        if (!config) {
            config = new RigConfig({
                projectFolderPath: projectFolderPath,
                rigFound: true,
                filePath: rigConfigFilePath,
                rigPackageName: json.rigPackageName,
                rigProfile: json.rigProfile
            });
        }
        if (!overrideRigJsonObject) {
            RigConfig._configCache.set(projectFolderPath, config);
        }
        return config;
    }
    /**
     * An async variant of {@link RigConfig.loadForProjectFolder}
     */
    static async loadForProjectFolderAsync(options) {
        const { overrideRigJsonObject, projectFolderPath } = options;
        const fromCache = !options.bypassCache && !overrideRigJsonObject && RigConfig._configCache.get(projectFolderPath);
        if (fromCache) {
            return fromCache;
        }
        const rigConfigFilePath = path.join(projectFolderPath, 'config/rig.json');
        let config;
        let json = overrideRigJsonObject;
        try {
            if (!json) {
                const rigConfigFileContent = (await fs.promises.readFile(rigConfigFilePath)).toString();
                json = JSON.parse((0, strip_json_comments_1.default)(rigConfigFileContent));
            }
            RigConfig._validateSchema(json);
        }
        catch (error) {
            config = RigConfig._handleConfigError(error, projectFolderPath, rigConfigFilePath);
        }
        if (!config) {
            config = new RigConfig({
                projectFolderPath: projectFolderPath,
                rigFound: true,
                filePath: rigConfigFilePath,
                rigPackageName: json.rigPackageName,
                rigProfile: json.rigProfile
            });
        }
        if (!overrideRigJsonObject) {
            RigConfig._configCache.set(projectFolderPath, config);
        }
        return config;
    }
    static _handleConfigError(error, projectFolderPath, rigConfigFilePath) {
        if (error.code !== 'ENOENT' && error.code !== 'ENOTDIR') {
            throw new Error(error.message + '\nError loading config file: ' + rigConfigFilePath);
        }
        // File not found, i.e. no rig config
        return new RigConfig({
            projectFolderPath,
            rigFound: false,
            filePath: '',
            rigPackageName: '',
            rigProfile: ''
        });
    }
    /**
     * Performs Node.js module resolution to locate the rig package folder, then returns the absolute path
     * of the rig profile folder specified by `rig.json`.
     *
     * @remarks
     * If no `rig.json` file was found, then this method throws an error.  The first time this method
     * is called, the result is cached and will be returned by all subsequent calls.
     *
     * Example: `/path/to/your-project/node_modules/example-rig/profiles/example-profile`
     */
    getResolvedProfileFolder() {
        if (this._resolvedRigPackageFolder === undefined) {
            if (!this.rigFound) {
                throw new Error('Cannot resolve the rig package because no rig was specified for this project');
            }
            const rigPackageJsonModuleSpecifier = `${this.rigPackageName}/package.json`;
            const resolveOptions = { basedir: this.projectFolderPath };
            const resolvedRigPackageJsonPath = nodeResolve.sync(rigPackageJsonModuleSpecifier, resolveOptions);
            this._resolvedRigPackageFolder = path.dirname(resolvedRigPackageJsonPath);
        }
        if (this._resolvedProfileFolder === undefined) {
            this._resolvedProfileFolder = path.join(this._resolvedRigPackageFolder, this.relativeProfileFolderPath);
            if (!fs.existsSync(this._resolvedProfileFolder)) {
                throw new Error(`The rig profile "${this.rigProfile}" is not defined` +
                    ` by the rig package "${this.rigPackageName}"`);
            }
        }
        return this._resolvedProfileFolder;
    }
    /**
     * An async variant of {@link RigConfig.getResolvedProfileFolder}
     */
    async getResolvedProfileFolderAsync() {
        if (this._resolvedRigPackageFolder === undefined) {
            if (!this.rigFound) {
                throw new Error('Cannot resolve the rig package because no rig was specified for this project');
            }
            const rigPackageJsonModuleSpecifier = `${this.rigPackageName}/package.json`;
            const resolveOptions = { basedir: this.projectFolderPath };
            const resolvedRigPackageJsonPath = await Helpers_1.Helpers.nodeResolveAsync(rigPackageJsonModuleSpecifier, resolveOptions);
            this._resolvedRigPackageFolder = path.dirname(resolvedRigPackageJsonPath);
        }
        if (this._resolvedProfileFolder === undefined) {
            this._resolvedProfileFolder = path.join(this._resolvedRigPackageFolder, this.relativeProfileFolderPath);
            if (!(await Helpers_1.Helpers.fsExistsAsync(this._resolvedProfileFolder))) {
                throw new Error(`The rig profile "${this.rigProfile}" is not defined` +
                    ` by the rig package "${this.rigPackageName}"`);
            }
        }
        return this._resolvedProfileFolder;
    }
    /**
     * This lookup first checks for the specified relative path under `projectFolderPath`; if it does
     * not exist there, then it checks in the resolved rig profile folder.  If the file is found,
     * its absolute path is returned. Otherwise, `undefined` is returned.
     *
     * @remarks
     * For example, suppose the rig profile is:
     *
     * `/path/to/your-project/node_modules/example-rig/profiles/example-profile`
     *
     * And suppose `configFileRelativePath` is `folder/file.json`. Then the following locations will be checked:
     *
     * `/path/to/your-project/folder/file.json`
     *
     * `/path/to/your-project/node_modules/example-rig/profiles/example-profile/folder/file.json`
     */
    tryResolveConfigFilePath(configFileRelativePath) {
        if (!Helpers_1.Helpers.isDownwardRelative(configFileRelativePath)) {
            throw new Error('The configFileRelativePath is not a relative path: ' + configFileRelativePath);
        }
        const localPath = path.join(this.projectFolderPath, configFileRelativePath);
        if (fs.existsSync(localPath)) {
            return localPath;
        }
        if (this.rigFound) {
            const riggedPath = path.join(this.getResolvedProfileFolder(), configFileRelativePath);
            if (fs.existsSync(riggedPath)) {
                return riggedPath;
            }
        }
        return undefined;
    }
    /**
     * An async variant of {@link RigConfig.tryResolveConfigFilePath}
     */
    async tryResolveConfigFilePathAsync(configFileRelativePath) {
        if (!Helpers_1.Helpers.isDownwardRelative(configFileRelativePath)) {
            throw new Error('The configFileRelativePath is not a relative path: ' + configFileRelativePath);
        }
        const localPath = path.join(this.projectFolderPath, configFileRelativePath);
        if (await Helpers_1.Helpers.fsExistsAsync(localPath)) {
            return localPath;
        }
        if (this.rigFound) {
            const riggedPath = path.join(await this.getResolvedProfileFolderAsync(), configFileRelativePath);
            if (await Helpers_1.Helpers.fsExistsAsync(riggedPath)) {
                return riggedPath;
            }
        }
        return undefined;
    }
    static _validateSchema(json) {
        for (const key of Object.getOwnPropertyNames(json)) {
            switch (key) {
                case '$schema':
                case 'rigPackageName':
                case 'rigProfile':
                    break;
                default:
                    throw new Error(`Unsupported field ${JSON.stringify(key)}`);
            }
        }
        if (!json.rigPackageName) {
            throw new Error('Missing required field "rigPackageName"');
        }
        if (!RigConfig._packageNameRegExp.test(json.rigPackageName)) {
            throw new Error(`The "rigPackageName" value is not a valid NPM package name: ${JSON.stringify(json.rigPackageName)}`);
        }
        if (!RigConfig._rigNameRegExp.test(json.rigPackageName)) {
            throw new Error(`The "rigPackageName" value is missing the "-rig" suffix: ` + JSON.stringify(json.rigProfile));
        }
        if (json.rigProfile !== undefined) {
            if (!RigConfig._profileNameRegExp.test(json.rigProfile)) {
                throw new Error(`The profile name must consist of lowercase alphanumeric words separated by hyphens: ` +
                    JSON.stringify(json.rigProfile));
            }
        }
    }
}
exports.RigConfig = RigConfig;
// For syntax details, see PackageNameParser from @rushstack/node-core-library
RigConfig._packageNameRegExp = /^(@[A-Za-z0-9\-_\.]+\/)?[A-Za-z0-9\-_\.]+$/;
// Rig package names must have the "-rig" suffix.
// Also silently accept "-rig-test" for our build test projects.
RigConfig._rigNameRegExp = /-rig(-test)?$/;
// Profiles must be lowercase alphanumeric words separated by hyphens
RigConfig._profileNameRegExp = /^[a-z0-9_\.]+(\-[a-z0-9_\.]+)*$/;
/**
 * Returns the absolute path of the `rig.schema.json` JSON schema file for `config/rig.json`,
 * which is bundled with this NPM package.
 *
 * @remarks
 * The `RigConfig` class already performs schema validation when loading `rig.json`; however
 * this schema file may be useful for integration with other validation tools.
 *
 * @public
 */
RigConfig.jsonSchemaPath = path.resolve(__dirname, './schemas/rig.schema.json');
RigConfig._jsonSchemaObject = undefined;
RigConfig._configCache = new Map();
//# sourceMappingURL=RigConfig.js.map

/***/ }),

/***/ 24289:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RigConfig = void 0;
/**
 * A system for sharing tool configurations between projects without duplicating config files.
 *
 * @remarks
 * The `config/rig.json` file is a system that Node.js build tools can support, in order to eliminate
 * duplication of config files when many projects share a common configuration.  This is particularly valuable
 * in a setup where hundreds of projects may be built using a small set of reusable recipes.
 *
 * @packageDocumentation
 */
var RigConfig_1 = __webpack_require__(85970);
Object.defineProperty(exports, "RigConfig", ({ enumerable: true, get: function () { return RigConfig_1.RigConfig; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 94931:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var async = __webpack_require__(55866);
async.core = __webpack_require__(36061);
async.isCore = __webpack_require__(91332);
async.sync = __webpack_require__(16198);

module.exports = async;


/***/ }),

/***/ 55866:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(35747);
var path = __webpack_require__(85622);
var caller = __webpack_require__(48644);
var nodeModulesPaths = __webpack_require__(42826);
var normalizeOptions = __webpack_require__(40426);
var isCore = __webpack_require__(91332);

var realpathFS = fs.realpath && typeof fs.realpath.native === 'function' ? fs.realpath.native : fs.realpath;

var defaultIsFile = function isFile(file, cb) {
    fs.stat(file, function (err, stat) {
        if (!err) {
            return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};

var defaultIsDir = function isDirectory(dir, cb) {
    fs.stat(dir, function (err, stat) {
        if (!err) {
            return cb(null, stat.isDirectory());
        }
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};

var defaultRealpath = function realpath(x, cb) {
    realpathFS(x, function (realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== 'ENOENT') cb(realpathErr);
        else cb(null, realpathErr ? x : realPath);
    });
};

var maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
    } else {
        cb(null, x);
    }
};

var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
};

module.exports = function resolve(x, options, callback) {
    var cb = callback;
    var opts = options;
    if (typeof options === 'function') {
        cb = opts;
        opts = {};
    }
    if (typeof x !== 'string') {
        var err = new TypeError('Path must be a string.');
        return process.nextTick(function () {
            cb(err);
        });
    }

    opts = normalizeOptions(x, opts);

    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile = opts.readFile || fs.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var packageIterator = opts.packageIterator;

    var extensions = opts.extensions || ['.js'];
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || [];

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = path.resolve(basedir);

    maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function (err, realStart) {
            if (err) cb(err);
            else init(realStart);
        }
    );

    var res;
    function init(basedir) {
        if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
            res = path.resolve(basedir, x);
            if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
            if ((/\/$/).test(x) && res === basedir) {
                loadAsDirectory(res, opts.package, onfile);
            } else loadAsFile(res, opts.package, onfile);
        } else if (isCore(x)) {
            return cb(null, x);
        } else loadNodeModules(x, basedir, function (err, n, pkg) {
            if (err) cb(err);
            else if (n) {
                return maybeRealpath(realpath, n, opts, function (err, realN) {
                    if (err) {
                        cb(err);
                    } else {
                        cb(null, realN, pkg);
                    }
                });
            } else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
            }
        });
    }

    function onfile(err, m, pkg) {
        if (err) cb(err);
        else if (m) cb(null, m, pkg);
        else loadAsDirectory(res, function (err, d, pkg) {
            if (err) cb(err);
            else if (d) {
                maybeRealpath(realpath, d, opts, function (err, realD) {
                    if (err) {
                        cb(err);
                    } else {
                        cb(null, realD, pkg);
                    }
                });
            } else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
            }
        });
    }

    function loadAsFile(x, thePackage, callback) {
        var loadAsFilePackage = thePackage;
        var cb = callback;
        if (typeof loadAsFilePackage === 'function') {
            cb = loadAsFilePackage;
            loadAsFilePackage = undefined;
        }

        var exts = [''].concat(extensions);
        load(exts, x, loadAsFilePackage);

        function load(exts, x, loadPackage) {
            if (exts.length === 0) return cb(null, undefined, loadPackage);
            var file = x + exts[0];

            var pkg = loadPackage;
            if (pkg) onpkg(null, pkg);
            else loadpkg(path.dirname(file), onpkg);

            function onpkg(err, pkg_, dir) {
                pkg = pkg_;
                if (err) return cb(err);
                if (dir && pkg && opts.pathFilter) {
                    var rfile = path.relative(dir, file);
                    var rel = rfile.slice(0, rfile.length - exts[0].length);
                    var r = opts.pathFilter(pkg, x, rel);
                    if (r) return load(
                        [''].concat(extensions.slice()),
                        path.resolve(dir, r),
                        pkg
                    );
                }
                isFile(file, onex);
            }
            function onex(err, ex) {
                if (err) return cb(err);
                if (ex) return cb(null, file, pkg);
                load(exts.slice(1), x, pkg);
            }
        }
    }

    function loadpkg(dir, cb) {
        if (dir === '' || dir === '/') return cb(null);
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
            return cb(null);
        }
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return cb(null);

        maybeRealpath(realpath, dir, opts, function (unwrapErr, pkgdir) {
            if (unwrapErr) return loadpkg(path.dirname(dir), cb);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) {
                // on err, ex is false
                if (!ex) return loadpkg(path.dirname(dir), cb);

                readFile(pkgfile, function (err, body) {
                    if (err) cb(err);
                    try { var pkg = JSON.parse(body); } catch (jsonErr) {}

                    if (pkg && opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }
                    cb(null, pkg, dir);
                });
            });
        });
    }

    function loadAsDirectory(x, loadAsDirectoryPackage, callback) {
        var cb = callback;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === 'function') {
            cb = fpkg;
            fpkg = opts.package;
        }

        maybeRealpath(realpath, x, opts, function (unwrapErr, pkgdir) {
            if (unwrapErr) return cb(unwrapErr);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) {
                if (err) return cb(err);
                if (!ex) return loadAsFile(path.join(x, 'index'), fpkg, cb);

                readFile(pkgfile, function (err, body) {
                    if (err) return cb(err);
                    try {
                        var pkg = JSON.parse(body);
                    } catch (jsonErr) {}

                    if (pkg && opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }

                    if (pkg && pkg.main) {
                        if (typeof pkg.main !== 'string') {
                            var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');
                            mainError.code = 'INVALID_PACKAGE_MAIN';
                            return cb(mainError);
                        }
                        if (pkg.main === '.' || pkg.main === './') {
                            pkg.main = 'index';
                        }
                        loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {
                            if (err) return cb(err);
                            if (m) return cb(null, m, pkg);
                            if (!pkg) return loadAsFile(path.join(x, 'index'), pkg, cb);

                            var dir = path.resolve(x, pkg.main);
                            loadAsDirectory(dir, pkg, function (err, n, pkg) {
                                if (err) return cb(err);
                                if (n) return cb(null, n, pkg);
                                loadAsFile(path.join(x, 'index'), pkg, cb);
                            });
                        });
                        return;
                    }

                    loadAsFile(path.join(x, '/index'), pkg, cb);
                });
            });
        });
    }

    function processDirs(cb, dirs) {
        if (dirs.length === 0) return cb(null, undefined);
        var dir = dirs[0];

        isDirectory(path.dirname(dir), isdir);

        function isdir(err, isdir) {
            if (err) return cb(err);
            if (!isdir) return processDirs(cb, dirs.slice(1));
            loadAsFile(dir, opts.package, onfile);
        }

        function onfile(err, m, pkg) {
            if (err) return cb(err);
            if (m) return cb(null, m, pkg);
            loadAsDirectory(dir, opts.package, ondir);
        }

        function ondir(err, n, pkg) {
            if (err) return cb(err);
            if (n) return cb(null, n, pkg);
            processDirs(cb, dirs.slice(1));
        }
    }
    function loadNodeModules(x, start, cb) {
        var thunk = function () { return getPackageCandidates(x, start, opts); };
        processDirs(
            cb,
            packageIterator ? packageIterator(x, start, thunk, opts) : thunk()
        );
    }
};


/***/ }),

/***/ 48644:
/***/ ((module) => {

module.exports = function () {
    // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function (_, stack) { return stack; };
    var stack = (new Error()).stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
};


/***/ }),

/***/ 36061:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var current = (process.versions && process.versions.node && process.versions.node.split('.')) || [];

function specifierIncluded(specifier) {
    var parts = specifier.split(' ');
    var op = parts.length > 1 ? parts[0] : '=';
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');

    for (var i = 0; i < 3; ++i) {
        var cur = Number(current[i] || 0);
        var ver = Number(versionParts[i] || 0);
        if (cur === ver) {
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        }
        if (op === '<') {
            return cur < ver;
        } else if (op === '>=') {
            return cur >= ver;
        } else {
            return false;
        }
    }
    return op === '>=';
}

function matchesRange(range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) { return false; }
    for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(specifiers[i])) { return false; }
    }
    return true;
}

function versionIncluded(specifierValue) {
    if (typeof specifierValue === 'boolean') { return specifierValue; }
    if (specifierValue && typeof specifierValue === 'object') {
        for (var i = 0; i < specifierValue.length; ++i) {
            if (matchesRange(specifierValue[i])) { return true; }
        }
        return false;
    }
    return matchesRange(specifierValue);
}

var data = __webpack_require__(15827);

var core = {};
for (var mod in data) { // eslint-disable-line no-restricted-syntax
    if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core[mod] = versionIncluded(data[mod]);
    }
}
module.exports = core;


/***/ }),

/***/ 91332:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var core = __webpack_require__(36061);

module.exports = function isCore(x) {
    return Object.prototype.hasOwnProperty.call(core, x);
};


/***/ }),

/***/ 42826:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var path = __webpack_require__(85622);
var parse = path.parse || __webpack_require__(5980);

var getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {
    var prefix = '/';
    if ((/^([A-Za-z]:)/).test(absoluteStart)) {
        prefix = '';
    } else if ((/^\\\\/).test(absoluteStart)) {
        prefix = '\\\\';
    }

    var paths = [absoluteStart];
    var parsed = parse(absoluteStart);
    while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
    }

    return paths.reduce(function (dirs, aPath) {
        return dirs.concat(modules.map(function (moduleDir) {
            return path.resolve(prefix, aPath, moduleDir);
        }));
    }, []);
};

module.exports = function nodeModulesPaths(start, opts, request) {
    var modules = opts && opts.moduleDirectory
        ? [].concat(opts.moduleDirectory)
        : ['node_modules'];

    if (opts && typeof opts.paths === 'function') {
        return opts.paths(
            request,
            start,
            function () { return getNodeModulesDirs(start, modules); },
            opts
        );
    }

    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
};


/***/ }),

/***/ 40426:
/***/ ((module) => {

module.exports = function (x, opts) {
    /**
     * This file is purposefully a passthrough. It's expected that third-party
     * environments will override it at runtime in order to inject special logic
     * into `resolve` (by manipulating the options). One such example is the PnP
     * code path in Yarn.
     */

    return opts || {};
};


/***/ }),

/***/ 16198:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCore = __webpack_require__(91332);
var fs = __webpack_require__(35747);
var path = __webpack_require__(85622);
var caller = __webpack_require__(48644);
var nodeModulesPaths = __webpack_require__(42826);
var normalizeOptions = __webpack_require__(40426);

var realpathFS = fs.realpathSync && typeof fs.realpathSync.native === 'function' ? fs.realpathSync.native : fs.realpathSync;

var defaultIsFile = function isFile(file) {
    try {
        var stat = fs.statSync(file);
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return stat.isFile() || stat.isFIFO();
};

var defaultIsDir = function isDirectory(dir) {
    try {
        var stat = fs.statSync(dir);
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return stat.isDirectory();
};

var defaultRealpathSync = function realpathSync(x) {
    try {
        return realpathFS(x);
    } catch (realpathErr) {
        if (realpathErr.code !== 'ENOENT') {
            throw realpathErr;
        }
    }
    return x;
};

var maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {
    if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
    }
    return x;
};

var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
};

module.exports = function resolveSync(x, options) {
    if (typeof x !== 'string') {
        throw new TypeError('Path must be a string.');
    }
    var opts = normalizeOptions(x, options);

    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var packageIterator = opts.packageIterator;

    var extensions = opts.extensions || ['.js'];
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || [];

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);

    if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
        var res = path.resolve(absoluteStart, x);
        if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m) return maybeRealpathSync(realpathSync, m, opts);
    } else if (isCore(x)) {
        return x;
    } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n) return maybeRealpathSync(realpathSync, n, opts);
    }

    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;

    function loadAsFileSync(x) {
        var pkg = loadpkg(path.dirname(x));

        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
            var rfile = path.relative(pkg.dir, x);
            var r = opts.pathFilter(pkg.pkg, x, rfile);
            if (r) {
                x = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign
            }
        }

        if (isFile(x)) {
            return x;
        }

        for (var i = 0; i < extensions.length; i++) {
            var file = x + extensions[i];
            if (isFile(file)) {
                return file;
            }
        }
    }

    function loadpkg(dir) {
        if (dir === '' || dir === '/') return;
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
            return;
        }
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return;

        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), 'package.json');

        if (!isFile(pkgfile)) {
            return loadpkg(path.dirname(dir));
        }

        var body = readFileSync(pkgfile);

        try {
            var pkg = JSON.parse(body);
        } catch (jsonErr) {}

        if (pkg && opts.packageFilter) {
            // v2 will pass pkgfile
            pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment
        }

        return { pkg: pkg, dir: dir };
    }

    function loadAsDirectorySync(x) {
        var pkgfile = path.join(maybeRealpathSync(realpathSync, x, opts), '/package.json');
        if (isFile(pkgfile)) {
            try {
                var body = readFileSync(pkgfile, 'UTF8');
                var pkg = JSON.parse(body);
            } catch (e) {}

            if (pkg && opts.packageFilter) {
                // v2 will pass pkgfile
                pkg = opts.packageFilter(pkg, /*pkgfile,*/ x); // eslint-disable-line spaced-comment
            }

            if (pkg && pkg.main) {
                if (typeof pkg.main !== 'string') {
                    var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');
                    mainError.code = 'INVALID_PACKAGE_MAIN';
                    throw mainError;
                }
                if (pkg.main === '.' || pkg.main === './') {
                    pkg.main = 'index';
                }
                try {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                    var n = loadAsDirectorySync(path.resolve(x, pkg.main));
                    if (n) return n;
                } catch (e) {}
            }
        }

        return loadAsFileSync(path.join(x, '/index'));
    }

    function loadNodeModulesSync(x, start) {
        var thunk = function () { return getPackageCandidates(x, start, opts); };
        var dirs = packageIterator ? packageIterator(x, start, thunk, opts) : thunk();

        for (var i = 0; i < dirs.length; i++) {
            var dir = dirs[i];
            if (isDirectory(path.dirname(dir))) {
                var m = loadAsFileSync(dir);
                if (m) return m;
                var n = loadAsDirectorySync(dir);
                if (n) return n;
            }
        }
    }
};


/***/ }),

/***/ 22815:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CollatedTerminal = void 0;
/**
 * This API was introduced as a temporary measure.
 * @deprecated Very soon we plan to replace this with the `Terminal` API from `@rushstack/node-core-library`.
 * @beta
 */
class CollatedTerminal {
    constructor(destination) {
        this._destination = destination;
    }
    writeChunk(chunk) {
        this._destination.writeChunk(chunk);
    }
    writeStdoutLine(message) {
        this._destination.writeChunk({ text: message + '\n', kind: "O" /* Stdout */ });
    }
    writeStderrLine(message) {
        this._destination.writeChunk({ text: message + '\n', kind: "E" /* Stderr */ });
    }
}
exports.CollatedTerminal = CollatedTerminal;
//# sourceMappingURL=CollatedTerminal.js.map

/***/ }),

/***/ 56570:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CollatedWriter = void 0;
const terminal_1 = __webpack_require__(11253);
const CollatedTerminal_1 = __webpack_require__(22815);
/**
 * An writable interface for managing output of simultaneous processes.
 *
 * @beta
 */
class CollatedWriter extends terminal_1.TerminalWritable {
    constructor(taskName, collator) {
        super({ preventAutoclose: true });
        this.taskName = taskName;
        this.terminal = new CollatedTerminal_1.CollatedTerminal(this);
        this._collator = collator;
        this._bufferedChunks = [];
    }
    /**
     * Returns true if this is the active writer for its associated {@link StreamCollator}.
     */
    get isActive() {
        return this._collator.activeWriter === this;
    }
    /**
     * For diagnostic purposes, if the writer is buffering chunks because it has
     * not become active yet, they can be inspected via this property.
     */
    get bufferedChunks() {
        return this._bufferedChunks;
    }
    /** {@inheritDoc @rushstack/terminal#TerminalWritable.onWriteChunk} */
    onWriteChunk(chunk) {
        this._collator._writerWriteChunk(this, chunk, this._bufferedChunks);
    }
    /** {@inheritDoc @rushstack/terminal#TerminalWritable.onClose} */
    onClose() {
        this._collator._writerClose(this, this._bufferedChunks);
    }
    /** @internal */
    _flushBufferedChunks() {
        for (const chunk of this._bufferedChunks) {
            this._collator.destination.writeChunk(chunk);
        }
        this._bufferedChunks.length = 0;
    }
}
exports.CollatedWriter = CollatedWriter;
//# sourceMappingURL=CollatedWriter.js.map

/***/ }),

/***/ 8786:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StreamCollator = void 0;
const node_core_library_1 = __webpack_require__(11851);
const CollatedWriter_1 = __webpack_require__(56570);
const CollatedTerminal_1 = __webpack_require__(22815);
/**
 * A static class which manages the output of multiple threads.
 *
 * @beta
 */
class StreamCollator {
    constructor(options) {
        this._taskNames = new Set();
        this._writers = new Set();
        // The writer whose output is being shown in realtime, or undefined if none
        this._activeWriter = undefined;
        // Writers that are not closed yet, and have never been active
        this._openInactiveWriters = new Set();
        // Writers that are now closed, but have accumulated buffered chunks, and have never been active
        this._closedInactiveWriters = new Set();
        this._preventReentrantCall = false;
        this.destination = options.destination;
        this.terminal = new CollatedTerminal_1.CollatedTerminal(this.destination);
        this._onWriterActive = options.onWriterActive;
    }
    /**
     * Returns the currently active `CollatedWriter`, or `undefined` if no writer
     * is active yet.
     */
    get activeWriter() {
        return this._activeWriter;
    }
    /**
     * For diagnostic purposes, returns the {@link CollatedWriter.taskName} for the
     * currently active writer, or an empty string if no writer is active.
     */
    get activeTaskName() {
        if (this._activeWriter) {
            return this._activeWriter.taskName;
        }
        return '';
    }
    /**
     * The list of writers that have been registered by calling {@link StreamCollator.registerTask},
     * in the order that they were registered.
     */
    get writers() {
        return this._writers;
    }
    /**
     * Registers a new task to be collated, and constructs a {@link CollatedWriter} object
     * to receive its input.
     */
    registerTask(taskName) {
        if (this._taskNames.has(taskName)) {
            throw new Error('A task with that name has already been registered');
        }
        const writer = new CollatedWriter_1.CollatedWriter(taskName, this);
        this._writers.add(writer);
        this._taskNames.add(writer.taskName);
        // When a task is initially registered, it is open and has not accumulated any buffered chunks
        this._openInactiveWriters.add(writer);
        if (this._activeWriter === undefined) {
            // If there is no active writer, then the first one to be registered becomes active.
            this._assignActiveWriter(writer);
        }
        return writer;
    }
    /** @internal */
    _writerWriteChunk(writer, chunk, bufferedChunks) {
        this._checkForReentrantCall();
        if (this._activeWriter === undefined) {
            // If no writer is currently active, then the first one to write something becomes active
            this._assignActiveWriter(writer);
        }
        if (writer.isActive) {
            this.destination.writeChunk(chunk);
        }
        else {
            bufferedChunks.push(chunk);
        }
    }
    /** @internal */
    _writerClose(writer, bufferedChunks) {
        this._checkForReentrantCall();
        if (writer.isActive) {
            writer._flushBufferedChunks();
            this._activeWriter = undefined;
            // If any buffered writers are already closed, activate them each immediately
            // We copy the set, since _assignActiveWriter() will be deleting from it.
            for (const closedInactiveWriter of [...this._closedInactiveWriters]) {
                try {
                    this._assignActiveWriter(closedInactiveWriter);
                }
                finally {
                    this._activeWriter = undefined;
                }
            }
            let writerToActivate = undefined;
            // Try to activate a writer that already accumulated some data
            for (const openInactiveWriter of this._openInactiveWriters) {
                if (openInactiveWriter.bufferedChunks.length > 0) {
                    writerToActivate = openInactiveWriter;
                    break;
                }
            }
            if (!writerToActivate) {
                // Otherwise just take the first one
                for (const openInactiveWriter of this._openInactiveWriters) {
                    writerToActivate = openInactiveWriter;
                    break;
                }
            }
            if (writerToActivate) {
                this._assignActiveWriter(writerToActivate);
            }
        }
        else {
            this._openInactiveWriters.delete(writer);
            this._closedInactiveWriters.add(writer);
        }
    }
    _assignActiveWriter(writer) {
        this._activeWriter = writer;
        this._closedInactiveWriters.delete(writer);
        this._openInactiveWriters.delete(writer);
        if (this._onWriterActive) {
            this._preventReentrantCall = true;
            try {
                this._onWriterActive(writer);
            }
            finally {
                this._preventReentrantCall = false;
            }
        }
        writer._flushBufferedChunks();
    }
    _checkForReentrantCall() {
        if (this._preventReentrantCall) {
            throw new node_core_library_1.InternalError('Reentrant call to StreamCollator');
        }
    }
}
exports.StreamCollator = StreamCollator;
//# sourceMappingURL=StreamCollator.js.map

/***/ }),

/***/ 59486:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * This library enables a tool to display live console output from multiple concurrent processes,
 * while ensuring that their output does not get jumbled together.
 *
 * @remarks
 *
 * For more info, please see the package {@link https://www.npmjs.com/package/@rushstack/stream-collator
 * | README}.
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(22815), exports);
__exportStar(__webpack_require__(56570), exports);
__exportStar(__webpack_require__(8786), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 54806:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AlreadyReportedError = void 0;
const TypeUuid_1 = __webpack_require__(22175);
const uuidAlreadyReportedError = 'f26b0640-a49b-49d1-9ead-1a516d5920c7';
/**
 * This exception can be thrown to indicate that an operation failed and an error message has already
 * been reported appropriately. Thus, the catch handler does not have responsibility for reporting
 * the error.
 *
 * @remarks
 * For example, suppose a tool writes interactive output to `console.log()`.  When an exception is thrown,
 * the `catch` handler will typically provide simplistic reporting such as this:
 *
 * ```ts
 * catch (error) {
 *   console.log("ERROR: " + error.message);
 * }
 * ```
 *
 * Suppose that the code performing the operation normally prints rich output to the console.  It may be able to
 * present an error message more nicely (for example, as part of a table, or structured log format).  Throwing
 * `AlreadyReportedError` provides a way to use exception handling to abort the operation, but instruct the `catch`
 * handler not to print an error a second time:
 *
 * ```ts
 * catch (error) {
 *   if (error instanceof AlreadyReportedError) {
 *     return;
 *   }
 *   console.log("ERROR: " + error.message);
 * }
 * ```
 *
 * @public
 */
class AlreadyReportedError extends Error {
    constructor() {
        super('An error occurred.');
        // Manually set the prototype, as we can no longer extend built-in classes like Error, Array, Map, etc
        // [https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work](https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work)
        //
        // Note: the prototype must also be set on any classes which extend this one
        this.__proto__ = AlreadyReportedError.prototype; // eslint-disable-line @typescript-eslint/no-explicit-any
    }
    static [Symbol.hasInstance](instance) {
        return TypeUuid_1.TypeUuid.isInstanceOf(instance, uuidAlreadyReportedError);
    }
}
exports.AlreadyReportedError = AlreadyReportedError;
TypeUuid_1.TypeUuid.registerClass(AlreadyReportedError, uuidAlreadyReportedError);
//# sourceMappingURL=AlreadyReportedError.js.map

/***/ }),

/***/ 6965:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Async = void 0;
/**
 * Utilities for parallel asynchronous operations, for use with the system `Promise` APIs.
 *
 * @beta
 */
class Async {
    /**
     * Given an input array and a `callback` function, invoke the callback to start a
     * promise for each element in the array.  Returns an array containing the results.
     *
     * @remarks
     * This API is similar to the system `Array#map`, except that the loop is asynchronous,
     * and the maximum number of concurrent promises can be throttled
     * using {@link IAsyncParallelismOptions.concurrency}.
     *
     * If `callback` throws a synchronous exception, or if it returns a promise that rejects,
     * then the loop stops immediately.  Any remaining array items will be skipped, and
     * overall operation will reject with the first error that was encountered.
     *
     * @param iterable - the array of inputs for the callback function
     * @param callback - a function that starts an asynchronous promise for an element
     *   from the array
     * @param options - options for customizing the control flow
     * @returns an array containing the result for each callback, in the same order
     *   as the original input `array`
     */
    static async mapAsync(iterable, callback, options) {
        const result = [];
        await Async.forEachAsync(iterable, async (item, arrayIndex) => {
            result[arrayIndex] = await callback(item, arrayIndex);
        }, options);
        return result;
    }
    /**
     * Given an input array and a `callback` function, invoke the callback to start a
     * promise for each element in the array.
     *
     * @remarks
     * This API is similar to the system `Array#forEach`, except that the loop is asynchronous,
     * and the maximum number of concurrent promises can be throttled
     * using {@link IAsyncParallelismOptions.concurrency}.
     *
     * If `callback` throws a synchronous exception, or if it returns a promise that rejects,
     * then the loop stops immediately.  Any remaining array items will be skipped, and
     * overall operation will reject with the first error that was encountered.
     *
     * @param iterable - the array of inputs for the callback function
     * @param callback - a function that starts an asynchronous promise for an element
     *   from the array
     * @param options - options for customizing the control flow
     */
    static async forEachAsync(iterable, callback, options) {
        await new Promise((resolve, reject) => {
            const concurrency = (options === null || options === void 0 ? void 0 : options.concurrency) && options.concurrency > 0 ? options.concurrency : Infinity;
            let operationsInProgress = 0;
            const iterator = (iterable[Symbol.iterator] ||
                iterable[Symbol.asyncIterator]).call(iterable);
            let arrayIndex = 0;
            let iteratorIsComplete = false;
            let promiseHasResolvedOrRejected = false;
            async function queueOperationsAsync() {
                while (operationsInProgress < concurrency && !iteratorIsComplete && !promiseHasResolvedOrRejected) {
                    const currentIteratorResult = await iterator.next();
                    // eslint-disable-next-line require-atomic-updates
                    iteratorIsComplete = !!currentIteratorResult.done;
                    if (!iteratorIsComplete) {
                        operationsInProgress++;
                        Promise.resolve(callback(currentIteratorResult.value, arrayIndex++))
                            .then(async () => {
                            operationsInProgress--;
                            await onOperationCompletionAsync();
                        })
                            .catch((error) => {
                            promiseHasResolvedOrRejected = true;
                            reject(error);
                        });
                    }
                }
                if (iteratorIsComplete) {
                    await onOperationCompletionAsync();
                }
            }
            async function onOperationCompletionAsync() {
                if (!promiseHasResolvedOrRejected) {
                    if (operationsInProgress === 0 && iteratorIsComplete) {
                        promiseHasResolvedOrRejected = true;
                        resolve();
                    }
                    else if (!iteratorIsComplete) {
                        await queueOperationsAsync();
                    }
                }
            }
            queueOperationsAsync().catch((error) => {
                promiseHasResolvedOrRejected = true;
                reject(error);
            });
        });
    }
    /**
     * Return a promise that resolves after the specified number of milliseconds.
     */
    static async sleep(ms) {
        await new Promise((resolve) => {
            setTimeout(resolve, ms);
        });
    }
}
exports.Async = Async;
//# sourceMappingURL=Async.js.map

/***/ }),

/***/ 38368:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Enum = void 0;
/**
 * A helper for looking up TypeScript `enum` keys/values.
 *
 * @remarks
 * TypeScript enums implement a lookup table for mapping between their keys and values:
 *
 * ```ts
 * enum Colors {
 *   Red = 1
 * }
 *
 * // Prints "Red"
 * console.log(Colors[1]);
 *
 * // Prints "1"
 * console.log(Colors["Red]);
 * ```
 *
 * However the compiler's "noImplicitAny" validation has trouble with these mappings, because
 * there are so many possible types for the map elements:
 *
 * ```ts
 * function f(s: string): Colors | undefined {
 *   // (TS 7015) Element implicitly has an 'any' type because
 *   // index expression is not of type 'number'.
 *   return Colors[s];
 * }
 * ```
 *
 * The `Enum` helper provides a more specific, strongly typed way to access members:
 *
 * ```ts
 * function f(s: string): Colors | undefined {
 *   return Enum.tryGetValueByKey(Colors, s);
 * }
 * ```
 *
 * @public
 */
class Enum {
    constructor() { }
    /**
     * Returns an enum value, given its key. Returns `undefined` if no matching key is found.
     *
     * @example
     *
     * Example usage:
     * ```ts
     * enum Colors {
     *   Red = 1
     * }
     *
     * // Prints "1"
     * console.log(Enum.tryGetValueByKey(Colors, "Red"));
     *
     * // Prints "undefined"
     * console.log(Enum.tryGetValueByKey(Colors, "Black"));
     * ```
     */
    static tryGetValueByKey(enumObject, key) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return enumObject[key];
    }
    /**
     * This API is similar to {@link Enum.tryGetValueByKey}, except that it throws an exception
     * if the key is undefined.
     */
    static getValueByKey(enumObject, key) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const result = enumObject[key];
        if (result === undefined) {
            throw new Error(`The lookup key ${JSON.stringify(key)} is not defined`);
        }
        return result;
    }
    /**
     * Returns an enum string key, given its numeric value.  Returns `undefined` if no matching value
     * is found.
     *
     * @remarks
     * The TypeScript compiler only creates a reverse mapping for enum members whose value is numeric.
     * For example:
     *
     * ```ts
     * enum E {
     *   A = 1,
     *   B = 'c'
     * }
     *
     * // Prints "A"
     * console.log(E[1]);
     *
     * // Prints "undefined"
     * console.log(E["c"]);
     * ```
     *
     * @example
     *
     * Example usage:
     * ```ts
     * enum Colors {
     *   Red = 1,
     *   Blue = 'blue'
     * }
     *
     * // Prints "Red"
     * console.log(Enum.tryGetKeyByNumber(Colors, 1));
     *
     * // Prints "undefined"
     * console.log(Enum.tryGetKeyByNumber(Colors, -1));
     * ```
     */
    static tryGetKeyByNumber(enumObject, value) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return enumObject[value];
    }
    /**
     * This API is similar to {@link Enum.tryGetKeyByNumber}, except that it throws an exception
     * if the key is undefined.
     */
    static getKeyByNumber(enumObject, value) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const result = enumObject[value];
        if (result === undefined) {
            throw new Error(`The value ${value} does not exist in the mapping`);
        }
        return result;
    }
}
exports.Enum = Enum;
//# sourceMappingURL=Enum.js.map

/***/ }),

/***/ 77686:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnvironmentMap = void 0;
const process_1 = __importDefault(__webpack_require__(61765));
const InternalError_1 = __webpack_require__(65230);
/**
 * A map data structure that stores process environment variables.  On Windows
 * operating system, the variable names are case-insensitive.
 * @public
 */
class EnvironmentMap {
    constructor(environmentObject = {}) {
        this._map = new Map();
        // This property helps catch a mistake where an instance of `EnvironmentMap` is accidentally passed to
        // a function that expects a `Record<string, string>` (as would be used with the `process.env` API).
        // The property getter will throw an exception if that function tries to enumerate the object values.
        Object.defineProperty(this, '_sanityCheck', {
            enumerable: true,
            get: function () {
                throw new InternalError_1.InternalError('Attempt to read EnvironmentMap class as an object');
            }
        });
        this.caseSensitive = process_1.default.platform !== 'win32';
        this.mergeFromObject(environmentObject);
    }
    /**
     * Clears all entries, resulting in an empty map.
     */
    clear() {
        this._map.clear();
    }
    /**
     * Assigns the variable to the specified value.  A previous value will be overwritten.
     *
     * @remarks
     * The value can be an empty string.  To completely remove the entry, use
     * {@link EnvironmentMap.unset} instead.
     */
    set(name, value) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        this._map.set(key, { name: name, value });
    }
    /**
     * Removes the key from the map, if present.
     */
    unset(name) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        this._map.delete(key);
    }
    /**
     * Returns the value of the specified variable, or `undefined` if the map does not contain that name.
     */
    get(name) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        const entry = this._map.get(key);
        if (entry === undefined) {
            return undefined;
        }
        return entry.value;
    }
    /**
     * Returns the map keys, which are environment variable names.
     */
    names() {
        return this._map.keys();
    }
    /**
     * Returns the map entries.
     */
    entries() {
        return this._map.values();
    }
    /**
     * Adds each entry from `environmentMap` to this map.
     */
    mergeFrom(environmentMap) {
        for (const entry of environmentMap.entries()) {
            this.set(entry.name, entry.value);
        }
    }
    /**
     * Merges entries from a plain JavaScript object, such as would be used with the `process.env` API.
     */
    mergeFromObject(environmentObject = {}) {
        for (const [name, value] of Object.entries(environmentObject)) {
            if (value !== undefined) {
                this.set(name, value);
            }
        }
    }
    /**
     * Returns the keys as a plain JavaScript object similar to the object returned by the `process.env` API.
     */
    toObject() {
        const result = {};
        for (const entry of this.entries()) {
            result[entry.name] = entry.value;
        }
        return result;
    }
}
exports.EnvironmentMap = EnvironmentMap;
//# sourceMappingURL=EnvironmentMap.js.map

/***/ }),

/***/ 93190:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Executable = void 0;
const child_process = __importStar(__webpack_require__(63129));
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const EnvironmentMap_1 = __webpack_require__(77686);
const FileSystem_1 = __webpack_require__(25271);
/**
 * The Executable class provides a safe, portable, recommended solution for tools that need
 * to launch child processes.
 *
 * @remarks
 * The NodeJS child_process API provides a solution for launching child processes, however
 * its design encourages reliance on the operating system shell for certain features.
 * Invoking the OS shell is not safe, not portable, and generally not recommended:
 *
 * - Different shells have different behavior and command-line syntax, and which shell you
 *   will get with NodeJS is unpredictable.  There is no universal shell guaranteed to be
 *   available on all platforms.
 *
 * - If a command parameter contains symbol characters, a shell may interpret them, which
 *   can introduce a security vulnerability
 *
 * - Each shell has different rules for escaping these symbols.  On Windows, the default
 *   shell is incapable of escaping certain character sequences.
 *
 * The Executable API provides a pure JavaScript implementation of primitive shell-like
 * functionality for searching the default PATH, appending default file extensions on Windows,
 * and executing a file that may contain a POSIX shebang.  This primitive functionality
 * is sufficient (and recommended) for most tooling scenarios.
 *
 * If you need additional shell features such as wildcard globbing, environment variable
 * expansion, piping, or built-in commands, then we recommend to use the `@microsoft/rushell`
 * library instead.  Rushell is a pure JavaScript shell with a standard syntax that is
 * guaranteed to work consistently across all platforms.
 *
 * @public
 */
class Executable {
    /**
     * Synchronously create a child process and optionally capture its output.
     *
     * @remarks
     * This function is similar to child_process.spawnSync().  The main differences are:
     *
     * - It does not invoke the OS shell unless the executable file is a shell script.
     * - Command-line arguments containing special characters are more accurately passed
     *   through to the child process.
     * - If the filename is missing a path, then the shell's default PATH will be searched.
     * - If the filename is missing a file extension, then Windows default file extensions
     *   will be searched.
     *
     * @param filename - The name of the executable file.  This string must not contain any
     * command-line arguments.  If the name contains any path delimiters, then the shell's
     * default PATH will not be searched.
     * @param args - The command-line arguments to be passed to the process.
     * @param options - Additional options
     * @returns the same data type as returned by the NodeJS child_process.spawnSync() API
     *
     * @privateRemarks
     *
     * NOTE: The NodeJS spawnSync() returns SpawnSyncReturns<string> or SpawnSyncReturns<Buffer>
     * polymorphically based on the options.encoding parameter value.  This is a fairly confusing
     * design.  In most cases, developers want string with the default encoding.  If/when someone
     * wants binary output or a non-default text encoding, we will introduce a separate API function
     * with a name like "spawnWithBufferSync".
     */
    static spawnSync(filename, args, options) {
        if (!options) {
            options = {};
        }
        const context = Executable._getExecutableContext(options);
        const resolvedPath = Executable._tryResolve(filename, options, context);
        if (!resolvedPath) {
            throw new Error(`The executable file was not found: "${filename}"`);
        }
        const spawnOptions = {
            cwd: context.currentWorkingDirectory,
            env: context.environmentMap.toObject(),
            input: options.input,
            stdio: options.stdio,
            timeout: options.timeoutMs,
            maxBuffer: options.maxBuffer,
            // Contrary to what the NodeJS typings imply, we must explicitly specify "utf8" here
            // if we want the result to be SpawnSyncReturns<string> instead of SpawnSyncReturns<Buffer>.
            encoding: 'utf8',
            // NOTE: This is always false, because Rushell will be recommended instead of relying on the OS shell.
            shell: false
        };
        const normalizedCommandLine = Executable._buildCommandLineFixup(resolvedPath, args, context);
        return child_process.spawnSync(normalizedCommandLine.path, normalizedCommandLine.args, spawnOptions);
    }
    /**
     * Start a child process.
     *
     * @remarks
     * This function is similar to child_process.spawn().  The main differences are:
     *
     * - It does not invoke the OS shell unless the executable file is a shell script.
     * - Command-line arguments containing special characters are more accurately passed
     *   through to the child process.
     * - If the filename is missing a path, then the shell's default PATH will be searched.
     * - If the filename is missing a file extension, then Windows default file extensions
     *   will be searched.
     *
     * This command is asynchronous, but it does not return a `Promise`.  Instead it returns
     * a Node.js `ChildProcess` supporting event notifications.
     *
     * @param filename - The name of the executable file.  This string must not contain any
     * command-line arguments.  If the name contains any path delimiters, then the shell's
     * default PATH will not be searched.
     * @param args - The command-line arguments to be passed to the process.
     * @param options - Additional options
     * @returns the same data type as returned by the NodeJS child_process.spawnSync() API
     */
    static spawn(filename, args, options) {
        if (!options) {
            options = {};
        }
        const context = Executable._getExecutableContext(options);
        const resolvedPath = Executable._tryResolve(filename, options, context);
        if (!resolvedPath) {
            throw new Error(`The executable file was not found: "${filename}"`);
        }
        const spawnOptions = {
            cwd: context.currentWorkingDirectory,
            env: context.environmentMap.toObject(),
            stdio: options.stdio,
            // NOTE: This is always false, because Rushell will be recommended instead of relying on the OS shell.
            shell: false
        };
        const normalizedCommandLine = Executable._buildCommandLineFixup(resolvedPath, args, context);
        return child_process.spawn(normalizedCommandLine.path, normalizedCommandLine.args, spawnOptions);
    }
    // PROBLEM: Given an "args" array of strings that may contain special characters (e.g. spaces,
    // backslashes, quotes), ensure that these strings pass through to the child process's ARGV array
    // without anything getting corrupted along the way.
    //
    // On Unix you just pass the array to spawnSync().  But on Windows, this is a very complex problem:
    // - The Win32 CreateProcess() API expects the args to be encoded as a single text string
    // - The decoding of this string is up to the application (not the OS), and there are 3 different
    //   algorithms in common usage:  the cmd.exe shell, the Microsoft CRT library init code, and
    //   the Win32 CommandLineToArgvW()
    // - The encodings are counterintuitive and have lots of special cases
    // - NodeJS spawnSync() tries do the encoding without knowing which decoder will be used
    //
    // See these articles for a full analysis:
    // http://www.windowsinspired.com/understanding-the-command-line-string-and-arguments-received-by-a-windows-program/
    // http://www.windowsinspired.com/how-a-windows-programs-splits-its-command-line-into-individual-arguments/
    static _buildCommandLineFixup(resolvedPath, args, context) {
        const fileExtension = path.extname(resolvedPath);
        if (os.platform() === 'win32') {
            // Do we need a custom handler for this file type?
            switch (fileExtension.toUpperCase()) {
                case '.EXE':
                case '.COM':
                    // okay to execute directly
                    break;
                case '.BAT':
                case '.CMD': {
                    Executable._validateArgsForWindowsShell(args);
                    // These file types must be invoked via the Windows shell
                    let shellPath = context.environmentMap.get('COMSPEC');
                    if (!shellPath || !Executable._canExecute(shellPath, context)) {
                        shellPath = Executable.tryResolve('cmd.exe');
                    }
                    if (!shellPath) {
                        throw new Error(`Unable to execute "${path.basename(resolvedPath)}" ` +
                            `because CMD.exe was not found in the PATH`);
                    }
                    const shellArgs = [];
                    // /D: Disable execution of AutoRun commands when starting the new shell context
                    shellArgs.push('/d');
                    // /S: Disable Cmd.exe's parsing of double-quote characters inside the command-line
                    shellArgs.push('/s');
                    // /C: Execute the following command and then exit immediately
                    shellArgs.push('/c');
                    // If the path contains special charactrers (e.g. spaces), escape them so that
                    // they don't get interpreted by the shell
                    shellArgs.push(Executable._getEscapedForWindowsShell(resolvedPath));
                    shellArgs.push(...args);
                    return { path: shellPath, args: shellArgs };
                }
                default:
                    throw new Error(`Cannot execute "${path.basename(resolvedPath)}" because the file type is not supported`);
            }
        }
        return {
            path: resolvedPath,
            args: args
        };
    }
    /**
     * Given a filename, this determines the absolute path of the executable file that would
     * be executed by a shell:
     *
     * - If the filename is missing a path, then the shell's default PATH will be searched.
     * - If the filename is missing a file extension, then Windows default file extensions
     *   will be searched.
     *
     * @remarks
     *
     * @param filename - The name of the executable file.  This string must not contain any
     * command-line arguments.  If the name contains any path delimiters, then the shell's
     * default PATH will not be searched.
     * @param options - optional other parameters
     * @returns the absolute path of the executable, or undefined if it was not found
     */
    static tryResolve(filename, options) {
        return Executable._tryResolve(filename, options || {}, Executable._getExecutableContext(options));
    }
    static _tryResolve(filename, options, context) {
        // NOTE: Since "filename" cannot contain command-line arguments, the "/" here
        // must be interpreted as a path delimiter
        const hasPathSeparators = filename.indexOf('/') >= 0 || (os.platform() === 'win32' && filename.indexOf('\\') >= 0);
        // Are there any path separators?
        if (hasPathSeparators) {
            // If so, then don't search the PATH.  Just resolve relative to the current working directory
            const resolvedPath = path.resolve(context.currentWorkingDirectory, filename);
            return Executable._tryResolveFileExtension(resolvedPath, context);
        }
        else {
            // Otherwise if it's a bare name, then try everything in the shell PATH
            const pathsToSearch = Executable._getSearchFolders(context);
            for (const pathToSearch of pathsToSearch) {
                const resolvedPath = path.join(pathToSearch, filename);
                const result = Executable._tryResolveFileExtension(resolvedPath, context);
                if (result) {
                    return result;
                }
            }
            // No match was found
            return undefined;
        }
    }
    static _tryResolveFileExtension(resolvedPath, context) {
        if (Executable._canExecute(resolvedPath, context)) {
            return resolvedPath;
        }
        // Try the default file extensions
        for (const shellExtension of context.windowsExecutableExtensions) {
            const resolvedNameWithExtension = resolvedPath + shellExtension;
            if (Executable._canExecute(resolvedNameWithExtension, context)) {
                return resolvedNameWithExtension;
            }
        }
        return undefined;
    }
    static _buildEnvironmentMap(options) {
        const environmentMap = new EnvironmentMap_1.EnvironmentMap();
        if (options.environment !== undefined && options.environmentMap !== undefined) {
            throw new Error('IExecutableResolveOptions.environment and IExecutableResolveOptions.environmentMap' +
                ' cannot both be specified');
        }
        if (options.environment !== undefined) {
            environmentMap.mergeFromObject(options.environment);
        }
        else if (options.environmentMap !== undefined) {
            environmentMap.mergeFrom(options.environmentMap);
        }
        else {
            environmentMap.mergeFromObject(process.env);
        }
        return environmentMap;
    }
    /**
     * This is used when searching the shell PATH for an executable, to determine
     * whether a match should be skipped or not.  If it returns true, this does not
     * guarantee that the file can be successfully executed.
     */
    static _canExecute(filePath, context) {
        if (!FileSystem_1.FileSystem.exists(filePath)) {
            return false;
        }
        if (os.platform() === 'win32') {
            // NOTE: For Windows, we don't validate that the file extension appears in PATHEXT.
            // That environment variable determines which extensions can be appended if the
            // extension is missing, but it does not affect whether a file may be executed or not.
            // Windows does have a (seldom used) ACL that can be used to deny execution permissions
            // for a file, but NodeJS doesn't expose that API, so we don't bother checking it.
            // However, Windows *does* require that the file has some kind of file extension
            if (path.extname(filePath) === '') {
                return false;
            }
        }
        else {
            // For Unix, check whether any of the POSIX execute bits are set
            try {
                // eslint-disable-next-line no-bitwise
                if ((FileSystem_1.FileSystem.getPosixModeBits(filePath) & 73 /* AllExecute */) === 0) {
                    return false; // not executable
                }
            }
            catch (error) {
                // If we have trouble accessing the file, ignore the error and consider it "not executable"
                // since that's what a shell would do
            }
        }
        return true;
    }
    /**
     * Returns the list of folders where we will search for an executable,
     * based on the PATH environment variable.
     */
    static _getSearchFolders(context) {
        const pathList = context.environmentMap.get('PATH') || '';
        const folders = [];
        // Avoid processing duplicates
        const seenPaths = new Set();
        // NOTE: Cmd.exe on Windows always searches the current working directory first.
        // PowerShell and Unix shells do NOT do that, because it's a security concern.
        // We follow their behavior.
        for (const splitPath of pathList.split(path.delimiter)) {
            const trimmedPath = splitPath.trim();
            if (trimmedPath !== '') {
                if (!seenPaths.has(trimmedPath)) {
                    // Fun fact: If you put relative paths in your PATH environment variable,
                    // all shells will dynamically match them against the current working directory.
                    // This is a terrible design, and in practice nobody does that, but it is supported...
                    // so we allow it here.
                    const resolvedPath = path.resolve(context.currentWorkingDirectory, trimmedPath);
                    if (!seenPaths.has(resolvedPath)) {
                        if (FileSystem_1.FileSystem.exists(resolvedPath)) {
                            folders.push(resolvedPath);
                        }
                        seenPaths.add(resolvedPath);
                    }
                    seenPaths.add(trimmedPath);
                }
            }
        }
        return folders;
    }
    static _getExecutableContext(options) {
        if (!options) {
            options = {};
        }
        const environment = Executable._buildEnvironmentMap(options);
        let currentWorkingDirectory;
        if (options.currentWorkingDirectory) {
            currentWorkingDirectory = path.resolve(options.currentWorkingDirectory);
        }
        else {
            currentWorkingDirectory = process.cwd();
        }
        const windowsExecutableExtensions = [];
        if (os.platform() === 'win32') {
            const pathExtVariable = environment.get('PATHEXT') || '';
            for (const splitValue of pathExtVariable.split(';')) {
                const trimmed = splitValue.trim().toLowerCase();
                // Ignore malformed extensions
                if (/^\.[a-z0-9\.]*[a-z0-9]$/i.test(trimmed)) {
                    // Don't add the same extension twice
                    if (windowsExecutableExtensions.indexOf(trimmed) < 0) {
                        windowsExecutableExtensions.push(trimmed);
                    }
                }
            }
        }
        return {
            environmentMap: environment,
            currentWorkingDirectory,
            windowsExecutableExtensions
        };
    }
    /**
     * Given an input string containing special symbol characters, this inserts the "^" escape
     * character to ensure the symbols are interpreted literally by the Windows shell.
     */
    static _getEscapedForWindowsShell(text) {
        const escapableCharRegExp = /[%\^&|<> ]/g;
        return text.replace(escapableCharRegExp, (value) => '^' + value);
    }
    /**
     * Checks for characters that are unsafe to pass to a Windows batch file
     * due to the way that cmd.exe implements escaping.
     */
    static _validateArgsForWindowsShell(args) {
        const specialCharRegExp = /[%\^&|<>\r\n]/g;
        for (const arg of args) {
            const match = arg.match(specialCharRegExp);
            if (match) {
                // NOTE: It is possible to escape some of these characters by prefixing them
                // with a caret (^), which allows these characters to be successfully passed
                // through to the batch file %1 variables.  But they will be expanded again
                // whenever they are used.  For example, NPM's binary wrapper batch files
                // use "%*" to pass their arguments to Node.exe, which causes them to be expanded
                // again.  Unfortunately the Cmd.exe batch language provides native escaping
                // function (that could be used to insert the carets again).
                //
                // We could work around that by adding double carets, but in general there
                // is no way to predict how many times the variable will get expanded.
                // Thus, there is no generally reliable way to pass these characters.
                throw new Error(`The command line argument ${JSON.stringify(arg)} contains a` +
                    ` special character ${JSON.stringify(match[0])} that cannot be escaped for the Windows shell`);
            }
        }
    }
}
exports.Executable = Executable;
//# sourceMappingURL=Executable.js.map

/***/ }),

/***/ 25271:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileSystem = void 0;
const nodeJsPath = __importStar(__webpack_require__(85622));
const fs = __importStar(__webpack_require__(35747));
const fsx = __importStar(__webpack_require__(5630));
const Text_1 = __webpack_require__(44756);
const MOVE_DEFAULT_OPTIONS = {
    overwrite: true,
    ensureFolderExists: false
};
const READ_FOLDER_DEFAULT_OPTIONS = {
    absolutePaths: false
};
const WRITE_FILE_DEFAULT_OPTIONS = {
    ensureFolderExists: false,
    convertLineEndings: undefined,
    encoding: "utf8" /* Utf8 */
};
const APPEND_TO_FILE_DEFAULT_OPTIONS = Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS);
const READ_FILE_DEFAULT_OPTIONS = {
    encoding: "utf8" /* Utf8 */,
    convertLineEndings: undefined
};
const COPY_FILE_DEFAULT_OPTIONS = {
    alreadyExistsBehavior: "overwrite" /* Overwrite */
};
const COPY_FILES_DEFAULT_OPTIONS = {
    alreadyExistsBehavior: "overwrite" /* Overwrite */
};
const DELETE_FILE_DEFAULT_OPTIONS = {
    throwIfNotExists: false
};
/**
 * The FileSystem API provides a complete set of recommended operations for interacting with the file system.
 *
 * @remarks
 * We recommend to use this instead of the native `fs` API, because `fs` is a minimal set of low-level
 * primitives that must be mapped for each supported operating system. The FileSystem API takes a
 * philosophical approach of providing "one obvious way" to do each operation. We also prefer synchronous
 * operations except in cases where there would be a clear performance benefit for using async, since synchronous
 * code is much easier to read and debug. Also, indiscriminate parallelism has been seen to actually worsen
 * performance, versus improving it.
 *
 * Note that in the documentation, we refer to "filesystem objects", this can be a
 * file, folder, symbolic link, hard link, directory junction, etc.
 *
 * @public
 */
class FileSystem {
    // ===============
    // COMMON OPERATIONS
    // ===============
    /**
     * Returns true if the path exists on disk.
     * Behind the scenes it uses `fs.existsSync()`.
     * @remarks
     * There is a debate about the fact that after `fs.existsSync()` returns true,
     * the file might be deleted before fs.readSync() is called, which would imply that everybody
     * should catch a `readSync()` exception, and nobody should ever use `fs.existsSync()`.
     * We find this to be unpersuasive, since "unexceptional exceptions" really hinder the
     * break-on-exception debugging experience. Also, throwing/catching is generally slow.
     * @param path - The absolute or relative path to the filesystem object.
     */
    static exists(path) {
        return FileSystem._wrapException(() => {
            return fsx.existsSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.exists}.
     */
    static async existsAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return new Promise((resolve) => {
                fsx.exists(path, resolve);
            });
        });
    }
    /**
     * Gets the statistics for a particular filesystem object.
     * If the path is a link, this function follows the link and returns statistics about the link target.
     * Behind the scenes it uses `fs.statSync()`.
     * @param path - The absolute or relative path to the filesystem object.
     */
    static getStatistics(path) {
        return FileSystem._wrapException(() => {
            return fsx.statSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.getStatistics}.
     */
    static async getStatisticsAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.stat(path);
        });
    }
    /**
     * Updates the accessed and modified timestamps of the filesystem object referenced by path.
     * Behind the scenes it uses `fs.utimesSync()`.
     * The caller should specify both times in the `times` parameter.
     * @param path - The path of the file that should be modified.
     * @param times - The times that the object should be updated to reflect.
     */
    static updateTimes(path, times) {
        return FileSystem._wrapException(() => {
            fsx.utimesSync(path, times.accessedTime, times.modifiedTime);
        });
    }
    /**
     * An async version of {@link FileSystem.updateTimes}.
     */
    static async updateTimesAsync(path, times) {
        await FileSystem._wrapExceptionAsync(() => {
            // This cast is needed because the fs-extra typings require both parameters
            // to have the same type (number or Date), whereas Node.js does not require that.
            return fsx.utimes(path, times.accessedTime, times.modifiedTime);
        });
    }
    /**
     * Changes the permissions (i.e. file mode bits) for a filesystem object.
     * Behind the scenes it uses `fs.chmodSync()`.
     * @param path - The absolute or relative path to the object that should be updated.
     * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum
     */
    static changePosixModeBits(path, mode) {
        FileSystem._wrapException(() => {
            fs.chmodSync(path, mode);
        });
    }
    /**
     * An async version of {@link FileSystem.changePosixModeBits}.
     */
    static async changePosixModeBitsAsync(path, mode) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.chmod(path, mode);
        });
    }
    /**
     * Retrieves the permissions (i.e. file mode bits) for a filesystem object.
     * Behind the scenes it uses `fs.chmodSync()`.
     * @param path - The absolute or relative path to the object that should be updated.
     *
     * @remarks
     * This calls {@link FileSystem.getStatistics} to get the POSIX mode bits.
     * If statistics in addition to the mode bits are needed, it is more efficient
     * to call {@link FileSystem.getStatistics} directly instead.
     */
    static getPosixModeBits(path) {
        return FileSystem._wrapException(() => {
            return FileSystem.getStatistics(path).mode;
        });
    }
    /**
     * An async version of {@link FileSystem.getPosixModeBits}.
     */
    static async getPosixModeBitsAsync(path) {
        return await FileSystem._wrapExceptionAsync(async () => {
            return (await FileSystem.getStatisticsAsync(path)).mode;
        });
    }
    /**
     * Returns a 10-character string representation of a PosixModeBits value similar to what
     * would be displayed by a command such as "ls -l" on a POSIX-like operating system.
     * @remarks
     * For example, `PosixModeBits.AllRead | PosixModeBits.AllWrite` would be formatted as "-rw-rw-rw-".
     * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum
     */
    static formatPosixModeBits(modeBits) {
        let result = '-'; // (later we may add support for additional states such as S_IFDIR or S_ISUID)
        result += modeBits & 256 /* UserRead */ ? 'r' : '-';
        result += modeBits & 128 /* UserWrite */ ? 'w' : '-';
        result += modeBits & 64 /* UserExecute */ ? 'x' : '-';
        result += modeBits & 32 /* GroupRead */ ? 'r' : '-';
        result += modeBits & 16 /* GroupWrite */ ? 'w' : '-';
        result += modeBits & 8 /* GroupExecute */ ? 'x' : '-';
        result += modeBits & 4 /* OthersRead */ ? 'r' : '-';
        result += modeBits & 2 /* OthersWrite */ ? 'w' : '-';
        result += modeBits & 1 /* OthersExecute */ ? 'x' : '-';
        return result;
    }
    /**
     * Moves a file. The folder must exist, unless the `ensureFolderExists` option is provided.
     * Behind the scenes it uses `fs-extra.moveSync()`
     */
    static move(options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, MOVE_DEFAULT_OPTIONS), options);
            try {
                fsx.moveSync(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(options.destinationPath);
                    FileSystem.ensureFolder(folderPath);
                    fsx.moveSync(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.move}.
     */
    static async moveAsync(options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, MOVE_DEFAULT_OPTIONS), options);
            try {
                await fsx.move(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(options.destinationPath);
                    await FileSystem.ensureFolderAsync(nodeJsPath.dirname(folderPath));
                    await fsx.move(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
                }
                else {
                    throw error;
                }
            }
        });
    }
    // ===============
    // FOLDER OPERATIONS
    // ===============
    /**
     * Recursively creates a folder at a given path.
     * Behind the scenes is uses `fs-extra.ensureDirSync()`.
     * @remarks
     * Throws an exception if anything in the folderPath is not a folder.
     * @param folderPath - The absolute or relative path of the folder which should be created.
     */
    static ensureFolder(folderPath) {
        FileSystem._wrapException(() => {
            fsx.ensureDirSync(folderPath);
        });
    }
    /**
     * An async version of {@link FileSystem.ensureFolder}.
     */
    static async ensureFolderAsync(folderPath) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.ensureDir(folderPath);
        });
    }
    /**
     * Reads the contents of the folder, not including "." or "..".
     * Behind the scenes it uses `fs.readdirSync()`.
     * @param folderPath - The absolute or relative path to the folder which should be read.
     * @param options - Optional settings that can change the behavior. Type: `IReadFolderOptions`
     */
    static readFolder(folderPath, options) {
        return FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, READ_FOLDER_DEFAULT_OPTIONS), options);
            // @todo: Update this to use Node 10's `withFileTypes: true` option when we drop support for Node 8
            const fileNames = fsx.readdirSync(folderPath);
            if (options.absolutePaths) {
                return fileNames.map((fileName) => nodeJsPath.resolve(folderPath, fileName));
            }
            else {
                return fileNames;
            }
        });
    }
    /**
     * An async version of {@link FileSystem.readFolder}.
     */
    static async readFolderAsync(folderPath, options) {
        return await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, READ_FOLDER_DEFAULT_OPTIONS), options);
            // @todo: Update this to use Node 10's `withFileTypes: true` option when we drop support for Node 8
            const fileNames = await fsx.readdir(folderPath);
            if (options.absolutePaths) {
                return fileNames.map((fileName) => nodeJsPath.resolve(folderPath, fileName));
            }
            else {
                return fileNames;
            }
        });
    }
    /**
     * Deletes a folder, including all of its contents.
     * Behind the scenes is uses `fs-extra.removeSync()`.
     * @remarks
     * Does not throw if the folderPath does not exist.
     * @param folderPath - The absolute or relative path to the folder which should be deleted.
     */
    static deleteFolder(folderPath) {
        FileSystem._wrapException(() => {
            fsx.removeSync(folderPath);
        });
    }
    /**
     * An async version of {@link FileSystem.deleteFolder}.
     */
    static async deleteFolderAsync(folderPath) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.remove(folderPath);
        });
    }
    /**
     * Deletes the content of a folder, but not the folder itself. Also ensures the folder exists.
     * Behind the scenes it uses `fs-extra.emptyDirSync()`.
     * @remarks
     * This is a workaround for a common race condition, where the virus scanner holds a lock on the folder
     * for a brief period after it was deleted, causing EBUSY errors for any code that tries to recreate the folder.
     * @param folderPath - The absolute or relative path to the folder which should have its contents deleted.
     */
    static ensureEmptyFolder(folderPath) {
        FileSystem._wrapException(() => {
            fsx.emptyDirSync(folderPath);
        });
    }
    /**
     * An async version of {@link FileSystem.ensureEmptyFolder}.
     */
    static async ensureEmptyFolderAsync(folderPath) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.emptyDir(folderPath);
        });
    }
    // ===============
    // FILE OPERATIONS
    // ===============
    /**
     * Writes a text string to a file on disk, overwriting the file if it already exists.
     * Behind the scenes it uses `fs.writeFileSync()`.
     * @remarks
     * Throws an error if the folder doesn't exist, unless ensureFolder=true.
     * @param filePath - The absolute or relative path of the file.
     * @param contents - The text that should be written to the file.
     * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`
     */
    static writeFile(filePath, contents, options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                fsx.writeFileSync(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    FileSystem.ensureFolder(folderPath);
                    fsx.writeFileSync(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.writeFile}.
     */
    static async writeFileAsync(filePath, contents, options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                await fsx.writeFile(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    await FileSystem.ensureFolderAsync(folderPath);
                    await fsx.writeFile(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * Writes a text string to a file on disk, appending to the file if it already exists.
     * Behind the scenes it uses `fs.appendFileSync()`.
     * @remarks
     * Throws an error if the folder doesn't exist, unless ensureFolder=true.
     * @param filePath - The absolute or relative path of the file.
     * @param contents - The text that should be written to the file.
     * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`
     */
    static appendToFile(filePath, contents, options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, APPEND_TO_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                fsx.appendFileSync(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    FileSystem.ensureFolder(folderPath);
                    fsx.appendFileSync(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.appendToFile}.
     */
    static async appendToFileAsync(filePath, contents, options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, APPEND_TO_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                await fsx.appendFile(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    await FileSystem.ensureFolderAsync(folderPath);
                    await fsx.appendFile(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * Reads the contents of a file into a string.
     * Behind the scenes it uses `fs.readFileSync()`.
     * @param filePath - The relative or absolute path to the file whose contents should be read.
     * @param options - Optional settings that can change the behavior. Type: `IReadFileOptions`
     */
    static readFile(filePath, options) {
        return FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, READ_FILE_DEFAULT_OPTIONS), options);
            let contents = FileSystem.readFileToBuffer(filePath).toString(options.encoding);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents, options.convertLineEndings);
            }
            return contents;
        });
    }
    /**
     * An async version of {@link FileSystem.readFile}.
     */
    static async readFileAsync(filePath, options) {
        return await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, READ_FILE_DEFAULT_OPTIONS), options);
            let contents = (await FileSystem.readFileToBufferAsync(filePath)).toString(options.encoding);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents, options.convertLineEndings);
            }
            return contents;
        });
    }
    /**
     * Reads the contents of a file into a buffer.
     * Behind the scenes is uses `fs.readFileSync()`.
     * @param filePath - The relative or absolute path to the file whose contents should be read.
     */
    static readFileToBuffer(filePath) {
        return FileSystem._wrapException(() => {
            return fsx.readFileSync(filePath);
        });
    }
    /**
     * An async version of {@link FileSystem.readFileToBuffer}.
     */
    static async readFileToBufferAsync(filePath) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.readFile(filePath);
        });
    }
    /**
     * Copies a single file from one location to another.
     * By default, destinationPath is overwritten if it already exists.
     *
     * @remarks
     * The `copyFile()` API cannot be used to copy folders.  It copies at most one file.
     * Use {@link FileSystem.copyFiles} if you need to recursively copy a tree of folders.
     *
     * The implementation is based on `copySync()` from the `fs-extra` package.
     */
    static copyFile(options) {
        options = Object.assign(Object.assign({}, COPY_FILE_DEFAULT_OPTIONS), options);
        if (FileSystem.getStatistics(options.sourcePath).isDirectory()) {
            throw new Error('The specified path refers to a folder; this operation expects a file object:\n' + options.sourcePath);
        }
        FileSystem._wrapException(() => {
            fsx.copySync(options.sourcePath, options.destinationPath, {
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */
            });
        });
    }
    /**
     * An async version of {@link FileSystem.copyFile}.
     */
    static async copyFileAsync(options) {
        options = Object.assign(Object.assign({}, COPY_FILE_DEFAULT_OPTIONS), options);
        if (FileSystem.getStatistics(options.sourcePath).isDirectory()) {
            throw new Error('The specified path refers to a folder; this operation expects a file object:\n' + options.sourcePath);
        }
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.copy(options.sourcePath, options.destinationPath, {
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */
            });
        });
    }
    /**
     * Copies a file or folder from one location to another, recursively copying any folder contents.
     * By default, destinationPath is overwritten if it already exists.
     *
     * @remarks
     * If you only intend to copy a single file, it is recommended to use {@link FileSystem.copyFile}
     * instead to more clearly communicate the intended operation.
     *
     * The implementation is based on `copySync()` from the `fs-extra` package.
     */
    static copyFiles(options) {
        options = Object.assign(Object.assign({}, COPY_FILES_DEFAULT_OPTIONS), options);
        FileSystem._wrapException(() => {
            fsx.copySync(options.sourcePath, options.destinationPath, {
                dereference: !!options.dereferenceSymlinks,
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */,
                preserveTimestamps: !!options.preserveTimestamps,
                filter: options.filter
            });
        });
    }
    /**
     * An async version of {@link FileSystem.copyFiles}.
     */
    static async copyFilesAsync(options) {
        options = Object.assign(Object.assign({}, COPY_FILES_DEFAULT_OPTIONS), options);
        await FileSystem._wrapExceptionAsync(async () => {
            fsx.copySync(options.sourcePath, options.destinationPath, {
                dereference: !!options.dereferenceSymlinks,
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */,
                preserveTimestamps: !!options.preserveTimestamps,
                filter: options.filter
            });
        });
    }
    /**
     * Deletes a file. Can optionally throw if the file doesn't exist.
     * Behind the scenes it uses `fs.unlinkSync()`.
     * @param filePath - The absolute or relative path to the file that should be deleted.
     * @param options - Optional settings that can change the behavior. Type: `IDeleteFileOptions`
     */
    static deleteFile(filePath, options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, DELETE_FILE_DEFAULT_OPTIONS), options);
            try {
                fsx.unlinkSync(filePath);
            }
            catch (error) {
                if (options.throwIfNotExists || !FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.deleteFile}.
     */
    static async deleteFileAsync(filePath, options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, DELETE_FILE_DEFAULT_OPTIONS), options);
            try {
                await fsx.unlink(filePath);
            }
            catch (error) {
                if (options.throwIfNotExists || !FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        });
    }
    // ===============
    // LINK OPERATIONS
    // ===============
    /**
     * Gets the statistics of a filesystem object. Does NOT follow the link to its target.
     * Behind the scenes it uses `fs.lstatSync()`.
     * @param path - The absolute or relative path to the filesystem object.
     */
    static getLinkStatistics(path) {
        return FileSystem._wrapException(() => {
            return fsx.lstatSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.getLinkStatistics}.
     */
    static async getLinkStatisticsAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.lstat(path);
        });
    }
    /**
     * If `path` refers to a symbolic link, this returns the path of the link target, which may be
     * an absolute or relative path.
     *
     * @remarks
     * If `path` refers to a filesystem object that is not a symbolic link, then an `ErrnoException` is thrown
     * with code 'UNKNOWN'.  If `path` does not exist, then an `ErrnoException` is thrown with code `ENOENT`.
     *
     * @param path - The absolute or relative path to the symbolic link.
     * @returns the path of the link target
     */
    static readLink(path) {
        return FileSystem._wrapException(() => {
            return fsx.readlinkSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.readLink}.
     */
    static async readLinkAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.readlink(path);
        });
    }
    /**
     * Creates an NTFS "directory junction" on Windows operating systems; for other operating systems, it
     * creates a regular symbolic link.  The link target must be a folder, not a file.
     * Behind the scenes it uses `fs.symlinkSync()`.
     *
     * @remarks
     * For security reasons, Windows operating systems by default require administrator elevation to create
     * symbolic links.  As a result, on Windows it's generally recommended for Node.js tools to use hard links
     * (for files) or NTFS directory junctions (for folders), since regular users are allowed to create them.
     * Hard links and junctions are less vulnerable to symlink attacks because they cannot reference a network share,
     * and their target must exist at the time of link creation.  Non-Windows operating systems generally don't
     * restrict symlink creation, and as such are more vulnerable to symlink attacks.  Note that Windows can be
     * configured to permit regular users to create symlinks, for example by enabling Windows 10 "developer mode."
     *
     * A directory junction requires the link source and target to both be located on local disk volumes;
     * if not, use a symbolic link instead.
     */
    static createSymbolicLinkJunction(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                // For directories, we use a Windows "junction".  On POSIX operating systems, this produces a regular symlink.
                return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'junction');
            }, options);
        });
    }
    /**
     * An async version of {@link FileSystem.createSymbolicLinkJunction}.
     */
    static async createSymbolicLinkJunctionAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                // For directories, we use a Windows "junction".  On POSIX operating systems, this produces a regular symlink.
                return fsx.symlink(options.linkTargetPath, options.newLinkPath, 'junction');
            }, options);
        });
    }
    /**
     * Creates a symbolic link to a file.  On Windows operating systems, this may require administrator elevation.
     * Behind the scenes it uses `fs.symlinkSync()`.
     *
     * @remarks
     * To avoid administrator elevation on Windows, use {@link FileSystem.createHardLink} instead.
     *
     * On Windows operating systems, the NTFS file system distinguishes file symlinks versus directory symlinks:
     * If the target is not the correct type, the symlink will be created successfully, but will fail to resolve.
     * Other operating systems do not make this distinction, in which case {@link FileSystem.createSymbolicLinkFile}
     * and {@link FileSystem.createSymbolicLinkFolder} can be used interchangeably, but doing so will make your
     * tool incompatible with Windows.
     */
    static createSymbolicLinkFile(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'file');
            }, options);
        });
    }
    /**
     * An async version of {@link FileSystem.createSymbolicLinkFile}.
     */
    static async createSymbolicLinkFileAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                return fsx.symlink(options.linkTargetPath, options.newLinkPath, 'file');
            }, options);
        });
    }
    /**
     * Creates a symbolic link to a folder.  On Windows operating systems, this may require administrator elevation.
     * Behind the scenes it uses `fs.symlinkSync()`.
     *
     * @remarks
     * To avoid administrator elevation on Windows, use {@link FileSystem.createSymbolicLinkJunction} instead.
     *
     * On Windows operating systems, the NTFS file system distinguishes file symlinks versus directory symlinks:
     * If the target is not the correct type, the symlink will be created successfully, but will fail to resolve.
     * Other operating systems do not make this distinction, in which case {@link FileSystem.createSymbolicLinkFile}
     * and {@link FileSystem.createSymbolicLinkFolder} can be used interchangeably, but doing so will make your
     * tool incompatible with Windows.
     */
    static createSymbolicLinkFolder(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'dir');
            }, options);
        });
    }
    /**
     * An async version of {@link FileSystem.createSymbolicLinkFolder}.
     */
    static async createSymbolicLinkFolderAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                return fsx.symlink(options.linkTargetPath, options.newLinkPath, 'dir');
            }, options);
        });
    }
    /**
     * Creates a hard link.  The link target must be a file, not a folder.
     * Behind the scenes it uses `fs.linkSync()`.
     *
     * @remarks
     * For security reasons, Windows operating systems by default require administrator elevation to create
     * symbolic links.  As a result, on Windows it's generally recommended for Node.js tools to use hard links
     * (for files) or NTFS directory junctions (for folders), since regular users are allowed to create them.
     * Hard links and junctions are less vulnerable to symlink attacks because they cannot reference a network share,
     * and their target must exist at the time of link creation.  Non-Windows operating systems generally don't
     * restrict symlink creation, and as such are more vulnerable to symlink attacks.  Note that Windows can be
     * configured to permit regular users to create symlinks, for example by enabling Windows 10 "developer mode."
     *
     * A hard link requires the link source and target to both be located on same disk volume;
     * if not, use a symbolic link instead.
     */
    static createHardLink(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                return fsx.linkSync(options.linkTargetPath, options.newLinkPath);
            }, Object.assign(Object.assign({}, options), { linkTargetMustExist: true }));
        });
    }
    /**
     * An async version of {@link FileSystem.createHardLink}.
     */
    static async createHardLinkAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                return fsx.link(options.linkTargetPath, options.newLinkPath);
            }, Object.assign(Object.assign({}, options), { linkTargetMustExist: true }));
        });
    }
    /**
     * Follows a link to its destination and returns the absolute path to the final target of the link.
     * Behind the scenes it uses `fs.realpathSync()`.
     * @param linkPath - The path to the link.
     */
    static getRealPath(linkPath) {
        return FileSystem._wrapException(() => {
            return fsx.realpathSync(linkPath);
        });
    }
    /**
     * An async version of {@link FileSystem.getRealPath}.
     */
    static async getRealPathAsync(linkPath) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.realpath(linkPath);
        });
    }
    // ===============
    // UTILITY FUNCTIONS
    // ===============
    /**
     * Returns true if the error object indicates the file or folder already exists (`EEXIST`).
     */
    static isExistError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'EEXIST';
    }
    /**
     * Returns true if the error object indicates the file or folder does not exist (`ENOENT` or `ENOTDIR`)
     */
    static isNotExistError(error) {
        return FileSystem.isFileDoesNotExistError(error) || FileSystem.isFolderDoesNotExistError(error);
    }
    /**
     * Returns true if the error object indicates the file does not exist (`ENOENT`).
     */
    static isFileDoesNotExistError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'ENOENT';
    }
    /**
     * Returns true if the error object indicates the folder does not exist (`ENOTDIR`).
     */
    static isFolderDoesNotExistError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'ENOTDIR';
    }
    /**
     * Returns true if the error object indicates that the `unlink` system call failed
     * due to a permissions issue (`EPERM`).
     */
    static isUnlinkNotPermittedError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'EPERM' && error.syscall === 'unlink';
    }
    /**
     * Detects if the provided error object is a `NodeJS.ErrnoException`
     */
    static isErrnoException(error) {
        const typedError = error;
        return (typeof typedError.code === 'string' &&
            typeof typedError.errno === 'number' &&
            typeof typedError.path === 'string' &&
            typeof typedError.syscall === 'string');
    }
    static _handleLink(linkFn, options) {
        try {
            linkFn();
        }
        catch (error) {
            if (FileSystem.isExistError(error)) {
                // Link exists, handle it
                switch (options.alreadyExistsBehavior) {
                    case "ignore" /* Ignore */:
                        break;
                    case "overwrite" /* Overwrite */:
                        // fsx.linkSync does not allow overwriting so we must manually delete. If it's
                        // a folder, it will throw an error.
                        this.deleteFile(options.newLinkPath);
                        linkFn();
                        break;
                    case "error" /* Error */:
                    default:
                        throw error;
                }
            }
            else {
                // When attempting to create a link in a directory that does not exist, an ENOENT
                // or ENOTDIR error is thrown, so we should ensure the directory exists before
                // retrying. There are also cases where the target file must exist, so validate in
                // those cases to avoid confusing the missing directory with the missing target file.
                if (FileSystem.isNotExistError(error) &&
                    (!options.linkTargetMustExist || FileSystem.exists(options.linkTargetPath))) {
                    this.ensureFolder(nodeJsPath.dirname(options.newLinkPath));
                    linkFn();
                }
                else {
                    throw error;
                }
            }
        }
    }
    static async _handleLinkAsync(linkFn, options) {
        try {
            await linkFn();
        }
        catch (error) {
            if (FileSystem.isExistError(error)) {
                // Link exists, handle it
                switch (options.alreadyExistsBehavior) {
                    case "ignore" /* Ignore */:
                        break;
                    case "overwrite" /* Overwrite */:
                        // fsx.linkSync does not allow overwriting so we must manually delete. If it's
                        // a folder, it will throw an error.
                        await this.deleteFileAsync(options.newLinkPath);
                        await linkFn();
                        break;
                    case "error" /* Error */:
                    default:
                        throw error;
                }
            }
            else {
                // When attempting to create a link in a directory that does not exist, an ENOENT
                // or ENOTDIR error is thrown, so we should ensure the directory exists before
                // retrying. There are also cases where the target file must exist, so validate in
                // those cases to avoid confusing the missing directory with the missing target file.
                if (FileSystem.isNotExistError(error) &&
                    (!options.linkTargetMustExist || (await FileSystem.existsAsync(options.linkTargetPath)))) {
                    await this.ensureFolderAsync(nodeJsPath.dirname(options.newLinkPath));
                    await linkFn();
                }
                else {
                    throw error;
                }
            }
        }
    }
    static _wrapException(fn) {
        try {
            return fn();
        }
        catch (error) {
            FileSystem._updateErrorMessage(error);
            throw error;
        }
    }
    static async _wrapExceptionAsync(fn) {
        try {
            return await fn();
        }
        catch (error) {
            FileSystem._updateErrorMessage(error);
            throw error;
        }
    }
    static _updateErrorMessage(error) {
        if (FileSystem.isErrnoException(error)) {
            if (FileSystem.isFileDoesNotExistError(error)) {
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `File does not exist: ${error.path}\n${error.message}`;
            }
            else if (FileSystem.isFolderDoesNotExistError(error)) {
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `Folder does not exist: ${error.path}\n${error.message}`;
            }
            else if (FileSystem.isExistError(error)) {
                // Oddly, the typing does not include the `dest` property even though the documentation
                // indicates it is there: https://nodejs.org/docs/latest-v10.x/api/errors.html#errors_error_dest
                const extendedError = error;
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `File or folder already exists: ${extendedError.dest}\n${error.message}`;
            }
            else if (FileSystem.isUnlinkNotPermittedError(error)) {
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `File or folder could not be deleted: ${error.path}\n${error.message}`;
            }
        }
    }
}
exports.FileSystem = FileSystem;
//# sourceMappingURL=FileSystem.js.map

/***/ }),

/***/ 61053:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileWriter = void 0;
const Import_1 = __webpack_require__(90277);
const fsx = Import_1.Import.lazy('fs-extra', require);
/**
 * API for interacting with file handles.
 * @public
 */
class FileWriter {
    constructor(fileDescriptor, filePath) {
        this._fileDescriptor = fileDescriptor;
        this.filePath = filePath;
    }
    /**
     * Opens a new file handle to the file at the specified path and given mode.
     * Behind the scenes it uses `fs.openSync()`.
     * The behaviour of this function is platform specific.
     * See: https://nodejs.org/docs/latest-v8.x/api/fs.html#fs_fs_open_path_flags_mode_callback
     * @param filePath - The absolute or relative path to the file handle that should be opened.
     * @param flags - The flags for opening the handle
     */
    static open(filePath, flags) {
        return new FileWriter(fsx.openSync(filePath, FileWriter._convertFlagsForNode(flags)), filePath);
    }
    /**
     * Helper function to convert the file writer array to a Node.js style string (e.g. "wx" or "a").
     * @param flags - The flags that should be converted.
     */
    static _convertFlagsForNode(flags) {
        flags = Object.assign({ append: false, exclusive: false }, flags);
        return [flags.append ? 'a' : 'w', flags.exclusive ? 'x' : ''].join('');
    }
    /**
     * Writes some text to the given file handle. Throws if the file handle has been closed.
     * Behind the scenes it uses `fs.writeSync()`.
     * @param text - The text to write to the file.
     */
    write(text) {
        if (!this._fileDescriptor) {
            throw new Error(`Cannot write to file, file descriptor has already been released.`);
        }
        fsx.writeSync(this._fileDescriptor, text);
    }
    /**
     * Closes the file handle permanently. No operations can be made on this file handle after calling this.
     * Behind the scenes it uses `fs.closeSync()` and releases the file descriptor to be re-used.
     *
     * @remarks
     * The `close()` method can be called more than once; additional calls are ignored.
     */
    close() {
        const fd = this._fileDescriptor;
        if (fd) {
            this._fileDescriptor = undefined;
            fsx.closeSync(fd);
        }
    }
}
exports.FileWriter = FileWriter;
//# sourceMappingURL=FileWriter.js.map

/***/ }),

/***/ 90277:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Import = void 0;
const path = __importStar(__webpack_require__(85622));
const importLazy = __webpack_require__(41239);
const Resolve = __importStar(__webpack_require__(88200));
const nodeModule = __webpack_require__(32282);
const PackageJsonLookup_1 = __webpack_require__(17805);
const FileSystem_1 = __webpack_require__(25271);
/**
 * Helpers for resolving and importing Node.js modules.
 * @public
 */
class Import {
    static get _builtInModules() {
        if (!Import.__builtInModules) {
            Import.__builtInModules = new Set(nodeModule.builtinModules);
        }
        return Import.__builtInModules;
    }
    /**
     * Provides a way to improve process startup times by lazy-loading imported modules.
     *
     * @remarks
     * This is a more structured wrapper for the {@link https://www.npmjs.com/package/import-lazy|import-lazy}
     * package.  It enables you to replace an import like this:
     *
     * ```ts
     * import * as example from 'example'; // <-- 100ms load time
     *
     * if (condition) {
     *   example.doSomething();
     * }
     * ```
     *
     * ...with a pattern like this:
     *
     * ```ts
     * const example: typeof import('example') = Import.lazy('example', require);
     *
     * if (condition) {
     *   example.doSomething(); // <-- 100ms load time occurs here, only if needed
     * }
     * ```
     *
     * The implementation relies on JavaScript's `Proxy` feature to intercept access to object members.  Thus
     * it will only work correctly with certain types of module exports.  If a particular export isn't well behaved,
     * you may need to find (or introduce) some other module in your dependency graph to apply the optimization to.
     *
     * Usage guidelines:
     *
     * - Always specify types using `typeof` as shown above.
     *
     * - Never apply lazy-loading in a way that would convert the module's type to `any`. Losing type safety
     *   seriously impacts the maintainability of the code base.
     *
     * - In cases where the non-runtime types are needed, import them separately using the `Types` suffix:
     *
     * ```ts
     * const example: typeof import('example') = Import.lazy('example', require);
     * import type * as exampleTypes from 'example';
     * ```
     *
     * - If the imported module confusingly has the same name as its export, then use the Module suffix:
     *
     * ```ts
     * const exampleModule: typeof import('../../logic/Example') = Import.lazy(
     *   '../../logic/Example', require);
     * import type * as exampleTypes from '../../logic/Example';
     * ```
     *
     * - If the exports cause a lot of awkwardness (e.g. too many expressions need to have `exampleModule.` inserted
     *   into them), or if some exports cannot be proxied (e.g. `Import.lazy('example', require)` returns a function
     *   signature), then do not lazy-load that module.  Instead, apply lazy-loading to some other module which is
     *   better behaved.
     *
     * - It's recommended to sort imports in a standard ordering:
     *
     * ```ts
     * // 1. external imports
     * import * as path from 'path';
     * import { Import, JsonFile, JsonObject } from '@rushstack/node-core-library';
     *
     * // 2. local imports
     * import { LocalFile } from './path/LocalFile';
     *
     * // 3. lazy-imports (which are technically variables, not imports)
     * const semver: typeof import('semver') = Import.lazy('semver', require);
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static lazy(moduleName, require) {
        const importLazyLocal = importLazy(require);
        return importLazyLocal(moduleName);
    }
    /**
     * This resolves a module path using similar logic as the Node.js `require.resolve()` API,
     * but supporting extra features such as specifying the base folder.
     *
     * @remarks
     * A module path is a text string that might appear in a statement such as
     * `import { X } from "____";` or `const x = require("___");`.  The implementation is based
     * on the popular `resolve` NPM package.
     *
     * Suppose `example` is an NPM package whose entry point is `lib/index.js`:
     * ```ts
     * // Returns "/path/to/project/node_modules/example/lib/index.js"
     * Import.resolveModule({ modulePath: 'example' });
     *
     * // Returns "/path/to/project/node_modules/example/lib/other.js"
     * Import.resolveModule({ modulePath: 'example/lib/other' });
     * ```
     * If you need to determine the containing package folder
     * (`/path/to/project/node_modules/example`), use {@link Import.resolvePackage} instead.
     *
     * @returns the absolute path of the resolved module.
     * If {@link IImportResolveOptions.includeSystemModules} is specified
     * and a system module is found, then its name is returned without any file path.
     */
    static resolveModule(options) {
        const { modulePath } = options;
        if (path.isAbsolute(modulePath)) {
            return modulePath;
        }
        const normalizedRootPath = FileSystem_1.FileSystem.getRealPath(options.baseFolderPath);
        if (modulePath.startsWith('.')) {
            // This looks like a conventional relative path
            return path.resolve(normalizedRootPath, modulePath);
        }
        if (options.includeSystemModules === true && Import._builtInModules.has(modulePath)) {
            return modulePath;
        }
        if (options.allowSelfReference === true) {
            const ownPackage = Import._getPackageName(options.baseFolderPath);
            if (ownPackage && modulePath.startsWith(ownPackage.packageName)) {
                const packagePath = modulePath.substr(ownPackage.packageName.length + 1);
                return path.resolve(ownPackage.packageRootPath, packagePath);
            }
        }
        try {
            return Resolve.sync(
            // Append a slash to the package name to ensure `resolve.sync` doesn't attempt to return a system package
            options.includeSystemModules !== true && modulePath.indexOf('/') === -1
                ? `${modulePath}/`
                : modulePath, {
                basedir: normalizedRootPath,
                preserveSymlinks: false
            });
        }
        catch (e) {
            throw new Error(`Cannot find module "${modulePath}" from "${options.baseFolderPath}".`);
        }
    }
    /**
     * Performs module resolution to determine the folder where a package is installed.
     *
     * @remarks
     * Suppose `example` is an NPM package whose entry point is `lib/index.js`:
     * ```ts
     * // Returns "/path/to/project/node_modules/example"
     * Import.resolvePackage({ packageName: 'example' });
     * ```
     *
     * If you need to resolve a module path, use {@link Import.resolveModule} instead:
     * ```ts
     * // Returns "/path/to/project/node_modules/example/lib/index.js"
     * Import.resolveModule({ modulePath: 'example' });
     * ```
     *
     * @returns the absolute path of the package folder.
     * If {@link IImportResolveOptions.includeSystemModules} is specified
     * and a system module is found, then its name is returned without any file path.
     */
    static resolvePackage(options) {
        const { packageName } = options;
        if (options.includeSystemModules && Import._builtInModules.has(packageName)) {
            return packageName;
        }
        const normalizedRootPath = FileSystem_1.FileSystem.getRealPath(options.baseFolderPath);
        if (options.allowSelfReference) {
            const ownPackage = Import._getPackageName(options.baseFolderPath);
            if (ownPackage && ownPackage.packageName === packageName) {
                return ownPackage.packageRootPath;
            }
        }
        try {
            const resolvedPath = Resolve.sync(packageName, {
                basedir: normalizedRootPath,
                preserveSymlinks: false,
                packageFilter: (pkg) => {
                    // Hardwire "main" to point to a file that is guaranteed to exist.
                    // This helps resolve packages such as @types/node that have no entry point.
                    // And then we can use path.dirname() below to locate the package folder,
                    // even if the real entry point was in an subfolder with arbitrary nesting.
                    pkg.main = 'package.json';
                    return pkg;
                }
            });
            const packagePath = path.dirname(resolvedPath);
            const packageJson = PackageJsonLookup_1.PackageJsonLookup.instance.loadPackageJson(path.join(packagePath, 'package.json'));
            if (packageJson.name === packageName) {
                return packagePath;
            }
            else {
                throw new Error();
            }
        }
        catch (e) {
            throw new Error(`Cannot find package "${packageName}" from "${options.baseFolderPath}".`);
        }
    }
    static _getPackageName(rootPath) {
        const packageJsonPath = PackageJsonLookup_1.PackageJsonLookup.instance.tryGetPackageJsonFilePathFor(rootPath);
        if (packageJsonPath) {
            const packageJson = PackageJsonLookup_1.PackageJsonLookup.instance.loadPackageJson(packageJsonPath);
            return {
                packageRootPath: path.dirname(packageJsonPath),
                packageName: packageJson.name
            };
        }
        else {
            return undefined;
        }
    }
}
exports.Import = Import;
//# sourceMappingURL=Import.js.map

/***/ }),

/***/ 65230:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InternalError = void 0;
/**
 * An `Error` subclass that should be thrown to report an unexpected state that may indicate a software defect.
 * An application may handle this error by instructing the end user to report an issue to the application maintainers.
 *
 * @remarks
 * Do not use this class unless you intend to solicit bug reports from end users.
 *
 * @public
 */
class InternalError extends Error {
    /**
     * Constructs a new instance of the {@link InternalError} class.
     *
     * @param message - A message describing the error.  This will be assigned to
     * {@link InternalError.unformattedMessage}.  The `Error.message` field will have additional boilerplate
     * explaining that the user has encountered a software defect.
     */
    constructor(message) {
        super(InternalError._formatMessage(message));
        // Manually set the prototype, as we can no longer extend built-in classes like Error, Array, Map, etc.
        // https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        //
        // Note: the prototype must also be set on any classes which extend this one
        this.__proto__ = InternalError.prototype; // eslint-disable-line @typescript-eslint/no-explicit-any
        this.unformattedMessage = message;
        if (InternalError.breakInDebugger) {
            // eslint-disable-next-line no-debugger
            debugger;
        }
    }
    static _formatMessage(unformattedMessage) {
        return (`Internal Error: ${unformattedMessage}\n\nYou have encountered a software defect. Please consider` +
            ` reporting the issue to the maintainers of this application.`);
    }
    /** @override */
    toString() {
        return this.message; // Avoid adding the "Error:" prefix
    }
}
exports.InternalError = InternalError;
/**
 * If true, a JavScript `debugger;` statement will be invoked whenever the `InternalError` constructor is called.
 *
 * @remarks
 * Generally applications should not be catching and ignoring an `InternalError`.  Instead, the error should
 * be reported and typically the application will terminate.  Thus, if `InternalError` is constructed, it's
 * almost always something we want to examine in a debugger.
 */
InternalError.breakInDebugger = true;
//# sourceMappingURL=InternalError.js.map

/***/ }),

/***/ 20785:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonFile = void 0;
const os = __importStar(__webpack_require__(12087));
const jju = __importStar(__webpack_require__(93304));
const Text_1 = __webpack_require__(44756);
const FileSystem_1 = __webpack_require__(25271);
const DEFAULT_ENCODING = 'utf8';
/**
 * Utilities for reading/writing JSON files.
 * @public
 */
class JsonFile {
    /**
     * Loads a JSON file.
     */
    static load(jsonFilename) {
        try {
            const contents = FileSystem_1.FileSystem.readFile(jsonFilename);
            return jju.parse(contents);
        }
        catch (error) {
            if (FileSystem_1.FileSystem.isNotExistError(error)) {
                throw error;
            }
            else {
                throw new Error(`Error reading "${JsonFile._formatPathForError(jsonFilename)}":` +
                    os.EOL +
                    `  ${error.message}`);
            }
        }
    }
    /**
     * An async version of {@link JsonFile.load}.
     */
    static async loadAsync(jsonFilename) {
        try {
            const contents = await FileSystem_1.FileSystem.readFileAsync(jsonFilename);
            return jju.parse(contents);
        }
        catch (error) {
            if (FileSystem_1.FileSystem.isNotExistError(error)) {
                throw error;
            }
            else {
                throw new Error(`Error reading "${JsonFile._formatPathForError(jsonFilename)}":` +
                    os.EOL +
                    `  ${error.message}`);
            }
        }
    }
    /**
     * Parses a JSON file's contents.
     */
    static parseString(jsonContents) {
        return jju.parse(jsonContents);
    }
    /**
     * Loads a JSON file and validate its schema.
     */
    static loadAndValidate(jsonFilename, jsonSchema, options) {
        const jsonObject = JsonFile.load(jsonFilename);
        jsonSchema.validateObject(jsonObject, jsonFilename, options);
        return jsonObject;
    }
    /**
     * An async version of {@link JsonFile.loadAndValidate}.
     */
    static async loadAndValidateAsync(jsonFilename, jsonSchema, options) {
        const jsonObject = await JsonFile.loadAsync(jsonFilename);
        jsonSchema.validateObject(jsonObject, jsonFilename, options);
        return jsonObject;
    }
    /**
     * Loads a JSON file and validate its schema, reporting errors using a callback
     * @remarks
     * See JsonSchema.validateObjectWithCallback() for more info.
     */
    static loadAndValidateWithCallback(jsonFilename, jsonSchema, errorCallback) {
        const jsonObject = JsonFile.load(jsonFilename);
        jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);
        return jsonObject;
    }
    /**
     * An async version of {@link JsonFile.loadAndValidateWithCallback}.
     */
    static async loadAndValidateWithCallbackAsync(jsonFilename, jsonSchema, errorCallback) {
        const jsonObject = await JsonFile.loadAsync(jsonFilename);
        jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);
        return jsonObject;
    }
    /**
     * Serializes the specified JSON object to a string buffer.
     * @param jsonObject - the object to be serialized
     * @param options - other settings that control serialization
     * @returns a JSON string, with newlines, and indented with two spaces
     */
    static stringify(jsonObject, options) {
        return JsonFile.updateString('', jsonObject, options);
    }
    /**
     * Serializes the specified JSON object to a string buffer.
     * @param jsonObject - the object to be serialized
     * @param options - other settings that control serialization
     * @returns a JSON string, with newlines, and indented with two spaces
     */
    static updateString(previousJson, newJsonObject, options) {
        if (!options) {
            options = {};
        }
        if (!options.ignoreUndefinedValues) {
            // Standard handling of `undefined` in JSON stringification is to discard the key.
            JsonFile.validateNoUndefinedMembers(newJsonObject);
        }
        let stringified;
        if (previousJson !== '') {
            // NOTE: We don't use mode=json here because comments aren't allowed by strict JSON
            stringified = jju.update(previousJson, newJsonObject, {
                mode: 'cjson',
                indent: 2
            });
        }
        else if (options.prettyFormatting) {
            stringified = jju.stringify(newJsonObject, {
                mode: 'json',
                indent: 2
            });
            if (options.headerComment !== undefined) {
                stringified = JsonFile._formatJsonHeaderComment(options.headerComment) + stringified;
            }
        }
        else {
            stringified = JSON.stringify(newJsonObject, undefined, 2);
            if (options.headerComment !== undefined) {
                stringified = JsonFile._formatJsonHeaderComment(options.headerComment) + stringified;
            }
        }
        // Add the trailing newline
        stringified = Text_1.Text.ensureTrailingNewline(stringified);
        if (options && options.newlineConversion) {
            stringified = Text_1.Text.convertTo(stringified, options.newlineConversion);
        }
        return stringified;
    }
    /**
     * Saves the file to disk.  Returns false if nothing was written due to options.onlyIfChanged.
     * @param jsonObject - the object to be saved
     * @param jsonFilename - the file path to write
     * @param options - other settings that control how the file is saved
     * @returns false if ISaveJsonFileOptions.onlyIfChanged didn't save anything; true otherwise
     */
    static save(jsonObject, jsonFilename, options) {
        if (!options) {
            options = {};
        }
        // Do we need to read the previous file contents?
        let oldBuffer = undefined;
        if (options.updateExistingFile || options.onlyIfChanged) {
            try {
                oldBuffer = FileSystem_1.FileSystem.readFileToBuffer(jsonFilename);
            }
            catch (error) {
                if (!FileSystem_1.FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        }
        let jsonToUpdate = '';
        if (options.updateExistingFile && oldBuffer) {
            jsonToUpdate = oldBuffer.toString(DEFAULT_ENCODING);
        }
        const newJson = JsonFile.updateString(jsonToUpdate, jsonObject, options);
        const newBuffer = Buffer.from(newJson, DEFAULT_ENCODING);
        if (options.onlyIfChanged) {
            // Has the file changed?
            if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {
                // Nothing has changed, so don't touch the file
                return false;
            }
        }
        FileSystem_1.FileSystem.writeFile(jsonFilename, newBuffer.toString(DEFAULT_ENCODING), {
            ensureFolderExists: options.ensureFolderExists
        });
        // TEST CODE: Used to verify that onlyIfChanged isn't broken by a hidden transformation during saving.
        /*
        const oldBuffer2: Buffer = FileSystem.readFileToBuffer(jsonFilename);
        if (Buffer.compare(buffer, oldBuffer2) !== 0) {
          console.log('new:' + buffer.toString('hex'));
          console.log('old:' + oldBuffer2.toString('hex'));
    
          throw new Error('onlyIfChanged logic is broken');
        }
        */
        return true;
    }
    /**
     * An async version of {@link JsonFile.save}.
     */
    static async saveAsync(jsonObject, jsonFilename, options) {
        if (!options) {
            options = {};
        }
        // Do we need to read the previous file contents?
        let oldBuffer = undefined;
        if (options.updateExistingFile || options.onlyIfChanged) {
            try {
                oldBuffer = await FileSystem_1.FileSystem.readFileToBufferAsync(jsonFilename);
            }
            catch (error) {
                if (!FileSystem_1.FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        }
        let jsonToUpdate = '';
        if (options.updateExistingFile && oldBuffer) {
            jsonToUpdate = oldBuffer.toString(DEFAULT_ENCODING);
        }
        const newJson = JsonFile.updateString(jsonToUpdate, jsonObject, options);
        const newBuffer = Buffer.from(newJson, DEFAULT_ENCODING);
        if (options.onlyIfChanged) {
            // Has the file changed?
            if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {
                // Nothing has changed, so don't touch the file
                return false;
            }
        }
        await FileSystem_1.FileSystem.writeFileAsync(jsonFilename, newBuffer.toString(DEFAULT_ENCODING), {
            ensureFolderExists: options.ensureFolderExists
        });
        // TEST CODE: Used to verify that onlyIfChanged isn't broken by a hidden transformation during saving.
        /*
        const oldBuffer2: Buffer = await FileSystem.readFileToBufferAsync(jsonFilename);
        if (Buffer.compare(buffer, oldBuffer2) !== 0) {
          console.log('new:' + buffer.toString('hex'));
          console.log('old:' + oldBuffer2.toString('hex'));
    
          throw new Error('onlyIfChanged logic is broken');
        }
        */
        return true;
    }
    /**
     * Used to validate a data structure before writing.  Reports an error if there
     * are any undefined members.
     */
    static validateNoUndefinedMembers(jsonObject) {
        return JsonFile._validateNoUndefinedMembers(jsonObject, []);
    }
    // Private implementation of validateNoUndefinedMembers()
    static _validateNoUndefinedMembers(jsonObject, keyPath) {
        if (!jsonObject) {
            return;
        }
        if (typeof jsonObject === 'object') {
            for (const key of Object.keys(jsonObject)) {
                keyPath.push(key);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const value = jsonObject[key];
                if (value === undefined) {
                    const fullPath = JsonFile._formatKeyPath(keyPath);
                    throw new Error(`The value for ${fullPath} is "undefined" and cannot be serialized as JSON`);
                }
                JsonFile._validateNoUndefinedMembers(value, keyPath);
                keyPath.pop();
            }
        }
    }
    // Given this input:    ['items', '4', 'syntax', 'parameters', 'string "with" symbols", 'type']
    // Return this string:  items[4].syntax.parameters["string \"with\" symbols"].type
    static _formatKeyPath(keyPath) {
        let result = '';
        for (const key of keyPath) {
            if (/^[0-9]+$/.test(key)) {
                // It's an integer, so display like this:  parent[123]
                result += `[${key}]`;
            }
            else if (/^[a-z_][a-z_0-9]*$/i.test(key)) {
                // It's an alphanumeric identifier, so display like this:  parent.name
                if (result) {
                    result += '.';
                }
                result += `${key}`;
            }
            else {
                // It's a freeform string, so display like this:  parent["A path: \"C:\\file\""]
                // Convert this:     A path: "C:\file"
                // To this:          A path: \"C:\\file\"
                const escapedKey = key
                    .replace(/[\\]/g, '\\\\') // escape backslashes
                    .replace(/["]/g, '\\'); // escape quotes
                result += `["${escapedKey}"]`;
            }
        }
        return result;
    }
    static _formatJsonHeaderComment(headerComment) {
        if (headerComment === '') {
            return '';
        }
        const lines = headerComment.split('\n');
        const result = [];
        for (const line of lines) {
            if (!/^\s*$/.test(line) && !/^\s*\/\//.test(line)) {
                throw new Error('The headerComment lines must be blank or start with the "//" prefix.\n' +
                    'Invalid line' +
                    JSON.stringify(line));
            }
            result.push(Text_1.Text.replaceAll(line, '\r', ''));
        }
        return lines.join('\n') + '\n';
    }
}
exports.JsonFile = JsonFile;
/**
 * @internal
 */
JsonFile._formatPathForError = (path) => path;
//# sourceMappingURL=JsonFile.js.map

/***/ }),

/***/ 31561:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonSchema = void 0;
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const JsonFile_1 = __webpack_require__(20785);
const FileSystem_1 = __webpack_require__(25271);
const Validator = __webpack_require__(59997);
/**
 * Represents a JSON schema that can be used to validate JSON data files loaded by the JsonFile class.
 * @remarks
 * The schema itself is normally loaded and compiled later, only if it is actually required to validate
 * an input.  To avoid schema errors at runtime, it's recommended to create a unit test that calls
 * JsonSchema.ensureCompiled() for each of your schema objects.
 *
 * @public
 */
class JsonSchema {
    constructor() {
        this._dependentSchemas = [];
        this._filename = '';
        this._validator = undefined;
        this._schemaObject = undefined;
    }
    /**
     * Registers a JsonSchema that will be loaded from a file on disk.
     * @remarks
     * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
     * until it the schema is actually used.
     */
    static fromFile(filename, options) {
        // This is a quick and inexpensive test to avoid the catch the most common errors early.
        // Full validation will happen later in JsonSchema.compile().
        if (!FileSystem_1.FileSystem.exists(filename)) {
            throw new Error('Schema file not found: ' + filename);
        }
        const schema = new JsonSchema();
        schema._filename = filename;
        if (options) {
            schema._dependentSchemas = options.dependentSchemas || [];
        }
        return schema;
    }
    /**
     * Registers a JsonSchema that will be loaded from a file on disk.
     * @remarks
     * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
     * until it the schema is actually used.
     */
    static fromLoadedObject(schemaObject) {
        const schema = new JsonSchema();
        schema._schemaObject = schemaObject;
        return schema;
    }
    static _collectDependentSchemas(collectedSchemas, dependentSchemas, seenObjects, seenIds) {
        for (const dependentSchema of dependentSchemas) {
            // It's okay for the same schema to appear multiple times in the tree, but we only process it once
            if (seenObjects.has(dependentSchema)) {
                continue;
            }
            seenObjects.add(dependentSchema);
            const schemaId = dependentSchema._ensureLoaded();
            if (schemaId === '') {
                throw new Error(`This schema ${dependentSchema.shortName} cannot be referenced` +
                    ' because is missing the "id" field');
            }
            if (seenIds.has(schemaId)) {
                throw new Error(`This schema ${dependentSchema.shortName} has the same "id" as another schema in this set`);
            }
            seenIds.add(schemaId);
            collectedSchemas.push(dependentSchema);
            JsonSchema._collectDependentSchemas(collectedSchemas, dependentSchema._dependentSchemas, seenObjects, seenIds);
        }
    }
    /**
     * Used to nicely format the ZSchema error tree.
     */
    static _formatErrorDetails(errorDetails) {
        return JsonSchema._formatErrorDetailsHelper(errorDetails, '', '');
    }
    /**
     * Used by _formatErrorDetails.
     */
    static _formatErrorDetailsHelper(errorDetails, indent, buffer) {
        for (const errorDetail of errorDetails) {
            buffer += os.EOL + indent + `Error: ${errorDetail.path}`;
            if (errorDetail.description) {
                const MAX_LENGTH = 40;
                let truncatedDescription = errorDetail.description.trim();
                if (truncatedDescription.length > MAX_LENGTH) {
                    truncatedDescription = truncatedDescription.substr(0, MAX_LENGTH - 3) + '...';
                }
                buffer += ` (${truncatedDescription})`;
            }
            buffer += os.EOL + indent + `       ${errorDetail.message}`;
            if (errorDetail.inner) {
                buffer = JsonSchema._formatErrorDetailsHelper(errorDetail.inner, indent + '  ', buffer);
            }
        }
        return buffer;
    }
    /**
     * Returns a short name for this schema, for use in error messages.
     * @remarks
     * If the schema was loaded from a file, then the base filename is used.  Otherwise, the "id"
     * field is used if available.
     */
    get shortName() {
        if (!this._filename) {
            if (this._schemaObject) {
                const schemaWithId = this._schemaObject;
                if (schemaWithId.id) {
                    return schemaWithId.id;
                }
            }
            return '(anonymous schema)';
        }
        else {
            return path.basename(this._filename);
        }
    }
    /**
     * If not already done, this loads the schema from disk and compiles it.
     * @remarks
     * Any dependencies will be compiled as well.
     */
    ensureCompiled() {
        this._ensureLoaded();
        if (!this._validator) {
            // Don't assign this to _validator until we're sure everything was successful
            const newValidator = new Validator({
                breakOnFirstError: false,
                noTypeless: true,
                noExtraKeywords: true
            });
            const anythingSchema = {
                type: ['array', 'boolean', 'integer', 'number', 'object', 'string']
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            newValidator.setRemoteReference('http://json-schema.org/draft-04/schema', anythingSchema);
            const collectedSchemas = [];
            const seenObjects = new Set();
            const seenIds = new Set();
            JsonSchema._collectDependentSchemas(collectedSchemas, this._dependentSchemas, seenObjects, seenIds);
            // Validate each schema in order.  We specifically do not supply them all together, because we want
            // to make sure that circular references will fail to validate.
            for (const collectedSchema of collectedSchemas) {
                if (!newValidator.validateSchema(collectedSchema._schemaObject)) {
                    throw new Error(`Failed to validate schema "${collectedSchema.shortName}":` +
                        os.EOL +
                        JsonSchema._formatErrorDetails(newValidator.getLastErrors()));
                }
            }
            this._validator = newValidator;
        }
    }
    /**
     * Validates the specified JSON object against this JSON schema.  If the validation fails,
     * an exception will be thrown.
     * @param jsonObject - The JSON data to be validated
     * @param filenameForErrors - The filename that the JSON data was available, or an empty string
     *    if not applicable
     * @param options - Other options that control the validation
     */
    validateObject(jsonObject, filenameForErrors, options) {
        this.validateObjectWithCallback(jsonObject, (errorInfo) => {
            const prefix = options && options.customErrorHeader ? options.customErrorHeader : 'JSON validation failed:';
            throw new Error(prefix + os.EOL + filenameForErrors + os.EOL + errorInfo.details);
        });
    }
    /**
     * Validates the specified JSON object against this JSON schema.  If the validation fails,
     * a callback is called for each validation error.
     */
    validateObjectWithCallback(jsonObject, errorCallback) {
        this.ensureCompiled();
        if (!this._validator.validate(jsonObject, this._schemaObject)) {
            const errorDetails = JsonSchema._formatErrorDetails(this._validator.getLastErrors());
            const args = {
                details: errorDetails
            };
            errorCallback(args);
        }
    }
    _ensureLoaded() {
        if (!this._schemaObject) {
            this._schemaObject = JsonFile_1.JsonFile.load(this._filename);
        }
        return this._schemaObject.id || '';
    }
}
exports.JsonSchema = JsonSchema;
//# sourceMappingURL=JsonSchema.js.map

/***/ }),

/***/ 4996:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LegacyAdapters = void 0;
const timsort_1 = __webpack_require__(46655);
const semver = __importStar(__webpack_require__(11383));
/**
 * Helper functions used when interacting with APIs that do not follow modern coding practices.
 * @public
 */
class LegacyAdapters {
    static convertCallbackToPromise(fn, arg1, arg2, arg3, arg4) {
        return new Promise((resolve, reject) => {
            const cb = (error, result) => {
                if (error) {
                    reject(LegacyAdapters.scrubError(error));
                }
                else {
                    resolve(result);
                }
            };
            try {
                if (arg1 !== undefined && arg2 !== undefined && arg3 !== undefined && arg4 !== undefined) {
                    fn(arg1, arg2, arg3, arg4, cb);
                }
                else if (arg1 !== undefined && arg2 !== undefined && arg3 !== undefined) {
                    fn(arg1, arg2, arg3, cb);
                }
                else if (arg1 !== undefined && arg2 !== undefined) {
                    fn(arg1, arg2, cb);
                }
                else if (arg1 !== undefined) {
                    fn(arg1, cb);
                }
                else {
                    fn(cb);
                }
            }
            catch (e) {
                reject(e);
            }
        });
    }
    /**
     * Normalizes an object into an `Error` object.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static scrubError(error) {
        if (error instanceof Error) {
            return error;
        }
        else if (typeof error === 'string') {
            return new Error(error);
        }
        else {
            const errorObject = new Error('An error occurred.');
            errorObject.errorData = error; // eslint-disable-line @typescript-eslint/no-explicit-any
            return errorObject;
        }
    }
    /**
     * Prior to Node 11.x, the `Array.sort()` algorithm is not guaranteed to be stable.
     * If you need a stable sort, you can use `sortStable()` as a workaround.
     *
     * @remarks
     * On NodeJS 11.x and later, this method simply calls the native `Array.sort()`.
     * For earlier versions, it uses an implementation of Timsort, which is the same algorithm used by modern NodeJS.
     */
    static sortStable(array, compare) {
        if (LegacyAdapters._useTimsort === undefined) {
            LegacyAdapters._useTimsort = semver.major(process.versions.node) < 11;
        }
        if (LegacyAdapters._useTimsort) {
            (0, timsort_1.sort)(array, compare);
        }
        else {
            Array.prototype.sort.call(array, compare);
        }
    }
}
exports.LegacyAdapters = LegacyAdapters;
LegacyAdapters._useTimsort = undefined;
//# sourceMappingURL=LegacyAdapters.js.map

/***/ }),

/***/ 51977:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LockFile = exports.getProcessStartTime = exports.getProcessStartTimeFromProcStat = void 0;
const path = __importStar(__webpack_require__(85622));
const child_process = __importStar(__webpack_require__(63129));
const FileSystem_1 = __webpack_require__(25271);
const FileWriter_1 = __webpack_require__(61053);
const Async_1 = __webpack_require__(6965);
/**
 * http://man7.org/linux/man-pages/man5/proc.5.html
 * (22) starttime  %llu
 * The time the process started after system boot. In kernels before Linux 2.6, this value was
 * expressed in jiffies. Since Linux 2.6, the value is expressed in clock ticks (divide by
 * sysconf(_SC_CLK_TCK)).
 * The format for this field was %lu before Linux 2.6.
 */
const procStatStartTimePos = 22;
/**
 * Parses the process start time from the contents of a linux /proc/[pid]/stat file.
 * @param stat - The contents of a linux /proc/[pid]/stat file.
 * @returns The process start time in jiffies, or undefined if stat has an unexpected format.
 */
function getProcessStartTimeFromProcStat(stat) {
    // Parse the value at position procStatStartTimePos.
    // We cannot just split stat on spaces, because value 2 may contain spaces.
    // For example, when running the following Shell commands:
    // > cp "$(which bash)" ./'bash 2)('
    // > ./'bash 2)(' -c 'OWNPID=$BASHPID;cat /proc/$OWNPID/stat'
    // 59389 (bash 2)() S 59358 59389 59358 34818 59389 4202496 329 0 0 0 0 0 0 0 20 0 1 0
    // > rm -rf ./'bash 2)('
    // The output shows a stat file such that value 2 contains spaces.
    // To still umambiguously parse such output we assume no values after the second ends with a right parenthesis...
    // trimRight to remove the trailing line terminator.
    let values = stat.trimRight().split(' ');
    let i = values.length - 1;
    while (i >= 0 &&
        // charAt returns an empty string if the index is out of bounds.
        values[i].charAt(values[i].length - 1) !== ')') {
        i -= 1;
    }
    // i is the index of the last part of the second value (but i need not be 1).
    if (i < 1) {
        // Format of stat has changed.
        return undefined;
    }
    const value2 = values.slice(1, i + 1).join(' ');
    values = [values[0], value2].concat(values.slice(i + 1));
    if (values.length < procStatStartTimePos) {
        // Older version of linux, or non-standard configuration of linux.
        return undefined;
    }
    const startTimeJiffies = values[procStatStartTimePos - 1];
    // In theory, the representations of start time returned by `cat /proc/[pid]/stat` and `ps -o lstart` can change
    // while the system is running, but we assume this does not happen.
    // So the caller can safely use this value as part of a unique process id (on the machine, without comparing
    // accross reboots).
    return startTimeJiffies;
}
exports.getProcessStartTimeFromProcStat = getProcessStartTimeFromProcStat;
/**
 * Helper function that is exported for unit tests only.
 * Returns undefined if the process doesn't exist with that pid.
 */
function getProcessStartTime(pid) {
    const pidString = pid.toString();
    if (pid < 0 || pidString.indexOf('e') >= 0 || pidString.indexOf('E') >= 0) {
        throw new Error(`"pid" is negative or too large`);
    }
    let args;
    if (process.platform === 'darwin') {
        args = [`-p ${pidString}`, '-o lstart'];
    }
    else if (process.platform === 'linux') {
        args = ['-p', pidString, '-o', 'lstart'];
    }
    else {
        throw new Error(`Unsupported system: ${process.platform}`);
    }
    const psResult = child_process.spawnSync('ps', args, {
        encoding: 'utf8'
    });
    const psStdout = psResult.stdout;
    // If no process with PID pid exists then the exit code is non-zero on linux but stdout is not empty.
    // But if no process exists we do not want to fall back on /proc/*/stat to determine the process
    // start time, so we we additionally test for !psStdout. NOTE: !psStdout evaluates to true if
    // zero bytes are written to stdout.
    if (psResult.status !== 0 && !psStdout && process.platform === 'linux') {
        // Try to read /proc/[pid]/stat and get the value at position procStatStartTimePos.
        let stat;
        try {
            stat = FileSystem_1.FileSystem.readFile(`/proc/${pidString}/stat`);
        }
        catch (error) {
            if (error.code !== 'ENOENT') {
                throw error;
            }
            // Either no process with PID pid exists, or this version/configuration of linux is non-standard.
            // We assume the former.
            return undefined;
        }
        if (stat !== undefined) {
            const startTimeJiffies = getProcessStartTimeFromProcStat(stat);
            if (startTimeJiffies === undefined) {
                throw new Error(`Could not retrieve the start time of process ${pidString} from the OS because the ` +
                    `contents of /proc/${pidString}/stat have an unexpected format`);
            }
            return startTimeJiffies;
        }
    }
    // there was an error executing ps (zero bytes were written to stdout).
    if (!psStdout) {
        throw new Error(`Unexpected output from "ps" command`);
    }
    const psSplit = psStdout.split('\n');
    // successfuly able to run "ps", but no process was found
    if (psSplit[1] === '') {
        return undefined;
    }
    if (psSplit[1]) {
        const trimmed = psSplit[1].trim();
        if (trimmed.length > 10) {
            return trimmed;
        }
    }
    throw new Error(`Unexpected output from the "ps" command`);
}
exports.getProcessStartTime = getProcessStartTime;
/**
 * The `LockFile` implements a file-based mutex for synchronizing access to a shared resource
 * between multiple Node.js processes.  It is not recommended for synchronization solely within
 * a single Node.js process.
 * @remarks
 * The implementation works on Windows, Mac, and Linux without requiring any native helpers.
 * On non-Windows systems, the algorithm requires access to the `ps` shell command.  On Linux,
 * it requires access the `/proc/${pidString}/stat` filesystem.
 * @public
 */
class LockFile {
    constructor(fileWriter, filePath, dirtyWhenAcquired) {
        this._fileWriter = fileWriter;
        this._filePath = filePath;
        this._dirtyWhenAcquired = dirtyWhenAcquired;
    }
    /**
     * Returns the path of the lockfile that will be created when a lock is successfully acquired.
     * @param resourceFolder - The folder where the lock file will be created
     * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
     *   the filename of the temporary file created to manage the lock.
     * @param pid - The PID for the current Node.js process (`process.pid`), which is used by the locking algorithm.
     */
    static getLockFilePath(resourceFolder, resourceName, pid = process.pid) {
        if (!resourceName.match(/^[a-zA-Z0-9][a-zA-Z0-9-.]+[a-zA-Z0-9]$/)) {
            throw new Error(`The resource name "${resourceName}" is invalid.` +
                ` It must be an alphanumberic string with only "-" or "." It must start with an alphanumeric character.`);
        }
        if (process.platform === 'win32') {
            return path.join(path.resolve(resourceFolder), `${resourceName}.lock`);
        }
        else if (process.platform === 'linux' || process.platform === 'darwin') {
            return path.join(path.resolve(resourceFolder), `${resourceName}#${pid}.lock`);
        }
        throw new Error(`File locking not implemented for platform: "${process.platform}"`);
    }
    /**
     * Attempts to create a lockfile with the given filePath.
     * @param resourceFolder - The folder where the lock file will be created
     * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
     *   the filename of the temporary file created to manage the lock.
     * @returns If successful, returns a `LockFile` instance.  If unable to get a lock, returns `undefined`.
     */
    static tryAcquire(resourceFolder, resourceName) {
        FileSystem_1.FileSystem.ensureFolder(resourceFolder);
        if (process.platform === 'win32') {
            return LockFile._tryAcquireWindows(resourceFolder, resourceName);
        }
        else if (process.platform === 'linux' || process.platform === 'darwin') {
            return LockFile._tryAcquireMacOrLinux(resourceFolder, resourceName);
        }
        throw new Error(`File locking not implemented for platform: "${process.platform}"`);
    }
    /**
     * Attempts to create the lockfile.  Will continue to loop at every 100ms until the lock becomes available
     * or the maxWaitMs is surpassed.
     *
     * @remarks
     * This function is subject to starvation, whereby it does not ensure that the process that has been
     * waiting the longest to acquire the lock will get it first. This means that a process could theoretically
     * wait for the lock forever, while other processes skipped it in line and acquired the lock first.
     *
     * @param resourceFolder - The folder where the lock file will be created
     * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
     *   the filename of the temporary file created to manage the lock.
     * @param maxWaitMs - The maximum number of milliseconds to wait for the lock before reporting an error
     */
    static acquire(resourceFolder, resourceName, maxWaitMs) {
        const interval = 100;
        const startTime = Date.now();
        const retryLoop = async () => {
            const lock = LockFile.tryAcquire(resourceFolder, resourceName);
            if (lock) {
                return lock;
            }
            if (maxWaitMs && Date.now() > startTime + maxWaitMs) {
                throw new Error(`Exceeded maximum wait time to acquire lock for resource "${resourceName}"`);
            }
            await Async_1.Async.sleep(interval);
            return retryLoop();
        };
        return retryLoop();
    }
    /**
     * Attempts to acquire the lock on a Linux or OSX machine
     */
    static _tryAcquireMacOrLinux(resourceFolder, resourceName) {
        let dirtyWhenAcquired = false;
        // get the current process' pid
        const pid = process.pid;
        const startTime = LockFile._getStartTime(pid);
        if (!startTime) {
            throw new Error(`Unable to calculate start time for current process.`);
        }
        const pidLockFilePath = LockFile.getLockFilePath(resourceFolder, resourceName);
        let lockFileHandle;
        let lockFile;
        try {
            // open in write mode since if this file exists, it cannot be from the current process
            // TODO: This will malfunction if the same process tries to acquire two locks on the same file.
            // We should ideally maintain a dictionary of normalized acquired filenames
            lockFileHandle = FileWriter_1.FileWriter.open(pidLockFilePath);
            lockFileHandle.write(startTime);
            const currentBirthTimeMs = FileSystem_1.FileSystem.getStatistics(pidLockFilePath).birthtime.getTime();
            let smallestBirthTimeMs = currentBirthTimeMs;
            let smallestBirthTimePid = pid.toString();
            // now, scan the directory for all lockfiles
            const files = FileSystem_1.FileSystem.readFolder(resourceFolder);
            // look for anything ending with # then numbers and ".lock"
            const lockFileRegExp = /^(.+)#([0-9]+)\.lock$/;
            let match;
            let otherPid;
            for (const fileInFolder of files) {
                if ((match = fileInFolder.match(lockFileRegExp)) &&
                    match[1] === resourceName &&
                    (otherPid = match[2]) !== pid.toString()) {
                    // we found at least one lockfile hanging around that isn't ours
                    const fileInFolderPath = path.join(resourceFolder, fileInFolder);
                    dirtyWhenAcquired = true;
                    // console.log(`FOUND OTHER LOCKFILE: ${otherPid}`);
                    const otherPidCurrentStartTime = LockFile._getStartTime(parseInt(otherPid, 10));
                    let otherPidOldStartTime;
                    let otherBirthtimeMs;
                    try {
                        otherPidOldStartTime = FileSystem_1.FileSystem.readFile(fileInFolderPath);
                        // check the timestamp of the file
                        otherBirthtimeMs = FileSystem_1.FileSystem.getStatistics(fileInFolderPath).birthtime.getTime();
                    }
                    catch (err) {
                        // this means the file is probably deleted already
                    }
                    // if the otherPidOldStartTime is invalid, then we should look at the timestamp,
                    // if this file was created after us, ignore it
                    // if it was created within 1 second before us, then it could be good, so we
                    //  will conservatively fail
                    // otherwise it is an old lock file and will be deleted
                    if (otherPidOldStartTime === '' && otherBirthtimeMs !== undefined) {
                        if (otherBirthtimeMs > currentBirthTimeMs) {
                            // ignore this file, he will be unable to get the lock since this process
                            // will hold it
                            // console.log(`Ignoring lock for pid ${otherPid} because its lockfile is newer than ours.`);
                            continue;
                        }
                        else if (otherBirthtimeMs - currentBirthTimeMs < 0 && // it was created before us AND
                            otherBirthtimeMs - currentBirthTimeMs > -1000) {
                            // it was created less than a second before
                            // conservatively be unable to keep the lock
                            return undefined;
                        }
                    }
                    // console.log(`Other pid ${otherPid} lockfile has start time: "${otherPidOldStartTime}"`);
                    // console.log(`Other pid ${otherPid} actually has start time: "${otherPidCurrentStartTime}"`);
                    // this means the process is no longer executing, delete the file
                    if (!otherPidCurrentStartTime || otherPidOldStartTime !== otherPidCurrentStartTime) {
                        // console.log(`Other pid ${otherPid} is no longer executing!`);
                        FileSystem_1.FileSystem.deleteFile(fileInFolderPath);
                        continue;
                    }
                    // console.log(`Pid ${otherPid} lockfile has birth time: ${otherBirthtimeMs}`);
                    // console.log(`Pid ${pid} lockfile has birth time: ${currentBirthTimeMs}`);
                    // this is a lockfile pointing at something valid
                    if (otherBirthtimeMs !== undefined && otherBirthtimeMs < smallestBirthTimeMs) {
                        smallestBirthTimeMs = otherBirthtimeMs;
                        smallestBirthTimePid = otherPid;
                    }
                }
            }
            if (smallestBirthTimePid !== pid.toString()) {
                // we do not have the lock
                return undefined;
            }
            // we have the lock!
            lockFile = new LockFile(lockFileHandle, pidLockFilePath, dirtyWhenAcquired);
            lockFileHandle = undefined; // we have handed the descriptor off to the instance
        }
        finally {
            if (lockFileHandle) {
                // ensure our lock is closed
                lockFileHandle.close();
                FileSystem_1.FileSystem.deleteFile(pidLockFilePath);
            }
        }
        return lockFile;
    }
    /**
     * Attempts to acquire the lock using Windows
     * This algorithm is much simpler since we can rely on the operating system
     */
    static _tryAcquireWindows(resourceFolder, resourceName) {
        const lockFilePath = LockFile.getLockFilePath(resourceFolder, resourceName);
        let dirtyWhenAcquired = false;
        let fileHandle;
        let lockFile;
        try {
            if (FileSystem_1.FileSystem.exists(lockFilePath)) {
                dirtyWhenAcquired = true;
                // If the lockfile is held by an process with an exclusive lock, then removing it will
                // silently fail. OpenSync() below will then fail and we will be unable to create a lock.
                // Otherwise, the lockfile is sitting on disk, but nothing is holding it, implying that
                // the last process to hold it died.
                FileSystem_1.FileSystem.deleteFile(lockFilePath);
            }
            try {
                // Attempt to open an exclusive lockfile
                fileHandle = FileWriter_1.FileWriter.open(lockFilePath, { exclusive: true });
            }
            catch (error) {
                // we tried to delete the lock, but something else is holding it,
                // (probably an active process), therefore we are unable to create a lock
                return undefined;
            }
            // Ensure we can hand off the file descriptor to the lockfile
            lockFile = new LockFile(fileHandle, lockFilePath, dirtyWhenAcquired);
            fileHandle = undefined;
        }
        finally {
            if (fileHandle) {
                fileHandle.close();
            }
        }
        return lockFile;
    }
    /**
     * Unlocks a file and removes it from disk.
     * This can only be called once.
     */
    release() {
        if (this.isReleased) {
            throw new Error(`The lock for file "${path.basename(this._filePath)}" has already been released.`);
        }
        this._fileWriter.close();
        FileSystem_1.FileSystem.deleteFile(this._filePath);
        this._fileWriter = undefined;
    }
    /**
     * Returns the initial state of the lock.
     * This can be used to detect if the previous process was terminated before releasing the resource.
     */
    get dirtyWhenAcquired() {
        return this._dirtyWhenAcquired;
    }
    /**
     * Returns the absolute path to the lockfile
     */
    get filePath() {
        return this._filePath;
    }
    /**
     * Returns true if this lock is currently being held.
     */
    get isReleased() {
        return this._fileWriter === undefined;
    }
}
exports.LockFile = LockFile;
LockFile._getStartTime = getProcessStartTime;
//# sourceMappingURL=LockFile.js.map

/***/ }),

/***/ 82565:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapExtensions = void 0;
/**
 * Helper functions for working with the `Map<K, V>` data type.
 *
 * @public
 */
class MapExtensions {
    /**
     * Adds all the (key, value) pairs from the source map into the target map.
     * @remarks
     * This function modifies targetMap.  Any existing keys will be overwritten.
     * @param targetMap - The map that entries will be added to
     * @param sourceMap - The map containing the entries to be added
     */
    static mergeFromMap(targetMap, sourceMap) {
        for (const pair of sourceMap.entries()) {
            targetMap.set(pair[0], pair[1]);
        }
    }
    /**
     * Converts a string-keyed map to an object.
     * @remarks
     * This function has the same effect as Object.fromEntries(map.entries())
     * in supported versions of Node (\>= 12.0.0).
     * @param map - The map that the object properties will be sourced from
     */
    static toObject(map) {
        const object = {};
        for (const [key, value] of map.entries()) {
            object[key] = value;
        }
        return object;
    }
}
exports.MapExtensions = MapExtensions;
//# sourceMappingURL=MapExtensions.js.map

/***/ }),

/***/ 17805:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageJsonLookup = void 0;
const path = __importStar(__webpack_require__(85622));
const JsonFile_1 = __webpack_require__(20785);
const FileSystem_1 = __webpack_require__(25271);
/**
 * This class provides methods for finding the nearest "package.json" for a folder
 * and retrieving the name of the package.  The results are cached.
 *
 * @public
 */
class PackageJsonLookup {
    constructor(parameters) {
        this._loadExtraFields = false;
        if (parameters) {
            if (parameters.loadExtraFields) {
                this._loadExtraFields = parameters.loadExtraFields;
            }
        }
        this.clearCache();
    }
    /**
     * A singleton instance of `PackageJsonLookup`, which is useful for short-lived processes
     * that can reasonably assume that the file system will not be modified after the cache
     * is populated.
     *
     * @remarks
     * For long-running processes that need to clear the cache at appropriate times,
     * it is recommended to create your own instance of `PackageJsonLookup` instead
     * of relying on this instance.
     */
    static get instance() {
        if (!PackageJsonLookup._instance) {
            PackageJsonLookup._instance = new PackageJsonLookup({ loadExtraFields: true });
        }
        return PackageJsonLookup._instance;
    }
    /**
     * A helper for loading the caller's own package.json file.
     *
     * @remarks
     *
     * This function provides a concise and efficient way for an NPM package to report metadata about itself.
     * For example, a tool might want to report its version.
     *
     * The `loadOwnPackageJson()` probes upwards from the caller's folder, expecting to find a package.json file,
     * which is assumed to be the caller's package.  The result is cached, under the assumption that a tool's
     * own package.json (and intermediary folders) will never change during the lifetime of the process.
     *
     * @example
     * ```ts
     * // Report the version of our NPM package
     * const myPackageVersion: string = PackageJsonLookup.loadOwnPackageJson(__dirname).version;
     * console.log(`Cool Tool - Version ${myPackageVersion}`);
     * ```
     *
     * @param dirnameOfCaller - The NodeJS `__dirname` macro for the caller.
     * @returns This function always returns a valid `IPackageJson` object.  If any problems are encountered during
     * loading, an exception will be thrown instead.
     */
    static loadOwnPackageJson(dirnameOfCaller) {
        const packageJson = PackageJsonLookup.instance.tryLoadPackageJsonFor(dirnameOfCaller);
        if (packageJson === undefined) {
            throw new Error(`PackageJsonLookup.loadOwnPackageJson() failed to find the caller's package.json.` +
                `  The __dirname was: ${dirnameOfCaller}`);
        }
        if (packageJson.version !== undefined) {
            return packageJson;
        }
        const errorPath = PackageJsonLookup.instance.tryGetPackageJsonFilePathFor(dirnameOfCaller) || 'package.json';
        throw new Error(`PackageJsonLookup.loadOwnPackageJson() failed because the "version" field is missing in` +
            ` ${errorPath}`);
    }
    /**
     * Clears the internal file cache.
     * @remarks
     * Call this method if changes have been made to the package.json files on disk.
     */
    clearCache() {
        this._packageFolderCache = new Map();
        this._packageJsonCache = new Map();
    }
    /**
     * Returns the absolute path of a folder containing a package.json file, by looking
     * upwards from the specified fileOrFolderPath.  If no package.json can be found,
     * undefined is returned.
     *
     * @remarks
     * The fileOrFolderPath is not required to actually exist on disk.
     * The fileOrFolderPath itself can be the return value, if it is a folder containing
     * a package.json file.
     * Both positive and negative lookup results are cached.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an absolute path to a folder containing a package.json file
     */
    tryGetPackageFolderFor(fileOrFolderPath) {
        // Convert it to an absolute path
        const resolvedFileOrFolderPath = path.resolve(fileOrFolderPath);
        // Optimistically hope that the starting string is already in the cache,
        // in which case we can avoid disk access entirely.
        //
        // (Two lookups are required, because get() cannot distinguish the undefined value
        // versus a missing key.)
        if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {
            return this._packageFolderCache.get(resolvedFileOrFolderPath);
        }
        // Now call the recursive part of the algorithm
        return this._tryGetPackageFolderFor(resolvedFileOrFolderPath);
    }
    /**
     * If the specified file or folder is part of a package, this returns the absolute path
     * to the associated package.json file.
     *
     * @remarks
     * The package folder is determined using the same algorithm
     * as {@link PackageJsonLookup.tryGetPackageFolderFor}.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an absolute path to * package.json file
     */
    tryGetPackageJsonFilePathFor(fileOrFolderPath) {
        const packageJsonFolder = this.tryGetPackageFolderFor(fileOrFolderPath);
        if (!packageJsonFolder) {
            return undefined;
        }
        return path.join(packageJsonFolder, "package.json" /* PackageJson */);
    }
    /**
     * If the specified file or folder is part of a package, this loads and returns the
     * associated package.json file.
     *
     * @remarks
     * The package folder is determined using the same algorithm
     * as {@link PackageJsonLookup.tryGetPackageFolderFor}.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an IPackageJson object, or undefined if the fileOrFolderPath does not
     * belong to a package
     */
    tryLoadPackageJsonFor(fileOrFolderPath) {
        const packageJsonFilePath = this.tryGetPackageJsonFilePathFor(fileOrFolderPath);
        if (!packageJsonFilePath) {
            return undefined;
        }
        return this.loadPackageJson(packageJsonFilePath);
    }
    /**
     * This function is similar to {@link PackageJsonLookup.tryLoadPackageJsonFor}, except that it does not report
     * an error if the `version` field is missing from the package.json file.
     */
    tryLoadNodePackageJsonFor(fileOrFolderPath) {
        const packageJsonFilePath = this.tryGetPackageJsonFilePathFor(fileOrFolderPath);
        if (!packageJsonFilePath) {
            return undefined;
        }
        return this.loadNodePackageJson(packageJsonFilePath);
    }
    /**
     * Loads the specified package.json file, if it is not already present in the cache.
     *
     * @remarks
     * Unless {@link IPackageJsonLookupParameters.loadExtraFields} was specified,
     * the returned IPackageJson object will contain a subset of essential fields.
     * The returned object should be considered to be immutable; the caller must never
     * modify it.
     *
     * @param jsonFilename - a relative or absolute path to a package.json file
     */
    loadPackageJson(jsonFilename) {
        const packageJson = this.loadNodePackageJson(jsonFilename);
        if (!packageJson.version) {
            throw new Error(`Error reading "${jsonFilename}":\n  The required field "version" was not found`);
        }
        return packageJson;
    }
    /**
     * This function is similar to {@link PackageJsonLookup.loadPackageJson}, except that it does not report an error
     * if the `version` field is missing from the package.json file.
     */
    loadNodePackageJson(jsonFilename) {
        if (!FileSystem_1.FileSystem.exists(jsonFilename)) {
            throw new Error(`Input file not found: ${jsonFilename}`);
        }
        // Since this will be a cache key, follow any symlinks and get an absolute path
        // to minimize duplication.  (Note that duplication can still occur due to e.g. character case.)
        const normalizedFilePath = FileSystem_1.FileSystem.getRealPath(jsonFilename);
        let packageJson = this._packageJsonCache.get(normalizedFilePath);
        if (!packageJson) {
            const loadedPackageJson = JsonFile_1.JsonFile.load(normalizedFilePath);
            // Make sure this is really a package.json file.  CommonJS has fairly strict requirements,
            // but NPM only requires "name" and "version"
            if (!loadedPackageJson.name) {
                throw new Error(`Error reading "${jsonFilename}":\n  The required field "name" was not found`);
            }
            if (this._loadExtraFields) {
                packageJson = loadedPackageJson;
            }
            else {
                packageJson = {};
                // Unless "loadExtraFields" was requested, copy over the essential fields only
                packageJson.bin = loadedPackageJson.bin;
                packageJson.dependencies = loadedPackageJson.dependencies;
                packageJson.description = loadedPackageJson.description;
                packageJson.devDependencies = loadedPackageJson.devDependencies;
                packageJson.homepage = loadedPackageJson.homepage;
                packageJson.license = loadedPackageJson.license;
                packageJson.main = loadedPackageJson.main;
                packageJson.name = loadedPackageJson.name;
                packageJson.optionalDependencies = loadedPackageJson.optionalDependencies;
                packageJson.peerDependencies = loadedPackageJson.peerDependencies;
                packageJson.private = loadedPackageJson.private;
                packageJson.scripts = loadedPackageJson.scripts;
                packageJson.typings = loadedPackageJson.typings || loadedPackageJson.types;
                packageJson.tsdocMetadata = loadedPackageJson.tsdocMetadata;
                packageJson.version = loadedPackageJson.version;
            }
            Object.freeze(packageJson);
            this._packageJsonCache.set(normalizedFilePath, packageJson);
        }
        return packageJson;
    }
    // Recursive part of the algorithm from tryGetPackageFolderFor()
    _tryGetPackageFolderFor(resolvedFileOrFolderPath) {
        // Two lookups are required, because get() cannot distinguish the undefined value
        // versus a missing key.
        if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {
            return this._packageFolderCache.get(resolvedFileOrFolderPath);
        }
        // Is resolvedFileOrFolderPath itself a folder with a package.json file?  If so, return it.
        if (FileSystem_1.FileSystem.exists(path.join(resolvedFileOrFolderPath, "package.json" /* PackageJson */))) {
            this._packageFolderCache.set(resolvedFileOrFolderPath, resolvedFileOrFolderPath);
            return resolvedFileOrFolderPath;
        }
        // Otherwise go up one level
        const parentFolder = path.dirname(resolvedFileOrFolderPath);
        if (!parentFolder || parentFolder === resolvedFileOrFolderPath) {
            // We reached the root directory without finding a package.json file,
            // so cache the negative result
            this._packageFolderCache.set(resolvedFileOrFolderPath, undefined);
            return undefined; // no match
        }
        // Recurse upwards, caching every step along the way
        const parentResult = this._tryGetPackageFolderFor(parentFolder);
        // Cache the parent's answer as well
        this._packageFolderCache.set(resolvedFileOrFolderPath, parentResult);
        return parentResult;
    }
}
exports.PackageJsonLookup = PackageJsonLookup;
//# sourceMappingURL=PackageJsonLookup.js.map

/***/ }),

/***/ 50111:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageName = exports.PackageNameParser = void 0;
/**
 * A configurable parser for validating and manipulating NPM package names such as `my-package` or `@scope/my-package`.
 *
 * @remarks
 * If you do not need to customize the parser configuration, it is recommended to use {@link PackageName}
 * which exposes these operations as a simple static class.
 *
 * @public
 */
class PackageNameParser {
    constructor(options = {}) {
        this._options = Object.assign({}, options);
    }
    /**
     * This attempts to parse a package name that may include a scope component.
     * The packageName must not be an empty string.
     * @remarks
     * This function will not throw an exception.
     *
     * @returns an {@link IParsedPackageNameOrError} structure whose `error` property will be
     * nonempty if the string could not be parsed.
     */
    tryParse(packageName) {
        const result = {
            scope: '',
            unscopedName: '',
            error: ''
        };
        let input = packageName;
        if (input === null || input === undefined) {
            result.error = 'The package name must not be null or undefined';
            return result;
        }
        // Rule from npmjs.com:
        // "The name must be less than or equal to 214 characters. This includes the scope for scoped packages."
        if (packageName.length > 214) {
            // Don't attempt to parse a ridiculously long input
            result.error = 'The package name cannot be longer than 214 characters';
            return result;
        }
        if (input[0] === '@') {
            const indexOfScopeSlash = input.indexOf('/');
            if (indexOfScopeSlash <= 0) {
                result.scope = input;
                result.error = `Error parsing "${packageName}": The scope must be followed by a slash`;
                return result;
            }
            // Extract the scope substring
            result.scope = input.substr(0, indexOfScopeSlash);
            input = input.substr(indexOfScopeSlash + 1);
        }
        result.unscopedName = input;
        if (result.scope === '@') {
            result.error = `Error parsing "${packageName}": The scope name cannot be empty`;
            return result;
        }
        if (result.unscopedName === '') {
            result.error = 'The package name must not be empty';
            return result;
        }
        // Rule from npmjs.com:
        // "The name can't start with a dot or an underscore."
        if (result.unscopedName[0] === '.' || result.unscopedName[0] === '_') {
            result.error = `The package name "${packageName}" starts with an invalid character`;
            return result;
        }
        // Convert "@scope/unscoped-name" --> "scopeunscoped-name"
        const nameWithoutScopeSymbols = (result.scope ? result.scope.slice(1, -1) : '') + result.unscopedName;
        if (!this._options.allowUpperCase) {
            // "New packages must not have uppercase letters in the name."
            // This can't be enforced because "old" packages are still actively maintained.
            // Example: https://www.npmjs.com/package/Base64
            // However it's pretty reasonable to require the scope to be lower case
            if (result.scope !== result.scope.toLowerCase()) {
                result.error = `The package scope "${result.scope}" must not contain upper case characters`;
                return result;
            }
        }
        // "The name ends up being part of a URL, an argument on the command line, and a folder name.
        // Therefore, the name can't contain any non-URL-safe characters"
        const match = nameWithoutScopeSymbols.match(PackageNameParser._invalidNameCharactersRegExp);
        if (match) {
            result.error = `The package name "${packageName}" contains an invalid character: "${match[0]}"`;
            return result;
        }
        return result;
    }
    /**
     * Same as {@link PackageName.tryParse}, except this throws an exception if the input
     * cannot be parsed.
     * @remarks
     * The packageName must not be an empty string.
     */
    parse(packageName) {
        const result = this.tryParse(packageName);
        if (result.error) {
            throw new Error(result.error);
        }
        return result;
    }
    /**
     * {@inheritDoc IParsedPackageName.scope}
     */
    getScope(packageName) {
        return this.parse(packageName).scope;
    }
    /**
     * {@inheritDoc IParsedPackageName.unscopedName}
     */
    getUnscopedName(packageName) {
        return this.parse(packageName).unscopedName;
    }
    /**
     * Returns true if the specified package name is valid, or false otherwise.
     * @remarks
     * This function will not throw an exception.
     */
    isValidName(packageName) {
        const result = this.tryParse(packageName);
        return !result.error;
    }
    /**
     * Throws an exception if the specified name is not a valid package name.
     * The packageName must not be an empty string.
     */
    validate(packageName) {
        this.parse(packageName);
    }
    /**
     * Combines an optional package scope with an unscoped root name.
     * @param scope - Must be either an empty string, or a scope name such as "\@example"
     * @param unscopedName - Must be a nonempty package name that does not contain a scope
     * @returns A full package name such as "\@example/some-library".
     */
    combineParts(scope, unscopedName) {
        if (scope !== '') {
            if (scope[0] !== '@') {
                throw new Error('The scope must start with an "@" character');
            }
        }
        if (scope.indexOf('/') >= 0) {
            throw new Error('The scope must not contain a "/" character');
        }
        if (unscopedName[0] === '@') {
            throw new Error('The unscopedName cannot start with an "@" character');
        }
        if (unscopedName.indexOf('/') >= 0) {
            throw new Error('The unscopedName must not contain a "/" character');
        }
        let result;
        if (scope === '') {
            result = unscopedName;
        }
        else {
            result = scope + '/' + unscopedName;
        }
        // Make sure the result is a valid package name
        this.validate(result);
        return result;
    }
}
exports.PackageNameParser = PackageNameParser;
// encodeURIComponent() escapes all characters except:  A-Z a-z 0-9 - _ . ! ~ * ' ( )
// However, these are disallowed because they are shell characters:       ! ~ * ' ( )
PackageNameParser._invalidNameCharactersRegExp = /[^A-Za-z0-9\-_\.]/;
/**
 * Provides basic operations for validating and manipulating NPM package names such as `my-package`
 * or `@scope/my-package`.
 *
 * @remarks
 * This is the default implementation of {@link PackageNameParser}, exposed as a convenient static class.
 * If you need to configure the parsing rules, use `PackageNameParser` instead.
 *
 * @public
 */
class PackageName {
    /** {@inheritDoc PackageNameParser.tryParse} */
    static tryParse(packageName) {
        return PackageName._parser.tryParse(packageName);
    }
    /** {@inheritDoc PackageNameParser.parse} */
    static parse(packageName) {
        return this._parser.parse(packageName);
    }
    /** {@inheritDoc PackageNameParser.getScope} */
    static getScope(packageName) {
        return this._parser.getScope(packageName);
    }
    /** {@inheritDoc PackageNameParser.getUnscopedName} */
    static getUnscopedName(packageName) {
        return this._parser.getUnscopedName(packageName);
    }
    /** {@inheritDoc PackageNameParser.isValidName} */
    static isValidName(packageName) {
        return this._parser.isValidName(packageName);
    }
    /** {@inheritDoc PackageNameParser.validate} */
    static validate(packageName) {
        return this._parser.validate(packageName);
    }
    /** {@inheritDoc PackageNameParser.combineParts} */
    static combineParts(scope, unscopedName) {
        return this._parser.combineParts(scope, unscopedName);
    }
}
exports.PackageName = PackageName;
PackageName._parser = new PackageNameParser();
//# sourceMappingURL=PackageName.js.map

/***/ }),

/***/ 80953:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Path = void 0;
const path = __importStar(__webpack_require__(85622));
const Text_1 = __webpack_require__(44756);
/**
 * Common operations for manipulating file and directory paths.
 * @remarks
 * This API is intended to eventually be a complete replacement for the NodeJS "path" API.
 * @public
 */
class Path {
    /**
     * Returns true if "childPath" is located inside the "parentFolderPath" folder
     * or one of its child folders.  Note that "parentFolderPath" is not considered to be
     * under itself.  The "childPath" can refer to any type of file system object.
     *
     * @remarks
     * The indicated file/folder objects are not required to actually exist on disk.
     * For example, "parentFolderPath" is interpreted as a folder name even if it refers to a file.
     * If the paths are relative, they will first be resolved using path.resolve().
     */
    static isUnder(childPath, parentFolderPath) {
        // If childPath is under parentPath, then relativePath will be something like
        // "../.." or "..\\..", which consists entirely of periods and slashes.
        // (Note that something like "....t" is actually a valid filename, but "...." is not.)
        const relativePath = path.relative(childPath, parentFolderPath);
        return Path._relativePathRegex.test(relativePath);
    }
    /**
     * Returns true if "childPath" is equal to "parentFolderPath", or if it is inside that folder
     * or one of its children.  The "childPath" can refer to any type of file system object.
     *
     * @remarks
     * The indicated file/folder objects are not required to actually exist on disk.
     * For example, "parentFolderPath" is interpreted as a folder name even if it refers to a file.
     * If the paths are relative, they will first be resolved using path.resolve().
     */
    static isUnderOrEqual(childPath, parentFolderPath) {
        const relativePath = path.relative(childPath, parentFolderPath);
        return relativePath === '' || Path._relativePathRegex.test(relativePath);
    }
    /**
     * Returns true if `path1` and `path2` refer to the same underlying path.
     *
     * @remarks
     *
     * The comparison is performed using `path.relative()`.
     */
    static isEqual(path1, path2) {
        return path.relative(path1, path2) === '';
    }
    /**
     * Formats a path to look nice for reporting purposes.
     * @remarks
     * If `pathToConvert` is under the `baseFolder`, then it will be converted to a relative with the `./` prefix.
     * Otherwise, it will be converted to an absolute path.
     *
     * Backslashes will be converted to slashes, unless the path starts with an OS-specific string like `C:\`.
     */
    static formatConcisely(options) {
        // Same logic as Path.isUnderOrEqual()
        const relativePath = path.relative(options.pathToConvert, options.baseFolder);
        const isUnderOrEqual = relativePath === '' || Path._relativePathRegex.test(relativePath);
        if (isUnderOrEqual) {
            // Note that isUnderOrEqual()'s relativePath is the reverse direction
            return './' + Path.convertToSlashes(path.relative(options.baseFolder, options.pathToConvert));
        }
        const absolutePath = path.resolve(options.pathToConvert);
        return absolutePath;
    }
    /**
     * Replaces Windows-style backslashes with POSIX-style slashes.
     *
     * @remarks
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    static convertToSlashes(inputPath) {
        return Text_1.Text.replaceAll(inputPath, '\\', '/');
    }
    /**
     * Replaces POSIX-style slashes with Windows-style backslashes
     *
     * @remarks
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    static convertToBackslashes(inputPath) {
        return Text_1.Text.replaceAll(inputPath, '/', '\\');
    }
    /**
     * Returns true if the specified path is a relative path and does not use `..` to walk upwards.
     *
     * @example
     * ```ts
     * // These evaluate to true
     * isDownwardRelative('folder');
     * isDownwardRelative('file');
     * isDownwardRelative('folder/');
     * isDownwardRelative('./folder/');
     * isDownwardRelative('./folder/file');
     *
     * // These evaluate to false
     * isDownwardRelative('../folder');
     * isDownwardRelative('folder/../file');
     * isDownwardRelative('/folder/file');
     * ```
     */
    static isDownwardRelative(inputPath) {
        if (path.isAbsolute(inputPath)) {
            return false;
        }
        // Does it contain ".."
        if (Path._upwardPathSegmentRegex.test(inputPath)) {
            return false;
        }
        return true;
    }
}
exports.Path = Path;
// Matches a relative path consisting entirely of periods and slashes
// Example: ".", "..", "../..", etc
Path._relativePathRegex = /^[.\/\\]+$/;
// Matches a relative path segment that traverses upwards
// Example: "a/../b"
Path._upwardPathSegmentRegex = /([\/\\]|^)\.\.([\/\\]|$)/;
//# sourceMappingURL=Path.js.map

/***/ }),

/***/ 76443:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtectableMap = void 0;
const ProtectableMapView_1 = __webpack_require__(68477);
/**
 * The ProtectableMap provides an easy way for an API to expose a `Map<K, V>` property
 * while intercepting and validating any write operations that are performed by
 * consumers of the API.
 *
 * @remarks
 * The ProtectableMap itself is intended to be a private object that only its owner
 * can access directly.  Any operations performed directly on the ProtectableMap will
 * bypass the hooks and any validation they perform.  The public property that is exposed
 * to API consumers should return {@link ProtectableMap.protectedView} instead.
 *
 * For example, suppose you want to share your `Map<string, number>` data structure,
 * but you want to enforce that the key must always be an upper case string:
 * You could use the onSet() hook to validate the keys and throw an exception
 * if the key is not uppercase.
 *
 * @public
 */
class ProtectableMap {
    constructor(parameters) {
        this._protectedView = new ProtectableMapView_1.ProtectableMapView(this, parameters);
    }
    /**
     * The owner of the protectable map should return this object via its public API.
     */
    get protectedView() {
        return this._protectedView;
    }
    // ---------------------------------------------------------------------------
    // lib.es2015.collections contract - write operations
    /**
     * Removes all entries from the map.
     * This operation does NOT invoke the ProtectableMap onClear() hook.
     */
    clear() {
        this._protectedView._clearUnprotected();
    }
    /**
     * Removes the specified key from the map.
     * This operation does NOT invoke the ProtectableMap onDelete() hook.
     */
    delete(key) {
        return this._protectedView._deleteUnprotected(key);
    }
    /**
     * Sets a value for the specified key.
     * This operation does NOT invoke the ProtectableMap onSet() hook.
     */
    set(key, value) {
        this._protectedView._setUnprotected(key, value);
        return this;
    }
    // ---------------------------------------------------------------------------
    // lib.es2015.collections contract - read operations
    /**
     * Performs an operation for each (key, value) entries in the map.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    forEach(callbackfn, thisArg) {
        this._protectedView.forEach(callbackfn);
    }
    /**
     * Retrieves the value for the specified key.
     * @returns undefined if the value is undefined OR if the key is missing;
     * otherwise returns the value associated with the key.
     */
    get(key) {
        return this._protectedView.get(key);
    }
    /**
     * Returns true if the specified key belongs to the map.
     */
    has(key) {
        return this._protectedView.has(key);
    }
    /**
     * Returns the number of (key, value) entries in the map.
     */
    get size() {
        return this._protectedView.size;
    }
}
exports.ProtectableMap = ProtectableMap;
//# sourceMappingURL=ProtectableMap.js.map

/***/ }),

/***/ 68477:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtectableMapView = void 0;
/**
 * The internal wrapper used by ProtectableMap.  It extends the real `Map<K, V>` base class,
 * but hooks the destructive operations (clear/delete/set) to give the owner a chance
 * to block them.
 *
 * NOTE: This is not a public API.
 */
class ProtectableMapView extends Map {
    constructor(owner, parameters) {
        super();
        this._owner = owner;
        this._parameters = parameters;
    }
    clear() {
        // override
        if (this._parameters.onClear) {
            this._parameters.onClear(this._owner);
        }
        super.clear();
    }
    delete(key) {
        // override
        if (this._parameters.onDelete) {
            this._parameters.onDelete(this._owner, key);
        }
        return super.delete(key);
    }
    set(key, value) {
        // override
        let modifiedValue = value;
        if (this._parameters.onSet) {
            modifiedValue = this._parameters.onSet(this._owner, key, modifiedValue);
        }
        super.set(key, modifiedValue);
        return this;
    }
    // INTERNAL USAGE ONLY
    _clearUnprotected() {
        super.clear();
    }
    // INTERNAL USAGE ONLY
    _deleteUnprotected(key) {
        return super.delete(key);
    }
    // INTERNAL USAGE ONLY
    _setUnprotected(key, value) {
        super.set(key, value);
    }
}
exports.ProtectableMapView = ProtectableMapView;
//# sourceMappingURL=ProtectableMapView.js.map

/***/ }),

/***/ 73728:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sort = void 0;
const LegacyAdapters_1 = __webpack_require__(4996);
/**
 * Operations for sorting collections.
 *
 * @remarks
 * NOTE: Prior to Node 11.x, the `Array.sort()` algorithm is not guaranteed to be stable.  For maximum
 * compatibility, consider using {@link LegacyAdapters.sortStable} instead of `Array.sort()`.
 *
 * @public
 */
class Sort {
    /**
     * Compares `x` and `y` using the JavaScript `>` and `<` operators.  This function is suitable for usage as
     * the callback for `array.sort()`.
     *
     * @remarks
     *
     * The JavaScript ordering is generalized so that `undefined` \< `null` \< all other values.
     *
     * @returns -1 if `x` is smaller than `y`, 1 if `x` is greater than `y`, or 0 if the values are equal.
     *
     * @example
     *
     * ```ts
     * let array: number[] = [3, 6, 2];
     * array.sort(Sort.compareByValue);  // [2, 3, 6]
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static compareByValue(x, y) {
        if (x === y) {
            return 0;
        }
        // Undefined is smaller than anything else
        if (x === undefined) {
            return -1;
        }
        if (y === undefined) {
            return 1;
        }
        // Null is smaller than anything except undefined
        if (x === null) {
            return -1;
        }
        if (y === null) {
            return 1;
        }
        // These comparisons always return false if either of the arguments is "undefined".
        // These comparisons return nonsense for "null" (true for "null > -1", but false for "null < 0" and "null > 0")
        if (x < y) {
            return -1;
        }
        if (x > y) {
            return 1;
        }
        return 0;
    }
    /**
     * Sorts the array according to a key which is obtained from the array elements.
     * The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let array: string[] = [ 'aaa', 'bb', 'c' ];
     * Sort.sortBy(array, x => x.length);  // [ 'c', 'bb', 'aaa' ]
     * ```
     */
    static sortBy(array, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    keySelector, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    comparer = Sort.compareByValue) {
        LegacyAdapters_1.LegacyAdapters.sortStable(array, (x, y) => comparer(keySelector(x), keySelector(y)));
    }
    /**
     * Returns true if the array is already sorted.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static isSorted(array, comparer = Sort.compareByValue) {
        let previous = undefined;
        for (const element of array) {
            if (comparer(previous, element) > 0) {
                return false;
            }
            previous = element;
        }
        return true;
    }
    /**
     * Returns true if the array is already sorted by the specified key.
     *
     * @example
     *
     * ```ts
     * let array: string[] = [ 'a', 'bb', 'ccc' ];
     * Sort.isSortedBy(array, x => x.length); // true
     * ```
     */
    static isSortedBy(array, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    keySelector, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    comparer = Sort.compareByValue) {
        let previousKey = undefined;
        for (const element of array) {
            const key = keySelector(element);
            if (comparer(previousKey, key) > 0) {
                return false;
            }
            previousKey = key;
        }
        return true;
    }
    /**
     * Sorts the entries in a Map object according to the map keys.
     * The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let map: Map<string, number> = new Map<string, number>();
     * map.set('zebra', 1);
     * map.set('goose', 2);
     * map.set('aardvark', 3);
     * Sort.sortMapKeys(map);
     * console.log(JSON.stringify(Array.from(map.keys()))); // ["aardvark","goose","zebra"]
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static sortMapKeys(map, keyComparer = Sort.compareByValue) {
        const pairs = Array.from(map.entries());
        // Sorting a map is expensive, so first check whether it's already sorted.
        if (Sort.isSortedBy(pairs, (x) => x[0], keyComparer)) {
            return;
        }
        Sort.sortBy(pairs, (x) => x[0], keyComparer);
        map.clear();
        for (const pair of pairs) {
            map.set(pair[0], pair[1]);
        }
    }
    /**
     * Sorts the entries in a Set object according to the specified keys.
     * The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let set: Set<string> = new Set<string>();
     * set.add('aaa');
     * set.add('bb');
     * set.add('c');
     * Sort.sortSetBy(set, x => x.length);
     * console.log(Array.from(set)); // ['c', 'bb', 'aaa']
     * ```
     */
    static sortSetBy(set, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    keySelector, keyComparer = Sort.compareByValue) {
        const array = Array.from(set);
        // Sorting a set is expensive, so first check whether it's already sorted.
        if (Sort.isSortedBy(array, keySelector, keyComparer)) {
            return;
        }
        LegacyAdapters_1.LegacyAdapters.sortStable(array, (x, y) => keyComparer(keySelector(x), keySelector(y)));
        set.clear();
        for (const item of array) {
            set.add(item);
        }
    }
    /**
     * Sorts the entries in a Set object.  The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let set: Set<string> = new Set<string>();
     * set.add('zebra');
     * set.add('goose');
     * set.add('aardvark');
     * Sort.sortSet(set);
     * console.log(Array.from(set)); // ['aardvark', 'goose', 'zebra']
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static sortSet(set, comparer = Sort.compareByValue) {
        const array = Array.from(set);
        // Sorting a set is expensive, so first check whether it's already sorted.
        if (Sort.isSorted(array, comparer)) {
            return;
        }
        LegacyAdapters_1.LegacyAdapters.sortStable(array, (x, y) => comparer(x, y));
        set.clear();
        for (const item of array) {
            set.add(item);
        }
    }
}
exports.Sort = Sort;
//# sourceMappingURL=Sort.js.map

/***/ }),

/***/ 83172:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringBuilder = void 0;
/**
 * This class allows a large text string to be constructed incrementally by appending small chunks.  The final
 * string can be obtained by calling StringBuilder.toString().
 *
 * @remarks
 * A naive approach might use the `+=` operator to append strings:  This would have the downside of copying
 * the entire string each time a chunk is appended, resulting in `O(n^2)` bytes of memory being allocated
 * (and later freed by the garbage  collector), and many of the allocations could be very large objects.
 * StringBuilder avoids this overhead by accumulating the chunks in an array, and efficiently joining them
 * when `getText()` is finally called.
 *
 * @public
 */
class StringBuilder {
    constructor() {
        this._chunks = [];
    }
    /** {@inheritDoc IStringBuilder.append} */
    append(text) {
        this._chunks.push(text);
    }
    /** {@inheritDoc IStringBuilder.toString} */
    toString() {
        if (this._chunks.length === 0) {
            return '';
        }
        if (this._chunks.length > 1) {
            const joined = this._chunks.join('');
            this._chunks.length = 1;
            this._chunks[0] = joined;
        }
        return this._chunks[0];
    }
}
exports.StringBuilder = StringBuilder;
//# sourceMappingURL=StringBuilder.js.map

/***/ }),

/***/ 27214:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnsiEscape = void 0;
const Colors_1 = __webpack_require__(33230);
/**
 * Operations for working with text strings that contain
 * {@link https://en.wikipedia.org/wiki/ANSI_escape_code | ANSI escape codes}.
 * The most commonly used escape codes set the foreground/background color for console output.
 * @public
 */
class AnsiEscape {
    /**
     * Returns the input text with all ANSI escape codes removed.  For example, this is useful when saving
     * colorized console output to a log file.
     */
    static removeCodes(text) {
        // eslint-disable-next-line no-control-regex
        return text.replace(AnsiEscape._csiRegExp, '');
    }
    /**
     * Replaces ANSI escape codes with human-readable tokens.  This is useful for unit tests
     * that compare text strings in test assertions or snapshot files.
     */
    static formatForTests(text, options) {
        if (!options) {
            options = {};
        }
        let result = text.replace(AnsiEscape._csiRegExp, (capture, csiCode) => {
            // If it is an SGR code, then try to show a friendly token
            const match = csiCode.match(AnsiEscape._sgrRegExp);
            if (match) {
                const sgrParameter = parseInt(match[1]);
                const sgrParameterName = AnsiEscape._tryGetSgrFriendlyName(sgrParameter);
                if (sgrParameterName) {
                    // Example: "[black-bg]"
                    return `[${sgrParameterName}]`;
                }
            }
            // Otherwise show the raw code, but without the "[" from the CSI prefix
            // Example: "[31m]"
            return `[${csiCode}]`;
        });
        if (options.encodeNewlines) {
            result = result
                .replace(AnsiEscape._backslashNRegExp, '[n]')
                .replace(AnsiEscape._backslashRRegExp, `[r]`);
        }
        return result;
    }
    // Returns a human-readable token representing an SGR parameter, or undefined for parameter that is not well-known.
    // The SGR parameter numbers are documented in this table:
    // https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_parameters
    static _tryGetSgrFriendlyName(sgiParameter) {
        switch (sgiParameter) {
            case Colors_1.ConsoleColorCodes.BlackForeground:
                return 'black';
            case Colors_1.ConsoleColorCodes.RedForeground:
                return 'red';
            case Colors_1.ConsoleColorCodes.GreenForeground:
                return 'green';
            case Colors_1.ConsoleColorCodes.YellowForeground:
                return 'yellow';
            case Colors_1.ConsoleColorCodes.BlueForeground:
                return 'blue';
            case Colors_1.ConsoleColorCodes.MagentaForeground:
                return 'magenta';
            case Colors_1.ConsoleColorCodes.CyanForeground:
                return 'cyan';
            case Colors_1.ConsoleColorCodes.WhiteForeground:
                return 'white';
            case Colors_1.ConsoleColorCodes.GrayForeground:
                return 'gray';
            case Colors_1.ConsoleColorCodes.DefaultForeground:
                return 'default';
            case Colors_1.ConsoleColorCodes.BlackBackground:
                return 'black-bg';
            case Colors_1.ConsoleColorCodes.RedBackground:
                return 'red-bg';
            case Colors_1.ConsoleColorCodes.GreenBackground:
                return 'green-bg';
            case Colors_1.ConsoleColorCodes.YellowBackground:
                return 'yellow-bg';
            case Colors_1.ConsoleColorCodes.BlueBackground:
                return 'blue-bg';
            case Colors_1.ConsoleColorCodes.MagentaBackground:
                return 'magenta-bg';
            case Colors_1.ConsoleColorCodes.CyanBackground:
                return 'cyan-bg';
            case Colors_1.ConsoleColorCodes.WhiteBackground:
                return 'white-bg';
            case Colors_1.ConsoleColorCodes.GrayBackground:
                return 'gray-bg';
            case Colors_1.ConsoleColorCodes.DefaultBackground:
                return 'default-bg';
            case Colors_1.ConsoleColorCodes.Bold:
                return 'bold';
            case Colors_1.ConsoleColorCodes.Dim:
                return 'dim';
            case Colors_1.ConsoleColorCodes.NormalColorOrIntensity:
                return 'normal';
            case Colors_1.ConsoleColorCodes.Underline:
                return 'underline';
            case Colors_1.ConsoleColorCodes.UnderlineOff:
                return 'underline-off';
            case Colors_1.ConsoleColorCodes.Blink:
                return 'blink';
            case Colors_1.ConsoleColorCodes.BlinkOff:
                return 'blink-off';
            case Colors_1.ConsoleColorCodes.InvertColor:
                return 'invert';
            case Colors_1.ConsoleColorCodes.InvertColorOff:
                return 'invert-off';
            case Colors_1.ConsoleColorCodes.Hidden:
                return 'hidden';
            case Colors_1.ConsoleColorCodes.HiddenOff:
                return 'hidden-off';
            default:
                return undefined;
        }
    }
}
exports.AnsiEscape = AnsiEscape;
// For now, we only care about the Control Sequence Introducer (CSI) commands which always start with "[".
// eslint-disable-next-line no-control-regex
AnsiEscape._csiRegExp = /\x1b\[([\x30-\x3f]*[\x20-\x2f]*[\x40-\x7e])/gu;
// Text coloring is performed using Select Graphic Rendition (SGR) codes, which come after the
// CSI introducer "ESC [".  The SGR sequence is a number followed by "m".
AnsiEscape._sgrRegExp = /([0-9]+)m/u;
AnsiEscape._backslashNRegExp = /\n/g;
AnsiEscape._backslashRRegExp = /\r/g;
//# sourceMappingURL=AnsiEscape.js.map

/***/ }),

/***/ 33230:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Colors = exports.ConsoleColorCodes = exports.TextAttribute = exports.ColorValue = exports.eolSequence = void 0;
exports.eolSequence = {
    isEol: true
};
/**
 * Colors used with {@link IColorableSequence}.
 * @beta
 */
var ColorValue;
(function (ColorValue) {
    ColorValue[ColorValue["Black"] = 0] = "Black";
    ColorValue[ColorValue["Red"] = 1] = "Red";
    ColorValue[ColorValue["Green"] = 2] = "Green";
    ColorValue[ColorValue["Yellow"] = 3] = "Yellow";
    ColorValue[ColorValue["Blue"] = 4] = "Blue";
    ColorValue[ColorValue["Magenta"] = 5] = "Magenta";
    ColorValue[ColorValue["Cyan"] = 6] = "Cyan";
    ColorValue[ColorValue["White"] = 7] = "White";
    ColorValue[ColorValue["Gray"] = 8] = "Gray";
})(ColorValue = exports.ColorValue || (exports.ColorValue = {}));
/**
 * Text styles used with {@link IColorableSequence}.
 * @beta
 */
var TextAttribute;
(function (TextAttribute) {
    TextAttribute[TextAttribute["Bold"] = 0] = "Bold";
    TextAttribute[TextAttribute["Dim"] = 1] = "Dim";
    TextAttribute[TextAttribute["Underline"] = 2] = "Underline";
    TextAttribute[TextAttribute["Blink"] = 3] = "Blink";
    TextAttribute[TextAttribute["InvertColor"] = 4] = "InvertColor";
    TextAttribute[TextAttribute["Hidden"] = 5] = "Hidden";
})(TextAttribute = exports.TextAttribute || (exports.TextAttribute = {}));
var ConsoleColorCodes;
(function (ConsoleColorCodes) {
    ConsoleColorCodes[ConsoleColorCodes["BlackForeground"] = 30] = "BlackForeground";
    ConsoleColorCodes[ConsoleColorCodes["RedForeground"] = 31] = "RedForeground";
    ConsoleColorCodes[ConsoleColorCodes["GreenForeground"] = 32] = "GreenForeground";
    ConsoleColorCodes[ConsoleColorCodes["YellowForeground"] = 33] = "YellowForeground";
    ConsoleColorCodes[ConsoleColorCodes["BlueForeground"] = 34] = "BlueForeground";
    ConsoleColorCodes[ConsoleColorCodes["MagentaForeground"] = 35] = "MagentaForeground";
    ConsoleColorCodes[ConsoleColorCodes["CyanForeground"] = 36] = "CyanForeground";
    ConsoleColorCodes[ConsoleColorCodes["WhiteForeground"] = 37] = "WhiteForeground";
    ConsoleColorCodes[ConsoleColorCodes["GrayForeground"] = 90] = "GrayForeground";
    ConsoleColorCodes[ConsoleColorCodes["DefaultForeground"] = 39] = "DefaultForeground";
    ConsoleColorCodes[ConsoleColorCodes["BlackBackground"] = 40] = "BlackBackground";
    ConsoleColorCodes[ConsoleColorCodes["RedBackground"] = 41] = "RedBackground";
    ConsoleColorCodes[ConsoleColorCodes["GreenBackground"] = 42] = "GreenBackground";
    ConsoleColorCodes[ConsoleColorCodes["YellowBackground"] = 43] = "YellowBackground";
    ConsoleColorCodes[ConsoleColorCodes["BlueBackground"] = 44] = "BlueBackground";
    ConsoleColorCodes[ConsoleColorCodes["MagentaBackground"] = 45] = "MagentaBackground";
    ConsoleColorCodes[ConsoleColorCodes["CyanBackground"] = 46] = "CyanBackground";
    ConsoleColorCodes[ConsoleColorCodes["WhiteBackground"] = 47] = "WhiteBackground";
    ConsoleColorCodes[ConsoleColorCodes["GrayBackground"] = 100] = "GrayBackground";
    ConsoleColorCodes[ConsoleColorCodes["DefaultBackground"] = 49] = "DefaultBackground";
    ConsoleColorCodes[ConsoleColorCodes["Bold"] = 1] = "Bold";
    // On Linux, the "BoldOff" code instead causes the text to be double-underlined:
    // https://en.wikipedia.org/wiki/Talk:ANSI_escape_code#SGR_21%E2%80%94%60Bold_off%60_not_widely_supported
    // Use "NormalColorOrIntensity" instead
    // BoldOff = 21,
    ConsoleColorCodes[ConsoleColorCodes["Dim"] = 2] = "Dim";
    ConsoleColorCodes[ConsoleColorCodes["NormalColorOrIntensity"] = 22] = "NormalColorOrIntensity";
    ConsoleColorCodes[ConsoleColorCodes["Underline"] = 4] = "Underline";
    ConsoleColorCodes[ConsoleColorCodes["UnderlineOff"] = 24] = "UnderlineOff";
    ConsoleColorCodes[ConsoleColorCodes["Blink"] = 5] = "Blink";
    ConsoleColorCodes[ConsoleColorCodes["BlinkOff"] = 25] = "BlinkOff";
    ConsoleColorCodes[ConsoleColorCodes["InvertColor"] = 7] = "InvertColor";
    ConsoleColorCodes[ConsoleColorCodes["InvertColorOff"] = 27] = "InvertColorOff";
    ConsoleColorCodes[ConsoleColorCodes["Hidden"] = 8] = "Hidden";
    ConsoleColorCodes[ConsoleColorCodes["HiddenOff"] = 28] = "HiddenOff";
})(ConsoleColorCodes = exports.ConsoleColorCodes || (exports.ConsoleColorCodes = {}));
/**
 * The static functions on this class are used to produce colored text
 * for use with the node-core-library terminal.
 *
 * @example
 * terminal.writeLine(Colors.green('Green Text!'), ' ', Colors.blue('Blue Text!'));
 *
 * @beta
 */
class Colors {
    static black(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Black });
    }
    static red(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Red });
    }
    static green(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Green });
    }
    static yellow(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Yellow });
    }
    static blue(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Blue });
    }
    static magenta(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Magenta });
    }
    static cyan(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Cyan });
    }
    static white(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.White });
    }
    static gray(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Gray });
    }
    static blackBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Black });
    }
    static redBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Red });
    }
    static greenBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Green });
    }
    static yellowBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Yellow });
    }
    static blueBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Blue });
    }
    static magentaBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Magenta });
    }
    static cyanBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Cyan });
    }
    static whiteBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.White });
    }
    static grayBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Gray });
    }
    static bold(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Bold);
    }
    static dim(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Dim);
    }
    static underline(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Underline);
    }
    static blink(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Blink);
    }
    static invertColor(text) {
        return Colors._applyTextAttribute(text, TextAttribute.InvertColor);
    }
    static hidden(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Hidden);
    }
    /**
     * If called with a string, returns the string wrapped in a {@link IColorableSequence}.
     * If called with a {@link IColorableSequence}, returns the {@link IColorableSequence}.
     *
     * @internal
     */
    static _normalizeStringOrColorableSequence(value) {
        if (typeof value === 'string') {
            return {
                text: value
            };
        }
        else {
            return value;
        }
    }
    static _applyTextAttribute(text, attribute) {
        const sequence = Colors._normalizeStringOrColorableSequence(text);
        if (!sequence.textAttributes) {
            sequence.textAttributes = [];
        }
        sequence.textAttributes.push(attribute);
        return sequence;
    }
}
exports.Colors = Colors;
//# sourceMappingURL=Colors.js.map

/***/ }),

/***/ 48634:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsoleTerminalProvider = void 0;
const os_1 = __webpack_require__(12087);
const safe_1 = __webpack_require__(41997);
const ITerminalProvider_1 = __webpack_require__(33341);
/**
 * Terminal provider that prints to STDOUT (for log- and verbose-level messages) and
 * STDERR (for warning- and error-level messsages).
 *
 * @beta
 */
class ConsoleTerminalProvider {
    constructor(options = {}) {
        /**
         * If true, verbose-level messages should be written to the console.
         */
        this.verboseEnabled = false;
        /**
         * If true, debug-level messages should be written to the console.
         */
        this.debugEnabled = false;
        this.verboseEnabled = !!options.verboseEnabled;
        this.debugEnabled = !!options.debugEnabled;
    }
    /**
     * {@inheritDoc ITerminalProvider.write}
     */
    write(data, severity) {
        switch (severity) {
            case ITerminalProvider_1.TerminalProviderSeverity.warning:
            case ITerminalProvider_1.TerminalProviderSeverity.error: {
                process.stderr.write(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.verbose: {
                if (this.verboseEnabled) {
                    process.stdout.write(data);
                }
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.debug: {
                if (this.debugEnabled) {
                    process.stdout.write(data);
                }
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.log:
            default: {
                process.stdout.write(data);
                break;
            }
        }
    }
    /**
     * {@inheritDoc ITerminalProvider.eolCharacter}
     */
    get eolCharacter() {
        return os_1.EOL;
    }
    /**
     * {@inheritDoc ITerminalProvider.supportsColor}
     */
    get supportsColor() {
        return safe_1.enabled;
    }
}
exports.ConsoleTerminalProvider = ConsoleTerminalProvider;
//# sourceMappingURL=ConsoleTerminalProvider.js.map

/***/ }),

/***/ 33341:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TerminalProviderSeverity = void 0;
/**
 * Similar to many popular logging packages, terminal providers support a range of message
 * severities. These severities have built-in formatting defaults in the Terminal object
 * (warnings are yellow, errors are red, etc.).
 *
 * Terminal providers may choose to suppress certain messages based on their severity,
 * or to route some messages to other providers or not based on severity.
 *
 *   Severity  | Purpose
 *   --------- | -------
 *   error     | Build errors and fatal issues
 *   warning   | Not necessarily fatal, but indicate a problem the user should fix
 *   log       | Informational messages
 *   verbose   | Additional information that may not always be necessary
 *   debug     | Highest detail level, best used for troubleshooting information
 *
 * @beta
 */
var TerminalProviderSeverity;
(function (TerminalProviderSeverity) {
    TerminalProviderSeverity[TerminalProviderSeverity["log"] = 0] = "log";
    TerminalProviderSeverity[TerminalProviderSeverity["warning"] = 1] = "warning";
    TerminalProviderSeverity[TerminalProviderSeverity["error"] = 2] = "error";
    TerminalProviderSeverity[TerminalProviderSeverity["verbose"] = 3] = "verbose";
    TerminalProviderSeverity[TerminalProviderSeverity["debug"] = 4] = "debug";
})(TerminalProviderSeverity = exports.TerminalProviderSeverity || (exports.TerminalProviderSeverity = {}));
//# sourceMappingURL=ITerminalProvider.js.map

/***/ }),

/***/ 1061:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringBufferTerminalProvider = void 0;
const ITerminalProvider_1 = __webpack_require__(33341);
const StringBuilder_1 = __webpack_require__(83172);
const Text_1 = __webpack_require__(44756);
const AnsiEscape_1 = __webpack_require__(27214);
/**
 * Terminal provider that stores written data in buffers separated by severity.
 * This terminal provider is designed to be used when code that prints to a terminal
 * is being unit tested.
 *
 * @beta
 */
class StringBufferTerminalProvider {
    constructor(supportsColor = false) {
        this._standardBuffer = new StringBuilder_1.StringBuilder();
        this._verboseBuffer = new StringBuilder_1.StringBuilder();
        this._debugBuffer = new StringBuilder_1.StringBuilder();
        this._warningBuffer = new StringBuilder_1.StringBuilder();
        this._errorBuffer = new StringBuilder_1.StringBuilder();
        this._supportsColor = supportsColor;
    }
    /**
     * {@inheritDoc ITerminalProvider.write}
     */
    write(data, severity) {
        switch (severity) {
            case ITerminalProvider_1.TerminalProviderSeverity.warning: {
                this._warningBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.error: {
                this._errorBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.verbose: {
                this._verboseBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.debug: {
                this._debugBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.log:
            default: {
                this._standardBuffer.append(data);
                break;
            }
        }
    }
    /**
     * {@inheritDoc ITerminalProvider.eolCharacter}
     */
    get eolCharacter() {
        return '[n]';
    }
    /**
     * {@inheritDoc ITerminalProvider.supportsColor}
     */
    get supportsColor() {
        return this._supportsColor;
    }
    /**
     * Get everything that has been written at log-level severity.
     */
    getOutput(options) {
        return this._normalizeOutput(this._standardBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at verbose-level severity.
     */
    getVerbose(options) {
        return this._normalizeOutput(this._verboseBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at debug-level severity.
     */
    getDebugOutput(options) {
        return this._normalizeOutput(this._debugBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at error-level severity.
     */
    getErrorOutput(options) {
        return this._normalizeOutput(this._errorBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at warning-level severity.
     */
    getWarningOutput(options) {
        return this._normalizeOutput(this._warningBuffer.toString(), options);
    }
    _normalizeOutput(s, options) {
        options = Object.assign({ normalizeSpecialCharacters: true }, (options || {}));
        s = Text_1.Text.convertToLf(s);
        if (options.normalizeSpecialCharacters) {
            return AnsiEscape_1.AnsiEscape.formatForTests(s, { encodeNewlines: true });
        }
        else {
            return s;
        }
    }
}
exports.StringBufferTerminalProvider = StringBufferTerminalProvider;
//# sourceMappingURL=StringBufferTerminalProvider.js.map

/***/ }),

/***/ 78099:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Terminal = void 0;
const ITerminalProvider_1 = __webpack_require__(33341);
const Colors_1 = __webpack_require__(33230);
/**
 * This class facilitates writing to a console.
 *
 * @beta
 */
class Terminal {
    constructor(provider) {
        this._providers = new Set();
        this._providers.add(provider);
    }
    /**
     * {@inheritdoc ITerminal.registerProvider}
     */
    registerProvider(provider) {
        this._providers.add(provider);
    }
    /**
     * {@inheritdoc ITerminal.unregisterProvider}
     */
    unregisterProvider(provider) {
        if (this._providers.has(provider)) {
            this._providers.delete(provider);
        }
    }
    /**
     * {@inheritdoc ITerminal.write}
     */
    write(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.log);
    }
    /**
     * {@inheritdoc ITerminal.writeLine}
     */
    writeLine(...messageParts) {
        this.write(...messageParts, Colors_1.eolSequence);
    }
    /**
     * {@inheritdoc ITerminal.writeWarning}
     */
    writeWarning(...messageParts) {
        this._writeSegmentsToProviders(messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Yellow }))), ITerminalProvider_1.TerminalProviderSeverity.warning);
    }
    /**
     * {@inheritdoc ITerminal.writeWarningLine}
     */
    writeWarningLine(...messageParts) {
        this._writeSegmentsToProviders([
            ...messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Yellow }))),
            Colors_1.eolSequence
        ], ITerminalProvider_1.TerminalProviderSeverity.warning);
    }
    /**
     * {@inheritdoc ITerminal.writeError}
     */
    writeError(...messageParts) {
        this._writeSegmentsToProviders(messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Red }))), ITerminalProvider_1.TerminalProviderSeverity.error);
    }
    /**
     * {@inheritdoc ITerminal.writeErrorLine}
     */
    writeErrorLine(...messageParts) {
        this._writeSegmentsToProviders([
            ...messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Red }))),
            Colors_1.eolSequence
        ], ITerminalProvider_1.TerminalProviderSeverity.error);
    }
    /**
     * {@inheritdoc ITerminal.writeVerbose}
     */
    writeVerbose(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.verbose);
    }
    /**
     * {@inheritdoc ITerminal.writeVerboseLine}
     */
    writeVerboseLine(...messageParts) {
        this.writeVerbose(...messageParts, Colors_1.eolSequence);
    }
    /**
     * {@inheritdoc ITerminal.writeDebug}
     */
    writeDebug(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.debug);
    }
    /**
     * {@inheritdoc ITerminal.writeDebugLine}
     */
    writeDebugLine(...messageParts) {
        this.writeDebug(...messageParts, Colors_1.eolSequence);
    }
    _writeSegmentsToProviders(segments, severity) {
        const withColorText = {};
        const withoutColorText = {};
        let withColorLines;
        let withoutColorLines;
        this._providers.forEach((provider) => {
            const eol = provider.eolCharacter;
            let textToWrite;
            if (provider.supportsColor) {
                if (!withColorLines) {
                    withColorLines = this._serializeFormattableTextSegments(segments, true);
                }
                if (!withColorText[eol]) {
                    withColorText[eol] = withColorLines.join(eol);
                }
                textToWrite = withColorText[eol];
            }
            else {
                if (!withoutColorLines) {
                    withoutColorLines = this._serializeFormattableTextSegments(segments, false);
                }
                if (!withoutColorText[eol]) {
                    withoutColorText[eol] = withoutColorLines.join(eol);
                }
                textToWrite = withoutColorText[eol];
            }
            provider.write(textToWrite, severity);
        });
    }
    _serializeFormattableTextSegments(segments, withColor) {
        const lines = [];
        let segmentsToJoin = [];
        let lastSegmentWasEol = false;
        for (let i = 0; i < segments.length; i++) {
            const segment = Colors_1.Colors._normalizeStringOrColorableSequence(segments[i]);
            lastSegmentWasEol = !!segment.isEol;
            if (lastSegmentWasEol) {
                lines.push(segmentsToJoin.join(''));
                segmentsToJoin = [];
            }
            else {
                if (withColor) {
                    const startColorCodes = [];
                    const endColorCodes = [];
                    switch (segment.foregroundColor) {
                        case Colors_1.ColorValue.Black: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlackForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Red: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.RedForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Green: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GreenForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Yellow: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.YellowForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Blue: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlueForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Magenta: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.MagentaForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Cyan: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.CyanForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.White: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.WhiteForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Gray: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GrayForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                    }
                    switch (segment.backgroundColor) {
                        case Colors_1.ColorValue.Black: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlackBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Red: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.RedBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Green: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GreenBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Yellow: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.YellowBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Blue: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlueBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Magenta: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.MagentaBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Cyan: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.CyanBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.White: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.WhiteBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Gray: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GrayBackground);
                            endColorCodes.push(49);
                            break;
                        }
                    }
                    if (segment.textAttributes) {
                        for (const textAttribute of segment.textAttributes) {
                            switch (textAttribute) {
                                case Colors_1.TextAttribute.Bold: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Bold);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.NormalColorOrIntensity);
                                    break;
                                }
                                case Colors_1.TextAttribute.Dim: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Dim);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.NormalColorOrIntensity);
                                    break;
                                }
                                case Colors_1.TextAttribute.Underline: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Underline);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.UnderlineOff);
                                    break;
                                }
                                case Colors_1.TextAttribute.Blink: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Blink);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.BlinkOff);
                                    break;
                                }
                                case Colors_1.TextAttribute.InvertColor: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.InvertColor);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.InvertColorOff);
                                    break;
                                }
                                case Colors_1.TextAttribute.Hidden: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Hidden);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.HiddenOff);
                                    break;
                                }
                            }
                        }
                    }
                    for (let j = 0; j < startColorCodes.length; j++) {
                        const code = startColorCodes[j];
                        segmentsToJoin.push(...['\u001b[', code.toString(), 'm']);
                    }
                    segmentsToJoin.push(segment.text);
                    for (let j = endColorCodes.length - 1; j >= 0; j--) {
                        const code = endColorCodes[j];
                        segmentsToJoin.push(...['\u001b[', code.toString(), 'm']);
                    }
                }
                else {
                    segmentsToJoin.push(segment.text);
                }
            }
        }
        if (segmentsToJoin.length > 0) {
            lines.push(segmentsToJoin.join(''));
        }
        if (lastSegmentWasEol) {
            lines.push('');
        }
        return lines;
    }
}
exports.Terminal = Terminal;
//# sourceMappingURL=Terminal.js.map

/***/ }),

/***/ 44756:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Text = void 0;
const os = __importStar(__webpack_require__(12087));
/**
 * Operations for working with strings that contain text.
 *
 * @remarks
 * The utilities provided by this class are intended to be simple, small, and very
 * broadly applicable.
 *
 * @public
 */
class Text {
    /**
     * Returns the same thing as targetString.replace(searchValue, replaceValue), except that
     * all matches are replaced, rather than just the first match.
     * @param input         - The string to be modified
     * @param searchValue   - The value to search for
     * @param replaceValue  - The replacement text
     */
    static replaceAll(input, searchValue, replaceValue) {
        return input.split(searchValue).join(replaceValue);
    }
    /**
     * Converts all newlines in the provided string to use Windows-style CRLF end of line characters.
     */
    static convertToCrLf(input) {
        return input.replace(Text._newLineRegEx, '\r\n');
    }
    /**
     * Converts all newlines in the provided string to use POSIX-style LF end of line characters.
     *
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    static convertToLf(input) {
        return input.replace(Text._newLineRegEx, '\n');
    }
    /**
     * Converts all newlines in the provided string to use the specified newline type.
     */
    static convertTo(input, newlineKind) {
        return input.replace(Text._newLineRegEx, Text.getNewline(newlineKind));
    }
    /**
     * Returns the newline character sequence for the specified `NewlineKind`.
     */
    static getNewline(newlineKind) {
        switch (newlineKind) {
            case "\r\n" /* CrLf */:
                return '\r\n';
            case "\n" /* Lf */:
                return '\n';
            case "os" /* OsDefault */:
                return os.EOL;
            default:
                throw new Error('Unsupported newline kind');
        }
    }
    /**
     * Append characters to the end of a string to ensure the result has a minimum length.
     * @remarks
     * If the string length already exceeds the minimum length, then the string is unchanged.
     * The string is not truncated.
     */
    static padEnd(s, minimumLength, paddingCharacter = ' ') {
        if (paddingCharacter.length !== 1) {
            throw new Error('The paddingCharacter parameter must be a single character.');
        }
        if (s.length < minimumLength) {
            const paddingArray = new Array(minimumLength - s.length);
            paddingArray.unshift(s);
            return paddingArray.join(paddingCharacter);
        }
        else {
            return s;
        }
    }
    /**
     * Append characters to the start of a string to ensure the result has a minimum length.
     * @remarks
     * If the string length already exceeds the minimum length, then the string is unchanged.
     * The string is not truncated.
     */
    static padStart(s, minimumLength, paddingCharacter = ' ') {
        if (paddingCharacter.length !== 1) {
            throw new Error('The paddingCharacter parameter must be a single character.');
        }
        if (s.length < minimumLength) {
            const paddingArray = new Array(minimumLength - s.length);
            paddingArray.push(s);
            return paddingArray.join(paddingCharacter);
        }
        else {
            return s;
        }
    }
    /**
     * If the string is longer than maximumLength characters, truncate it to that length
     * using "..." to indicate the truncation.
     *
     * @remarks
     * For example truncateWithEllipsis('1234578', 5) would produce '12...'.
     */
    static truncateWithEllipsis(s, maximumLength) {
        if (maximumLength < 0) {
            throw new Error('The maximumLength cannot be a negative number');
        }
        if (s.length <= maximumLength) {
            return s;
        }
        if (s.length <= 3) {
            return s.substring(0, maximumLength);
        }
        return s.substring(0, maximumLength - 3) + '...';
    }
    /**
     * Returns the input string with a trailing `\n` character appended, if not already present.
     */
    static ensureTrailingNewline(s, newlineKind = "\n" /* Lf */) {
        // Is there already a newline?
        if (Text._newLineAtEndRegEx.test(s)) {
            return s; // yes, no change
        }
        return s + newlineKind; // no, add it
    }
}
exports.Text = Text;
Text._newLineRegEx = /\r\n|\n\r|\r|\n/g;
Text._newLineAtEndRegEx = /(\r\n|\n\r|\r|\n)$/;
//# sourceMappingURL=Text.js.map

/***/ }),

/***/ 22175:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeUuid = void 0;
const InternalError_1 = __webpack_require__(65230);
const classPrototypeUuidSymbol = Symbol.for('TypeUuid.classPrototypeUuid');
/**
 * Provides a version-independent implementation of the JavaScript `instanceof` operator.
 *
 * @remarks
 * The JavaScript `instanceof` operator normally only identifies objects from a particular library instance.
 * For example, suppose the NPM package `example-lib` has two published versions 1.2.0 and 1.3.0, and
 * it exports a class called `A`.  Suppose some code consumes version `1.3.0` of the library, but it receives
 * an object that was constructed using version `1.2.0`.  In this situation `a instanceof A` will return `false`,
 * even though `a` is an instance of `A`.  The reason is that there are two prototypes for `A`; one for each
 * version.
 *
 * The `TypeUuid` facility provides a way to make `a instanceof A` return true for both prototypes of `A`,
 * by instead using a universally unique identifier (UUID) to detect object instances.
 *
 * You can use `Symbol.hasInstance` to enable the system `instanceof` operator to recognize type UUID equivalence:
 * ```ts
 * const uuidWidget: string = '9c340ef0-d29f-4e2e-a09f-42bacc59024b';
 * class Widget {
 *   public static [Symbol.hasInstance](instance: object): boolean {
 *     return TypeUuid.isInstanceOf(instance, uuidWidget);
 *   }
 * }
 * ```
 * // Example usage:
 * ```ts
 * import { Widget as Widget1 } from 'v1-of-library';
 * import { Widget as Widget2 } from 'v2-of-library';
 * const widget = new Widget2();
 * console.log(widget instanceof Widget1); // prints true
 * ```
 *
 * @public
 */
class TypeUuid {
    /**
     * Registers a JavaScript class as having a type identified by the specified UUID.
     * @privateRemarks
     * We cannot use a construct signature for `targetClass` because it may be an abstract class.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static registerClass(targetClass, typeUuid) {
        if (typeof targetClass !== 'function') {
            throw new Error('The targetClass parameter must be a JavaScript class');
        }
        if (!TypeUuid._uuidRegExp.test(typeUuid)) {
            throw new Error(`The type UUID must be specified as lowercase hexadecimal with dashes: "${typeUuid}"`);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const targetClassPrototype = targetClass.prototype;
        if (Object.hasOwnProperty.call(targetClassPrototype, classPrototypeUuidSymbol)) {
            const existingUuid = targetClassPrototype[classPrototypeUuidSymbol];
            throw new InternalError_1.InternalError(`Cannot register the target class ${targetClass.name || ''} typeUuid=${typeUuid}` +
                ` because it was already registered with typeUuid=${existingUuid}`);
        }
        targetClassPrototype[classPrototypeUuidSymbol] = typeUuid;
    }
    /**
     * Returns true if the `targetObject` is an instance of a JavaScript class that was previously
     * registered using the specified `typeUuid`.  Base classes are also considered.
     */
    static isInstanceOf(targetObject, typeUuid) {
        if (targetObject === undefined || targetObject === null) {
            return false;
        }
        let objectPrototype = Object.getPrototypeOf(targetObject);
        while (objectPrototype !== undefined && objectPrototype !== null) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const registeredUuid = objectPrototype[classPrototypeUuidSymbol];
            if (registeredUuid === typeUuid) {
                return true;
            }
            // Walk upwards an examine base class prototypes
            objectPrototype = Object.getPrototypeOf(objectPrototype);
        }
        return false;
    }
}
exports.TypeUuid = TypeUuid;
TypeUuid._uuidRegExp = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
//# sourceMappingURL=TypeUuid.js.map

/***/ }),

/***/ 11851:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeUuid = exports.StringBufferTerminalProvider = exports.ConsoleTerminalProvider = exports.TerminalProviderSeverity = exports.TextAttribute = exports.ColorValue = exports.Colors = exports.Terminal = exports.StringBuilder = exports.LegacyAdapters = exports.FileWriter = exports.FileSystem = exports.Sort = exports.Text = exports.Path = exports.PackageNameParser = exports.PackageName = exports.PackageJsonLookup = exports.ProtectableMap = exports.MapExtensions = exports.LockFile = exports.JsonSchema = exports.JsonFile = exports.InternalError = exports.Import = exports.Executable = exports.EnvironmentMap = exports.Enum = exports.Async = exports.AnsiEscape = exports.AlreadyReportedError = void 0;
/**
 * Core libraries that every NodeJS toolchain project should use.
 *
 * @packageDocumentation
 */
var AlreadyReportedError_1 = __webpack_require__(54806);
Object.defineProperty(exports, "AlreadyReportedError", ({ enumerable: true, get: function () { return AlreadyReportedError_1.AlreadyReportedError; } }));
var AnsiEscape_1 = __webpack_require__(27214);
Object.defineProperty(exports, "AnsiEscape", ({ enumerable: true, get: function () { return AnsiEscape_1.AnsiEscape; } }));
var Async_1 = __webpack_require__(6965);
Object.defineProperty(exports, "Async", ({ enumerable: true, get: function () { return Async_1.Async; } }));
var Enum_1 = __webpack_require__(38368);
Object.defineProperty(exports, "Enum", ({ enumerable: true, get: function () { return Enum_1.Enum; } }));
var EnvironmentMap_1 = __webpack_require__(77686);
Object.defineProperty(exports, "EnvironmentMap", ({ enumerable: true, get: function () { return EnvironmentMap_1.EnvironmentMap; } }));
var Executable_1 = __webpack_require__(93190);
Object.defineProperty(exports, "Executable", ({ enumerable: true, get: function () { return Executable_1.Executable; } }));
var Import_1 = __webpack_require__(90277);
Object.defineProperty(exports, "Import", ({ enumerable: true, get: function () { return Import_1.Import; } }));
var InternalError_1 = __webpack_require__(65230);
Object.defineProperty(exports, "InternalError", ({ enumerable: true, get: function () { return InternalError_1.InternalError; } }));
var JsonFile_1 = __webpack_require__(20785);
Object.defineProperty(exports, "JsonFile", ({ enumerable: true, get: function () { return JsonFile_1.JsonFile; } }));
var JsonSchema_1 = __webpack_require__(31561);
Object.defineProperty(exports, "JsonSchema", ({ enumerable: true, get: function () { return JsonSchema_1.JsonSchema; } }));
var LockFile_1 = __webpack_require__(51977);
Object.defineProperty(exports, "LockFile", ({ enumerable: true, get: function () { return LockFile_1.LockFile; } }));
var MapExtensions_1 = __webpack_require__(82565);
Object.defineProperty(exports, "MapExtensions", ({ enumerable: true, get: function () { return MapExtensions_1.MapExtensions; } }));
var ProtectableMap_1 = __webpack_require__(76443);
Object.defineProperty(exports, "ProtectableMap", ({ enumerable: true, get: function () { return ProtectableMap_1.ProtectableMap; } }));
var PackageJsonLookup_1 = __webpack_require__(17805);
Object.defineProperty(exports, "PackageJsonLookup", ({ enumerable: true, get: function () { return PackageJsonLookup_1.PackageJsonLookup; } }));
var PackageName_1 = __webpack_require__(50111);
Object.defineProperty(exports, "PackageName", ({ enumerable: true, get: function () { return PackageName_1.PackageName; } }));
Object.defineProperty(exports, "PackageNameParser", ({ enumerable: true, get: function () { return PackageName_1.PackageNameParser; } }));
var Path_1 = __webpack_require__(80953);
Object.defineProperty(exports, "Path", ({ enumerable: true, get: function () { return Path_1.Path; } }));
var Text_1 = __webpack_require__(44756);
Object.defineProperty(exports, "Text", ({ enumerable: true, get: function () { return Text_1.Text; } }));
var Sort_1 = __webpack_require__(73728);
Object.defineProperty(exports, "Sort", ({ enumerable: true, get: function () { return Sort_1.Sort; } }));
var FileSystem_1 = __webpack_require__(25271);
Object.defineProperty(exports, "FileSystem", ({ enumerable: true, get: function () { return FileSystem_1.FileSystem; } }));
var FileWriter_1 = __webpack_require__(61053);
Object.defineProperty(exports, "FileWriter", ({ enumerable: true, get: function () { return FileWriter_1.FileWriter; } }));
var LegacyAdapters_1 = __webpack_require__(4996);
Object.defineProperty(exports, "LegacyAdapters", ({ enumerable: true, get: function () { return LegacyAdapters_1.LegacyAdapters; } }));
var StringBuilder_1 = __webpack_require__(83172);
Object.defineProperty(exports, "StringBuilder", ({ enumerable: true, get: function () { return StringBuilder_1.StringBuilder; } }));
var Terminal_1 = __webpack_require__(78099);
Object.defineProperty(exports, "Terminal", ({ enumerable: true, get: function () { return Terminal_1.Terminal; } }));
var Colors_1 = __webpack_require__(33230);
Object.defineProperty(exports, "Colors", ({ enumerable: true, get: function () { return Colors_1.Colors; } }));
Object.defineProperty(exports, "ColorValue", ({ enumerable: true, get: function () { return Colors_1.ColorValue; } }));
Object.defineProperty(exports, "TextAttribute", ({ enumerable: true, get: function () { return Colors_1.TextAttribute; } }));
var ITerminalProvider_1 = __webpack_require__(33341);
Object.defineProperty(exports, "TerminalProviderSeverity", ({ enumerable: true, get: function () { return ITerminalProvider_1.TerminalProviderSeverity; } }));
var ConsoleTerminalProvider_1 = __webpack_require__(48634);
Object.defineProperty(exports, "ConsoleTerminalProvider", ({ enumerable: true, get: function () { return ConsoleTerminalProvider_1.ConsoleTerminalProvider; } }));
var StringBufferTerminalProvider_1 = __webpack_require__(1061);
Object.defineProperty(exports, "StringBufferTerminalProvider", ({ enumerable: true, get: function () { return StringBufferTerminalProvider_1.StringBufferTerminalProvider; } }));
var TypeUuid_1 = __webpack_require__(22175);
Object.defineProperty(exports, "TypeUuid", ({ enumerable: true, get: function () { return TypeUuid_1.TypeUuid; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 88200:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var async = __webpack_require__(32313);
async.core = __webpack_require__(83467);
async.isCore = __webpack_require__(36567);
async.sync = __webpack_require__(6977);

module.exports = async;


/***/ }),

/***/ 32313:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(35747);
var path = __webpack_require__(85622);
var caller = __webpack_require__(3472);
var nodeModulesPaths = __webpack_require__(92310);
var normalizeOptions = __webpack_require__(86051);
var isCore = __webpack_require__(36567);

var realpathFS = fs.realpath && typeof fs.realpath.native === 'function' ? fs.realpath.native : fs.realpath;

var defaultIsFile = function isFile(file, cb) {
    fs.stat(file, function (err, stat) {
        if (!err) {
            return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};

var defaultIsDir = function isDirectory(dir, cb) {
    fs.stat(dir, function (err, stat) {
        if (!err) {
            return cb(null, stat.isDirectory());
        }
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};

var defaultRealpath = function realpath(x, cb) {
    realpathFS(x, function (realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== 'ENOENT') cb(realpathErr);
        else cb(null, realpathErr ? x : realPath);
    });
};

var maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
    } else {
        cb(null, x);
    }
};

var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
};

module.exports = function resolve(x, options, callback) {
    var cb = callback;
    var opts = options;
    if (typeof options === 'function') {
        cb = opts;
        opts = {};
    }
    if (typeof x !== 'string') {
        var err = new TypeError('Path must be a string.');
        return process.nextTick(function () {
            cb(err);
        });
    }

    opts = normalizeOptions(x, opts);

    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile = opts.readFile || fs.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var packageIterator = opts.packageIterator;

    var extensions = opts.extensions || ['.js'];
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || [];

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = path.resolve(basedir);

    maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function (err, realStart) {
            if (err) cb(err);
            else init(realStart);
        }
    );

    var res;
    function init(basedir) {
        if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
            res = path.resolve(basedir, x);
            if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
            if ((/\/$/).test(x) && res === basedir) {
                loadAsDirectory(res, opts.package, onfile);
            } else loadAsFile(res, opts.package, onfile);
        } else if (isCore(x)) {
            return cb(null, x);
        } else loadNodeModules(x, basedir, function (err, n, pkg) {
            if (err) cb(err);
            else if (n) {
                return maybeRealpath(realpath, n, opts, function (err, realN) {
                    if (err) {
                        cb(err);
                    } else {
                        cb(null, realN, pkg);
                    }
                });
            } else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
            }
        });
    }

    function onfile(err, m, pkg) {
        if (err) cb(err);
        else if (m) cb(null, m, pkg);
        else loadAsDirectory(res, function (err, d, pkg) {
            if (err) cb(err);
            else if (d) {
                maybeRealpath(realpath, d, opts, function (err, realD) {
                    if (err) {
                        cb(err);
                    } else {
                        cb(null, realD, pkg);
                    }
                });
            } else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
            }
        });
    }

    function loadAsFile(x, thePackage, callback) {
        var loadAsFilePackage = thePackage;
        var cb = callback;
        if (typeof loadAsFilePackage === 'function') {
            cb = loadAsFilePackage;
            loadAsFilePackage = undefined;
        }

        var exts = [''].concat(extensions);
        load(exts, x, loadAsFilePackage);

        function load(exts, x, loadPackage) {
            if (exts.length === 0) return cb(null, undefined, loadPackage);
            var file = x + exts[0];

            var pkg = loadPackage;
            if (pkg) onpkg(null, pkg);
            else loadpkg(path.dirname(file), onpkg);

            function onpkg(err, pkg_, dir) {
                pkg = pkg_;
                if (err) return cb(err);
                if (dir && pkg && opts.pathFilter) {
                    var rfile = path.relative(dir, file);
                    var rel = rfile.slice(0, rfile.length - exts[0].length);
                    var r = opts.pathFilter(pkg, x, rel);
                    if (r) return load(
                        [''].concat(extensions.slice()),
                        path.resolve(dir, r),
                        pkg
                    );
                }
                isFile(file, onex);
            }
            function onex(err, ex) {
                if (err) return cb(err);
                if (ex) return cb(null, file, pkg);
                load(exts.slice(1), x, pkg);
            }
        }
    }

    function loadpkg(dir, cb) {
        if (dir === '' || dir === '/') return cb(null);
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
            return cb(null);
        }
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return cb(null);

        maybeRealpath(realpath, dir, opts, function (unwrapErr, pkgdir) {
            if (unwrapErr) return loadpkg(path.dirname(dir), cb);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) {
                // on err, ex is false
                if (!ex) return loadpkg(path.dirname(dir), cb);

                readFile(pkgfile, function (err, body) {
                    if (err) cb(err);
                    try { var pkg = JSON.parse(body); } catch (jsonErr) {}

                    if (pkg && opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }
                    cb(null, pkg, dir);
                });
            });
        });
    }

    function loadAsDirectory(x, loadAsDirectoryPackage, callback) {
        var cb = callback;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === 'function') {
            cb = fpkg;
            fpkg = opts.package;
        }

        maybeRealpath(realpath, x, opts, function (unwrapErr, pkgdir) {
            if (unwrapErr) return cb(unwrapErr);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) {
                if (err) return cb(err);
                if (!ex) return loadAsFile(path.join(x, 'index'), fpkg, cb);

                readFile(pkgfile, function (err, body) {
                    if (err) return cb(err);
                    try {
                        var pkg = JSON.parse(body);
                    } catch (jsonErr) {}

                    if (pkg && opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }

                    if (pkg && pkg.main) {
                        if (typeof pkg.main !== 'string') {
                            var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');
                            mainError.code = 'INVALID_PACKAGE_MAIN';
                            return cb(mainError);
                        }
                        if (pkg.main === '.' || pkg.main === './') {
                            pkg.main = 'index';
                        }
                        loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {
                            if (err) return cb(err);
                            if (m) return cb(null, m, pkg);
                            if (!pkg) return loadAsFile(path.join(x, 'index'), pkg, cb);

                            var dir = path.resolve(x, pkg.main);
                            loadAsDirectory(dir, pkg, function (err, n, pkg) {
                                if (err) return cb(err);
                                if (n) return cb(null, n, pkg);
                                loadAsFile(path.join(x, 'index'), pkg, cb);
                            });
                        });
                        return;
                    }

                    loadAsFile(path.join(x, '/index'), pkg, cb);
                });
            });
        });
    }

    function processDirs(cb, dirs) {
        if (dirs.length === 0) return cb(null, undefined);
        var dir = dirs[0];

        isDirectory(path.dirname(dir), isdir);

        function isdir(err, isdir) {
            if (err) return cb(err);
            if (!isdir) return processDirs(cb, dirs.slice(1));
            loadAsFile(dir, opts.package, onfile);
        }

        function onfile(err, m, pkg) {
            if (err) return cb(err);
            if (m) return cb(null, m, pkg);
            loadAsDirectory(dir, opts.package, ondir);
        }

        function ondir(err, n, pkg) {
            if (err) return cb(err);
            if (n) return cb(null, n, pkg);
            processDirs(cb, dirs.slice(1));
        }
    }
    function loadNodeModules(x, start, cb) {
        var thunk = function () { return getPackageCandidates(x, start, opts); };
        processDirs(
            cb,
            packageIterator ? packageIterator(x, start, thunk, opts) : thunk()
        );
    }
};


/***/ }),

/***/ 3472:
/***/ ((module) => {

module.exports = function () {
    // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function (_, stack) { return stack; };
    var stack = (new Error()).stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
};


/***/ }),

/***/ 83467:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var current = (process.versions && process.versions.node && process.versions.node.split('.')) || [];

function specifierIncluded(specifier) {
    var parts = specifier.split(' ');
    var op = parts.length > 1 ? parts[0] : '=';
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');

    for (var i = 0; i < 3; ++i) {
        var cur = Number(current[i] || 0);
        var ver = Number(versionParts[i] || 0);
        if (cur === ver) {
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        }
        if (op === '<') {
            return cur < ver;
        } else if (op === '>=') {
            return cur >= ver;
        } else {
            return false;
        }
    }
    return op === '>=';
}

function matchesRange(range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) { return false; }
    for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(specifiers[i])) { return false; }
    }
    return true;
}

function versionIncluded(specifierValue) {
    if (typeof specifierValue === 'boolean') { return specifierValue; }
    if (specifierValue && typeof specifierValue === 'object') {
        for (var i = 0; i < specifierValue.length; ++i) {
            if (matchesRange(specifierValue[i])) { return true; }
        }
        return false;
    }
    return matchesRange(specifierValue);
}

var data = __webpack_require__(9838);

var core = {};
for (var mod in data) { // eslint-disable-line no-restricted-syntax
    if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core[mod] = versionIncluded(data[mod]);
    }
}
module.exports = core;


/***/ }),

/***/ 36567:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var core = __webpack_require__(83467);

module.exports = function isCore(x) {
    return Object.prototype.hasOwnProperty.call(core, x);
};


/***/ }),

/***/ 92310:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var path = __webpack_require__(85622);
var parse = path.parse || __webpack_require__(5980);

var getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {
    var prefix = '/';
    if ((/^([A-Za-z]:)/).test(absoluteStart)) {
        prefix = '';
    } else if ((/^\\\\/).test(absoluteStart)) {
        prefix = '\\\\';
    }

    var paths = [absoluteStart];
    var parsed = parse(absoluteStart);
    while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
    }

    return paths.reduce(function (dirs, aPath) {
        return dirs.concat(modules.map(function (moduleDir) {
            return path.resolve(prefix, aPath, moduleDir);
        }));
    }, []);
};

module.exports = function nodeModulesPaths(start, opts, request) {
    var modules = opts && opts.moduleDirectory
        ? [].concat(opts.moduleDirectory)
        : ['node_modules'];

    if (opts && typeof opts.paths === 'function') {
        return opts.paths(
            request,
            start,
            function () { return getNodeModulesDirs(start, modules); },
            opts
        );
    }

    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
};


/***/ }),

/***/ 86051:
/***/ ((module) => {

module.exports = function (x, opts) {
    /**
     * This file is purposefully a passthrough. It's expected that third-party
     * environments will override it at runtime in order to inject special logic
     * into `resolve` (by manipulating the options). One such example is the PnP
     * code path in Yarn.
     */

    return opts || {};
};


/***/ }),

/***/ 6977:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCore = __webpack_require__(36567);
var fs = __webpack_require__(35747);
var path = __webpack_require__(85622);
var caller = __webpack_require__(3472);
var nodeModulesPaths = __webpack_require__(92310);
var normalizeOptions = __webpack_require__(86051);

var realpathFS = fs.realpathSync && typeof fs.realpathSync.native === 'function' ? fs.realpathSync.native : fs.realpathSync;

var defaultIsFile = function isFile(file) {
    try {
        var stat = fs.statSync(file);
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return stat.isFile() || stat.isFIFO();
};

var defaultIsDir = function isDirectory(dir) {
    try {
        var stat = fs.statSync(dir);
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return stat.isDirectory();
};

var defaultRealpathSync = function realpathSync(x) {
    try {
        return realpathFS(x);
    } catch (realpathErr) {
        if (realpathErr.code !== 'ENOENT') {
            throw realpathErr;
        }
    }
    return x;
};

var maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {
    if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
    }
    return x;
};

var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
};

module.exports = function resolveSync(x, options) {
    if (typeof x !== 'string') {
        throw new TypeError('Path must be a string.');
    }
    var opts = normalizeOptions(x, options);

    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var packageIterator = opts.packageIterator;

    var extensions = opts.extensions || ['.js'];
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || [];

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);

    if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
        var res = path.resolve(absoluteStart, x);
        if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m) return maybeRealpathSync(realpathSync, m, opts);
    } else if (isCore(x)) {
        return x;
    } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n) return maybeRealpathSync(realpathSync, n, opts);
    }

    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;

    function loadAsFileSync(x) {
        var pkg = loadpkg(path.dirname(x));

        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
            var rfile = path.relative(pkg.dir, x);
            var r = opts.pathFilter(pkg.pkg, x, rfile);
            if (r) {
                x = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign
            }
        }

        if (isFile(x)) {
            return x;
        }

        for (var i = 0; i < extensions.length; i++) {
            var file = x + extensions[i];
            if (isFile(file)) {
                return file;
            }
        }
    }

    function loadpkg(dir) {
        if (dir === '' || dir === '/') return;
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
            return;
        }
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return;

        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), 'package.json');

        if (!isFile(pkgfile)) {
            return loadpkg(path.dirname(dir));
        }

        var body = readFileSync(pkgfile);

        try {
            var pkg = JSON.parse(body);
        } catch (jsonErr) {}

        if (pkg && opts.packageFilter) {
            // v2 will pass pkgfile
            pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment
        }

        return { pkg: pkg, dir: dir };
    }

    function loadAsDirectorySync(x) {
        var pkgfile = path.join(maybeRealpathSync(realpathSync, x, opts), '/package.json');
        if (isFile(pkgfile)) {
            try {
                var body = readFileSync(pkgfile, 'UTF8');
                var pkg = JSON.parse(body);
            } catch (e) {}

            if (pkg && opts.packageFilter) {
                // v2 will pass pkgfile
                pkg = opts.packageFilter(pkg, /*pkgfile,*/ x); // eslint-disable-line spaced-comment
            }

            if (pkg && pkg.main) {
                if (typeof pkg.main !== 'string') {
                    var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');
                    mainError.code = 'INVALID_PACKAGE_MAIN';
                    throw mainError;
                }
                if (pkg.main === '.' || pkg.main === './') {
                    pkg.main = 'index';
                }
                try {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                    var n = loadAsDirectorySync(path.resolve(x, pkg.main));
                    if (n) return n;
                } catch (e) {}
            }
        }

        return loadAsFileSync(path.join(x, '/index'));
    }

    function loadNodeModulesSync(x, start) {
        var thunk = function () { return getPackageCandidates(x, start, opts); };
        var dirs = packageIterator ? packageIterator(x, start, thunk, opts) : thunk();

        for (var i = 0; i < dirs.length; i++) {
            var dir = dirs[i];
            if (isDirectory(path.dirname(dir))) {
                var m = loadAsFileSync(dir);
                if (m) return m;
                var n = loadAsDirectorySync(dir);
                if (n) return n;
            }
        }
    }
};


/***/ }),

/***/ 145:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallbackWritable = void 0;
const TerminalWritable_1 = __webpack_require__(41565);
/**
 * This class enables very basic {@link TerminalWritable.onWriteChunk} operations to be implemented
 * as a callback function, avoiding the need to define a subclass of `TerminalWritable`.
 *
 * @remarks
 * `CallbackWritable` is provided as a convenience for very simple situations. For most cases,
 * it is generally preferable to create a proper subclass.
 *
 * @privateRemarks
 * We intentionally do not expose a callback for {@link TerminalWritable.onClose}; if special
 * close behavior is required, it is better to create a subclass.
 *
 * @public
 */
class CallbackWritable extends TerminalWritable_1.TerminalWritable {
    constructor(options) {
        super();
        this._callback = options.onWriteChunk;
    }
    onWriteChunk(chunk) {
        this._callback(chunk);
    }
}
exports.CallbackWritable = CallbackWritable;
//# sourceMappingURL=CallbackWritable.js.map

/***/ }),

/***/ 91224:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiscardStdoutTransform = void 0;
const TerminalTransform_1 = __webpack_require__(59662);
var State;
(function (State) {
    State[State["Okay"] = 0] = "Okay";
    State[State["StderrFragment"] = 1] = "StderrFragment";
    State[State["InsertLinefeed"] = 2] = "InsertLinefeed";
})(State || (State = {}));
/**
 * `DiscardStdoutTransform` discards `stdout` chunks while fixing up malformed `stderr` lines.
 *
 * @remarks
 * Suppose that a poorly behaved process produces output like this:
 *
 * ```ts
 * process.stdout.write('Starting operation...\n');
 * process.stderr.write('An error occurred');
 * process.stdout.write('\nFinishing up\n');
 * process.stderr.write('The process completed with errors\n');
 * ```
 *
 * When `stdout` and `stderr` are combined on the console, the mistake in the output would not be noticeable:
 * ```
 * Starting operation...
 * An error occurred
 * Finishing up
 * The process completed with errors
 * ```
 *
 * However, if we discard `stdout`, then `stderr` is missing a newline:
 * ```
 * An error occurredThe process completed with errors
 * ```
 *
 * Tooling scripts can introduce these sorts of problems via edge cases that are difficult to find and fix.
 * `DiscardStdoutTransform` can discard the `stdout` stream and fix up `stderr`:
 *
 * ```
 * An error occurred
 * The process completed with errors
 * ```
 *
 * @privateRemarks
 * This class is experimental and marked as `@beta`.  The algorithm may need some fine-tuning, or there may
 * be better solutions to this problem.
 *
 * @beta
 */
class DiscardStdoutTransform extends TerminalTransform_1.TerminalTransform {
    constructor(options) {
        super(options);
        this._state = State.Okay;
    }
    onWriteChunk(chunk) {
        if (chunk.text.indexOf('\r') >= 0) {
            throw new Error('DiscardStdoutTransform expects chunks with normalized newlines');
        }
        if (chunk.kind === "O" /* Stdout */) {
            if (this._state === State.StderrFragment) {
                if (chunk.text.indexOf('\n') >= 0) {
                    this._state = State.InsertLinefeed;
                }
            }
        }
        else if (chunk.kind === "E" /* Stderr */) {
            let correctedText;
            if (this._state === State.InsertLinefeed) {
                correctedText = '\n' + chunk.text;
            }
            else {
                correctedText = chunk.text;
            }
            this.destination.writeChunk({ kind: "E" /* Stderr */, text: correctedText });
            if (correctedText.length > 0) {
                if (correctedText[correctedText.length - 1] === '\n') {
                    this._state = State.Okay;
                }
                else {
                    this._state = State.StderrFragment;
                }
            }
        }
        else {
            this.destination.writeChunk(chunk);
        }
    }
}
exports.DiscardStdoutTransform = DiscardStdoutTransform;
//# sourceMappingURL=DiscardStdoutTransform.js.map

/***/ }),

/***/ 63230:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=ITerminalChunk.js.map

/***/ }),

/***/ 1704:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MockWritable = void 0;
const TerminalWritable_1 = __webpack_require__(41565);
const node_core_library_1 = __webpack_require__(65919);
/**
 * A {@link TerminalWritable} subclass for use by unit tests.
 *
 * @beta
 */
class MockWritable extends TerminalWritable_1.TerminalWritable {
    constructor() {
        super(...arguments);
        this.chunks = [];
    }
    onWriteChunk(chunk) {
        this.chunks.push(chunk);
    }
    reset() {
        this.chunks.length = 0;
    }
    getAllOutput() {
        return node_core_library_1.AnsiEscape.formatForTests(this.chunks.map((x) => x.text).join(''));
    }
    getFormattedChunks() {
        return this.chunks.map((x) => (Object.assign(Object.assign({}, x), { text: node_core_library_1.AnsiEscape.formatForTests(x.text) })));
    }
}
exports.MockWritable = MockWritable;
//# sourceMappingURL=MockWritable.js.map

/***/ }),

/***/ 62893:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NormalizeNewlinesTextRewriter = void 0;
const node_core_library_1 = __webpack_require__(65919);
const TextRewriter_1 = __webpack_require__(55220);
/**
 * For use with {@link TextRewriterTransform}, this rewriter converts all newlines to
 * a standard format.
 *
 * @public
 */
class NormalizeNewlinesTextRewriter extends TextRewriter_1.TextRewriter {
    constructor(options) {
        super();
        this.newlineKind = options.newlineKind;
        this.newline = node_core_library_1.Text.getNewline(options.newlineKind);
        this.ensureNewlineAtEnd = !!options.ensureNewlineAtEnd;
    }
    initialize() {
        return {
            characterToIgnore: '',
            incompleteLine: false
        };
    }
    process(unknownState, text) {
        const state = unknownState;
        let result = '';
        if (text.length > 0) {
            let i = 0;
            do {
                const c = text[i];
                ++i;
                if (c === state.characterToIgnore) {
                    state.characterToIgnore = '';
                }
                else if (c === '\r') {
                    result += this.newline;
                    state.characterToIgnore = '\n';
                    state.incompleteLine = false;
                }
                else if (c === '\n') {
                    result += this.newline;
                    state.characterToIgnore = '\r';
                    state.incompleteLine = false;
                }
                else {
                    result += c;
                    state.characterToIgnore = '';
                    state.incompleteLine = true;
                }
            } while (i < text.length);
        }
        return result;
    }
    close(unknownState) {
        const state = unknownState;
        state.characterToIgnore = '';
        if (state.incompleteLine) {
            state.incompleteLine = false;
            return this.newline;
        }
        else {
            return '';
        }
    }
}
exports.NormalizeNewlinesTextRewriter = NormalizeNewlinesTextRewriter;
//# sourceMappingURL=NormalizeNewlinesTextRewriter.js.map

/***/ }),

/***/ 47409:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrintUtilities = exports.DEFAULT_CONSOLE_WIDTH = void 0;
const wordwrap_1 = __importDefault(__webpack_require__(321));
/**
 * A sensible fallback column width for consoles.
 *
 * @public
 */
exports.DEFAULT_CONSOLE_WIDTH = 80;
/**
 * A collection of utilities for printing messages to the console.
 *
 * @public
 */
class PrintUtilities {
    /**
     * Returns the width of the console, measured in columns
     */
    static getConsoleWidth() {
        const stdout = process.stdout;
        if (stdout && stdout.columns) {
            return stdout.columns;
        }
    }
    /**
     * Applies word wrapping.  If maxLineLength is unspecified, then it defaults to the
     * console width.
     */
    static wrapWords(text, maxLineLength, indent) {
        if (!indent) {
            indent = 0;
        }
        if (!maxLineLength) {
            maxLineLength = PrintUtilities.getConsoleWidth() || exports.DEFAULT_CONSOLE_WIDTH;
        }
        const wrap = (0, wordwrap_1.default)(indent, maxLineLength, { mode: 'soft' });
        return wrap(text);
    }
    /**
     * Displays a message in the console wrapped in a box UI.
     *
     * @param boxWidth - The width of the box, defaults to half of the console width.
     */
    static printMessageInBox(message, terminal, boxWidth) {
        if (!boxWidth) {
            const consoleWidth = PrintUtilities.getConsoleWidth() || exports.DEFAULT_CONSOLE_WIDTH;
            boxWidth = Math.floor(consoleWidth / 2);
        }
        const maxLineLength = boxWidth - 10;
        const wrappedMessage = PrintUtilities.wrapWords(message, maxLineLength);
        const wrappedMessageLines = wrappedMessage.split('\n');
        // 
        //   Message  
        // 
        terminal.writeLine(` ${''.repeat(boxWidth - 2)} `);
        for (const line of wrappedMessageLines) {
            const trimmedLine = line.trim();
            const padding = boxWidth - trimmedLine.length - 2;
            const leftPadding = Math.floor(padding / 2);
            const rightPadding = padding - leftPadding;
            terminal.writeLine(` ${' '.repeat(leftPadding)}${trimmedLine}${' '.repeat(rightPadding)} `);
        }
        terminal.writeLine(` ${''.repeat(boxWidth - 2)} `);
    }
}
exports.PrintUtilities = PrintUtilities;
//# sourceMappingURL=PrintUtilities.js.map

/***/ }),

/***/ 50247:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RemoveColorsTextRewriter = void 0;
const node_core_library_1 = __webpack_require__(65919);
const TextRewriter_1 = __webpack_require__(55220);
var State;
(function (State) {
    // Buffer is empty, and we're looking for the ESC character
    State[State["Start"] = 0] = "Start";
    // We're looking for the '[' character
    State[State["AwaitingBracket"] = 1] = "AwaitingBracket";
    // We're reading the codes after the '[' character
    State[State["ReadingCodes"] = 2] = "ReadingCodes";
})(State || (State = {}));
/**
 * For use with {@link TextRewriterTransform}, this rewriter removes ANSI escape codes
 * including colored text.
 *
 * @remarks
 * The implementation also removes other ANSI escape codes such as cursor positioning.
 * The specific set of affected codes may be adjusted in the future.
 *
 * @public
 */
class RemoveColorsTextRewriter extends TextRewriter_1.TextRewriter {
    initialize() {
        return { buffer: '', parseState: State.Start };
    }
    process(unknownState, text) {
        const state = unknownState;
        // We will be matching AnsiEscape._csiRegExp:
        //
        //  /\x1b\[([\x30-\x3f]*[\x20-\x2f]*[\x40-\x7e])/gu
        //
        const ESC = '\x1b';
        let result = '';
        let index = 0;
        while (index < text.length) {
            if (state.parseState === State.Start) {
                // The buffer is empty, which means we haven't found anything yet
                const csiIndex = text.indexOf(ESC, index);
                if (csiIndex < 0) {
                    // We reached the end of "text" without finding another CSI prefix
                    result += text.substring(index);
                    break;
                }
                // Append everything up to the CSI prefix
                result += text.substring(index, csiIndex);
                // Save the partial match in the buffer
                state.buffer = ESC;
                index = csiIndex + 1;
                state.parseState = State.AwaitingBracket;
            }
            else {
                // The buffer has characters, which means we started matching a partial sequence
                // Read another character into the buffer
                const c = text[index];
                ++index;
                state.buffer += c;
                if (state.parseState === State.AwaitingBracket) {
                    if (c === '[') {
                        state.parseState = State.ReadingCodes;
                    }
                    else {
                        // Failed to match, so append the buffer and start over
                        result += state.buffer;
                        state.buffer = '';
                        state.parseState = State.Start;
                    }
                }
                else {
                    // state.state === State.ReadingCodes
                    // Stop when we reach any character that is not [\x30-\x3f] or [\x20-\x2f]
                    const code = c.charCodeAt(0);
                    if (code < 0x20 || code > 0x3f) {
                        result += node_core_library_1.AnsiEscape.removeCodes(state.buffer);
                        state.buffer = '';
                        state.parseState = State.Start;
                    }
                }
            }
        }
        return result;
    }
    close(unknownState) {
        const state = unknownState;
        const result = state.buffer;
        state.buffer = '';
        return result;
    }
}
exports.RemoveColorsTextRewriter = RemoveColorsTextRewriter;
//# sourceMappingURL=RemoveColorsTextRewriter.js.map

/***/ }),

/***/ 57139:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SplitterTransform = void 0;
const TerminalWritable_1 = __webpack_require__(41565);
/**
 * Use this instead of {@link TerminalTransform} if you need to output `ITerminalChunk`
 * data to more than one destination.
 *
 * @remarks
 *
 * Splitting streams complicates the pipeline topology and can make debugging more difficult.
 * For this reason, it is modeled as an explicit `SplitterTransform` node, rather than
 * as a built-in feature of `TerminalTransform`.
 *
 * @public
 */
class SplitterTransform extends TerminalWritable_1.TerminalWritable {
    constructor(options) {
        super();
        this.destinations = [...options.destinations];
    }
    onWriteChunk(chunk) {
        for (const destination of this.destinations) {
            destination.writeChunk(chunk);
        }
    }
    onClose() {
        const errors = [];
        // If an exception is thrown, try to ensure that the other destinations get closed properly
        for (const destination of this.destinations) {
            if (!destination.preventAutoclose) {
                try {
                    destination.close();
                }
                catch (error) {
                    errors.push(error);
                }
            }
        }
        if (errors.length > 0) {
            throw errors[0];
        }
    }
}
exports.SplitterTransform = SplitterTransform;
//# sourceMappingURL=SplitterTransform.js.map

/***/ }),

/***/ 65229:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StderrLineTransform = void 0;
const node_core_library_1 = __webpack_require__(65919);
const TerminalTransform_1 = __webpack_require__(59662);
/**
 * `StderrLineTransform` normalizes lines that mix characters from `stdout` and `stderr`,
 * so that each output line is routed entirely to `stdout` or `stderr`.
 *
 * @remarks
 * IMPORTANT: This transform assumes that its input has been normalized to use `"\n"` newlines.
 *
 * IMPORTANT: This transform does not produce realtime output, because lines are buffered
 * until a newline character is encountered.
 *
 * Suppose that a poorly behaved process produces output like this:
 *
 * ```ts
 * process.stderr.write('An error occurred, cleaning up');
 * process.stdout.write('.'); // (delay)
 * process.stdout.write('.'); // (delay)
 * process.stdout.write('.');
 * process.stdout.write('\n');
 * process.stderr.write('The process completed with errors\n');
 * ```
 *
 * When `stdout` and `stderr` are combined on the console, the mistake in the output would not be noticeable:
 * ```
 * An error occurred, cleaning up...
 * The process completed with errors
 * ```
 *
 * However, if we discard `stdout`, then `stderr` is malformed:
 * ```
 * An error occurred, cleaning upThe process completed with errors
 * ```
 *
 * Tooling scripts can introduce these sorts of problems via edge cases that are difficult to find and fix.
 *
 * `StderrLineTransform` normalizes the output so that if a combined line contains any `stderr` characters,
 * then the entire line is routed to `stderr`.  Later, if we discard `stdout`, then the output will
 * preserve the appropriate context:
 *
 * ```
 * An error occurred, cleaning up...
 * The process completed with errors
 * ```
 *
 * @privateRemarks
 * This class is experimental and marked as `@beta`.  The algorithm may need some fine-tuning, or there may
 * be better solutions to this problem.
 *
 * @beta
 */
class StderrLineTransform extends TerminalTransform_1.TerminalTransform {
    constructor(options) {
        super(options);
        this._accumulatedLine = '';
        this._accumulatedStderr = false;
        this.newline = node_core_library_1.Text.getNewline(options.newlineKind || "\n" /* Lf */);
    }
    onWriteChunk(chunk) {
        if (chunk.text.indexOf('\r') >= 0) {
            throw new Error('StderrLineTransform expects chunks with normalized newlines');
        }
        // After _newlineNormalizerTransform was applied, we can now assume that all newlines
        // use the "\n" string
        const text = chunk.text;
        let startIndex = 0;
        while (startIndex < text.length) {
            if (chunk.kind === "E" /* Stderr */) {
                this._accumulatedStderr = true;
            }
            const endIndex = text.indexOf('\n', startIndex);
            if (endIndex < 0) {
                // we did not find \n, so simply append
                this._accumulatedLine += text.substring(startIndex);
                break;
            }
            // append everything up to \n
            this._accumulatedLine += text.substring(startIndex, endIndex);
            this._processAccumulatedLine();
            // skip the \n
            startIndex = endIndex + 1;
        }
    }
    onClose() {
        if (this._accumulatedLine.length > 0) {
            this._processAccumulatedLine();
        }
        this.autocloseDestination();
    }
    _processAccumulatedLine() {
        this._accumulatedLine += this.newline;
        if (this._accumulatedStderr) {
            this.destination.writeChunk({
                kind: "E" /* Stderr */,
                text: this._accumulatedLine
            });
        }
        else {
            this.destination.writeChunk({
                kind: "O" /* Stdout */,
                text: this._accumulatedLine
            });
        }
        this._accumulatedLine = '';
        this._accumulatedStderr = false;
    }
}
exports.StderrLineTransform = StderrLineTransform;
//# sourceMappingURL=StdioLineTransform.js.map

/***/ }),

/***/ 36438:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StdioSummarizer = void 0;
const TerminalWritable_1 = __webpack_require__(41565);
/**
 * Summarizes the results of a failed build task by returning a subset of `stderr` output not to exceed
 * a specified maximum number of lines.
 *
 * @remarks
 * IMPORTANT: This transform assumes that its input was prepared by {@link StderrLineTransform}, so that each
 * {@link ITerminalChunk.text} item is a single line terminated by a `"\n"` character.
 *
 * The {@link IStdioSummarizerOptions.leadingLines} and {@link IStdioSummarizerOptions.trailingLines}
 * counts specify the maximum number of lines to be returned. Any additional lines will be omitted.
 * For example, if `leadingLines` and `trailingLines` were set to `3`, then the summary of 16 `stderr` lines might
 * look like this:
 *
 * ```
 * Line 1
 * Line 2
 * Line 3
 *   ...10 lines omitted...
 * Line 14
 * Line 15
 * Line 16
 * ```
 *
 * If the `stderr` output is completely empty, then the `stdout` output will be summarized instead.
 *
 * @beta
 */
class StdioSummarizer extends TerminalWritable_1.TerminalWritable {
    constructor(options) {
        super();
        this._abridgedOmittedLines = 0;
        if (!options) {
            options = {};
        }
        this._leadingLines = options.leadingLines !== undefined ? options.leadingLines : 10;
        this._trailingLines = options.trailingLines !== undefined ? options.trailingLines : 10;
        this._abridgedLeading = [];
        this._abridgedTrailing = [];
        this._abridgedStderr = false;
    }
    /**
     * Returns the summary report.
     *
     * @remarks
     * The `close()` method must be called before `getReport()` can be used.
     */
    getReport() {
        if (this.isOpen) {
            throw new Error('The summary cannot be prepared until after close() is called.');
        }
        const report = [...this._abridgedLeading];
        if (this._abridgedOmittedLines === 1) {
            report.push(`  ...${this._abridgedOmittedLines} line omitted...\n`);
        }
        if (this._abridgedOmittedLines > 1) {
            report.push(`  ...${this._abridgedOmittedLines} lines omitted...\n`);
        }
        report.push(...this._abridgedTrailing);
        return report.join('');
    }
    onWriteChunk(chunk) {
        if (chunk.text.length === 0 || chunk.text[chunk.text.length - 1] !== '\n') {
            throw new Error('StdioSummarizer expects chunks that were separated parsed into lines by StderrLineTransform\n' +
                ' Invalid input: ' +
                JSON.stringify(chunk.text));
        }
        if (chunk.kind === "E" /* Stderr */ && !this._abridgedStderr) {
            // The first time we see stderr, switch to capturing stderr
            this._abridgedStderr = true;
            this._abridgedLeading.length = 0;
            this._abridgedTrailing.length = 0;
            this._abridgedOmittedLines = 0;
        }
        else if (this._abridgedStderr && chunk.kind !== "E" /* Stderr */) {
            // If we're capturing stderr, then ignore non-stderr input
            return;
        }
        // Did we capture enough leading lines?
        if (this._abridgedLeading.length < this._leadingLines) {
            this._abridgedLeading.push(chunk.text);
            return;
        }
        this._abridgedTrailing.push(chunk.text);
        // If we captured to many trailing lines, omit the extras
        while (this._abridgedTrailing.length > this._trailingLines) {
            this._abridgedTrailing.shift();
            ++this._abridgedOmittedLines;
        }
    }
}
exports.StdioSummarizer = StdioSummarizer;
//# sourceMappingURL=StdioSummarizer.js.map

/***/ }),

/***/ 42370:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StdioWritable = void 0;
const process_1 = __importDefault(__webpack_require__(61765));
const TerminalWritable_1 = __webpack_require__(41565);
/**
 * A {@link TerminalWritable} subclass that writes its output directly to the process `stdout` and `stderr`
 * streams.
 *
 * @remarks
 * This is the standard output target for a process.  You normally do not need to construct
 * this class; the {@link StdioWritable."instance"} singleton can be used instead.
 *
 * @public
 */
class StdioWritable extends TerminalWritable_1.TerminalWritable {
    onWriteChunk(chunk) {
        if (chunk.kind === "O" /* Stdout */) {
            process_1.default.stdout.write(chunk.text);
        }
        else if (chunk.kind === "E" /* Stderr */) {
            process_1.default.stderr.write(chunk.text);
        }
    }
}
exports.StdioWritable = StdioWritable;
StdioWritable.instance = new StdioWritable();
//# sourceMappingURL=StdioWritable.js.map

/***/ }),

/***/ 59662:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TerminalTransform = void 0;
const TerminalWritable_1 = __webpack_require__(41565);
/**
 * The abstract base class for {@link TerminalWritable} objects that receive an input,
 * transform it somehow, and then write the output to another `TerminalWritable`.
 *
 * @remarks
 *
 * The `TerminalTransform` and {@link SplitterTransform} base classes formalize the idea
 * of modeling data flow as a directed acyclic graph of reusable transforms, whose
 * final outputs are `TerminalWritable` objects.
 *
 * The design is based loosely on the `WritableStream` and `TransformStream` classes from
 * the system {@link https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Concepts
 * | Streams API}, except that instead of asynchronous byte streams, the `TerminalWritable`
 * system synchronously transmits human readable messages intended to be rendered on a
 * text console or log file.
 *
 * The main feature of the `TerminalTransform` class is its {@link TerminalTransform.destination}
 * property, which tracks the next link in the graph.
 *
 * @public
 */
class TerminalTransform extends TerminalWritable_1.TerminalWritable {
    constructor(options) {
        super();
        this.destination = options.destination;
        this.preventDestinationAutoclose = !!options.preventDestinationAutoclose;
    }
    /** @override */
    onClose() {
        this.autocloseDestination();
    }
    /**
     * The default implementation of {@link TerminalTransform.onClose} calls this
     * method, which closes the {@link TerminalTransform.destination} if appropriate.
     *
     * @remarks
     * The destination will not be closed if its {@link TerminalWritable.preventAutoclose}
     * property is `true`.  The destination will not be closed if
     * {@link ITerminalTransformOptions.preventDestinationAutoclose}
     * is `true`.
     *
     * @sealed
     */
    autocloseDestination() {
        if (!this.preventDestinationAutoclose && !this.destination.preventAutoclose) {
            this.destination.close();
        }
    }
}
exports.TerminalTransform = TerminalTransform;
//# sourceMappingURL=TerminalTransform.js.map

/***/ }),

/***/ 41565:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TerminalWritable = void 0;
/**
 * The abstract base class for objects that can present, route, or process text output for
 * a console application.  This output is typically prepared using
 * the {@link @rushstack/node-core-library#Terminal} API.
 *
 * @remarks
 *
 * The design is based loosely on the `WritableStream` and `TransformStream` classes from
 * the system {@link https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Concepts
 * | Streams API}, except that instead of asynchronous byte streams, the `TerminalWritable`
 * system synchronously transmits human readable messages intended to be rendered on a text
 * console or log file.
 *
 * Consider a console application whose output may need to be processed in different ways
 * before finally being output.  The conceptual block diagram might look like this:
 *
 * ```
 *          [Terminal API]
 *                 |
 *                 V
 *        [normalize newlines]
 *                 |
 *                 V
 *       +----[splitter]-------+
 *       |                     |
 *       V                     V
 *   [shell console]     [remove ANSI colors]
 *                             |
 *                             V
 *                       [write to build.log]
 * ```
 *
 * The application uses the `Terminal` API to print `stdout` and `stderr` messages, for example with standardized
 * formatting for errors and warnings, and ANSI escapes to make nice colors.  Maybe it also includes text
 * received from external processes, whose newlines may be inconsistent.  Ultimately we want to write the
 * output to the shell console and a `build.log` file, but we don't want to put ANSI colors in the build log.
 *
 * For the above example, `[shell console]` and `[write to build.log]` would be modeled as subclasses of
 * `TerminalWritable`.  The `[normalize newlines]` and `[remove ANSI colors]` steps are modeled as subclasses
 * of {@link TerminalTransform}, because they output to a "destination" object.  The `[splitter]` would be
 * implemented using {@link SplitterTransform}.
 *
 * The stream of messages are {@link ITerminalChunk} objects, which can represent both `stdout` and `stderr`
 * channels.  The pipeline operates synchronously on each chunk, but by processing one chunk at a time,
 * it avoids storing the entire output in memory.  This means that operations like `[remove ANSI colors]`
 * cannot be simple regular expressions -- they must be implemented as state machines ({@link TextRewriter}
 * subclasses) capable of matching substrings that span multiple chunks.
 *
 * @public
 */
class TerminalWritable {
    constructor(options) {
        this._isOpen = true;
        if (!options) {
            options = {};
        }
        this.preventAutoclose = !!options.preventAutoclose;
    }
    /**
     * This property is initially `true` when the object is constructed, and becomes `false`
     * when `close()` is called.
     * @sealed
     */
    get isOpen() {
        return this._isOpen;
    }
    /**
     * Upstream objects call this method to provide inputs to this object.
     *
     * @remarks
     * The subclass provides its implementation via the the {@link TerminalWritable.onWriteChunk}
     * method, which is called by `writeChunk()`.
     *
     * The object that calls `writeChunk()` must call `close()` when it is finished;
     * failing to do so may introduce a resource leak, or may prevent some buffered data from
     * being written.
     *
     * @sealed
     */
    writeChunk(chunk) {
        if (!this._isOpen) {
            throw new Error('Writer was already closed');
        }
        this.onWriteChunk(chunk);
    }
    /**
     * Calling this method flushes any remaining outputs and permanently transitions the
     * `TerminalWritable` to a "closed" state, where no further chunks can be written.
     *
     * @remarks
     * The subclass provides its implementation via the the {@link TerminalWritable.onClose}
     * method, which is called by `close()`.
     *
     * If this method is called more than once, the additional calls are ignored;
     * `TerminalWritable.onClose` will be called at most once.
     *
     * @sealed
     */
    close() {
        if (this._isOpen) {
            this.onClose();
            this._isOpen = false;
        }
    }
    /**
     * Subclasses can override this empty method to perform additional operations
     * such as closing a file handle.
     *
     * @remarks
     * It is guaranteed that this method will be called at most once during the lifetime
     * of a `TerminalWritable` object.
     *
     * @virtual
     */
    onClose() { }
}
exports.TerminalWritable = TerminalWritable;
//# sourceMappingURL=TerminalWritable.js.map

/***/ }),

/***/ 55220:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextRewriter = void 0;
/**
 * The abstract base class for operations that can be applied by {@link TextRewriterTransform}.
 *
 * @remarks
 * The {@link TextRewriterTransform} applies one or more character rewriting operations to its
 * chunk stream.  Since these operations are applied separately to `stderr` and `stdout`, the
 * state is stored in an opaque `TextRewriterState` object.
 *
 * Conceptually, a `TextRewriter` subclass is very similar to a regular expression, with the difference
 * that `RegExp` operates on a text string, whereas `TextRewriter` operates on a stream of characters.
 *
 * The two most common subclasses are {@link NormalizeNewlinesTextRewriter} and {@link RemoveColorsTextRewriter}.
 *
 * A rewriting operation starts with `initialize()`, followed by any number of `process()` calls, and
 * then finishes with `close()`.  For example:
 *
 * ```ts
 * const rewriter: NormalizeNewlinesTextRewriter = new NormalizeNewlinesTextRewriter(NewlineKind.Lf);
 * const state: TextRewriterState = rewriter.initialize();
 * let output: string = rewriter.process(state, 'line 1\r');
 * output += rewriter.process(state, '\nline 2\r\n');
 * output += rewriter.close(state);
 *
 * // The final "output" value is: "line 1\nline 2\n"
 * ```
 *
 * After `close()` has been called, the `TextRewriterState` state should not be reused.
 *
 * @public
 */
class TextRewriter {
}
exports.TextRewriter = TextRewriter;
//# sourceMappingURL=TextRewriter.js.map

/***/ }),

/***/ 72629:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextRewriterTransform = void 0;
const TerminalTransform_1 = __webpack_require__(59662);
const RemoveColorsTextRewriter_1 = __webpack_require__(50247);
const NormalizeNewlinesTextRewriter_1 = __webpack_require__(62893);
/**
 * A {@link TerminalTransform} subclass that performs one or more {@link TextRewriter} operations.
 * The most common operations are {@link NormalizeNewlinesTextRewriter} and {@link RemoveColorsTextRewriter}.
 *
 * @remarks
 * The `TextRewriter` operations are applied separately to the `stderr` and `stdout` streams.
 * If multiple {@link ITextRewriterTransformOptions.textRewriters} are configured, they are applied
 * in the order that they appear in the array.
 *
 * @public
 */
class TextRewriterTransform extends TerminalTransform_1.TerminalTransform {
    constructor(options) {
        super(options);
        const textRewriters = options.textRewriters || [];
        if (options.removeColors) {
            textRewriters.push(new RemoveColorsTextRewriter_1.RemoveColorsTextRewriter());
        }
        if (options.normalizeNewlines) {
            textRewriters.push(new NormalizeNewlinesTextRewriter_1.NormalizeNewlinesTextRewriter({
                newlineKind: options.normalizeNewlines,
                ensureNewlineAtEnd: options.ensureNewlineAtEnd
            }));
        }
        if (textRewriters.length === 0) {
            throw new Error('TextRewriterTransform requires at least one matcher');
        }
        this.textRewriters = textRewriters;
        this._stderrStates = this.textRewriters.map((x) => x.initialize());
        this._stdoutStates = this.textRewriters.map((x) => x.initialize());
    }
    onWriteChunk(chunk) {
        if (chunk.kind === "E" /* Stderr */) {
            this._processText(chunk, this._stderrStates);
        }
        else if (chunk.kind === "O" /* Stdout */) {
            this._processText(chunk, this._stdoutStates);
        }
        else {
            this.destination.writeChunk(chunk);
        }
    }
    _processText(chunk, states) {
        let text = chunk.text;
        for (let i = 0; i < states.length; ++i) {
            if (text.length > 0) {
                text = this.textRewriters[i].process(states[i], text);
            }
        }
        if (text.length > 0) {
            // If possible, avoid allocating a new chunk
            if (text === chunk.text) {
                this.destination.writeChunk(chunk);
            }
            else {
                this.destination.writeChunk({
                    text: text,
                    kind: chunk.kind
                });
            }
        }
    }
    _closeRewriters(states, chunkKind) {
        let text = '';
        for (let i = 0; i < states.length; ++i) {
            if (text.length > 0) {
                text = this.textRewriters[i].process(states[i], text);
            }
            text += this.textRewriters[i].close(states[i]);
        }
        if (text.length > 0) {
            this.destination.writeChunk({
                text: text,
                kind: chunkKind
            });
        }
    }
    onClose() {
        this._closeRewriters(this._stderrStates, "E" /* Stderr */);
        this._closeRewriters(this._stderrStates, "O" /* Stdout */);
        this.autocloseDestination();
    }
}
exports.TextRewriterTransform = TextRewriterTransform;
//# sourceMappingURL=TextRewriterTransform.js.map

/***/ }),

/***/ 11253:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * This library implements a system for processing human readable text that
 * will be output by console applications.
 *
 * @remarks
 * See the {@link TerminalWritable} documentation for an overview of the major concepts.
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(145), exports);
__exportStar(__webpack_require__(91224), exports);
__exportStar(__webpack_require__(63230), exports);
__exportStar(__webpack_require__(1704), exports);
__exportStar(__webpack_require__(62893), exports);
__exportStar(__webpack_require__(47409), exports);
__exportStar(__webpack_require__(50247), exports);
__exportStar(__webpack_require__(57139), exports);
__exportStar(__webpack_require__(65229), exports);
__exportStar(__webpack_require__(36438), exports);
__exportStar(__webpack_require__(42370), exports);
__exportStar(__webpack_require__(59662), exports);
__exportStar(__webpack_require__(41565), exports);
__exportStar(__webpack_require__(55220), exports);
__exportStar(__webpack_require__(72629), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 51050:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AlreadyReportedError = void 0;
const TypeUuid_1 = __webpack_require__(51567);
const uuidAlreadyReportedError = 'f26b0640-a49b-49d1-9ead-1a516d5920c7';
/**
 * This exception can be thrown to indicate that an operation failed and an error message has already
 * been reported appropriately. Thus, the catch handler does not have responsibility for reporting
 * the error.
 *
 * @remarks
 * For example, suppose a tool writes interactive output to `console.log()`.  When an exception is thrown,
 * the `catch` handler will typically provide simplistic reporting such as this:
 *
 * ```ts
 * catch (error) {
 *   console.log("ERROR: " + error.message);
 * }
 * ```
 *
 * Suppose that the code performing the operation normally prints rich output to the console.  It may be able to
 * present an error message more nicely (for example, as part of a table, or structured log format).  Throwing
 * `AlreadyReportedError` provides a way to use exception handling to abort the operation, but instruct the `catch`
 * handler not to print an error a second time:
 *
 * ```ts
 * catch (error) {
 *   if (error instanceof AlreadyReportedError) {
 *     return;
 *   }
 *   console.log("ERROR: " + error.message);
 * }
 * ```
 *
 * @public
 */
class AlreadyReportedError extends Error {
    constructor() {
        super('An error occurred.');
        // Manually set the prototype, as we can no longer extend built-in classes like Error, Array, Map, etc
        // [https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work](https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work)
        //
        // Note: the prototype must also be set on any classes which extend this one
        this.__proto__ = AlreadyReportedError.prototype; // eslint-disable-line @typescript-eslint/no-explicit-any
    }
    static [Symbol.hasInstance](instance) {
        return TypeUuid_1.TypeUuid.isInstanceOf(instance, uuidAlreadyReportedError);
    }
}
exports.AlreadyReportedError = AlreadyReportedError;
TypeUuid_1.TypeUuid.registerClass(AlreadyReportedError, uuidAlreadyReportedError);
//# sourceMappingURL=AlreadyReportedError.js.map

/***/ }),

/***/ 40223:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Async = void 0;
/**
 * Utilities for parallel asynchronous operations, for use with the system `Promise` APIs.
 *
 * @beta
 */
class Async {
    /**
     * Given an input array and a `callback` function, invoke the callback to start a
     * promise for each element in the array.  Returns an array containing the results.
     *
     * @remarks
     * This API is similar to the system `Array#map`, except that the loop is asynchronous,
     * and the maximum number of concurrent promises can be throttled
     * using {@link IAsyncParallelismOptions.concurrency}.
     *
     * If `callback` throws a synchronous exception, or if it returns a promise that rejects,
     * then the loop stops immediately.  Any remaining array items will be skipped, and
     * overall operation will reject with the first error that was encountered.
     *
     * @param iterable - the array of inputs for the callback function
     * @param callback - a function that starts an asynchronous promise for an element
     *   from the array
     * @param options - options for customizing the control flow
     * @returns an array containing the result for each callback, in the same order
     *   as the original input `array`
     */
    static async mapAsync(iterable, callback, options) {
        const result = [];
        await Async.forEachAsync(iterable, async (item, arrayIndex) => {
            result[arrayIndex] = await callback(item, arrayIndex);
        }, options);
        return result;
    }
    /**
     * Given an input array and a `callback` function, invoke the callback to start a
     * promise for each element in the array.
     *
     * @remarks
     * This API is similar to the system `Array#forEach`, except that the loop is asynchronous,
     * and the maximum number of concurrent promises can be throttled
     * using {@link IAsyncParallelismOptions.concurrency}.
     *
     * If `callback` throws a synchronous exception, or if it returns a promise that rejects,
     * then the loop stops immediately.  Any remaining array items will be skipped, and
     * overall operation will reject with the first error that was encountered.
     *
     * @param iterable - the array of inputs for the callback function
     * @param callback - a function that starts an asynchronous promise for an element
     *   from the array
     * @param options - options for customizing the control flow
     */
    static async forEachAsync(iterable, callback, options) {
        await new Promise((resolve, reject) => {
            const concurrency = (options === null || options === void 0 ? void 0 : options.concurrency) && options.concurrency > 0 ? options.concurrency : Infinity;
            let operationsInProgress = 0;
            const iterator = (iterable[Symbol.iterator] ||
                iterable[Symbol.asyncIterator]).call(iterable);
            let arrayIndex = 0;
            let iteratorIsComplete = false;
            let promiseHasResolvedOrRejected = false;
            async function queueOperationsAsync() {
                while (operationsInProgress < concurrency && !iteratorIsComplete && !promiseHasResolvedOrRejected) {
                    const currentIteratorResult = await iterator.next();
                    // eslint-disable-next-line require-atomic-updates
                    iteratorIsComplete = !!currentIteratorResult.done;
                    if (!iteratorIsComplete) {
                        operationsInProgress++;
                        Promise.resolve(callback(currentIteratorResult.value, arrayIndex++))
                            .then(async () => {
                            operationsInProgress--;
                            await onOperationCompletionAsync();
                        })
                            .catch((error) => {
                            promiseHasResolvedOrRejected = true;
                            reject(error);
                        });
                    }
                }
                if (iteratorIsComplete) {
                    await onOperationCompletionAsync();
                }
            }
            async function onOperationCompletionAsync() {
                if (!promiseHasResolvedOrRejected) {
                    if (operationsInProgress === 0 && iteratorIsComplete) {
                        promiseHasResolvedOrRejected = true;
                        resolve();
                    }
                    else if (!iteratorIsComplete) {
                        await queueOperationsAsync();
                    }
                }
            }
            queueOperationsAsync().catch((error) => {
                promiseHasResolvedOrRejected = true;
                reject(error);
            });
        });
    }
    /**
     * Return a promise that resolves after the specified number of milliseconds.
     */
    static async sleep(ms) {
        await new Promise((resolve) => {
            setTimeout(resolve, ms);
        });
    }
}
exports.Async = Async;
//# sourceMappingURL=Async.js.map

/***/ }),

/***/ 45008:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Enum = void 0;
/**
 * A helper for looking up TypeScript `enum` keys/values.
 *
 * @remarks
 * TypeScript enums implement a lookup table for mapping between their keys and values:
 *
 * ```ts
 * enum Colors {
 *   Red = 1
 * }
 *
 * // Prints "Red"
 * console.log(Colors[1]);
 *
 * // Prints "1"
 * console.log(Colors["Red]);
 * ```
 *
 * However the compiler's "noImplicitAny" validation has trouble with these mappings, because
 * there are so many possible types for the map elements:
 *
 * ```ts
 * function f(s: string): Colors | undefined {
 *   // (TS 7015) Element implicitly has an 'any' type because
 *   // index expression is not of type 'number'.
 *   return Colors[s];
 * }
 * ```
 *
 * The `Enum` helper provides a more specific, strongly typed way to access members:
 *
 * ```ts
 * function f(s: string): Colors | undefined {
 *   return Enum.tryGetValueByKey(Colors, s);
 * }
 * ```
 *
 * @public
 */
class Enum {
    constructor() { }
    /**
     * Returns an enum value, given its key. Returns `undefined` if no matching key is found.
     *
     * @example
     *
     * Example usage:
     * ```ts
     * enum Colors {
     *   Red = 1
     * }
     *
     * // Prints "1"
     * console.log(Enum.tryGetValueByKey(Colors, "Red"));
     *
     * // Prints "undefined"
     * console.log(Enum.tryGetValueByKey(Colors, "Black"));
     * ```
     */
    static tryGetValueByKey(enumObject, key) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return enumObject[key];
    }
    /**
     * This API is similar to {@link Enum.tryGetValueByKey}, except that it throws an exception
     * if the key is undefined.
     */
    static getValueByKey(enumObject, key) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const result = enumObject[key];
        if (result === undefined) {
            throw new Error(`The lookup key ${JSON.stringify(key)} is not defined`);
        }
        return result;
    }
    /**
     * Returns an enum string key, given its numeric value.  Returns `undefined` if no matching value
     * is found.
     *
     * @remarks
     * The TypeScript compiler only creates a reverse mapping for enum members whose value is numeric.
     * For example:
     *
     * ```ts
     * enum E {
     *   A = 1,
     *   B = 'c'
     * }
     *
     * // Prints "A"
     * console.log(E[1]);
     *
     * // Prints "undefined"
     * console.log(E["c"]);
     * ```
     *
     * @example
     *
     * Example usage:
     * ```ts
     * enum Colors {
     *   Red = 1,
     *   Blue = 'blue'
     * }
     *
     * // Prints "Red"
     * console.log(Enum.tryGetKeyByNumber(Colors, 1));
     *
     * // Prints "undefined"
     * console.log(Enum.tryGetKeyByNumber(Colors, -1));
     * ```
     */
    static tryGetKeyByNumber(enumObject, value) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return enumObject[value];
    }
    /**
     * This API is similar to {@link Enum.tryGetKeyByNumber}, except that it throws an exception
     * if the key is undefined.
     */
    static getKeyByNumber(enumObject, value) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const result = enumObject[value];
        if (result === undefined) {
            throw new Error(`The value ${value} does not exist in the mapping`);
        }
        return result;
    }
}
exports.Enum = Enum;
//# sourceMappingURL=Enum.js.map

/***/ }),

/***/ 47897:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnvironmentMap = void 0;
const process_1 = __importDefault(__webpack_require__(61765));
const InternalError_1 = __webpack_require__(20318);
/**
 * A map data structure that stores process environment variables.  On Windows
 * operating system, the variable names are case-insensitive.
 * @public
 */
class EnvironmentMap {
    constructor(environmentObject = {}) {
        this._map = new Map();
        // This property helps catch a mistake where an instance of `EnvironmentMap` is accidentally passed to
        // a function that expects a `Record<string, string>` (as would be used with the `process.env` API).
        // The property getter will throw an exception if that function tries to enumerate the object values.
        Object.defineProperty(this, '_sanityCheck', {
            enumerable: true,
            get: function () {
                throw new InternalError_1.InternalError('Attempt to read EnvironmentMap class as an object');
            }
        });
        this.caseSensitive = process_1.default.platform !== 'win32';
        this.mergeFromObject(environmentObject);
    }
    /**
     * Clears all entries, resulting in an empty map.
     */
    clear() {
        this._map.clear();
    }
    /**
     * Assigns the variable to the specified value.  A previous value will be overwritten.
     *
     * @remarks
     * The value can be an empty string.  To completely remove the entry, use
     * {@link EnvironmentMap.unset} instead.
     */
    set(name, value) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        this._map.set(key, { name: name, value });
    }
    /**
     * Removes the key from the map, if present.
     */
    unset(name) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        this._map.delete(key);
    }
    /**
     * Returns the value of the specified variable, or `undefined` if the map does not contain that name.
     */
    get(name) {
        const key = this.caseSensitive ? name : name.toUpperCase();
        const entry = this._map.get(key);
        if (entry === undefined) {
            return undefined;
        }
        return entry.value;
    }
    /**
     * Returns the map keys, which are environment variable names.
     */
    names() {
        return this._map.keys();
    }
    /**
     * Returns the map entries.
     */
    entries() {
        return this._map.values();
    }
    /**
     * Adds each entry from `environmentMap` to this map.
     */
    mergeFrom(environmentMap) {
        for (const entry of environmentMap.entries()) {
            this.set(entry.name, entry.value);
        }
    }
    /**
     * Merges entries from a plain JavaScript object, such as would be used with the `process.env` API.
     */
    mergeFromObject(environmentObject = {}) {
        for (const [name, value] of Object.entries(environmentObject)) {
            if (value !== undefined) {
                this.set(name, value);
            }
        }
    }
    /**
     * Returns the keys as a plain JavaScript object similar to the object returned by the `process.env` API.
     */
    toObject() {
        const result = {};
        for (const entry of this.entries()) {
            result[entry.name] = entry.value;
        }
        return result;
    }
}
exports.EnvironmentMap = EnvironmentMap;
//# sourceMappingURL=EnvironmentMap.js.map

/***/ }),

/***/ 14015:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Executable = void 0;
const child_process = __importStar(__webpack_require__(63129));
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const EnvironmentMap_1 = __webpack_require__(47897);
const FileSystem_1 = __webpack_require__(29371);
/**
 * The Executable class provides a safe, portable, recommended solution for tools that need
 * to launch child processes.
 *
 * @remarks
 * The NodeJS child_process API provides a solution for launching child processes, however
 * its design encourages reliance on the operating system shell for certain features.
 * Invoking the OS shell is not safe, not portable, and generally not recommended:
 *
 * - Different shells have different behavior and command-line syntax, and which shell you
 *   will get with NodeJS is unpredictable.  There is no universal shell guaranteed to be
 *   available on all platforms.
 *
 * - If a command parameter contains symbol characters, a shell may interpret them, which
 *   can introduce a security vulnerability
 *
 * - Each shell has different rules for escaping these symbols.  On Windows, the default
 *   shell is incapable of escaping certain character sequences.
 *
 * The Executable API provides a pure JavaScript implementation of primitive shell-like
 * functionality for searching the default PATH, appending default file extensions on Windows,
 * and executing a file that may contain a POSIX shebang.  This primitive functionality
 * is sufficient (and recommended) for most tooling scenarios.
 *
 * If you need additional shell features such as wildcard globbing, environment variable
 * expansion, piping, or built-in commands, then we recommend to use the `@microsoft/rushell`
 * library instead.  Rushell is a pure JavaScript shell with a standard syntax that is
 * guaranteed to work consistently across all platforms.
 *
 * @public
 */
class Executable {
    /**
     * Synchronously create a child process and optionally capture its output.
     *
     * @remarks
     * This function is similar to child_process.spawnSync().  The main differences are:
     *
     * - It does not invoke the OS shell unless the executable file is a shell script.
     * - Command-line arguments containing special characters are more accurately passed
     *   through to the child process.
     * - If the filename is missing a path, then the shell's default PATH will be searched.
     * - If the filename is missing a file extension, then Windows default file extensions
     *   will be searched.
     *
     * @param filename - The name of the executable file.  This string must not contain any
     * command-line arguments.  If the name contains any path delimiters, then the shell's
     * default PATH will not be searched.
     * @param args - The command-line arguments to be passed to the process.
     * @param options - Additional options
     * @returns the same data type as returned by the NodeJS child_process.spawnSync() API
     *
     * @privateRemarks
     *
     * NOTE: The NodeJS spawnSync() returns SpawnSyncReturns<string> or SpawnSyncReturns<Buffer>
     * polymorphically based on the options.encoding parameter value.  This is a fairly confusing
     * design.  In most cases, developers want string with the default encoding.  If/when someone
     * wants binary output or a non-default text encoding, we will introduce a separate API function
     * with a name like "spawnWithBufferSync".
     */
    static spawnSync(filename, args, options) {
        if (!options) {
            options = {};
        }
        const context = Executable._getExecutableContext(options);
        const resolvedPath = Executable._tryResolve(filename, options, context);
        if (!resolvedPath) {
            throw new Error(`The executable file was not found: "${filename}"`);
        }
        const spawnOptions = {
            cwd: context.currentWorkingDirectory,
            env: context.environmentMap.toObject(),
            input: options.input,
            stdio: options.stdio,
            timeout: options.timeoutMs,
            maxBuffer: options.maxBuffer,
            // Contrary to what the NodeJS typings imply, we must explicitly specify "utf8" here
            // if we want the result to be SpawnSyncReturns<string> instead of SpawnSyncReturns<Buffer>.
            encoding: 'utf8',
            // NOTE: This is always false, because Rushell will be recommended instead of relying on the OS shell.
            shell: false
        };
        const normalizedCommandLine = Executable._buildCommandLineFixup(resolvedPath, args, context);
        return child_process.spawnSync(normalizedCommandLine.path, normalizedCommandLine.args, spawnOptions);
    }
    /**
     * Start a child process.
     *
     * @remarks
     * This function is similar to child_process.spawn().  The main differences are:
     *
     * - It does not invoke the OS shell unless the executable file is a shell script.
     * - Command-line arguments containing special characters are more accurately passed
     *   through to the child process.
     * - If the filename is missing a path, then the shell's default PATH will be searched.
     * - If the filename is missing a file extension, then Windows default file extensions
     *   will be searched.
     *
     * This command is asynchronous, but it does not return a `Promise`.  Instead it returns
     * a Node.js `ChildProcess` supporting event notifications.
     *
     * @param filename - The name of the executable file.  This string must not contain any
     * command-line arguments.  If the name contains any path delimiters, then the shell's
     * default PATH will not be searched.
     * @param args - The command-line arguments to be passed to the process.
     * @param options - Additional options
     * @returns the same data type as returned by the NodeJS child_process.spawnSync() API
     */
    static spawn(filename, args, options) {
        if (!options) {
            options = {};
        }
        const context = Executable._getExecutableContext(options);
        const resolvedPath = Executable._tryResolve(filename, options, context);
        if (!resolvedPath) {
            throw new Error(`The executable file was not found: "${filename}"`);
        }
        const spawnOptions = {
            cwd: context.currentWorkingDirectory,
            env: context.environmentMap.toObject(),
            stdio: options.stdio,
            // NOTE: This is always false, because Rushell will be recommended instead of relying on the OS shell.
            shell: false
        };
        const normalizedCommandLine = Executable._buildCommandLineFixup(resolvedPath, args, context);
        return child_process.spawn(normalizedCommandLine.path, normalizedCommandLine.args, spawnOptions);
    }
    // PROBLEM: Given an "args" array of strings that may contain special characters (e.g. spaces,
    // backslashes, quotes), ensure that these strings pass through to the child process's ARGV array
    // without anything getting corrupted along the way.
    //
    // On Unix you just pass the array to spawnSync().  But on Windows, this is a very complex problem:
    // - The Win32 CreateProcess() API expects the args to be encoded as a single text string
    // - The decoding of this string is up to the application (not the OS), and there are 3 different
    //   algorithms in common usage:  the cmd.exe shell, the Microsoft CRT library init code, and
    //   the Win32 CommandLineToArgvW()
    // - The encodings are counterintuitive and have lots of special cases
    // - NodeJS spawnSync() tries do the encoding without knowing which decoder will be used
    //
    // See these articles for a full analysis:
    // http://www.windowsinspired.com/understanding-the-command-line-string-and-arguments-received-by-a-windows-program/
    // http://www.windowsinspired.com/how-a-windows-programs-splits-its-command-line-into-individual-arguments/
    static _buildCommandLineFixup(resolvedPath, args, context) {
        const fileExtension = path.extname(resolvedPath);
        if (os.platform() === 'win32') {
            // Do we need a custom handler for this file type?
            switch (fileExtension.toUpperCase()) {
                case '.EXE':
                case '.COM':
                    // okay to execute directly
                    break;
                case '.BAT':
                case '.CMD': {
                    Executable._validateArgsForWindowsShell(args);
                    // These file types must be invoked via the Windows shell
                    let shellPath = context.environmentMap.get('COMSPEC');
                    if (!shellPath || !Executable._canExecute(shellPath, context)) {
                        shellPath = Executable.tryResolve('cmd.exe');
                    }
                    if (!shellPath) {
                        throw new Error(`Unable to execute "${path.basename(resolvedPath)}" ` +
                            `because CMD.exe was not found in the PATH`);
                    }
                    const shellArgs = [];
                    // /D: Disable execution of AutoRun commands when starting the new shell context
                    shellArgs.push('/d');
                    // /S: Disable Cmd.exe's parsing of double-quote characters inside the command-line
                    shellArgs.push('/s');
                    // /C: Execute the following command and then exit immediately
                    shellArgs.push('/c');
                    // If the path contains special charactrers (e.g. spaces), escape them so that
                    // they don't get interpreted by the shell
                    shellArgs.push(Executable._getEscapedForWindowsShell(resolvedPath));
                    shellArgs.push(...args);
                    return { path: shellPath, args: shellArgs };
                }
                default:
                    throw new Error(`Cannot execute "${path.basename(resolvedPath)}" because the file type is not supported`);
            }
        }
        return {
            path: resolvedPath,
            args: args
        };
    }
    /**
     * Given a filename, this determines the absolute path of the executable file that would
     * be executed by a shell:
     *
     * - If the filename is missing a path, then the shell's default PATH will be searched.
     * - If the filename is missing a file extension, then Windows default file extensions
     *   will be searched.
     *
     * @remarks
     *
     * @param filename - The name of the executable file.  This string must not contain any
     * command-line arguments.  If the name contains any path delimiters, then the shell's
     * default PATH will not be searched.
     * @param options - optional other parameters
     * @returns the absolute path of the executable, or undefined if it was not found
     */
    static tryResolve(filename, options) {
        return Executable._tryResolve(filename, options || {}, Executable._getExecutableContext(options));
    }
    static _tryResolve(filename, options, context) {
        // NOTE: Since "filename" cannot contain command-line arguments, the "/" here
        // must be interpreted as a path delimiter
        const hasPathSeparators = filename.indexOf('/') >= 0 || (os.platform() === 'win32' && filename.indexOf('\\') >= 0);
        // Are there any path separators?
        if (hasPathSeparators) {
            // If so, then don't search the PATH.  Just resolve relative to the current working directory
            const resolvedPath = path.resolve(context.currentWorkingDirectory, filename);
            return Executable._tryResolveFileExtension(resolvedPath, context);
        }
        else {
            // Otherwise if it's a bare name, then try everything in the shell PATH
            const pathsToSearch = Executable._getSearchFolders(context);
            for (const pathToSearch of pathsToSearch) {
                const resolvedPath = path.join(pathToSearch, filename);
                const result = Executable._tryResolveFileExtension(resolvedPath, context);
                if (result) {
                    return result;
                }
            }
            // No match was found
            return undefined;
        }
    }
    static _tryResolveFileExtension(resolvedPath, context) {
        if (Executable._canExecute(resolvedPath, context)) {
            return resolvedPath;
        }
        // Try the default file extensions
        for (const shellExtension of context.windowsExecutableExtensions) {
            const resolvedNameWithExtension = resolvedPath + shellExtension;
            if (Executable._canExecute(resolvedNameWithExtension, context)) {
                return resolvedNameWithExtension;
            }
        }
        return undefined;
    }
    static _buildEnvironmentMap(options) {
        const environmentMap = new EnvironmentMap_1.EnvironmentMap();
        if (options.environment !== undefined && options.environmentMap !== undefined) {
            throw new Error('IExecutableResolveOptions.environment and IExecutableResolveOptions.environmentMap' +
                ' cannot both be specified');
        }
        if (options.environment !== undefined) {
            environmentMap.mergeFromObject(options.environment);
        }
        else if (options.environmentMap !== undefined) {
            environmentMap.mergeFrom(options.environmentMap);
        }
        else {
            environmentMap.mergeFromObject(process.env);
        }
        return environmentMap;
    }
    /**
     * This is used when searching the shell PATH for an executable, to determine
     * whether a match should be skipped or not.  If it returns true, this does not
     * guarantee that the file can be successfully executed.
     */
    static _canExecute(filePath, context) {
        if (!FileSystem_1.FileSystem.exists(filePath)) {
            return false;
        }
        if (os.platform() === 'win32') {
            // NOTE: For Windows, we don't validate that the file extension appears in PATHEXT.
            // That environment variable determines which extensions can be appended if the
            // extension is missing, but it does not affect whether a file may be executed or not.
            // Windows does have a (seldom used) ACL that can be used to deny execution permissions
            // for a file, but NodeJS doesn't expose that API, so we don't bother checking it.
            // However, Windows *does* require that the file has some kind of file extension
            if (path.extname(filePath) === '') {
                return false;
            }
        }
        else {
            // For Unix, check whether any of the POSIX execute bits are set
            try {
                // eslint-disable-next-line no-bitwise
                if ((FileSystem_1.FileSystem.getPosixModeBits(filePath) & 73 /* AllExecute */) === 0) {
                    return false; // not executable
                }
            }
            catch (error) {
                // If we have trouble accessing the file, ignore the error and consider it "not executable"
                // since that's what a shell would do
            }
        }
        return true;
    }
    /**
     * Returns the list of folders where we will search for an executable,
     * based on the PATH environment variable.
     */
    static _getSearchFolders(context) {
        const pathList = context.environmentMap.get('PATH') || '';
        const folders = [];
        // Avoid processing duplicates
        const seenPaths = new Set();
        // NOTE: Cmd.exe on Windows always searches the current working directory first.
        // PowerShell and Unix shells do NOT do that, because it's a security concern.
        // We follow their behavior.
        for (const splitPath of pathList.split(path.delimiter)) {
            const trimmedPath = splitPath.trim();
            if (trimmedPath !== '') {
                if (!seenPaths.has(trimmedPath)) {
                    // Fun fact: If you put relative paths in your PATH environment variable,
                    // all shells will dynamically match them against the current working directory.
                    // This is a terrible design, and in practice nobody does that, but it is supported...
                    // so we allow it here.
                    const resolvedPath = path.resolve(context.currentWorkingDirectory, trimmedPath);
                    if (!seenPaths.has(resolvedPath)) {
                        if (FileSystem_1.FileSystem.exists(resolvedPath)) {
                            folders.push(resolvedPath);
                        }
                        seenPaths.add(resolvedPath);
                    }
                    seenPaths.add(trimmedPath);
                }
            }
        }
        return folders;
    }
    static _getExecutableContext(options) {
        if (!options) {
            options = {};
        }
        const environment = Executable._buildEnvironmentMap(options);
        let currentWorkingDirectory;
        if (options.currentWorkingDirectory) {
            currentWorkingDirectory = path.resolve(options.currentWorkingDirectory);
        }
        else {
            currentWorkingDirectory = process.cwd();
        }
        const windowsExecutableExtensions = [];
        if (os.platform() === 'win32') {
            const pathExtVariable = environment.get('PATHEXT') || '';
            for (const splitValue of pathExtVariable.split(';')) {
                const trimmed = splitValue.trim().toLowerCase();
                // Ignore malformed extensions
                if (/^\.[a-z0-9\.]*[a-z0-9]$/i.test(trimmed)) {
                    // Don't add the same extension twice
                    if (windowsExecutableExtensions.indexOf(trimmed) < 0) {
                        windowsExecutableExtensions.push(trimmed);
                    }
                }
            }
        }
        return {
            environmentMap: environment,
            currentWorkingDirectory,
            windowsExecutableExtensions
        };
    }
    /**
     * Given an input string containing special symbol characters, this inserts the "^" escape
     * character to ensure the symbols are interpreted literally by the Windows shell.
     */
    static _getEscapedForWindowsShell(text) {
        const escapableCharRegExp = /[%\^&|<> ]/g;
        return text.replace(escapableCharRegExp, (value) => '^' + value);
    }
    /**
     * Checks for characters that are unsafe to pass to a Windows batch file
     * due to the way that cmd.exe implements escaping.
     */
    static _validateArgsForWindowsShell(args) {
        const specialCharRegExp = /[%\^&|<>\r\n]/g;
        for (const arg of args) {
            const match = arg.match(specialCharRegExp);
            if (match) {
                // NOTE: It is possible to escape some of these characters by prefixing them
                // with a caret (^), which allows these characters to be successfully passed
                // through to the batch file %1 variables.  But they will be expanded again
                // whenever they are used.  For example, NPM's binary wrapper batch files
                // use "%*" to pass their arguments to Node.exe, which causes them to be expanded
                // again.  Unfortunately the Cmd.exe batch language provides native escaping
                // function (that could be used to insert the carets again).
                //
                // We could work around that by adding double carets, but in general there
                // is no way to predict how many times the variable will get expanded.
                // Thus, there is no generally reliable way to pass these characters.
                throw new Error(`The command line argument ${JSON.stringify(arg)} contains a` +
                    ` special character ${JSON.stringify(match[0])} that cannot be escaped for the Windows shell`);
            }
        }
    }
}
exports.Executable = Executable;
//# sourceMappingURL=Executable.js.map

/***/ }),

/***/ 29371:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileSystem = void 0;
const nodeJsPath = __importStar(__webpack_require__(85622));
const fs = __importStar(__webpack_require__(35747));
const fsx = __importStar(__webpack_require__(5630));
const Text_1 = __webpack_require__(67638);
const MOVE_DEFAULT_OPTIONS = {
    overwrite: true,
    ensureFolderExists: false
};
const READ_FOLDER_DEFAULT_OPTIONS = {
    absolutePaths: false
};
const WRITE_FILE_DEFAULT_OPTIONS = {
    ensureFolderExists: false,
    convertLineEndings: undefined,
    encoding: "utf8" /* Utf8 */
};
const APPEND_TO_FILE_DEFAULT_OPTIONS = Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS);
const READ_FILE_DEFAULT_OPTIONS = {
    encoding: "utf8" /* Utf8 */,
    convertLineEndings: undefined
};
const COPY_FILE_DEFAULT_OPTIONS = {
    alreadyExistsBehavior: "overwrite" /* Overwrite */
};
const COPY_FILES_DEFAULT_OPTIONS = {
    alreadyExistsBehavior: "overwrite" /* Overwrite */
};
const DELETE_FILE_DEFAULT_OPTIONS = {
    throwIfNotExists: false
};
/**
 * The FileSystem API provides a complete set of recommended operations for interacting with the file system.
 *
 * @remarks
 * We recommend to use this instead of the native `fs` API, because `fs` is a minimal set of low-level
 * primitives that must be mapped for each supported operating system. The FileSystem API takes a
 * philosophical approach of providing "one obvious way" to do each operation. We also prefer synchronous
 * operations except in cases where there would be a clear performance benefit for using async, since synchronous
 * code is much easier to read and debug. Also, indiscriminate parallelism has been seen to actually worsen
 * performance, versus improving it.
 *
 * Note that in the documentation, we refer to "filesystem objects", this can be a
 * file, folder, symbolic link, hard link, directory junction, etc.
 *
 * @public
 */
class FileSystem {
    // ===============
    // COMMON OPERATIONS
    // ===============
    /**
     * Returns true if the path exists on disk.
     * Behind the scenes it uses `fs.existsSync()`.
     * @remarks
     * There is a debate about the fact that after `fs.existsSync()` returns true,
     * the file might be deleted before fs.readSync() is called, which would imply that everybody
     * should catch a `readSync()` exception, and nobody should ever use `fs.existsSync()`.
     * We find this to be unpersuasive, since "unexceptional exceptions" really hinder the
     * break-on-exception debugging experience. Also, throwing/catching is generally slow.
     * @param path - The absolute or relative path to the filesystem object.
     */
    static exists(path) {
        return FileSystem._wrapException(() => {
            return fsx.existsSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.exists}.
     */
    static async existsAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return new Promise((resolve) => {
                fsx.exists(path, resolve);
            });
        });
    }
    /**
     * Gets the statistics for a particular filesystem object.
     * If the path is a link, this function follows the link and returns statistics about the link target.
     * Behind the scenes it uses `fs.statSync()`.
     * @param path - The absolute or relative path to the filesystem object.
     */
    static getStatistics(path) {
        return FileSystem._wrapException(() => {
            return fsx.statSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.getStatistics}.
     */
    static async getStatisticsAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.stat(path);
        });
    }
    /**
     * Updates the accessed and modified timestamps of the filesystem object referenced by path.
     * Behind the scenes it uses `fs.utimesSync()`.
     * The caller should specify both times in the `times` parameter.
     * @param path - The path of the file that should be modified.
     * @param times - The times that the object should be updated to reflect.
     */
    static updateTimes(path, times) {
        return FileSystem._wrapException(() => {
            fsx.utimesSync(path, times.accessedTime, times.modifiedTime);
        });
    }
    /**
     * An async version of {@link FileSystem.updateTimes}.
     */
    static async updateTimesAsync(path, times) {
        await FileSystem._wrapExceptionAsync(() => {
            // This cast is needed because the fs-extra typings require both parameters
            // to have the same type (number or Date), whereas Node.js does not require that.
            return fsx.utimes(path, times.accessedTime, times.modifiedTime);
        });
    }
    /**
     * Changes the permissions (i.e. file mode bits) for a filesystem object.
     * Behind the scenes it uses `fs.chmodSync()`.
     * @param path - The absolute or relative path to the object that should be updated.
     * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum
     */
    static changePosixModeBits(path, mode) {
        FileSystem._wrapException(() => {
            fs.chmodSync(path, mode);
        });
    }
    /**
     * An async version of {@link FileSystem.changePosixModeBits}.
     */
    static async changePosixModeBitsAsync(path, mode) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.chmod(path, mode);
        });
    }
    /**
     * Retrieves the permissions (i.e. file mode bits) for a filesystem object.
     * Behind the scenes it uses `fs.chmodSync()`.
     * @param path - The absolute or relative path to the object that should be updated.
     *
     * @remarks
     * This calls {@link FileSystem.getStatistics} to get the POSIX mode bits.
     * If statistics in addition to the mode bits are needed, it is more efficient
     * to call {@link FileSystem.getStatistics} directly instead.
     */
    static getPosixModeBits(path) {
        return FileSystem._wrapException(() => {
            return FileSystem.getStatistics(path).mode;
        });
    }
    /**
     * An async version of {@link FileSystem.getPosixModeBits}.
     */
    static async getPosixModeBitsAsync(path) {
        return await FileSystem._wrapExceptionAsync(async () => {
            return (await FileSystem.getStatisticsAsync(path)).mode;
        });
    }
    /**
     * Returns a 10-character string representation of a PosixModeBits value similar to what
     * would be displayed by a command such as "ls -l" on a POSIX-like operating system.
     * @remarks
     * For example, `PosixModeBits.AllRead | PosixModeBits.AllWrite` would be formatted as "-rw-rw-rw-".
     * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum
     */
    static formatPosixModeBits(modeBits) {
        let result = '-'; // (later we may add support for additional states such as S_IFDIR or S_ISUID)
        result += modeBits & 256 /* UserRead */ ? 'r' : '-';
        result += modeBits & 128 /* UserWrite */ ? 'w' : '-';
        result += modeBits & 64 /* UserExecute */ ? 'x' : '-';
        result += modeBits & 32 /* GroupRead */ ? 'r' : '-';
        result += modeBits & 16 /* GroupWrite */ ? 'w' : '-';
        result += modeBits & 8 /* GroupExecute */ ? 'x' : '-';
        result += modeBits & 4 /* OthersRead */ ? 'r' : '-';
        result += modeBits & 2 /* OthersWrite */ ? 'w' : '-';
        result += modeBits & 1 /* OthersExecute */ ? 'x' : '-';
        return result;
    }
    /**
     * Moves a file. The folder must exist, unless the `ensureFolderExists` option is provided.
     * Behind the scenes it uses `fs-extra.moveSync()`
     */
    static move(options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, MOVE_DEFAULT_OPTIONS), options);
            try {
                fsx.moveSync(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(options.destinationPath);
                    FileSystem.ensureFolder(folderPath);
                    fsx.moveSync(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.move}.
     */
    static async moveAsync(options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, MOVE_DEFAULT_OPTIONS), options);
            try {
                await fsx.move(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(options.destinationPath);
                    await FileSystem.ensureFolderAsync(nodeJsPath.dirname(folderPath));
                    await fsx.move(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
                }
                else {
                    throw error;
                }
            }
        });
    }
    // ===============
    // FOLDER OPERATIONS
    // ===============
    /**
     * Recursively creates a folder at a given path.
     * Behind the scenes is uses `fs-extra.ensureDirSync()`.
     * @remarks
     * Throws an exception if anything in the folderPath is not a folder.
     * @param folderPath - The absolute or relative path of the folder which should be created.
     */
    static ensureFolder(folderPath) {
        FileSystem._wrapException(() => {
            fsx.ensureDirSync(folderPath);
        });
    }
    /**
     * An async version of {@link FileSystem.ensureFolder}.
     */
    static async ensureFolderAsync(folderPath) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.ensureDir(folderPath);
        });
    }
    /**
     * Reads the contents of the folder, not including "." or "..".
     * Behind the scenes it uses `fs.readdirSync()`.
     * @param folderPath - The absolute or relative path to the folder which should be read.
     * @param options - Optional settings that can change the behavior. Type: `IReadFolderOptions`
     */
    static readFolder(folderPath, options) {
        return FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, READ_FOLDER_DEFAULT_OPTIONS), options);
            // @todo: Update this to use Node 10's `withFileTypes: true` option when we drop support for Node 8
            const fileNames = fsx.readdirSync(folderPath);
            if (options.absolutePaths) {
                return fileNames.map((fileName) => nodeJsPath.resolve(folderPath, fileName));
            }
            else {
                return fileNames;
            }
        });
    }
    /**
     * An async version of {@link FileSystem.readFolder}.
     */
    static async readFolderAsync(folderPath, options) {
        return await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, READ_FOLDER_DEFAULT_OPTIONS), options);
            // @todo: Update this to use Node 10's `withFileTypes: true` option when we drop support for Node 8
            const fileNames = await fsx.readdir(folderPath);
            if (options.absolutePaths) {
                return fileNames.map((fileName) => nodeJsPath.resolve(folderPath, fileName));
            }
            else {
                return fileNames;
            }
        });
    }
    /**
     * Deletes a folder, including all of its contents.
     * Behind the scenes is uses `fs-extra.removeSync()`.
     * @remarks
     * Does not throw if the folderPath does not exist.
     * @param folderPath - The absolute or relative path to the folder which should be deleted.
     */
    static deleteFolder(folderPath) {
        FileSystem._wrapException(() => {
            fsx.removeSync(folderPath);
        });
    }
    /**
     * An async version of {@link FileSystem.deleteFolder}.
     */
    static async deleteFolderAsync(folderPath) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.remove(folderPath);
        });
    }
    /**
     * Deletes the content of a folder, but not the folder itself. Also ensures the folder exists.
     * Behind the scenes it uses `fs-extra.emptyDirSync()`.
     * @remarks
     * This is a workaround for a common race condition, where the virus scanner holds a lock on the folder
     * for a brief period after it was deleted, causing EBUSY errors for any code that tries to recreate the folder.
     * @param folderPath - The absolute or relative path to the folder which should have its contents deleted.
     */
    static ensureEmptyFolder(folderPath) {
        FileSystem._wrapException(() => {
            fsx.emptyDirSync(folderPath);
        });
    }
    /**
     * An async version of {@link FileSystem.ensureEmptyFolder}.
     */
    static async ensureEmptyFolderAsync(folderPath) {
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.emptyDir(folderPath);
        });
    }
    // ===============
    // FILE OPERATIONS
    // ===============
    /**
     * Writes a text string to a file on disk, overwriting the file if it already exists.
     * Behind the scenes it uses `fs.writeFileSync()`.
     * @remarks
     * Throws an error if the folder doesn't exist, unless ensureFolder=true.
     * @param filePath - The absolute or relative path of the file.
     * @param contents - The text that should be written to the file.
     * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`
     */
    static writeFile(filePath, contents, options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                fsx.writeFileSync(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    FileSystem.ensureFolder(folderPath);
                    fsx.writeFileSync(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.writeFile}.
     */
    static async writeFileAsync(filePath, contents, options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, WRITE_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                await fsx.writeFile(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    await FileSystem.ensureFolderAsync(folderPath);
                    await fsx.writeFile(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * Writes a text string to a file on disk, appending to the file if it already exists.
     * Behind the scenes it uses `fs.appendFileSync()`.
     * @remarks
     * Throws an error if the folder doesn't exist, unless ensureFolder=true.
     * @param filePath - The absolute or relative path of the file.
     * @param contents - The text that should be written to the file.
     * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`
     */
    static appendToFile(filePath, contents, options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, APPEND_TO_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                fsx.appendFileSync(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    FileSystem.ensureFolder(folderPath);
                    fsx.appendFileSync(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.appendToFile}.
     */
    static async appendToFileAsync(filePath, contents, options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, APPEND_TO_FILE_DEFAULT_OPTIONS), options);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
            }
            try {
                await fsx.appendFile(filePath, contents, { encoding: options.encoding });
            }
            catch (error) {
                if (options.ensureFolderExists) {
                    if (!FileSystem.isNotExistError(error)) {
                        throw error;
                    }
                    const folderPath = nodeJsPath.dirname(filePath);
                    await FileSystem.ensureFolderAsync(folderPath);
                    await fsx.appendFile(filePath, contents, { encoding: options.encoding });
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**
     * Reads the contents of a file into a string.
     * Behind the scenes it uses `fs.readFileSync()`.
     * @param filePath - The relative or absolute path to the file whose contents should be read.
     * @param options - Optional settings that can change the behavior. Type: `IReadFileOptions`
     */
    static readFile(filePath, options) {
        return FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, READ_FILE_DEFAULT_OPTIONS), options);
            let contents = FileSystem.readFileToBuffer(filePath).toString(options.encoding);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents, options.convertLineEndings);
            }
            return contents;
        });
    }
    /**
     * An async version of {@link FileSystem.readFile}.
     */
    static async readFileAsync(filePath, options) {
        return await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, READ_FILE_DEFAULT_OPTIONS), options);
            let contents = (await FileSystem.readFileToBufferAsync(filePath)).toString(options.encoding);
            if (options.convertLineEndings) {
                contents = Text_1.Text.convertTo(contents, options.convertLineEndings);
            }
            return contents;
        });
    }
    /**
     * Reads the contents of a file into a buffer.
     * Behind the scenes is uses `fs.readFileSync()`.
     * @param filePath - The relative or absolute path to the file whose contents should be read.
     */
    static readFileToBuffer(filePath) {
        return FileSystem._wrapException(() => {
            return fsx.readFileSync(filePath);
        });
    }
    /**
     * An async version of {@link FileSystem.readFileToBuffer}.
     */
    static async readFileToBufferAsync(filePath) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.readFile(filePath);
        });
    }
    /**
     * Copies a single file from one location to another.
     * By default, destinationPath is overwritten if it already exists.
     *
     * @remarks
     * The `copyFile()` API cannot be used to copy folders.  It copies at most one file.
     * Use {@link FileSystem.copyFiles} if you need to recursively copy a tree of folders.
     *
     * The implementation is based on `copySync()` from the `fs-extra` package.
     */
    static copyFile(options) {
        options = Object.assign(Object.assign({}, COPY_FILE_DEFAULT_OPTIONS), options);
        if (FileSystem.getStatistics(options.sourcePath).isDirectory()) {
            throw new Error('The specified path refers to a folder; this operation expects a file object:\n' + options.sourcePath);
        }
        FileSystem._wrapException(() => {
            fsx.copySync(options.sourcePath, options.destinationPath, {
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */
            });
        });
    }
    /**
     * An async version of {@link FileSystem.copyFile}.
     */
    static async copyFileAsync(options) {
        options = Object.assign(Object.assign({}, COPY_FILE_DEFAULT_OPTIONS), options);
        if (FileSystem.getStatistics(options.sourcePath).isDirectory()) {
            throw new Error('The specified path refers to a folder; this operation expects a file object:\n' + options.sourcePath);
        }
        await FileSystem._wrapExceptionAsync(() => {
            return fsx.copy(options.sourcePath, options.destinationPath, {
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */
            });
        });
    }
    /**
     * Copies a file or folder from one location to another, recursively copying any folder contents.
     * By default, destinationPath is overwritten if it already exists.
     *
     * @remarks
     * If you only intend to copy a single file, it is recommended to use {@link FileSystem.copyFile}
     * instead to more clearly communicate the intended operation.
     *
     * The implementation is based on `copySync()` from the `fs-extra` package.
     */
    static copyFiles(options) {
        options = Object.assign(Object.assign({}, COPY_FILES_DEFAULT_OPTIONS), options);
        FileSystem._wrapException(() => {
            fsx.copySync(options.sourcePath, options.destinationPath, {
                dereference: !!options.dereferenceSymlinks,
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */,
                preserveTimestamps: !!options.preserveTimestamps,
                filter: options.filter
            });
        });
    }
    /**
     * An async version of {@link FileSystem.copyFiles}.
     */
    static async copyFilesAsync(options) {
        options = Object.assign(Object.assign({}, COPY_FILES_DEFAULT_OPTIONS), options);
        await FileSystem._wrapExceptionAsync(async () => {
            fsx.copySync(options.sourcePath, options.destinationPath, {
                dereference: !!options.dereferenceSymlinks,
                errorOnExist: options.alreadyExistsBehavior === "error" /* Error */,
                overwrite: options.alreadyExistsBehavior === "overwrite" /* Overwrite */,
                preserveTimestamps: !!options.preserveTimestamps,
                filter: options.filter
            });
        });
    }
    /**
     * Deletes a file. Can optionally throw if the file doesn't exist.
     * Behind the scenes it uses `fs.unlinkSync()`.
     * @param filePath - The absolute or relative path to the file that should be deleted.
     * @param options - Optional settings that can change the behavior. Type: `IDeleteFileOptions`
     */
    static deleteFile(filePath, options) {
        FileSystem._wrapException(() => {
            options = Object.assign(Object.assign({}, DELETE_FILE_DEFAULT_OPTIONS), options);
            try {
                fsx.unlinkSync(filePath);
            }
            catch (error) {
                if (options.throwIfNotExists || !FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        });
    }
    /**
     * An async version of {@link FileSystem.deleteFile}.
     */
    static async deleteFileAsync(filePath, options) {
        await FileSystem._wrapExceptionAsync(async () => {
            options = Object.assign(Object.assign({}, DELETE_FILE_DEFAULT_OPTIONS), options);
            try {
                await fsx.unlink(filePath);
            }
            catch (error) {
                if (options.throwIfNotExists || !FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        });
    }
    // ===============
    // LINK OPERATIONS
    // ===============
    /**
     * Gets the statistics of a filesystem object. Does NOT follow the link to its target.
     * Behind the scenes it uses `fs.lstatSync()`.
     * @param path - The absolute or relative path to the filesystem object.
     */
    static getLinkStatistics(path) {
        return FileSystem._wrapException(() => {
            return fsx.lstatSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.getLinkStatistics}.
     */
    static async getLinkStatisticsAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.lstat(path);
        });
    }
    /**
     * If `path` refers to a symbolic link, this returns the path of the link target, which may be
     * an absolute or relative path.
     *
     * @remarks
     * If `path` refers to a filesystem object that is not a symbolic link, then an `ErrnoException` is thrown
     * with code 'UNKNOWN'.  If `path` does not exist, then an `ErrnoException` is thrown with code `ENOENT`.
     *
     * @param path - The absolute or relative path to the symbolic link.
     * @returns the path of the link target
     */
    static readLink(path) {
        return FileSystem._wrapException(() => {
            return fsx.readlinkSync(path);
        });
    }
    /**
     * An async version of {@link FileSystem.readLink}.
     */
    static async readLinkAsync(path) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.readlink(path);
        });
    }
    /**
     * Creates an NTFS "directory junction" on Windows operating systems; for other operating systems, it
     * creates a regular symbolic link.  The link target must be a folder, not a file.
     * Behind the scenes it uses `fs.symlinkSync()`.
     *
     * @remarks
     * For security reasons, Windows operating systems by default require administrator elevation to create
     * symbolic links.  As a result, on Windows it's generally recommended for Node.js tools to use hard links
     * (for files) or NTFS directory junctions (for folders), since regular users are allowed to create them.
     * Hard links and junctions are less vulnerable to symlink attacks because they cannot reference a network share,
     * and their target must exist at the time of link creation.  Non-Windows operating systems generally don't
     * restrict symlink creation, and as such are more vulnerable to symlink attacks.  Note that Windows can be
     * configured to permit regular users to create symlinks, for example by enabling Windows 10 "developer mode."
     *
     * A directory junction requires the link source and target to both be located on local disk volumes;
     * if not, use a symbolic link instead.
     */
    static createSymbolicLinkJunction(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                // For directories, we use a Windows "junction".  On POSIX operating systems, this produces a regular symlink.
                return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'junction');
            }, options);
        });
    }
    /**
     * An async version of {@link FileSystem.createSymbolicLinkJunction}.
     */
    static async createSymbolicLinkJunctionAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                // For directories, we use a Windows "junction".  On POSIX operating systems, this produces a regular symlink.
                return fsx.symlink(options.linkTargetPath, options.newLinkPath, 'junction');
            }, options);
        });
    }
    /**
     * Creates a symbolic link to a file.  On Windows operating systems, this may require administrator elevation.
     * Behind the scenes it uses `fs.symlinkSync()`.
     *
     * @remarks
     * To avoid administrator elevation on Windows, use {@link FileSystem.createHardLink} instead.
     *
     * On Windows operating systems, the NTFS file system distinguishes file symlinks versus directory symlinks:
     * If the target is not the correct type, the symlink will be created successfully, but will fail to resolve.
     * Other operating systems do not make this distinction, in which case {@link FileSystem.createSymbolicLinkFile}
     * and {@link FileSystem.createSymbolicLinkFolder} can be used interchangeably, but doing so will make your
     * tool incompatible with Windows.
     */
    static createSymbolicLinkFile(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'file');
            }, options);
        });
    }
    /**
     * An async version of {@link FileSystem.createSymbolicLinkFile}.
     */
    static async createSymbolicLinkFileAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                return fsx.symlink(options.linkTargetPath, options.newLinkPath, 'file');
            }, options);
        });
    }
    /**
     * Creates a symbolic link to a folder.  On Windows operating systems, this may require administrator elevation.
     * Behind the scenes it uses `fs.symlinkSync()`.
     *
     * @remarks
     * To avoid administrator elevation on Windows, use {@link FileSystem.createSymbolicLinkJunction} instead.
     *
     * On Windows operating systems, the NTFS file system distinguishes file symlinks versus directory symlinks:
     * If the target is not the correct type, the symlink will be created successfully, but will fail to resolve.
     * Other operating systems do not make this distinction, in which case {@link FileSystem.createSymbolicLinkFile}
     * and {@link FileSystem.createSymbolicLinkFolder} can be used interchangeably, but doing so will make your
     * tool incompatible with Windows.
     */
    static createSymbolicLinkFolder(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                return fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'dir');
            }, options);
        });
    }
    /**
     * An async version of {@link FileSystem.createSymbolicLinkFolder}.
     */
    static async createSymbolicLinkFolderAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                return fsx.symlink(options.linkTargetPath, options.newLinkPath, 'dir');
            }, options);
        });
    }
    /**
     * Creates a hard link.  The link target must be a file, not a folder.
     * Behind the scenes it uses `fs.linkSync()`.
     *
     * @remarks
     * For security reasons, Windows operating systems by default require administrator elevation to create
     * symbolic links.  As a result, on Windows it's generally recommended for Node.js tools to use hard links
     * (for files) or NTFS directory junctions (for folders), since regular users are allowed to create them.
     * Hard links and junctions are less vulnerable to symlink attacks because they cannot reference a network share,
     * and their target must exist at the time of link creation.  Non-Windows operating systems generally don't
     * restrict symlink creation, and as such are more vulnerable to symlink attacks.  Note that Windows can be
     * configured to permit regular users to create symlinks, for example by enabling Windows 10 "developer mode."
     *
     * A hard link requires the link source and target to both be located on same disk volume;
     * if not, use a symbolic link instead.
     */
    static createHardLink(options) {
        FileSystem._wrapException(() => {
            return FileSystem._handleLink(() => {
                return fsx.linkSync(options.linkTargetPath, options.newLinkPath);
            }, Object.assign(Object.assign({}, options), { linkTargetMustExist: true }));
        });
    }
    /**
     * An async version of {@link FileSystem.createHardLink}.
     */
    static async createHardLinkAsync(options) {
        await FileSystem._wrapExceptionAsync(() => {
            return FileSystem._handleLinkAsync(() => {
                return fsx.link(options.linkTargetPath, options.newLinkPath);
            }, Object.assign(Object.assign({}, options), { linkTargetMustExist: true }));
        });
    }
    /**
     * Follows a link to its destination and returns the absolute path to the final target of the link.
     * Behind the scenes it uses `fs.realpathSync()`.
     * @param linkPath - The path to the link.
     */
    static getRealPath(linkPath) {
        return FileSystem._wrapException(() => {
            return fsx.realpathSync(linkPath);
        });
    }
    /**
     * An async version of {@link FileSystem.getRealPath}.
     */
    static async getRealPathAsync(linkPath) {
        return await FileSystem._wrapExceptionAsync(() => {
            return fsx.realpath(linkPath);
        });
    }
    // ===============
    // UTILITY FUNCTIONS
    // ===============
    /**
     * Returns true if the error object indicates the file or folder already exists (`EEXIST`).
     */
    static isExistError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'EEXIST';
    }
    /**
     * Returns true if the error object indicates the file or folder does not exist (`ENOENT` or `ENOTDIR`)
     */
    static isNotExistError(error) {
        return FileSystem.isFileDoesNotExistError(error) || FileSystem.isFolderDoesNotExistError(error);
    }
    /**
     * Returns true if the error object indicates the file does not exist (`ENOENT`).
     */
    static isFileDoesNotExistError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'ENOENT';
    }
    /**
     * Returns true if the error object indicates the folder does not exist (`ENOTDIR`).
     */
    static isFolderDoesNotExistError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'ENOTDIR';
    }
    /**
     * Returns true if the error object indicates that the `unlink` system call failed
     * due to a permissions issue (`EPERM`).
     */
    static isUnlinkNotPermittedError(error) {
        return FileSystem.isErrnoException(error) && error.code === 'EPERM' && error.syscall === 'unlink';
    }
    /**
     * Detects if the provided error object is a `NodeJS.ErrnoException`
     */
    static isErrnoException(error) {
        const typedError = error;
        return (typeof typedError.code === 'string' &&
            typeof typedError.errno === 'number' &&
            typeof typedError.path === 'string' &&
            typeof typedError.syscall === 'string');
    }
    static _handleLink(linkFn, options) {
        try {
            linkFn();
        }
        catch (error) {
            if (FileSystem.isExistError(error)) {
                // Link exists, handle it
                switch (options.alreadyExistsBehavior) {
                    case "ignore" /* Ignore */:
                        break;
                    case "overwrite" /* Overwrite */:
                        // fsx.linkSync does not allow overwriting so we must manually delete. If it's
                        // a folder, it will throw an error.
                        this.deleteFile(options.newLinkPath);
                        linkFn();
                        break;
                    case "error" /* Error */:
                    default:
                        throw error;
                }
            }
            else {
                // When attempting to create a link in a directory that does not exist, an ENOENT
                // or ENOTDIR error is thrown, so we should ensure the directory exists before
                // retrying. There are also cases where the target file must exist, so validate in
                // those cases to avoid confusing the missing directory with the missing target file.
                if (FileSystem.isNotExistError(error) &&
                    (!options.linkTargetMustExist || FileSystem.exists(options.linkTargetPath))) {
                    this.ensureFolder(nodeJsPath.dirname(options.newLinkPath));
                    linkFn();
                }
                else {
                    throw error;
                }
            }
        }
    }
    static async _handleLinkAsync(linkFn, options) {
        try {
            await linkFn();
        }
        catch (error) {
            if (FileSystem.isExistError(error)) {
                // Link exists, handle it
                switch (options.alreadyExistsBehavior) {
                    case "ignore" /* Ignore */:
                        break;
                    case "overwrite" /* Overwrite */:
                        // fsx.linkSync does not allow overwriting so we must manually delete. If it's
                        // a folder, it will throw an error.
                        await this.deleteFileAsync(options.newLinkPath);
                        await linkFn();
                        break;
                    case "error" /* Error */:
                    default:
                        throw error;
                }
            }
            else {
                // When attempting to create a link in a directory that does not exist, an ENOENT
                // or ENOTDIR error is thrown, so we should ensure the directory exists before
                // retrying. There are also cases where the target file must exist, so validate in
                // those cases to avoid confusing the missing directory with the missing target file.
                if (FileSystem.isNotExistError(error) &&
                    (!options.linkTargetMustExist || (await FileSystem.existsAsync(options.linkTargetPath)))) {
                    await this.ensureFolderAsync(nodeJsPath.dirname(options.newLinkPath));
                    await linkFn();
                }
                else {
                    throw error;
                }
            }
        }
    }
    static _wrapException(fn) {
        try {
            return fn();
        }
        catch (error) {
            FileSystem._updateErrorMessage(error);
            throw error;
        }
    }
    static async _wrapExceptionAsync(fn) {
        try {
            return await fn();
        }
        catch (error) {
            FileSystem._updateErrorMessage(error);
            throw error;
        }
    }
    static _updateErrorMessage(error) {
        if (FileSystem.isErrnoException(error)) {
            if (FileSystem.isFileDoesNotExistError(error)) {
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `File does not exist: ${error.path}\n${error.message}`;
            }
            else if (FileSystem.isFolderDoesNotExistError(error)) {
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `Folder does not exist: ${error.path}\n${error.message}`;
            }
            else if (FileSystem.isExistError(error)) {
                // Oddly, the typing does not include the `dest` property even though the documentation
                // indicates it is there: https://nodejs.org/docs/latest-v10.x/api/errors.html#errors_error_dest
                const extendedError = error;
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `File or folder already exists: ${extendedError.dest}\n${error.message}`;
            }
            else if (FileSystem.isUnlinkNotPermittedError(error)) {
                // eslint-disable-line @typescript-eslint/no-use-before-define
                error.message = `File or folder could not be deleted: ${error.path}\n${error.message}`;
            }
        }
    }
}
exports.FileSystem = FileSystem;
//# sourceMappingURL=FileSystem.js.map

/***/ }),

/***/ 20830:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileWriter = void 0;
const Import_1 = __webpack_require__(40923);
const fsx = Import_1.Import.lazy('fs-extra', require);
/**
 * API for interacting with file handles.
 * @public
 */
class FileWriter {
    constructor(fileDescriptor, filePath) {
        this._fileDescriptor = fileDescriptor;
        this.filePath = filePath;
    }
    /**
     * Opens a new file handle to the file at the specified path and given mode.
     * Behind the scenes it uses `fs.openSync()`.
     * The behaviour of this function is platform specific.
     * See: https://nodejs.org/docs/latest-v8.x/api/fs.html#fs_fs_open_path_flags_mode_callback
     * @param filePath - The absolute or relative path to the file handle that should be opened.
     * @param flags - The flags for opening the handle
     */
    static open(filePath, flags) {
        return new FileWriter(fsx.openSync(filePath, FileWriter._convertFlagsForNode(flags)), filePath);
    }
    /**
     * Helper function to convert the file writer array to a Node.js style string (e.g. "wx" or "a").
     * @param flags - The flags that should be converted.
     */
    static _convertFlagsForNode(flags) {
        flags = Object.assign({ append: false, exclusive: false }, flags);
        return [flags.append ? 'a' : 'w', flags.exclusive ? 'x' : ''].join('');
    }
    /**
     * Writes some text to the given file handle. Throws if the file handle has been closed.
     * Behind the scenes it uses `fs.writeSync()`.
     * @param text - The text to write to the file.
     */
    write(text) {
        if (!this._fileDescriptor) {
            throw new Error(`Cannot write to file, file descriptor has already been released.`);
        }
        fsx.writeSync(this._fileDescriptor, text);
    }
    /**
     * Closes the file handle permanently. No operations can be made on this file handle after calling this.
     * Behind the scenes it uses `fs.closeSync()` and releases the file descriptor to be re-used.
     *
     * @remarks
     * The `close()` method can be called more than once; additional calls are ignored.
     */
    close() {
        const fd = this._fileDescriptor;
        if (fd) {
            this._fileDescriptor = undefined;
            fsx.closeSync(fd);
        }
    }
}
exports.FileWriter = FileWriter;
//# sourceMappingURL=FileWriter.js.map

/***/ }),

/***/ 40923:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Import = void 0;
const path = __importStar(__webpack_require__(85622));
const importLazy = __webpack_require__(41239);
const Resolve = __importStar(__webpack_require__(70154));
const nodeModule = __webpack_require__(32282);
const PackageJsonLookup_1 = __webpack_require__(87330);
const FileSystem_1 = __webpack_require__(29371);
/**
 * Helpers for resolving and importing Node.js modules.
 * @public
 */
class Import {
    static get _builtInModules() {
        if (!Import.__builtInModules) {
            Import.__builtInModules = new Set(nodeModule.builtinModules);
        }
        return Import.__builtInModules;
    }
    /**
     * Provides a way to improve process startup times by lazy-loading imported modules.
     *
     * @remarks
     * This is a more structured wrapper for the {@link https://www.npmjs.com/package/import-lazy|import-lazy}
     * package.  It enables you to replace an import like this:
     *
     * ```ts
     * import * as example from 'example'; // <-- 100ms load time
     *
     * if (condition) {
     *   example.doSomething();
     * }
     * ```
     *
     * ...with a pattern like this:
     *
     * ```ts
     * const example: typeof import('example') = Import.lazy('example', require);
     *
     * if (condition) {
     *   example.doSomething(); // <-- 100ms load time occurs here, only if needed
     * }
     * ```
     *
     * The implementation relies on JavaScript's `Proxy` feature to intercept access to object members.  Thus
     * it will only work correctly with certain types of module exports.  If a particular export isn't well behaved,
     * you may need to find (or introduce) some other module in your dependency graph to apply the optimization to.
     *
     * Usage guidelines:
     *
     * - Always specify types using `typeof` as shown above.
     *
     * - Never apply lazy-loading in a way that would convert the module's type to `any`. Losing type safety
     *   seriously impacts the maintainability of the code base.
     *
     * - In cases where the non-runtime types are needed, import them separately using the `Types` suffix:
     *
     * ```ts
     * const example: typeof import('example') = Import.lazy('example', require);
     * import type * as exampleTypes from 'example';
     * ```
     *
     * - If the imported module confusingly has the same name as its export, then use the Module suffix:
     *
     * ```ts
     * const exampleModule: typeof import('../../logic/Example') = Import.lazy(
     *   '../../logic/Example', require);
     * import type * as exampleTypes from '../../logic/Example';
     * ```
     *
     * - If the exports cause a lot of awkwardness (e.g. too many expressions need to have `exampleModule.` inserted
     *   into them), or if some exports cannot be proxied (e.g. `Import.lazy('example', require)` returns a function
     *   signature), then do not lazy-load that module.  Instead, apply lazy-loading to some other module which is
     *   better behaved.
     *
     * - It's recommended to sort imports in a standard ordering:
     *
     * ```ts
     * // 1. external imports
     * import * as path from 'path';
     * import { Import, JsonFile, JsonObject } from '@rushstack/node-core-library';
     *
     * // 2. local imports
     * import { LocalFile } from './path/LocalFile';
     *
     * // 3. lazy-imports (which are technically variables, not imports)
     * const semver: typeof import('semver') = Import.lazy('semver', require);
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static lazy(moduleName, require) {
        const importLazyLocal = importLazy(require);
        return importLazyLocal(moduleName);
    }
    /**
     * This resolves a module path using similar logic as the Node.js `require.resolve()` API,
     * but supporting extra features such as specifying the base folder.
     *
     * @remarks
     * A module path is a text string that might appear in a statement such as
     * `import { X } from "____";` or `const x = require("___");`.  The implementation is based
     * on the popular `resolve` NPM package.
     *
     * Suppose `example` is an NPM package whose entry point is `lib/index.js`:
     * ```ts
     * // Returns "/path/to/project/node_modules/example/lib/index.js"
     * Import.resolveModule({ modulePath: 'example' });
     *
     * // Returns "/path/to/project/node_modules/example/lib/other.js"
     * Import.resolveModule({ modulePath: 'example/lib/other' });
     * ```
     * If you need to determine the containing package folder
     * (`/path/to/project/node_modules/example`), use {@link Import.resolvePackage} instead.
     *
     * @returns the absolute path of the resolved module.
     * If {@link IImportResolveOptions.includeSystemModules} is specified
     * and a system module is found, then its name is returned without any file path.
     */
    static resolveModule(options) {
        const { modulePath } = options;
        if (path.isAbsolute(modulePath)) {
            return modulePath;
        }
        const normalizedRootPath = FileSystem_1.FileSystem.getRealPath(options.baseFolderPath);
        if (modulePath.startsWith('.')) {
            // This looks like a conventional relative path
            return path.resolve(normalizedRootPath, modulePath);
        }
        if (options.includeSystemModules === true && Import._builtInModules.has(modulePath)) {
            return modulePath;
        }
        if (options.allowSelfReference === true) {
            const ownPackage = Import._getPackageName(options.baseFolderPath);
            if (ownPackage && modulePath.startsWith(ownPackage.packageName)) {
                const packagePath = modulePath.substr(ownPackage.packageName.length + 1);
                return path.resolve(ownPackage.packageRootPath, packagePath);
            }
        }
        try {
            return Resolve.sync(
            // Append a slash to the package name to ensure `resolve.sync` doesn't attempt to return a system package
            options.includeSystemModules !== true && modulePath.indexOf('/') === -1
                ? `${modulePath}/`
                : modulePath, {
                basedir: normalizedRootPath,
                preserveSymlinks: false
            });
        }
        catch (e) {
            throw new Error(`Cannot find module "${modulePath}" from "${options.baseFolderPath}".`);
        }
    }
    /**
     * Performs module resolution to determine the folder where a package is installed.
     *
     * @remarks
     * Suppose `example` is an NPM package whose entry point is `lib/index.js`:
     * ```ts
     * // Returns "/path/to/project/node_modules/example"
     * Import.resolvePackage({ packageName: 'example' });
     * ```
     *
     * If you need to resolve a module path, use {@link Import.resolveModule} instead:
     * ```ts
     * // Returns "/path/to/project/node_modules/example/lib/index.js"
     * Import.resolveModule({ modulePath: 'example' });
     * ```
     *
     * @returns the absolute path of the package folder.
     * If {@link IImportResolveOptions.includeSystemModules} is specified
     * and a system module is found, then its name is returned without any file path.
     */
    static resolvePackage(options) {
        const { packageName } = options;
        if (options.includeSystemModules && Import._builtInModules.has(packageName)) {
            return packageName;
        }
        const normalizedRootPath = FileSystem_1.FileSystem.getRealPath(options.baseFolderPath);
        if (options.allowSelfReference) {
            const ownPackage = Import._getPackageName(options.baseFolderPath);
            if (ownPackage && ownPackage.packageName === packageName) {
                return ownPackage.packageRootPath;
            }
        }
        try {
            const resolvedPath = Resolve.sync(packageName, {
                basedir: normalizedRootPath,
                preserveSymlinks: false,
                packageFilter: (pkg) => {
                    // Hardwire "main" to point to a file that is guaranteed to exist.
                    // This helps resolve packages such as @types/node that have no entry point.
                    // And then we can use path.dirname() below to locate the package folder,
                    // even if the real entry point was in an subfolder with arbitrary nesting.
                    pkg.main = 'package.json';
                    return pkg;
                }
            });
            const packagePath = path.dirname(resolvedPath);
            const packageJson = PackageJsonLookup_1.PackageJsonLookup.instance.loadPackageJson(path.join(packagePath, 'package.json'));
            if (packageJson.name === packageName) {
                return packagePath;
            }
            else {
                throw new Error();
            }
        }
        catch (e) {
            throw new Error(`Cannot find package "${packageName}" from "${options.baseFolderPath}".`);
        }
    }
    static _getPackageName(rootPath) {
        const packageJsonPath = PackageJsonLookup_1.PackageJsonLookup.instance.tryGetPackageJsonFilePathFor(rootPath);
        if (packageJsonPath) {
            const packageJson = PackageJsonLookup_1.PackageJsonLookup.instance.loadPackageJson(packageJsonPath);
            return {
                packageRootPath: path.dirname(packageJsonPath),
                packageName: packageJson.name
            };
        }
        else {
            return undefined;
        }
    }
}
exports.Import = Import;
//# sourceMappingURL=Import.js.map

/***/ }),

/***/ 20318:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InternalError = void 0;
/**
 * An `Error` subclass that should be thrown to report an unexpected state that may indicate a software defect.
 * An application may handle this error by instructing the end user to report an issue to the application maintainers.
 *
 * @remarks
 * Do not use this class unless you intend to solicit bug reports from end users.
 *
 * @public
 */
class InternalError extends Error {
    /**
     * Constructs a new instance of the {@link InternalError} class.
     *
     * @param message - A message describing the error.  This will be assigned to
     * {@link InternalError.unformattedMessage}.  The `Error.message` field will have additional boilerplate
     * explaining that the user has encountered a software defect.
     */
    constructor(message) {
        super(InternalError._formatMessage(message));
        // Manually set the prototype, as we can no longer extend built-in classes like Error, Array, Map, etc.
        // https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        //
        // Note: the prototype must also be set on any classes which extend this one
        this.__proto__ = InternalError.prototype; // eslint-disable-line @typescript-eslint/no-explicit-any
        this.unformattedMessage = message;
        if (InternalError.breakInDebugger) {
            // eslint-disable-next-line no-debugger
            debugger;
        }
    }
    static _formatMessage(unformattedMessage) {
        return (`Internal Error: ${unformattedMessage}\n\nYou have encountered a software defect. Please consider` +
            ` reporting the issue to the maintainers of this application.`);
    }
    /** @override */
    toString() {
        return this.message; // Avoid adding the "Error:" prefix
    }
}
exports.InternalError = InternalError;
/**
 * If true, a JavScript `debugger;` statement will be invoked whenever the `InternalError` constructor is called.
 *
 * @remarks
 * Generally applications should not be catching and ignoring an `InternalError`.  Instead, the error should
 * be reported and typically the application will terminate.  Thus, if `InternalError` is constructed, it's
 * almost always something we want to examine in a debugger.
 */
InternalError.breakInDebugger = true;
//# sourceMappingURL=InternalError.js.map

/***/ }),

/***/ 66768:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonFile = void 0;
const os = __importStar(__webpack_require__(12087));
const jju = __importStar(__webpack_require__(93304));
const Text_1 = __webpack_require__(67638);
const FileSystem_1 = __webpack_require__(29371);
const DEFAULT_ENCODING = 'utf8';
/**
 * Utilities for reading/writing JSON files.
 * @public
 */
class JsonFile {
    /**
     * Loads a JSON file.
     */
    static load(jsonFilename) {
        try {
            const contents = FileSystem_1.FileSystem.readFile(jsonFilename);
            return jju.parse(contents);
        }
        catch (error) {
            if (FileSystem_1.FileSystem.isNotExistError(error)) {
                throw error;
            }
            else {
                throw new Error(`Error reading "${JsonFile._formatPathForError(jsonFilename)}":` +
                    os.EOL +
                    `  ${error.message}`);
            }
        }
    }
    /**
     * An async version of {@link JsonFile.load}.
     */
    static async loadAsync(jsonFilename) {
        try {
            const contents = await FileSystem_1.FileSystem.readFileAsync(jsonFilename);
            return jju.parse(contents);
        }
        catch (error) {
            if (FileSystem_1.FileSystem.isNotExistError(error)) {
                throw error;
            }
            else {
                throw new Error(`Error reading "${JsonFile._formatPathForError(jsonFilename)}":` +
                    os.EOL +
                    `  ${error.message}`);
            }
        }
    }
    /**
     * Parses a JSON file's contents.
     */
    static parseString(jsonContents) {
        return jju.parse(jsonContents);
    }
    /**
     * Loads a JSON file and validate its schema.
     */
    static loadAndValidate(jsonFilename, jsonSchema, options) {
        const jsonObject = JsonFile.load(jsonFilename);
        jsonSchema.validateObject(jsonObject, jsonFilename, options);
        return jsonObject;
    }
    /**
     * An async version of {@link JsonFile.loadAndValidate}.
     */
    static async loadAndValidateAsync(jsonFilename, jsonSchema, options) {
        const jsonObject = await JsonFile.loadAsync(jsonFilename);
        jsonSchema.validateObject(jsonObject, jsonFilename, options);
        return jsonObject;
    }
    /**
     * Loads a JSON file and validate its schema, reporting errors using a callback
     * @remarks
     * See JsonSchema.validateObjectWithCallback() for more info.
     */
    static loadAndValidateWithCallback(jsonFilename, jsonSchema, errorCallback) {
        const jsonObject = JsonFile.load(jsonFilename);
        jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);
        return jsonObject;
    }
    /**
     * An async version of {@link JsonFile.loadAndValidateWithCallback}.
     */
    static async loadAndValidateWithCallbackAsync(jsonFilename, jsonSchema, errorCallback) {
        const jsonObject = await JsonFile.loadAsync(jsonFilename);
        jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);
        return jsonObject;
    }
    /**
     * Serializes the specified JSON object to a string buffer.
     * @param jsonObject - the object to be serialized
     * @param options - other settings that control serialization
     * @returns a JSON string, with newlines, and indented with two spaces
     */
    static stringify(jsonObject, options) {
        return JsonFile.updateString('', jsonObject, options);
    }
    /**
     * Serializes the specified JSON object to a string buffer.
     * @param jsonObject - the object to be serialized
     * @param options - other settings that control serialization
     * @returns a JSON string, with newlines, and indented with two spaces
     */
    static updateString(previousJson, newJsonObject, options) {
        if (!options) {
            options = {};
        }
        if (!options.ignoreUndefinedValues) {
            // Standard handling of `undefined` in JSON stringification is to discard the key.
            JsonFile.validateNoUndefinedMembers(newJsonObject);
        }
        let stringified;
        if (previousJson !== '') {
            // NOTE: We don't use mode=json here because comments aren't allowed by strict JSON
            stringified = jju.update(previousJson, newJsonObject, {
                mode: 'cjson',
                indent: 2
            });
        }
        else if (options.prettyFormatting) {
            stringified = jju.stringify(newJsonObject, {
                mode: 'json',
                indent: 2
            });
            if (options.headerComment !== undefined) {
                stringified = JsonFile._formatJsonHeaderComment(options.headerComment) + stringified;
            }
        }
        else {
            stringified = JSON.stringify(newJsonObject, undefined, 2);
            if (options.headerComment !== undefined) {
                stringified = JsonFile._formatJsonHeaderComment(options.headerComment) + stringified;
            }
        }
        // Add the trailing newline
        stringified = Text_1.Text.ensureTrailingNewline(stringified);
        if (options && options.newlineConversion) {
            stringified = Text_1.Text.convertTo(stringified, options.newlineConversion);
        }
        return stringified;
    }
    /**
     * Saves the file to disk.  Returns false if nothing was written due to options.onlyIfChanged.
     * @param jsonObject - the object to be saved
     * @param jsonFilename - the file path to write
     * @param options - other settings that control how the file is saved
     * @returns false if ISaveJsonFileOptions.onlyIfChanged didn't save anything; true otherwise
     */
    static save(jsonObject, jsonFilename, options) {
        if (!options) {
            options = {};
        }
        // Do we need to read the previous file contents?
        let oldBuffer = undefined;
        if (options.updateExistingFile || options.onlyIfChanged) {
            try {
                oldBuffer = FileSystem_1.FileSystem.readFileToBuffer(jsonFilename);
            }
            catch (error) {
                if (!FileSystem_1.FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        }
        let jsonToUpdate = '';
        if (options.updateExistingFile && oldBuffer) {
            jsonToUpdate = oldBuffer.toString(DEFAULT_ENCODING);
        }
        const newJson = JsonFile.updateString(jsonToUpdate, jsonObject, options);
        const newBuffer = Buffer.from(newJson, DEFAULT_ENCODING);
        if (options.onlyIfChanged) {
            // Has the file changed?
            if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {
                // Nothing has changed, so don't touch the file
                return false;
            }
        }
        FileSystem_1.FileSystem.writeFile(jsonFilename, newBuffer.toString(DEFAULT_ENCODING), {
            ensureFolderExists: options.ensureFolderExists
        });
        // TEST CODE: Used to verify that onlyIfChanged isn't broken by a hidden transformation during saving.
        /*
        const oldBuffer2: Buffer = FileSystem.readFileToBuffer(jsonFilename);
        if (Buffer.compare(buffer, oldBuffer2) !== 0) {
          console.log('new:' + buffer.toString('hex'));
          console.log('old:' + oldBuffer2.toString('hex'));
    
          throw new Error('onlyIfChanged logic is broken');
        }
        */
        return true;
    }
    /**
     * An async version of {@link JsonFile.save}.
     */
    static async saveAsync(jsonObject, jsonFilename, options) {
        if (!options) {
            options = {};
        }
        // Do we need to read the previous file contents?
        let oldBuffer = undefined;
        if (options.updateExistingFile || options.onlyIfChanged) {
            try {
                oldBuffer = await FileSystem_1.FileSystem.readFileToBufferAsync(jsonFilename);
            }
            catch (error) {
                if (!FileSystem_1.FileSystem.isNotExistError(error)) {
                    throw error;
                }
            }
        }
        let jsonToUpdate = '';
        if (options.updateExistingFile && oldBuffer) {
            jsonToUpdate = oldBuffer.toString(DEFAULT_ENCODING);
        }
        const newJson = JsonFile.updateString(jsonToUpdate, jsonObject, options);
        const newBuffer = Buffer.from(newJson, DEFAULT_ENCODING);
        if (options.onlyIfChanged) {
            // Has the file changed?
            if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {
                // Nothing has changed, so don't touch the file
                return false;
            }
        }
        await FileSystem_1.FileSystem.writeFileAsync(jsonFilename, newBuffer.toString(DEFAULT_ENCODING), {
            ensureFolderExists: options.ensureFolderExists
        });
        // TEST CODE: Used to verify that onlyIfChanged isn't broken by a hidden transformation during saving.
        /*
        const oldBuffer2: Buffer = await FileSystem.readFileToBufferAsync(jsonFilename);
        if (Buffer.compare(buffer, oldBuffer2) !== 0) {
          console.log('new:' + buffer.toString('hex'));
          console.log('old:' + oldBuffer2.toString('hex'));
    
          throw new Error('onlyIfChanged logic is broken');
        }
        */
        return true;
    }
    /**
     * Used to validate a data structure before writing.  Reports an error if there
     * are any undefined members.
     */
    static validateNoUndefinedMembers(jsonObject) {
        return JsonFile._validateNoUndefinedMembers(jsonObject, []);
    }
    // Private implementation of validateNoUndefinedMembers()
    static _validateNoUndefinedMembers(jsonObject, keyPath) {
        if (!jsonObject) {
            return;
        }
        if (typeof jsonObject === 'object') {
            for (const key of Object.keys(jsonObject)) {
                keyPath.push(key);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const value = jsonObject[key];
                if (value === undefined) {
                    const fullPath = JsonFile._formatKeyPath(keyPath);
                    throw new Error(`The value for ${fullPath} is "undefined" and cannot be serialized as JSON`);
                }
                JsonFile._validateNoUndefinedMembers(value, keyPath);
                keyPath.pop();
            }
        }
    }
    // Given this input:    ['items', '4', 'syntax', 'parameters', 'string "with" symbols", 'type']
    // Return this string:  items[4].syntax.parameters["string \"with\" symbols"].type
    static _formatKeyPath(keyPath) {
        let result = '';
        for (const key of keyPath) {
            if (/^[0-9]+$/.test(key)) {
                // It's an integer, so display like this:  parent[123]
                result += `[${key}]`;
            }
            else if (/^[a-z_][a-z_0-9]*$/i.test(key)) {
                // It's an alphanumeric identifier, so display like this:  parent.name
                if (result) {
                    result += '.';
                }
                result += `${key}`;
            }
            else {
                // It's a freeform string, so display like this:  parent["A path: \"C:\\file\""]
                // Convert this:     A path: "C:\file"
                // To this:          A path: \"C:\\file\"
                const escapedKey = key
                    .replace(/[\\]/g, '\\\\') // escape backslashes
                    .replace(/["]/g, '\\'); // escape quotes
                result += `["${escapedKey}"]`;
            }
        }
        return result;
    }
    static _formatJsonHeaderComment(headerComment) {
        if (headerComment === '') {
            return '';
        }
        const lines = headerComment.split('\n');
        const result = [];
        for (const line of lines) {
            if (!/^\s*$/.test(line) && !/^\s*\/\//.test(line)) {
                throw new Error('The headerComment lines must be blank or start with the "//" prefix.\n' +
                    'Invalid line' +
                    JSON.stringify(line));
            }
            result.push(Text_1.Text.replaceAll(line, '\r', ''));
        }
        return lines.join('\n') + '\n';
    }
}
exports.JsonFile = JsonFile;
/**
 * @internal
 */
JsonFile._formatPathForError = (path) => path;
//# sourceMappingURL=JsonFile.js.map

/***/ }),

/***/ 64155:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonSchema = void 0;
const os = __importStar(__webpack_require__(12087));
const path = __importStar(__webpack_require__(85622));
const JsonFile_1 = __webpack_require__(66768);
const FileSystem_1 = __webpack_require__(29371);
const Validator = __webpack_require__(59997);
/**
 * Represents a JSON schema that can be used to validate JSON data files loaded by the JsonFile class.
 * @remarks
 * The schema itself is normally loaded and compiled later, only if it is actually required to validate
 * an input.  To avoid schema errors at runtime, it's recommended to create a unit test that calls
 * JsonSchema.ensureCompiled() for each of your schema objects.
 *
 * @public
 */
class JsonSchema {
    constructor() {
        this._dependentSchemas = [];
        this._filename = '';
        this._validator = undefined;
        this._schemaObject = undefined;
    }
    /**
     * Registers a JsonSchema that will be loaded from a file on disk.
     * @remarks
     * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
     * until it the schema is actually used.
     */
    static fromFile(filename, options) {
        // This is a quick and inexpensive test to avoid the catch the most common errors early.
        // Full validation will happen later in JsonSchema.compile().
        if (!FileSystem_1.FileSystem.exists(filename)) {
            throw new Error('Schema file not found: ' + filename);
        }
        const schema = new JsonSchema();
        schema._filename = filename;
        if (options) {
            schema._dependentSchemas = options.dependentSchemas || [];
        }
        return schema;
    }
    /**
     * Registers a JsonSchema that will be loaded from a file on disk.
     * @remarks
     * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
     * until it the schema is actually used.
     */
    static fromLoadedObject(schemaObject) {
        const schema = new JsonSchema();
        schema._schemaObject = schemaObject;
        return schema;
    }
    static _collectDependentSchemas(collectedSchemas, dependentSchemas, seenObjects, seenIds) {
        for (const dependentSchema of dependentSchemas) {
            // It's okay for the same schema to appear multiple times in the tree, but we only process it once
            if (seenObjects.has(dependentSchema)) {
                continue;
            }
            seenObjects.add(dependentSchema);
            const schemaId = dependentSchema._ensureLoaded();
            if (schemaId === '') {
                throw new Error(`This schema ${dependentSchema.shortName} cannot be referenced` +
                    ' because is missing the "id" field');
            }
            if (seenIds.has(schemaId)) {
                throw new Error(`This schema ${dependentSchema.shortName} has the same "id" as another schema in this set`);
            }
            seenIds.add(schemaId);
            collectedSchemas.push(dependentSchema);
            JsonSchema._collectDependentSchemas(collectedSchemas, dependentSchema._dependentSchemas, seenObjects, seenIds);
        }
    }
    /**
     * Used to nicely format the ZSchema error tree.
     */
    static _formatErrorDetails(errorDetails) {
        return JsonSchema._formatErrorDetailsHelper(errorDetails, '', '');
    }
    /**
     * Used by _formatErrorDetails.
     */
    static _formatErrorDetailsHelper(errorDetails, indent, buffer) {
        for (const errorDetail of errorDetails) {
            buffer += os.EOL + indent + `Error: ${errorDetail.path}`;
            if (errorDetail.description) {
                const MAX_LENGTH = 40;
                let truncatedDescription = errorDetail.description.trim();
                if (truncatedDescription.length > MAX_LENGTH) {
                    truncatedDescription = truncatedDescription.substr(0, MAX_LENGTH - 3) + '...';
                }
                buffer += ` (${truncatedDescription})`;
            }
            buffer += os.EOL + indent + `       ${errorDetail.message}`;
            if (errorDetail.inner) {
                buffer = JsonSchema._formatErrorDetailsHelper(errorDetail.inner, indent + '  ', buffer);
            }
        }
        return buffer;
    }
    /**
     * Returns a short name for this schema, for use in error messages.
     * @remarks
     * If the schema was loaded from a file, then the base filename is used.  Otherwise, the "id"
     * field is used if available.
     */
    get shortName() {
        if (!this._filename) {
            if (this._schemaObject) {
                const schemaWithId = this._schemaObject;
                if (schemaWithId.id) {
                    return schemaWithId.id;
                }
            }
            return '(anonymous schema)';
        }
        else {
            return path.basename(this._filename);
        }
    }
    /**
     * If not already done, this loads the schema from disk and compiles it.
     * @remarks
     * Any dependencies will be compiled as well.
     */
    ensureCompiled() {
        this._ensureLoaded();
        if (!this._validator) {
            // Don't assign this to _validator until we're sure everything was successful
            const newValidator = new Validator({
                breakOnFirstError: false,
                noTypeless: true,
                noExtraKeywords: true
            });
            const anythingSchema = {
                type: ['array', 'boolean', 'integer', 'number', 'object', 'string']
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            newValidator.setRemoteReference('http://json-schema.org/draft-04/schema', anythingSchema);
            const collectedSchemas = [];
            const seenObjects = new Set();
            const seenIds = new Set();
            JsonSchema._collectDependentSchemas(collectedSchemas, this._dependentSchemas, seenObjects, seenIds);
            // Validate each schema in order.  We specifically do not supply them all together, because we want
            // to make sure that circular references will fail to validate.
            for (const collectedSchema of collectedSchemas) {
                if (!newValidator.validateSchema(collectedSchema._schemaObject)) {
                    throw new Error(`Failed to validate schema "${collectedSchema.shortName}":` +
                        os.EOL +
                        JsonSchema._formatErrorDetails(newValidator.getLastErrors()));
                }
            }
            this._validator = newValidator;
        }
    }
    /**
     * Validates the specified JSON object against this JSON schema.  If the validation fails,
     * an exception will be thrown.
     * @param jsonObject - The JSON data to be validated
     * @param filenameForErrors - The filename that the JSON data was available, or an empty string
     *    if not applicable
     * @param options - Other options that control the validation
     */
    validateObject(jsonObject, filenameForErrors, options) {
        this.validateObjectWithCallback(jsonObject, (errorInfo) => {
            const prefix = options && options.customErrorHeader ? options.customErrorHeader : 'JSON validation failed:';
            throw new Error(prefix + os.EOL + filenameForErrors + os.EOL + errorInfo.details);
        });
    }
    /**
     * Validates the specified JSON object against this JSON schema.  If the validation fails,
     * a callback is called for each validation error.
     */
    validateObjectWithCallback(jsonObject, errorCallback) {
        this.ensureCompiled();
        if (!this._validator.validate(jsonObject, this._schemaObject)) {
            const errorDetails = JsonSchema._formatErrorDetails(this._validator.getLastErrors());
            const args = {
                details: errorDetails
            };
            errorCallback(args);
        }
    }
    _ensureLoaded() {
        if (!this._schemaObject) {
            this._schemaObject = JsonFile_1.JsonFile.load(this._filename);
        }
        return this._schemaObject.id || '';
    }
}
exports.JsonSchema = JsonSchema;
//# sourceMappingURL=JsonSchema.js.map

/***/ }),

/***/ 81941:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LegacyAdapters = void 0;
const timsort_1 = __webpack_require__(46655);
const semver = __importStar(__webpack_require__(11383));
/**
 * Helper functions used when interacting with APIs that do not follow modern coding practices.
 * @public
 */
class LegacyAdapters {
    static convertCallbackToPromise(fn, arg1, arg2, arg3, arg4) {
        return new Promise((resolve, reject) => {
            const cb = (error, result) => {
                if (error) {
                    reject(LegacyAdapters.scrubError(error));
                }
                else {
                    resolve(result);
                }
            };
            try {
                if (arg1 !== undefined && arg2 !== undefined && arg3 !== undefined && arg4 !== undefined) {
                    fn(arg1, arg2, arg3, arg4, cb);
                }
                else if (arg1 !== undefined && arg2 !== undefined && arg3 !== undefined) {
                    fn(arg1, arg2, arg3, cb);
                }
                else if (arg1 !== undefined && arg2 !== undefined) {
                    fn(arg1, arg2, cb);
                }
                else if (arg1 !== undefined) {
                    fn(arg1, cb);
                }
                else {
                    fn(cb);
                }
            }
            catch (e) {
                reject(e);
            }
        });
    }
    /**
     * Normalizes an object into an `Error` object.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static scrubError(error) {
        if (error instanceof Error) {
            return error;
        }
        else if (typeof error === 'string') {
            return new Error(error);
        }
        else {
            const errorObject = new Error('An error occurred.');
            errorObject.errorData = error; // eslint-disable-line @typescript-eslint/no-explicit-any
            return errorObject;
        }
    }
    /**
     * Prior to Node 11.x, the `Array.sort()` algorithm is not guaranteed to be stable.
     * If you need a stable sort, you can use `sortStable()` as a workaround.
     *
     * @remarks
     * On NodeJS 11.x and later, this method simply calls the native `Array.sort()`.
     * For earlier versions, it uses an implementation of Timsort, which is the same algorithm used by modern NodeJS.
     */
    static sortStable(array, compare) {
        if (LegacyAdapters._useTimsort === undefined) {
            LegacyAdapters._useTimsort = semver.major(process.versions.node) < 11;
        }
        if (LegacyAdapters._useTimsort) {
            (0, timsort_1.sort)(array, compare);
        }
        else {
            Array.prototype.sort.call(array, compare);
        }
    }
}
exports.LegacyAdapters = LegacyAdapters;
LegacyAdapters._useTimsort = undefined;
//# sourceMappingURL=LegacyAdapters.js.map

/***/ }),

/***/ 58954:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LockFile = exports.getProcessStartTime = exports.getProcessStartTimeFromProcStat = void 0;
const path = __importStar(__webpack_require__(85622));
const child_process = __importStar(__webpack_require__(63129));
const FileSystem_1 = __webpack_require__(29371);
const FileWriter_1 = __webpack_require__(20830);
const Async_1 = __webpack_require__(40223);
/**
 * http://man7.org/linux/man-pages/man5/proc.5.html
 * (22) starttime  %llu
 * The time the process started after system boot. In kernels before Linux 2.6, this value was
 * expressed in jiffies. Since Linux 2.6, the value is expressed in clock ticks (divide by
 * sysconf(_SC_CLK_TCK)).
 * The format for this field was %lu before Linux 2.6.
 */
const procStatStartTimePos = 22;
/**
 * Parses the process start time from the contents of a linux /proc/[pid]/stat file.
 * @param stat - The contents of a linux /proc/[pid]/stat file.
 * @returns The process start time in jiffies, or undefined if stat has an unexpected format.
 */
function getProcessStartTimeFromProcStat(stat) {
    // Parse the value at position procStatStartTimePos.
    // We cannot just split stat on spaces, because value 2 may contain spaces.
    // For example, when running the following Shell commands:
    // > cp "$(which bash)" ./'bash 2)('
    // > ./'bash 2)(' -c 'OWNPID=$BASHPID;cat /proc/$OWNPID/stat'
    // 59389 (bash 2)() S 59358 59389 59358 34818 59389 4202496 329 0 0 0 0 0 0 0 20 0 1 0
    // > rm -rf ./'bash 2)('
    // The output shows a stat file such that value 2 contains spaces.
    // To still umambiguously parse such output we assume no values after the second ends with a right parenthesis...
    // trimRight to remove the trailing line terminator.
    let values = stat.trimRight().split(' ');
    let i = values.length - 1;
    while (i >= 0 &&
        // charAt returns an empty string if the index is out of bounds.
        values[i].charAt(values[i].length - 1) !== ')') {
        i -= 1;
    }
    // i is the index of the last part of the second value (but i need not be 1).
    if (i < 1) {
        // Format of stat has changed.
        return undefined;
    }
    const value2 = values.slice(1, i + 1).join(' ');
    values = [values[0], value2].concat(values.slice(i + 1));
    if (values.length < procStatStartTimePos) {
        // Older version of linux, or non-standard configuration of linux.
        return undefined;
    }
    const startTimeJiffies = values[procStatStartTimePos - 1];
    // In theory, the representations of start time returned by `cat /proc/[pid]/stat` and `ps -o lstart` can change
    // while the system is running, but we assume this does not happen.
    // So the caller can safely use this value as part of a unique process id (on the machine, without comparing
    // accross reboots).
    return startTimeJiffies;
}
exports.getProcessStartTimeFromProcStat = getProcessStartTimeFromProcStat;
/**
 * Helper function that is exported for unit tests only.
 * Returns undefined if the process doesn't exist with that pid.
 */
function getProcessStartTime(pid) {
    const pidString = pid.toString();
    if (pid < 0 || pidString.indexOf('e') >= 0 || pidString.indexOf('E') >= 0) {
        throw new Error(`"pid" is negative or too large`);
    }
    let args;
    if (process.platform === 'darwin') {
        args = [`-p ${pidString}`, '-o lstart'];
    }
    else if (process.platform === 'linux') {
        args = ['-p', pidString, '-o', 'lstart'];
    }
    else {
        throw new Error(`Unsupported system: ${process.platform}`);
    }
    const psResult = child_process.spawnSync('ps', args, {
        encoding: 'utf8'
    });
    const psStdout = psResult.stdout;
    // If no process with PID pid exists then the exit code is non-zero on linux but stdout is not empty.
    // But if no process exists we do not want to fall back on /proc/*/stat to determine the process
    // start time, so we we additionally test for !psStdout. NOTE: !psStdout evaluates to true if
    // zero bytes are written to stdout.
    if (psResult.status !== 0 && !psStdout && process.platform === 'linux') {
        // Try to read /proc/[pid]/stat and get the value at position procStatStartTimePos.
        let stat;
        try {
            stat = FileSystem_1.FileSystem.readFile(`/proc/${pidString}/stat`);
        }
        catch (error) {
            if (error.code !== 'ENOENT') {
                throw error;
            }
            // Either no process with PID pid exists, or this version/configuration of linux is non-standard.
            // We assume the former.
            return undefined;
        }
        if (stat !== undefined) {
            const startTimeJiffies = getProcessStartTimeFromProcStat(stat);
            if (startTimeJiffies === undefined) {
                throw new Error(`Could not retrieve the start time of process ${pidString} from the OS because the ` +
                    `contents of /proc/${pidString}/stat have an unexpected format`);
            }
            return startTimeJiffies;
        }
    }
    // there was an error executing ps (zero bytes were written to stdout).
    if (!psStdout) {
        throw new Error(`Unexpected output from "ps" command`);
    }
    const psSplit = psStdout.split('\n');
    // successfuly able to run "ps", but no process was found
    if (psSplit[1] === '') {
        return undefined;
    }
    if (psSplit[1]) {
        const trimmed = psSplit[1].trim();
        if (trimmed.length > 10) {
            return trimmed;
        }
    }
    throw new Error(`Unexpected output from the "ps" command`);
}
exports.getProcessStartTime = getProcessStartTime;
/**
 * The `LockFile` implements a file-based mutex for synchronizing access to a shared resource
 * between multiple Node.js processes.  It is not recommended for synchronization solely within
 * a single Node.js process.
 * @remarks
 * The implementation works on Windows, Mac, and Linux without requiring any native helpers.
 * On non-Windows systems, the algorithm requires access to the `ps` shell command.  On Linux,
 * it requires access the `/proc/${pidString}/stat` filesystem.
 * @public
 */
class LockFile {
    constructor(fileWriter, filePath, dirtyWhenAcquired) {
        this._fileWriter = fileWriter;
        this._filePath = filePath;
        this._dirtyWhenAcquired = dirtyWhenAcquired;
    }
    /**
     * Returns the path of the lockfile that will be created when a lock is successfully acquired.
     * @param resourceFolder - The folder where the lock file will be created
     * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
     *   the filename of the temporary file created to manage the lock.
     * @param pid - The PID for the current Node.js process (`process.pid`), which is used by the locking algorithm.
     */
    static getLockFilePath(resourceFolder, resourceName, pid = process.pid) {
        if (!resourceName.match(/^[a-zA-Z0-9][a-zA-Z0-9-.]+[a-zA-Z0-9]$/)) {
            throw new Error(`The resource name "${resourceName}" is invalid.` +
                ` It must be an alphanumberic string with only "-" or "." It must start with an alphanumeric character.`);
        }
        if (process.platform === 'win32') {
            return path.join(path.resolve(resourceFolder), `${resourceName}.lock`);
        }
        else if (process.platform === 'linux' || process.platform === 'darwin') {
            return path.join(path.resolve(resourceFolder), `${resourceName}#${pid}.lock`);
        }
        throw new Error(`File locking not implemented for platform: "${process.platform}"`);
    }
    /**
     * Attempts to create a lockfile with the given filePath.
     * @param resourceFolder - The folder where the lock file will be created
     * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
     *   the filename of the temporary file created to manage the lock.
     * @returns If successful, returns a `LockFile` instance.  If unable to get a lock, returns `undefined`.
     */
    static tryAcquire(resourceFolder, resourceName) {
        FileSystem_1.FileSystem.ensureFolder(resourceFolder);
        if (process.platform === 'win32') {
            return LockFile._tryAcquireWindows(resourceFolder, resourceName);
        }
        else if (process.platform === 'linux' || process.platform === 'darwin') {
            return LockFile._tryAcquireMacOrLinux(resourceFolder, resourceName);
        }
        throw new Error(`File locking not implemented for platform: "${process.platform}"`);
    }
    /**
     * Attempts to create the lockfile.  Will continue to loop at every 100ms until the lock becomes available
     * or the maxWaitMs is surpassed.
     *
     * @remarks
     * This function is subject to starvation, whereby it does not ensure that the process that has been
     * waiting the longest to acquire the lock will get it first. This means that a process could theoretically
     * wait for the lock forever, while other processes skipped it in line and acquired the lock first.
     *
     * @param resourceFolder - The folder where the lock file will be created
     * @param resourceName - An alphanumeric name that describes the resource being locked.  This will become
     *   the filename of the temporary file created to manage the lock.
     * @param maxWaitMs - The maximum number of milliseconds to wait for the lock before reporting an error
     */
    static acquire(resourceFolder, resourceName, maxWaitMs) {
        const interval = 100;
        const startTime = Date.now();
        const retryLoop = async () => {
            const lock = LockFile.tryAcquire(resourceFolder, resourceName);
            if (lock) {
                return lock;
            }
            if (maxWaitMs && Date.now() > startTime + maxWaitMs) {
                throw new Error(`Exceeded maximum wait time to acquire lock for resource "${resourceName}"`);
            }
            await Async_1.Async.sleep(interval);
            return retryLoop();
        };
        return retryLoop();
    }
    /**
     * Attempts to acquire the lock on a Linux or OSX machine
     */
    static _tryAcquireMacOrLinux(resourceFolder, resourceName) {
        let dirtyWhenAcquired = false;
        // get the current process' pid
        const pid = process.pid;
        const startTime = LockFile._getStartTime(pid);
        if (!startTime) {
            throw new Error(`Unable to calculate start time for current process.`);
        }
        const pidLockFilePath = LockFile.getLockFilePath(resourceFolder, resourceName);
        let lockFileHandle;
        let lockFile;
        try {
            // open in write mode since if this file exists, it cannot be from the current process
            // TODO: This will malfunction if the same process tries to acquire two locks on the same file.
            // We should ideally maintain a dictionary of normalized acquired filenames
            lockFileHandle = FileWriter_1.FileWriter.open(pidLockFilePath);
            lockFileHandle.write(startTime);
            const currentBirthTimeMs = FileSystem_1.FileSystem.getStatistics(pidLockFilePath).birthtime.getTime();
            let smallestBirthTimeMs = currentBirthTimeMs;
            let smallestBirthTimePid = pid.toString();
            // now, scan the directory for all lockfiles
            const files = FileSystem_1.FileSystem.readFolder(resourceFolder);
            // look for anything ending with # then numbers and ".lock"
            const lockFileRegExp = /^(.+)#([0-9]+)\.lock$/;
            let match;
            let otherPid;
            for (const fileInFolder of files) {
                if ((match = fileInFolder.match(lockFileRegExp)) &&
                    match[1] === resourceName &&
                    (otherPid = match[2]) !== pid.toString()) {
                    // we found at least one lockfile hanging around that isn't ours
                    const fileInFolderPath = path.join(resourceFolder, fileInFolder);
                    dirtyWhenAcquired = true;
                    // console.log(`FOUND OTHER LOCKFILE: ${otherPid}`);
                    const otherPidCurrentStartTime = LockFile._getStartTime(parseInt(otherPid, 10));
                    let otherPidOldStartTime;
                    let otherBirthtimeMs;
                    try {
                        otherPidOldStartTime = FileSystem_1.FileSystem.readFile(fileInFolderPath);
                        // check the timestamp of the file
                        otherBirthtimeMs = FileSystem_1.FileSystem.getStatistics(fileInFolderPath).birthtime.getTime();
                    }
                    catch (err) {
                        // this means the file is probably deleted already
                    }
                    // if the otherPidOldStartTime is invalid, then we should look at the timestamp,
                    // if this file was created after us, ignore it
                    // if it was created within 1 second before us, then it could be good, so we
                    //  will conservatively fail
                    // otherwise it is an old lock file and will be deleted
                    if (otherPidOldStartTime === '' && otherBirthtimeMs !== undefined) {
                        if (otherBirthtimeMs > currentBirthTimeMs) {
                            // ignore this file, he will be unable to get the lock since this process
                            // will hold it
                            // console.log(`Ignoring lock for pid ${otherPid} because its lockfile is newer than ours.`);
                            continue;
                        }
                        else if (otherBirthtimeMs - currentBirthTimeMs < 0 && // it was created before us AND
                            otherBirthtimeMs - currentBirthTimeMs > -1000) {
                            // it was created less than a second before
                            // conservatively be unable to keep the lock
                            return undefined;
                        }
                    }
                    // console.log(`Other pid ${otherPid} lockfile has start time: "${otherPidOldStartTime}"`);
                    // console.log(`Other pid ${otherPid} actually has start time: "${otherPidCurrentStartTime}"`);
                    // this means the process is no longer executing, delete the file
                    if (!otherPidCurrentStartTime || otherPidOldStartTime !== otherPidCurrentStartTime) {
                        // console.log(`Other pid ${otherPid} is no longer executing!`);
                        FileSystem_1.FileSystem.deleteFile(fileInFolderPath);
                        continue;
                    }
                    // console.log(`Pid ${otherPid} lockfile has birth time: ${otherBirthtimeMs}`);
                    // console.log(`Pid ${pid} lockfile has birth time: ${currentBirthTimeMs}`);
                    // this is a lockfile pointing at something valid
                    if (otherBirthtimeMs !== undefined && otherBirthtimeMs < smallestBirthTimeMs) {
                        smallestBirthTimeMs = otherBirthtimeMs;
                        smallestBirthTimePid = otherPid;
                    }
                }
            }
            if (smallestBirthTimePid !== pid.toString()) {
                // we do not have the lock
                return undefined;
            }
            // we have the lock!
            lockFile = new LockFile(lockFileHandle, pidLockFilePath, dirtyWhenAcquired);
            lockFileHandle = undefined; // we have handed the descriptor off to the instance
        }
        finally {
            if (lockFileHandle) {
                // ensure our lock is closed
                lockFileHandle.close();
                FileSystem_1.FileSystem.deleteFile(pidLockFilePath);
            }
        }
        return lockFile;
    }
    /**
     * Attempts to acquire the lock using Windows
     * This algorithm is much simpler since we can rely on the operating system
     */
    static _tryAcquireWindows(resourceFolder, resourceName) {
        const lockFilePath = LockFile.getLockFilePath(resourceFolder, resourceName);
        let dirtyWhenAcquired = false;
        let fileHandle;
        let lockFile;
        try {
            if (FileSystem_1.FileSystem.exists(lockFilePath)) {
                dirtyWhenAcquired = true;
                // If the lockfile is held by an process with an exclusive lock, then removing it will
                // silently fail. OpenSync() below will then fail and we will be unable to create a lock.
                // Otherwise, the lockfile is sitting on disk, but nothing is holding it, implying that
                // the last process to hold it died.
                FileSystem_1.FileSystem.deleteFile(lockFilePath);
            }
            try {
                // Attempt to open an exclusive lockfile
                fileHandle = FileWriter_1.FileWriter.open(lockFilePath, { exclusive: true });
            }
            catch (error) {
                // we tried to delete the lock, but something else is holding it,
                // (probably an active process), therefore we are unable to create a lock
                return undefined;
            }
            // Ensure we can hand off the file descriptor to the lockfile
            lockFile = new LockFile(fileHandle, lockFilePath, dirtyWhenAcquired);
            fileHandle = undefined;
        }
        finally {
            if (fileHandle) {
                fileHandle.close();
            }
        }
        return lockFile;
    }
    /**
     * Unlocks a file and removes it from disk.
     * This can only be called once.
     */
    release() {
        if (this.isReleased) {
            throw new Error(`The lock for file "${path.basename(this._filePath)}" has already been released.`);
        }
        this._fileWriter.close();
        FileSystem_1.FileSystem.deleteFile(this._filePath);
        this._fileWriter = undefined;
    }
    /**
     * Returns the initial state of the lock.
     * This can be used to detect if the previous process was terminated before releasing the resource.
     */
    get dirtyWhenAcquired() {
        return this._dirtyWhenAcquired;
    }
    /**
     * Returns the absolute path to the lockfile
     */
    get filePath() {
        return this._filePath;
    }
    /**
     * Returns true if this lock is currently being held.
     */
    get isReleased() {
        return this._fileWriter === undefined;
    }
}
exports.LockFile = LockFile;
LockFile._getStartTime = getProcessStartTime;
//# sourceMappingURL=LockFile.js.map

/***/ }),

/***/ 54396:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapExtensions = void 0;
/**
 * Helper functions for working with the `Map<K, V>` data type.
 *
 * @public
 */
class MapExtensions {
    /**
     * Adds all the (key, value) pairs from the source map into the target map.
     * @remarks
     * This function modifies targetMap.  Any existing keys will be overwritten.
     * @param targetMap - The map that entries will be added to
     * @param sourceMap - The map containing the entries to be added
     */
    static mergeFromMap(targetMap, sourceMap) {
        for (const pair of sourceMap.entries()) {
            targetMap.set(pair[0], pair[1]);
        }
    }
    /**
     * Converts a string-keyed map to an object.
     * @remarks
     * This function has the same effect as Object.fromEntries(map.entries())
     * in supported versions of Node (\>= 12.0.0).
     * @param map - The map that the object properties will be sourced from
     */
    static toObject(map) {
        const object = {};
        for (const [key, value] of map.entries()) {
            object[key] = value;
        }
        return object;
    }
}
exports.MapExtensions = MapExtensions;
//# sourceMappingURL=MapExtensions.js.map

/***/ }),

/***/ 87330:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageJsonLookup = void 0;
const path = __importStar(__webpack_require__(85622));
const JsonFile_1 = __webpack_require__(66768);
const FileSystem_1 = __webpack_require__(29371);
/**
 * This class provides methods for finding the nearest "package.json" for a folder
 * and retrieving the name of the package.  The results are cached.
 *
 * @public
 */
class PackageJsonLookup {
    constructor(parameters) {
        this._loadExtraFields = false;
        if (parameters) {
            if (parameters.loadExtraFields) {
                this._loadExtraFields = parameters.loadExtraFields;
            }
        }
        this.clearCache();
    }
    /**
     * A singleton instance of `PackageJsonLookup`, which is useful for short-lived processes
     * that can reasonably assume that the file system will not be modified after the cache
     * is populated.
     *
     * @remarks
     * For long-running processes that need to clear the cache at appropriate times,
     * it is recommended to create your own instance of `PackageJsonLookup` instead
     * of relying on this instance.
     */
    static get instance() {
        if (!PackageJsonLookup._instance) {
            PackageJsonLookup._instance = new PackageJsonLookup({ loadExtraFields: true });
        }
        return PackageJsonLookup._instance;
    }
    /**
     * A helper for loading the caller's own package.json file.
     *
     * @remarks
     *
     * This function provides a concise and efficient way for an NPM package to report metadata about itself.
     * For example, a tool might want to report its version.
     *
     * The `loadOwnPackageJson()` probes upwards from the caller's folder, expecting to find a package.json file,
     * which is assumed to be the caller's package.  The result is cached, under the assumption that a tool's
     * own package.json (and intermediary folders) will never change during the lifetime of the process.
     *
     * @example
     * ```ts
     * // Report the version of our NPM package
     * const myPackageVersion: string = PackageJsonLookup.loadOwnPackageJson(__dirname).version;
     * console.log(`Cool Tool - Version ${myPackageVersion}`);
     * ```
     *
     * @param dirnameOfCaller - The NodeJS `__dirname` macro for the caller.
     * @returns This function always returns a valid `IPackageJson` object.  If any problems are encountered during
     * loading, an exception will be thrown instead.
     */
    static loadOwnPackageJson(dirnameOfCaller) {
        const packageJson = PackageJsonLookup.instance.tryLoadPackageJsonFor(dirnameOfCaller);
        if (packageJson === undefined) {
            throw new Error(`PackageJsonLookup.loadOwnPackageJson() failed to find the caller's package.json.` +
                `  The __dirname was: ${dirnameOfCaller}`);
        }
        if (packageJson.version !== undefined) {
            return packageJson;
        }
        const errorPath = PackageJsonLookup.instance.tryGetPackageJsonFilePathFor(dirnameOfCaller) || 'package.json';
        throw new Error(`PackageJsonLookup.loadOwnPackageJson() failed because the "version" field is missing in` +
            ` ${errorPath}`);
    }
    /**
     * Clears the internal file cache.
     * @remarks
     * Call this method if changes have been made to the package.json files on disk.
     */
    clearCache() {
        this._packageFolderCache = new Map();
        this._packageJsonCache = new Map();
    }
    /**
     * Returns the absolute path of a folder containing a package.json file, by looking
     * upwards from the specified fileOrFolderPath.  If no package.json can be found,
     * undefined is returned.
     *
     * @remarks
     * The fileOrFolderPath is not required to actually exist on disk.
     * The fileOrFolderPath itself can be the return value, if it is a folder containing
     * a package.json file.
     * Both positive and negative lookup results are cached.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an absolute path to a folder containing a package.json file
     */
    tryGetPackageFolderFor(fileOrFolderPath) {
        // Convert it to an absolute path
        const resolvedFileOrFolderPath = path.resolve(fileOrFolderPath);
        // Optimistically hope that the starting string is already in the cache,
        // in which case we can avoid disk access entirely.
        //
        // (Two lookups are required, because get() cannot distinguish the undefined value
        // versus a missing key.)
        if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {
            return this._packageFolderCache.get(resolvedFileOrFolderPath);
        }
        // Now call the recursive part of the algorithm
        return this._tryGetPackageFolderFor(resolvedFileOrFolderPath);
    }
    /**
     * If the specified file or folder is part of a package, this returns the absolute path
     * to the associated package.json file.
     *
     * @remarks
     * The package folder is determined using the same algorithm
     * as {@link PackageJsonLookup.tryGetPackageFolderFor}.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an absolute path to * package.json file
     */
    tryGetPackageJsonFilePathFor(fileOrFolderPath) {
        const packageJsonFolder = this.tryGetPackageFolderFor(fileOrFolderPath);
        if (!packageJsonFolder) {
            return undefined;
        }
        return path.join(packageJsonFolder, "package.json" /* PackageJson */);
    }
    /**
     * If the specified file or folder is part of a package, this loads and returns the
     * associated package.json file.
     *
     * @remarks
     * The package folder is determined using the same algorithm
     * as {@link PackageJsonLookup.tryGetPackageFolderFor}.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an IPackageJson object, or undefined if the fileOrFolderPath does not
     * belong to a package
     */
    tryLoadPackageJsonFor(fileOrFolderPath) {
        const packageJsonFilePath = this.tryGetPackageJsonFilePathFor(fileOrFolderPath);
        if (!packageJsonFilePath) {
            return undefined;
        }
        return this.loadPackageJson(packageJsonFilePath);
    }
    /**
     * This function is similar to {@link PackageJsonLookup.tryLoadPackageJsonFor}, except that it does not report
     * an error if the `version` field is missing from the package.json file.
     */
    tryLoadNodePackageJsonFor(fileOrFolderPath) {
        const packageJsonFilePath = this.tryGetPackageJsonFilePathFor(fileOrFolderPath);
        if (!packageJsonFilePath) {
            return undefined;
        }
        return this.loadNodePackageJson(packageJsonFilePath);
    }
    /**
     * Loads the specified package.json file, if it is not already present in the cache.
     *
     * @remarks
     * Unless {@link IPackageJsonLookupParameters.loadExtraFields} was specified,
     * the returned IPackageJson object will contain a subset of essential fields.
     * The returned object should be considered to be immutable; the caller must never
     * modify it.
     *
     * @param jsonFilename - a relative or absolute path to a package.json file
     */
    loadPackageJson(jsonFilename) {
        const packageJson = this.loadNodePackageJson(jsonFilename);
        if (!packageJson.version) {
            throw new Error(`Error reading "${jsonFilename}":\n  The required field "version" was not found`);
        }
        return packageJson;
    }
    /**
     * This function is similar to {@link PackageJsonLookup.loadPackageJson}, except that it does not report an error
     * if the `version` field is missing from the package.json file.
     */
    loadNodePackageJson(jsonFilename) {
        if (!FileSystem_1.FileSystem.exists(jsonFilename)) {
            throw new Error(`Input file not found: ${jsonFilename}`);
        }
        // Since this will be a cache key, follow any symlinks and get an absolute path
        // to minimize duplication.  (Note that duplication can still occur due to e.g. character case.)
        const normalizedFilePath = FileSystem_1.FileSystem.getRealPath(jsonFilename);
        let packageJson = this._packageJsonCache.get(normalizedFilePath);
        if (!packageJson) {
            const loadedPackageJson = JsonFile_1.JsonFile.load(normalizedFilePath);
            // Make sure this is really a package.json file.  CommonJS has fairly strict requirements,
            // but NPM only requires "name" and "version"
            if (!loadedPackageJson.name) {
                throw new Error(`Error reading "${jsonFilename}":\n  The required field "name" was not found`);
            }
            if (this._loadExtraFields) {
                packageJson = loadedPackageJson;
            }
            else {
                packageJson = {};
                // Unless "loadExtraFields" was requested, copy over the essential fields only
                packageJson.bin = loadedPackageJson.bin;
                packageJson.dependencies = loadedPackageJson.dependencies;
                packageJson.description = loadedPackageJson.description;
                packageJson.devDependencies = loadedPackageJson.devDependencies;
                packageJson.homepage = loadedPackageJson.homepage;
                packageJson.license = loadedPackageJson.license;
                packageJson.main = loadedPackageJson.main;
                packageJson.name = loadedPackageJson.name;
                packageJson.optionalDependencies = loadedPackageJson.optionalDependencies;
                packageJson.peerDependencies = loadedPackageJson.peerDependencies;
                packageJson.private = loadedPackageJson.private;
                packageJson.scripts = loadedPackageJson.scripts;
                packageJson.typings = loadedPackageJson.typings || loadedPackageJson.types;
                packageJson.tsdocMetadata = loadedPackageJson.tsdocMetadata;
                packageJson.version = loadedPackageJson.version;
            }
            Object.freeze(packageJson);
            this._packageJsonCache.set(normalizedFilePath, packageJson);
        }
        return packageJson;
    }
    // Recursive part of the algorithm from tryGetPackageFolderFor()
    _tryGetPackageFolderFor(resolvedFileOrFolderPath) {
        // Two lookups are required, because get() cannot distinguish the undefined value
        // versus a missing key.
        if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {
            return this._packageFolderCache.get(resolvedFileOrFolderPath);
        }
        // Is resolvedFileOrFolderPath itself a folder with a package.json file?  If so, return it.
        if (FileSystem_1.FileSystem.exists(path.join(resolvedFileOrFolderPath, "package.json" /* PackageJson */))) {
            this._packageFolderCache.set(resolvedFileOrFolderPath, resolvedFileOrFolderPath);
            return resolvedFileOrFolderPath;
        }
        // Otherwise go up one level
        const parentFolder = path.dirname(resolvedFileOrFolderPath);
        if (!parentFolder || parentFolder === resolvedFileOrFolderPath) {
            // We reached the root directory without finding a package.json file,
            // so cache the negative result
            this._packageFolderCache.set(resolvedFileOrFolderPath, undefined);
            return undefined; // no match
        }
        // Recurse upwards, caching every step along the way
        const parentResult = this._tryGetPackageFolderFor(parentFolder);
        // Cache the parent's answer as well
        this._packageFolderCache.set(resolvedFileOrFolderPath, parentResult);
        return parentResult;
    }
}
exports.PackageJsonLookup = PackageJsonLookup;
//# sourceMappingURL=PackageJsonLookup.js.map

/***/ }),

/***/ 76737:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageName = exports.PackageNameParser = void 0;
/**
 * A configurable parser for validating and manipulating NPM package names such as `my-package` or `@scope/my-package`.
 *
 * @remarks
 * If you do not need to customize the parser configuration, it is recommended to use {@link PackageName}
 * which exposes these operations as a simple static class.
 *
 * @public
 */
class PackageNameParser {
    constructor(options = {}) {
        this._options = Object.assign({}, options);
    }
    /**
     * This attempts to parse a package name that may include a scope component.
     * The packageName must not be an empty string.
     * @remarks
     * This function will not throw an exception.
     *
     * @returns an {@link IParsedPackageNameOrError} structure whose `error` property will be
     * nonempty if the string could not be parsed.
     */
    tryParse(packageName) {
        const result = {
            scope: '',
            unscopedName: '',
            error: ''
        };
        let input = packageName;
        if (input === null || input === undefined) {
            result.error = 'The package name must not be null or undefined';
            return result;
        }
        // Rule from npmjs.com:
        // "The name must be less than or equal to 214 characters. This includes the scope for scoped packages."
        if (packageName.length > 214) {
            // Don't attempt to parse a ridiculously long input
            result.error = 'The package name cannot be longer than 214 characters';
            return result;
        }
        if (input[0] === '@') {
            const indexOfScopeSlash = input.indexOf('/');
            if (indexOfScopeSlash <= 0) {
                result.scope = input;
                result.error = `Error parsing "${packageName}": The scope must be followed by a slash`;
                return result;
            }
            // Extract the scope substring
            result.scope = input.substr(0, indexOfScopeSlash);
            input = input.substr(indexOfScopeSlash + 1);
        }
        result.unscopedName = input;
        if (result.scope === '@') {
            result.error = `Error parsing "${packageName}": The scope name cannot be empty`;
            return result;
        }
        if (result.unscopedName === '') {
            result.error = 'The package name must not be empty';
            return result;
        }
        // Rule from npmjs.com:
        // "The name can't start with a dot or an underscore."
        if (result.unscopedName[0] === '.' || result.unscopedName[0] === '_') {
            result.error = `The package name "${packageName}" starts with an invalid character`;
            return result;
        }
        // Convert "@scope/unscoped-name" --> "scopeunscoped-name"
        const nameWithoutScopeSymbols = (result.scope ? result.scope.slice(1, -1) : '') + result.unscopedName;
        if (!this._options.allowUpperCase) {
            // "New packages must not have uppercase letters in the name."
            // This can't be enforced because "old" packages are still actively maintained.
            // Example: https://www.npmjs.com/package/Base64
            // However it's pretty reasonable to require the scope to be lower case
            if (result.scope !== result.scope.toLowerCase()) {
                result.error = `The package scope "${result.scope}" must not contain upper case characters`;
                return result;
            }
        }
        // "The name ends up being part of a URL, an argument on the command line, and a folder name.
        // Therefore, the name can't contain any non-URL-safe characters"
        const match = nameWithoutScopeSymbols.match(PackageNameParser._invalidNameCharactersRegExp);
        if (match) {
            result.error = `The package name "${packageName}" contains an invalid character: "${match[0]}"`;
            return result;
        }
        return result;
    }
    /**
     * Same as {@link PackageName.tryParse}, except this throws an exception if the input
     * cannot be parsed.
     * @remarks
     * The packageName must not be an empty string.
     */
    parse(packageName) {
        const result = this.tryParse(packageName);
        if (result.error) {
            throw new Error(result.error);
        }
        return result;
    }
    /**
     * {@inheritDoc IParsedPackageName.scope}
     */
    getScope(packageName) {
        return this.parse(packageName).scope;
    }
    /**
     * {@inheritDoc IParsedPackageName.unscopedName}
     */
    getUnscopedName(packageName) {
        return this.parse(packageName).unscopedName;
    }
    /**
     * Returns true if the specified package name is valid, or false otherwise.
     * @remarks
     * This function will not throw an exception.
     */
    isValidName(packageName) {
        const result = this.tryParse(packageName);
        return !result.error;
    }
    /**
     * Throws an exception if the specified name is not a valid package name.
     * The packageName must not be an empty string.
     */
    validate(packageName) {
        this.parse(packageName);
    }
    /**
     * Combines an optional package scope with an unscoped root name.
     * @param scope - Must be either an empty string, or a scope name such as "\@example"
     * @param unscopedName - Must be a nonempty package name that does not contain a scope
     * @returns A full package name such as "\@example/some-library".
     */
    combineParts(scope, unscopedName) {
        if (scope !== '') {
            if (scope[0] !== '@') {
                throw new Error('The scope must start with an "@" character');
            }
        }
        if (scope.indexOf('/') >= 0) {
            throw new Error('The scope must not contain a "/" character');
        }
        if (unscopedName[0] === '@') {
            throw new Error('The unscopedName cannot start with an "@" character');
        }
        if (unscopedName.indexOf('/') >= 0) {
            throw new Error('The unscopedName must not contain a "/" character');
        }
        let result;
        if (scope === '') {
            result = unscopedName;
        }
        else {
            result = scope + '/' + unscopedName;
        }
        // Make sure the result is a valid package name
        this.validate(result);
        return result;
    }
}
exports.PackageNameParser = PackageNameParser;
// encodeURIComponent() escapes all characters except:  A-Z a-z 0-9 - _ . ! ~ * ' ( )
// However, these are disallowed because they are shell characters:       ! ~ * ' ( )
PackageNameParser._invalidNameCharactersRegExp = /[^A-Za-z0-9\-_\.]/;
/**
 * Provides basic operations for validating and manipulating NPM package names such as `my-package`
 * or `@scope/my-package`.
 *
 * @remarks
 * This is the default implementation of {@link PackageNameParser}, exposed as a convenient static class.
 * If you need to configure the parsing rules, use `PackageNameParser` instead.
 *
 * @public
 */
class PackageName {
    /** {@inheritDoc PackageNameParser.tryParse} */
    static tryParse(packageName) {
        return PackageName._parser.tryParse(packageName);
    }
    /** {@inheritDoc PackageNameParser.parse} */
    static parse(packageName) {
        return this._parser.parse(packageName);
    }
    /** {@inheritDoc PackageNameParser.getScope} */
    static getScope(packageName) {
        return this._parser.getScope(packageName);
    }
    /** {@inheritDoc PackageNameParser.getUnscopedName} */
    static getUnscopedName(packageName) {
        return this._parser.getUnscopedName(packageName);
    }
    /** {@inheritDoc PackageNameParser.isValidName} */
    static isValidName(packageName) {
        return this._parser.isValidName(packageName);
    }
    /** {@inheritDoc PackageNameParser.validate} */
    static validate(packageName) {
        return this._parser.validate(packageName);
    }
    /** {@inheritDoc PackageNameParser.combineParts} */
    static combineParts(scope, unscopedName) {
        return this._parser.combineParts(scope, unscopedName);
    }
}
exports.PackageName = PackageName;
PackageName._parser = new PackageNameParser();
//# sourceMappingURL=PackageName.js.map

/***/ }),

/***/ 45574:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Path = void 0;
const path = __importStar(__webpack_require__(85622));
const Text_1 = __webpack_require__(67638);
/**
 * Common operations for manipulating file and directory paths.
 * @remarks
 * This API is intended to eventually be a complete replacement for the NodeJS "path" API.
 * @public
 */
class Path {
    /**
     * Returns true if "childPath" is located inside the "parentFolderPath" folder
     * or one of its child folders.  Note that "parentFolderPath" is not considered to be
     * under itself.  The "childPath" can refer to any type of file system object.
     *
     * @remarks
     * The indicated file/folder objects are not required to actually exist on disk.
     * For example, "parentFolderPath" is interpreted as a folder name even if it refers to a file.
     * If the paths are relative, they will first be resolved using path.resolve().
     */
    static isUnder(childPath, parentFolderPath) {
        // If childPath is under parentPath, then relativePath will be something like
        // "../.." or "..\\..", which consists entirely of periods and slashes.
        // (Note that something like "....t" is actually a valid filename, but "...." is not.)
        const relativePath = path.relative(childPath, parentFolderPath);
        return Path._relativePathRegex.test(relativePath);
    }
    /**
     * Returns true if "childPath" is equal to "parentFolderPath", or if it is inside that folder
     * or one of its children.  The "childPath" can refer to any type of file system object.
     *
     * @remarks
     * The indicated file/folder objects are not required to actually exist on disk.
     * For example, "parentFolderPath" is interpreted as a folder name even if it refers to a file.
     * If the paths are relative, they will first be resolved using path.resolve().
     */
    static isUnderOrEqual(childPath, parentFolderPath) {
        const relativePath = path.relative(childPath, parentFolderPath);
        return relativePath === '' || Path._relativePathRegex.test(relativePath);
    }
    /**
     * Returns true if `path1` and `path2` refer to the same underlying path.
     *
     * @remarks
     *
     * The comparison is performed using `path.relative()`.
     */
    static isEqual(path1, path2) {
        return path.relative(path1, path2) === '';
    }
    /**
     * Formats a path to look nice for reporting purposes.
     * @remarks
     * If `pathToConvert` is under the `baseFolder`, then it will be converted to a relative with the `./` prefix.
     * Otherwise, it will be converted to an absolute path.
     *
     * Backslashes will be converted to slashes, unless the path starts with an OS-specific string like `C:\`.
     */
    static formatConcisely(options) {
        // Same logic as Path.isUnderOrEqual()
        const relativePath = path.relative(options.pathToConvert, options.baseFolder);
        const isUnderOrEqual = relativePath === '' || Path._relativePathRegex.test(relativePath);
        if (isUnderOrEqual) {
            // Note that isUnderOrEqual()'s relativePath is the reverse direction
            return './' + Path.convertToSlashes(path.relative(options.baseFolder, options.pathToConvert));
        }
        const absolutePath = path.resolve(options.pathToConvert);
        return absolutePath;
    }
    /**
     * Replaces Windows-style backslashes with POSIX-style slashes.
     *
     * @remarks
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    static convertToSlashes(inputPath) {
        return Text_1.Text.replaceAll(inputPath, '\\', '/');
    }
    /**
     * Replaces POSIX-style slashes with Windows-style backslashes
     *
     * @remarks
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    static convertToBackslashes(inputPath) {
        return Text_1.Text.replaceAll(inputPath, '/', '\\');
    }
    /**
     * Returns true if the specified path is a relative path and does not use `..` to walk upwards.
     *
     * @example
     * ```ts
     * // These evaluate to true
     * isDownwardRelative('folder');
     * isDownwardRelative('file');
     * isDownwardRelative('folder/');
     * isDownwardRelative('./folder/');
     * isDownwardRelative('./folder/file');
     *
     * // These evaluate to false
     * isDownwardRelative('../folder');
     * isDownwardRelative('folder/../file');
     * isDownwardRelative('/folder/file');
     * ```
     */
    static isDownwardRelative(inputPath) {
        if (path.isAbsolute(inputPath)) {
            return false;
        }
        // Does it contain ".."
        if (Path._upwardPathSegmentRegex.test(inputPath)) {
            return false;
        }
        return true;
    }
}
exports.Path = Path;
// Matches a relative path consisting entirely of periods and slashes
// Example: ".", "..", "../..", etc
Path._relativePathRegex = /^[.\/\\]+$/;
// Matches a relative path segment that traverses upwards
// Example: "a/../b"
Path._upwardPathSegmentRegex = /([\/\\]|^)\.\.([\/\\]|$)/;
//# sourceMappingURL=Path.js.map

/***/ }),

/***/ 86027:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtectableMap = void 0;
const ProtectableMapView_1 = __webpack_require__(99898);
/**
 * The ProtectableMap provides an easy way for an API to expose a `Map<K, V>` property
 * while intercepting and validating any write operations that are performed by
 * consumers of the API.
 *
 * @remarks
 * The ProtectableMap itself is intended to be a private object that only its owner
 * can access directly.  Any operations performed directly on the ProtectableMap will
 * bypass the hooks and any validation they perform.  The public property that is exposed
 * to API consumers should return {@link ProtectableMap.protectedView} instead.
 *
 * For example, suppose you want to share your `Map<string, number>` data structure,
 * but you want to enforce that the key must always be an upper case string:
 * You could use the onSet() hook to validate the keys and throw an exception
 * if the key is not uppercase.
 *
 * @public
 */
class ProtectableMap {
    constructor(parameters) {
        this._protectedView = new ProtectableMapView_1.ProtectableMapView(this, parameters);
    }
    /**
     * The owner of the protectable map should return this object via its public API.
     */
    get protectedView() {
        return this._protectedView;
    }
    // ---------------------------------------------------------------------------
    // lib.es2015.collections contract - write operations
    /**
     * Removes all entries from the map.
     * This operation does NOT invoke the ProtectableMap onClear() hook.
     */
    clear() {
        this._protectedView._clearUnprotected();
    }
    /**
     * Removes the specified key from the map.
     * This operation does NOT invoke the ProtectableMap onDelete() hook.
     */
    delete(key) {
        return this._protectedView._deleteUnprotected(key);
    }
    /**
     * Sets a value for the specified key.
     * This operation does NOT invoke the ProtectableMap onSet() hook.
     */
    set(key, value) {
        this._protectedView._setUnprotected(key, value);
        return this;
    }
    // ---------------------------------------------------------------------------
    // lib.es2015.collections contract - read operations
    /**
     * Performs an operation for each (key, value) entries in the map.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    forEach(callbackfn, thisArg) {
        this._protectedView.forEach(callbackfn);
    }
    /**
     * Retrieves the value for the specified key.
     * @returns undefined if the value is undefined OR if the key is missing;
     * otherwise returns the value associated with the key.
     */
    get(key) {
        return this._protectedView.get(key);
    }
    /**
     * Returns true if the specified key belongs to the map.
     */
    has(key) {
        return this._protectedView.has(key);
    }
    /**
     * Returns the number of (key, value) entries in the map.
     */
    get size() {
        return this._protectedView.size;
    }
}
exports.ProtectableMap = ProtectableMap;
//# sourceMappingURL=ProtectableMap.js.map

/***/ }),

/***/ 99898:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtectableMapView = void 0;
/**
 * The internal wrapper used by ProtectableMap.  It extends the real `Map<K, V>` base class,
 * but hooks the destructive operations (clear/delete/set) to give the owner a chance
 * to block them.
 *
 * NOTE: This is not a public API.
 */
class ProtectableMapView extends Map {
    constructor(owner, parameters) {
        super();
        this._owner = owner;
        this._parameters = parameters;
    }
    clear() {
        // override
        if (this._parameters.onClear) {
            this._parameters.onClear(this._owner);
        }
        super.clear();
    }
    delete(key) {
        // override
        if (this._parameters.onDelete) {
            this._parameters.onDelete(this._owner, key);
        }
        return super.delete(key);
    }
    set(key, value) {
        // override
        let modifiedValue = value;
        if (this._parameters.onSet) {
            modifiedValue = this._parameters.onSet(this._owner, key, modifiedValue);
        }
        super.set(key, modifiedValue);
        return this;
    }
    // INTERNAL USAGE ONLY
    _clearUnprotected() {
        super.clear();
    }
    // INTERNAL USAGE ONLY
    _deleteUnprotected(key) {
        return super.delete(key);
    }
    // INTERNAL USAGE ONLY
    _setUnprotected(key, value) {
        super.set(key, value);
    }
}
exports.ProtectableMapView = ProtectableMapView;
//# sourceMappingURL=ProtectableMapView.js.map

/***/ }),

/***/ 33551:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sort = void 0;
const LegacyAdapters_1 = __webpack_require__(81941);
/**
 * Operations for sorting collections.
 *
 * @remarks
 * NOTE: Prior to Node 11.x, the `Array.sort()` algorithm is not guaranteed to be stable.  For maximum
 * compatibility, consider using {@link LegacyAdapters.sortStable} instead of `Array.sort()`.
 *
 * @public
 */
class Sort {
    /**
     * Compares `x` and `y` using the JavaScript `>` and `<` operators.  This function is suitable for usage as
     * the callback for `array.sort()`.
     *
     * @remarks
     *
     * The JavaScript ordering is generalized so that `undefined` \< `null` \< all other values.
     *
     * @returns -1 if `x` is smaller than `y`, 1 if `x` is greater than `y`, or 0 if the values are equal.
     *
     * @example
     *
     * ```ts
     * let array: number[] = [3, 6, 2];
     * array.sort(Sort.compareByValue);  // [2, 3, 6]
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static compareByValue(x, y) {
        if (x === y) {
            return 0;
        }
        // Undefined is smaller than anything else
        if (x === undefined) {
            return -1;
        }
        if (y === undefined) {
            return 1;
        }
        // Null is smaller than anything except undefined
        if (x === null) {
            return -1;
        }
        if (y === null) {
            return 1;
        }
        // These comparisons always return false if either of the arguments is "undefined".
        // These comparisons return nonsense for "null" (true for "null > -1", but false for "null < 0" and "null > 0")
        if (x < y) {
            return -1;
        }
        if (x > y) {
            return 1;
        }
        return 0;
    }
    /**
     * Sorts the array according to a key which is obtained from the array elements.
     * The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let array: string[] = [ 'aaa', 'bb', 'c' ];
     * Sort.sortBy(array, x => x.length);  // [ 'c', 'bb', 'aaa' ]
     * ```
     */
    static sortBy(array, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    keySelector, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    comparer = Sort.compareByValue) {
        LegacyAdapters_1.LegacyAdapters.sortStable(array, (x, y) => comparer(keySelector(x), keySelector(y)));
    }
    /**
     * Returns true if the array is already sorted.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static isSorted(array, comparer = Sort.compareByValue) {
        let previous = undefined;
        for (const element of array) {
            if (comparer(previous, element) > 0) {
                return false;
            }
            previous = element;
        }
        return true;
    }
    /**
     * Returns true if the array is already sorted by the specified key.
     *
     * @example
     *
     * ```ts
     * let array: string[] = [ 'a', 'bb', 'ccc' ];
     * Sort.isSortedBy(array, x => x.length); // true
     * ```
     */
    static isSortedBy(array, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    keySelector, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    comparer = Sort.compareByValue) {
        let previousKey = undefined;
        for (const element of array) {
            const key = keySelector(element);
            if (comparer(previousKey, key) > 0) {
                return false;
            }
            previousKey = key;
        }
        return true;
    }
    /**
     * Sorts the entries in a Map object according to the map keys.
     * The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let map: Map<string, number> = new Map<string, number>();
     * map.set('zebra', 1);
     * map.set('goose', 2);
     * map.set('aardvark', 3);
     * Sort.sortMapKeys(map);
     * console.log(JSON.stringify(Array.from(map.keys()))); // ["aardvark","goose","zebra"]
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static sortMapKeys(map, keyComparer = Sort.compareByValue) {
        const pairs = Array.from(map.entries());
        // Sorting a map is expensive, so first check whether it's already sorted.
        if (Sort.isSortedBy(pairs, (x) => x[0], keyComparer)) {
            return;
        }
        Sort.sortBy(pairs, (x) => x[0], keyComparer);
        map.clear();
        for (const pair of pairs) {
            map.set(pair[0], pair[1]);
        }
    }
    /**
     * Sorts the entries in a Set object according to the specified keys.
     * The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let set: Set<string> = new Set<string>();
     * set.add('aaa');
     * set.add('bb');
     * set.add('c');
     * Sort.sortSetBy(set, x => x.length);
     * console.log(Array.from(set)); // ['c', 'bb', 'aaa']
     * ```
     */
    static sortSetBy(set, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    keySelector, keyComparer = Sort.compareByValue) {
        const array = Array.from(set);
        // Sorting a set is expensive, so first check whether it's already sorted.
        if (Sort.isSortedBy(array, keySelector, keyComparer)) {
            return;
        }
        LegacyAdapters_1.LegacyAdapters.sortStable(array, (x, y) => keyComparer(keySelector(x), keySelector(y)));
        set.clear();
        for (const item of array) {
            set.add(item);
        }
    }
    /**
     * Sorts the entries in a Set object.  The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let set: Set<string> = new Set<string>();
     * set.add('zebra');
     * set.add('goose');
     * set.add('aardvark');
     * Sort.sortSet(set);
     * console.log(Array.from(set)); // ['aardvark', 'goose', 'zebra']
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static sortSet(set, comparer = Sort.compareByValue) {
        const array = Array.from(set);
        // Sorting a set is expensive, so first check whether it's already sorted.
        if (Sort.isSorted(array, comparer)) {
            return;
        }
        LegacyAdapters_1.LegacyAdapters.sortStable(array, (x, y) => comparer(x, y));
        set.clear();
        for (const item of array) {
            set.add(item);
        }
    }
}
exports.Sort = Sort;
//# sourceMappingURL=Sort.js.map

/***/ }),

/***/ 26049:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringBuilder = void 0;
/**
 * This class allows a large text string to be constructed incrementally by appending small chunks.  The final
 * string can be obtained by calling StringBuilder.toString().
 *
 * @remarks
 * A naive approach might use the `+=` operator to append strings:  This would have the downside of copying
 * the entire string each time a chunk is appended, resulting in `O(n^2)` bytes of memory being allocated
 * (and later freed by the garbage  collector), and many of the allocations could be very large objects.
 * StringBuilder avoids this overhead by accumulating the chunks in an array, and efficiently joining them
 * when `getText()` is finally called.
 *
 * @public
 */
class StringBuilder {
    constructor() {
        this._chunks = [];
    }
    /** {@inheritDoc IStringBuilder.append} */
    append(text) {
        this._chunks.push(text);
    }
    /** {@inheritDoc IStringBuilder.toString} */
    toString() {
        if (this._chunks.length === 0) {
            return '';
        }
        if (this._chunks.length > 1) {
            const joined = this._chunks.join('');
            this._chunks.length = 1;
            this._chunks[0] = joined;
        }
        return this._chunks[0];
    }
}
exports.StringBuilder = StringBuilder;
//# sourceMappingURL=StringBuilder.js.map

/***/ }),

/***/ 1268:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnsiEscape = void 0;
const Colors_1 = __webpack_require__(35158);
/**
 * Operations for working with text strings that contain
 * {@link https://en.wikipedia.org/wiki/ANSI_escape_code | ANSI escape codes}.
 * The most commonly used escape codes set the foreground/background color for console output.
 * @public
 */
class AnsiEscape {
    /**
     * Returns the input text with all ANSI escape codes removed.  For example, this is useful when saving
     * colorized console output to a log file.
     */
    static removeCodes(text) {
        // eslint-disable-next-line no-control-regex
        return text.replace(AnsiEscape._csiRegExp, '');
    }
    /**
     * Replaces ANSI escape codes with human-readable tokens.  This is useful for unit tests
     * that compare text strings in test assertions or snapshot files.
     */
    static formatForTests(text, options) {
        if (!options) {
            options = {};
        }
        let result = text.replace(AnsiEscape._csiRegExp, (capture, csiCode) => {
            // If it is an SGR code, then try to show a friendly token
            const match = csiCode.match(AnsiEscape._sgrRegExp);
            if (match) {
                const sgrParameter = parseInt(match[1]);
                const sgrParameterName = AnsiEscape._tryGetSgrFriendlyName(sgrParameter);
                if (sgrParameterName) {
                    // Example: "[black-bg]"
                    return `[${sgrParameterName}]`;
                }
            }
            // Otherwise show the raw code, but without the "[" from the CSI prefix
            // Example: "[31m]"
            return `[${csiCode}]`;
        });
        if (options.encodeNewlines) {
            result = result
                .replace(AnsiEscape._backslashNRegExp, '[n]')
                .replace(AnsiEscape._backslashRRegExp, `[r]`);
        }
        return result;
    }
    // Returns a human-readable token representing an SGR parameter, or undefined for parameter that is not well-known.
    // The SGR parameter numbers are documented in this table:
    // https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_parameters
    static _tryGetSgrFriendlyName(sgiParameter) {
        switch (sgiParameter) {
            case Colors_1.ConsoleColorCodes.BlackForeground:
                return 'black';
            case Colors_1.ConsoleColorCodes.RedForeground:
                return 'red';
            case Colors_1.ConsoleColorCodes.GreenForeground:
                return 'green';
            case Colors_1.ConsoleColorCodes.YellowForeground:
                return 'yellow';
            case Colors_1.ConsoleColorCodes.BlueForeground:
                return 'blue';
            case Colors_1.ConsoleColorCodes.MagentaForeground:
                return 'magenta';
            case Colors_1.ConsoleColorCodes.CyanForeground:
                return 'cyan';
            case Colors_1.ConsoleColorCodes.WhiteForeground:
                return 'white';
            case Colors_1.ConsoleColorCodes.GrayForeground:
                return 'gray';
            case Colors_1.ConsoleColorCodes.DefaultForeground:
                return 'default';
            case Colors_1.ConsoleColorCodes.BlackBackground:
                return 'black-bg';
            case Colors_1.ConsoleColorCodes.RedBackground:
                return 'red-bg';
            case Colors_1.ConsoleColorCodes.GreenBackground:
                return 'green-bg';
            case Colors_1.ConsoleColorCodes.YellowBackground:
                return 'yellow-bg';
            case Colors_1.ConsoleColorCodes.BlueBackground:
                return 'blue-bg';
            case Colors_1.ConsoleColorCodes.MagentaBackground:
                return 'magenta-bg';
            case Colors_1.ConsoleColorCodes.CyanBackground:
                return 'cyan-bg';
            case Colors_1.ConsoleColorCodes.WhiteBackground:
                return 'white-bg';
            case Colors_1.ConsoleColorCodes.GrayBackground:
                return 'gray-bg';
            case Colors_1.ConsoleColorCodes.DefaultBackground:
                return 'default-bg';
            case Colors_1.ConsoleColorCodes.Bold:
                return 'bold';
            case Colors_1.ConsoleColorCodes.Dim:
                return 'dim';
            case Colors_1.ConsoleColorCodes.NormalColorOrIntensity:
                return 'normal';
            case Colors_1.ConsoleColorCodes.Underline:
                return 'underline';
            case Colors_1.ConsoleColorCodes.UnderlineOff:
                return 'underline-off';
            case Colors_1.ConsoleColorCodes.Blink:
                return 'blink';
            case Colors_1.ConsoleColorCodes.BlinkOff:
                return 'blink-off';
            case Colors_1.ConsoleColorCodes.InvertColor:
                return 'invert';
            case Colors_1.ConsoleColorCodes.InvertColorOff:
                return 'invert-off';
            case Colors_1.ConsoleColorCodes.Hidden:
                return 'hidden';
            case Colors_1.ConsoleColorCodes.HiddenOff:
                return 'hidden-off';
            default:
                return undefined;
        }
    }
}
exports.AnsiEscape = AnsiEscape;
// For now, we only care about the Control Sequence Introducer (CSI) commands which always start with "[".
// eslint-disable-next-line no-control-regex
AnsiEscape._csiRegExp = /\x1b\[([\x30-\x3f]*[\x20-\x2f]*[\x40-\x7e])/gu;
// Text coloring is performed using Select Graphic Rendition (SGR) codes, which come after the
// CSI introducer "ESC [".  The SGR sequence is a number followed by "m".
AnsiEscape._sgrRegExp = /([0-9]+)m/u;
AnsiEscape._backslashNRegExp = /\n/g;
AnsiEscape._backslashRRegExp = /\r/g;
//# sourceMappingURL=AnsiEscape.js.map

/***/ }),

/***/ 35158:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Colors = exports.ConsoleColorCodes = exports.TextAttribute = exports.ColorValue = exports.eolSequence = void 0;
exports.eolSequence = {
    isEol: true
};
/**
 * Colors used with {@link IColorableSequence}.
 * @beta
 */
var ColorValue;
(function (ColorValue) {
    ColorValue[ColorValue["Black"] = 0] = "Black";
    ColorValue[ColorValue["Red"] = 1] = "Red";
    ColorValue[ColorValue["Green"] = 2] = "Green";
    ColorValue[ColorValue["Yellow"] = 3] = "Yellow";
    ColorValue[ColorValue["Blue"] = 4] = "Blue";
    ColorValue[ColorValue["Magenta"] = 5] = "Magenta";
    ColorValue[ColorValue["Cyan"] = 6] = "Cyan";
    ColorValue[ColorValue["White"] = 7] = "White";
    ColorValue[ColorValue["Gray"] = 8] = "Gray";
})(ColorValue = exports.ColorValue || (exports.ColorValue = {}));
/**
 * Text styles used with {@link IColorableSequence}.
 * @beta
 */
var TextAttribute;
(function (TextAttribute) {
    TextAttribute[TextAttribute["Bold"] = 0] = "Bold";
    TextAttribute[TextAttribute["Dim"] = 1] = "Dim";
    TextAttribute[TextAttribute["Underline"] = 2] = "Underline";
    TextAttribute[TextAttribute["Blink"] = 3] = "Blink";
    TextAttribute[TextAttribute["InvertColor"] = 4] = "InvertColor";
    TextAttribute[TextAttribute["Hidden"] = 5] = "Hidden";
})(TextAttribute = exports.TextAttribute || (exports.TextAttribute = {}));
var ConsoleColorCodes;
(function (ConsoleColorCodes) {
    ConsoleColorCodes[ConsoleColorCodes["BlackForeground"] = 30] = "BlackForeground";
    ConsoleColorCodes[ConsoleColorCodes["RedForeground"] = 31] = "RedForeground";
    ConsoleColorCodes[ConsoleColorCodes["GreenForeground"] = 32] = "GreenForeground";
    ConsoleColorCodes[ConsoleColorCodes["YellowForeground"] = 33] = "YellowForeground";
    ConsoleColorCodes[ConsoleColorCodes["BlueForeground"] = 34] = "BlueForeground";
    ConsoleColorCodes[ConsoleColorCodes["MagentaForeground"] = 35] = "MagentaForeground";
    ConsoleColorCodes[ConsoleColorCodes["CyanForeground"] = 36] = "CyanForeground";
    ConsoleColorCodes[ConsoleColorCodes["WhiteForeground"] = 37] = "WhiteForeground";
    ConsoleColorCodes[ConsoleColorCodes["GrayForeground"] = 90] = "GrayForeground";
    ConsoleColorCodes[ConsoleColorCodes["DefaultForeground"] = 39] = "DefaultForeground";
    ConsoleColorCodes[ConsoleColorCodes["BlackBackground"] = 40] = "BlackBackground";
    ConsoleColorCodes[ConsoleColorCodes["RedBackground"] = 41] = "RedBackground";
    ConsoleColorCodes[ConsoleColorCodes["GreenBackground"] = 42] = "GreenBackground";
    ConsoleColorCodes[ConsoleColorCodes["YellowBackground"] = 43] = "YellowBackground";
    ConsoleColorCodes[ConsoleColorCodes["BlueBackground"] = 44] = "BlueBackground";
    ConsoleColorCodes[ConsoleColorCodes["MagentaBackground"] = 45] = "MagentaBackground";
    ConsoleColorCodes[ConsoleColorCodes["CyanBackground"] = 46] = "CyanBackground";
    ConsoleColorCodes[ConsoleColorCodes["WhiteBackground"] = 47] = "WhiteBackground";
    ConsoleColorCodes[ConsoleColorCodes["GrayBackground"] = 100] = "GrayBackground";
    ConsoleColorCodes[ConsoleColorCodes["DefaultBackground"] = 49] = "DefaultBackground";
    ConsoleColorCodes[ConsoleColorCodes["Bold"] = 1] = "Bold";
    // On Linux, the "BoldOff" code instead causes the text to be double-underlined:
    // https://en.wikipedia.org/wiki/Talk:ANSI_escape_code#SGR_21%E2%80%94%60Bold_off%60_not_widely_supported
    // Use "NormalColorOrIntensity" instead
    // BoldOff = 21,
    ConsoleColorCodes[ConsoleColorCodes["Dim"] = 2] = "Dim";
    ConsoleColorCodes[ConsoleColorCodes["NormalColorOrIntensity"] = 22] = "NormalColorOrIntensity";
    ConsoleColorCodes[ConsoleColorCodes["Underline"] = 4] = "Underline";
    ConsoleColorCodes[ConsoleColorCodes["UnderlineOff"] = 24] = "UnderlineOff";
    ConsoleColorCodes[ConsoleColorCodes["Blink"] = 5] = "Blink";
    ConsoleColorCodes[ConsoleColorCodes["BlinkOff"] = 25] = "BlinkOff";
    ConsoleColorCodes[ConsoleColorCodes["InvertColor"] = 7] = "InvertColor";
    ConsoleColorCodes[ConsoleColorCodes["InvertColorOff"] = 27] = "InvertColorOff";
    ConsoleColorCodes[ConsoleColorCodes["Hidden"] = 8] = "Hidden";
    ConsoleColorCodes[ConsoleColorCodes["HiddenOff"] = 28] = "HiddenOff";
})(ConsoleColorCodes = exports.ConsoleColorCodes || (exports.ConsoleColorCodes = {}));
/**
 * The static functions on this class are used to produce colored text
 * for use with the node-core-library terminal.
 *
 * @example
 * terminal.writeLine(Colors.green('Green Text!'), ' ', Colors.blue('Blue Text!'));
 *
 * @beta
 */
class Colors {
    static black(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Black });
    }
    static red(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Red });
    }
    static green(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Green });
    }
    static yellow(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Yellow });
    }
    static blue(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Blue });
    }
    static magenta(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Magenta });
    }
    static cyan(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Cyan });
    }
    static white(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.White });
    }
    static gray(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { foregroundColor: ColorValue.Gray });
    }
    static blackBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Black });
    }
    static redBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Red });
    }
    static greenBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Green });
    }
    static yellowBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Yellow });
    }
    static blueBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Blue });
    }
    static magentaBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Magenta });
    }
    static cyanBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Cyan });
    }
    static whiteBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.White });
    }
    static grayBackground(text) {
        return Object.assign(Object.assign({}, Colors._normalizeStringOrColorableSequence(text)), { backgroundColor: ColorValue.Gray });
    }
    static bold(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Bold);
    }
    static dim(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Dim);
    }
    static underline(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Underline);
    }
    static blink(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Blink);
    }
    static invertColor(text) {
        return Colors._applyTextAttribute(text, TextAttribute.InvertColor);
    }
    static hidden(text) {
        return Colors._applyTextAttribute(text, TextAttribute.Hidden);
    }
    /**
     * If called with a string, returns the string wrapped in a {@link IColorableSequence}.
     * If called with a {@link IColorableSequence}, returns the {@link IColorableSequence}.
     *
     * @internal
     */
    static _normalizeStringOrColorableSequence(value) {
        if (typeof value === 'string') {
            return {
                text: value
            };
        }
        else {
            return value;
        }
    }
    static _applyTextAttribute(text, attribute) {
        const sequence = Colors._normalizeStringOrColorableSequence(text);
        if (!sequence.textAttributes) {
            sequence.textAttributes = [];
        }
        sequence.textAttributes.push(attribute);
        return sequence;
    }
}
exports.Colors = Colors;
//# sourceMappingURL=Colors.js.map

/***/ }),

/***/ 51735:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsoleTerminalProvider = void 0;
const os_1 = __webpack_require__(12087);
const safe_1 = __webpack_require__(41997);
const ITerminalProvider_1 = __webpack_require__(10924);
/**
 * Terminal provider that prints to STDOUT (for log- and verbose-level messages) and
 * STDERR (for warning- and error-level messsages).
 *
 * @beta
 */
class ConsoleTerminalProvider {
    constructor(options = {}) {
        /**
         * If true, verbose-level messages should be written to the console.
         */
        this.verboseEnabled = false;
        /**
         * If true, debug-level messages should be written to the console.
         */
        this.debugEnabled = false;
        this.verboseEnabled = !!options.verboseEnabled;
        this.debugEnabled = !!options.debugEnabled;
    }
    /**
     * {@inheritDoc ITerminalProvider.write}
     */
    write(data, severity) {
        switch (severity) {
            case ITerminalProvider_1.TerminalProviderSeverity.warning:
            case ITerminalProvider_1.TerminalProviderSeverity.error: {
                process.stderr.write(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.verbose: {
                if (this.verboseEnabled) {
                    process.stdout.write(data);
                }
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.debug: {
                if (this.debugEnabled) {
                    process.stdout.write(data);
                }
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.log:
            default: {
                process.stdout.write(data);
                break;
            }
        }
    }
    /**
     * {@inheritDoc ITerminalProvider.eolCharacter}
     */
    get eolCharacter() {
        return os_1.EOL;
    }
    /**
     * {@inheritDoc ITerminalProvider.supportsColor}
     */
    get supportsColor() {
        return safe_1.enabled;
    }
}
exports.ConsoleTerminalProvider = ConsoleTerminalProvider;
//# sourceMappingURL=ConsoleTerminalProvider.js.map

/***/ }),

/***/ 10924:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TerminalProviderSeverity = void 0;
/**
 * Similar to many popular logging packages, terminal providers support a range of message
 * severities. These severities have built-in formatting defaults in the Terminal object
 * (warnings are yellow, errors are red, etc.).
 *
 * Terminal providers may choose to suppress certain messages based on their severity,
 * or to route some messages to other providers or not based on severity.
 *
 *   Severity  | Purpose
 *   --------- | -------
 *   error     | Build errors and fatal issues
 *   warning   | Not necessarily fatal, but indicate a problem the user should fix
 *   log       | Informational messages
 *   verbose   | Additional information that may not always be necessary
 *   debug     | Highest detail level, best used for troubleshooting information
 *
 * @beta
 */
var TerminalProviderSeverity;
(function (TerminalProviderSeverity) {
    TerminalProviderSeverity[TerminalProviderSeverity["log"] = 0] = "log";
    TerminalProviderSeverity[TerminalProviderSeverity["warning"] = 1] = "warning";
    TerminalProviderSeverity[TerminalProviderSeverity["error"] = 2] = "error";
    TerminalProviderSeverity[TerminalProviderSeverity["verbose"] = 3] = "verbose";
    TerminalProviderSeverity[TerminalProviderSeverity["debug"] = 4] = "debug";
})(TerminalProviderSeverity = exports.TerminalProviderSeverity || (exports.TerminalProviderSeverity = {}));
//# sourceMappingURL=ITerminalProvider.js.map

/***/ }),

/***/ 73649:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringBufferTerminalProvider = void 0;
const ITerminalProvider_1 = __webpack_require__(10924);
const StringBuilder_1 = __webpack_require__(26049);
const Text_1 = __webpack_require__(67638);
const AnsiEscape_1 = __webpack_require__(1268);
/**
 * Terminal provider that stores written data in buffers separated by severity.
 * This terminal provider is designed to be used when code that prints to a terminal
 * is being unit tested.
 *
 * @beta
 */
class StringBufferTerminalProvider {
    constructor(supportsColor = false) {
        this._standardBuffer = new StringBuilder_1.StringBuilder();
        this._verboseBuffer = new StringBuilder_1.StringBuilder();
        this._debugBuffer = new StringBuilder_1.StringBuilder();
        this._warningBuffer = new StringBuilder_1.StringBuilder();
        this._errorBuffer = new StringBuilder_1.StringBuilder();
        this._supportsColor = supportsColor;
    }
    /**
     * {@inheritDoc ITerminalProvider.write}
     */
    write(data, severity) {
        switch (severity) {
            case ITerminalProvider_1.TerminalProviderSeverity.warning: {
                this._warningBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.error: {
                this._errorBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.verbose: {
                this._verboseBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.debug: {
                this._debugBuffer.append(data);
                break;
            }
            case ITerminalProvider_1.TerminalProviderSeverity.log:
            default: {
                this._standardBuffer.append(data);
                break;
            }
        }
    }
    /**
     * {@inheritDoc ITerminalProvider.eolCharacter}
     */
    get eolCharacter() {
        return '[n]';
    }
    /**
     * {@inheritDoc ITerminalProvider.supportsColor}
     */
    get supportsColor() {
        return this._supportsColor;
    }
    /**
     * Get everything that has been written at log-level severity.
     */
    getOutput(options) {
        return this._normalizeOutput(this._standardBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at verbose-level severity.
     */
    getVerbose(options) {
        return this._normalizeOutput(this._verboseBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at debug-level severity.
     */
    getDebugOutput(options) {
        return this._normalizeOutput(this._debugBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at error-level severity.
     */
    getErrorOutput(options) {
        return this._normalizeOutput(this._errorBuffer.toString(), options);
    }
    /**
     * Get everything that has been written at warning-level severity.
     */
    getWarningOutput(options) {
        return this._normalizeOutput(this._warningBuffer.toString(), options);
    }
    _normalizeOutput(s, options) {
        options = Object.assign({ normalizeSpecialCharacters: true }, (options || {}));
        s = Text_1.Text.convertToLf(s);
        if (options.normalizeSpecialCharacters) {
            return AnsiEscape_1.AnsiEscape.formatForTests(s, { encodeNewlines: true });
        }
        else {
            return s;
        }
    }
}
exports.StringBufferTerminalProvider = StringBufferTerminalProvider;
//# sourceMappingURL=StringBufferTerminalProvider.js.map

/***/ }),

/***/ 10437:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Terminal = void 0;
const ITerminalProvider_1 = __webpack_require__(10924);
const Colors_1 = __webpack_require__(35158);
/**
 * This class facilitates writing to a console.
 *
 * @beta
 */
class Terminal {
    constructor(provider) {
        this._providers = new Set();
        this._providers.add(provider);
    }
    /**
     * {@inheritdoc ITerminal.registerProvider}
     */
    registerProvider(provider) {
        this._providers.add(provider);
    }
    /**
     * {@inheritdoc ITerminal.unregisterProvider}
     */
    unregisterProvider(provider) {
        if (this._providers.has(provider)) {
            this._providers.delete(provider);
        }
    }
    /**
     * {@inheritdoc ITerminal.write}
     */
    write(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.log);
    }
    /**
     * {@inheritdoc ITerminal.writeLine}
     */
    writeLine(...messageParts) {
        this.write(...messageParts, Colors_1.eolSequence);
    }
    /**
     * {@inheritdoc ITerminal.writeWarning}
     */
    writeWarning(...messageParts) {
        this._writeSegmentsToProviders(messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Yellow }))), ITerminalProvider_1.TerminalProviderSeverity.warning);
    }
    /**
     * {@inheritdoc ITerminal.writeWarningLine}
     */
    writeWarningLine(...messageParts) {
        this._writeSegmentsToProviders([
            ...messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Yellow }))),
            Colors_1.eolSequence
        ], ITerminalProvider_1.TerminalProviderSeverity.warning);
    }
    /**
     * {@inheritdoc ITerminal.writeError}
     */
    writeError(...messageParts) {
        this._writeSegmentsToProviders(messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Red }))), ITerminalProvider_1.TerminalProviderSeverity.error);
    }
    /**
     * {@inheritdoc ITerminal.writeErrorLine}
     */
    writeErrorLine(...messageParts) {
        this._writeSegmentsToProviders([
            ...messageParts.map((part) => (Object.assign(Object.assign({}, Colors_1.Colors._normalizeStringOrColorableSequence(part)), { foregroundColor: Colors_1.ColorValue.Red }))),
            Colors_1.eolSequence
        ], ITerminalProvider_1.TerminalProviderSeverity.error);
    }
    /**
     * {@inheritdoc ITerminal.writeVerbose}
     */
    writeVerbose(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.verbose);
    }
    /**
     * {@inheritdoc ITerminal.writeVerboseLine}
     */
    writeVerboseLine(...messageParts) {
        this.writeVerbose(...messageParts, Colors_1.eolSequence);
    }
    /**
     * {@inheritdoc ITerminal.writeDebug}
     */
    writeDebug(...messageParts) {
        this._writeSegmentsToProviders(messageParts, ITerminalProvider_1.TerminalProviderSeverity.debug);
    }
    /**
     * {@inheritdoc ITerminal.writeDebugLine}
     */
    writeDebugLine(...messageParts) {
        this.writeDebug(...messageParts, Colors_1.eolSequence);
    }
    _writeSegmentsToProviders(segments, severity) {
        const withColorText = {};
        const withoutColorText = {};
        let withColorLines;
        let withoutColorLines;
        this._providers.forEach((provider) => {
            const eol = provider.eolCharacter;
            let textToWrite;
            if (provider.supportsColor) {
                if (!withColorLines) {
                    withColorLines = this._serializeFormattableTextSegments(segments, true);
                }
                if (!withColorText[eol]) {
                    withColorText[eol] = withColorLines.join(eol);
                }
                textToWrite = withColorText[eol];
            }
            else {
                if (!withoutColorLines) {
                    withoutColorLines = this._serializeFormattableTextSegments(segments, false);
                }
                if (!withoutColorText[eol]) {
                    withoutColorText[eol] = withoutColorLines.join(eol);
                }
                textToWrite = withoutColorText[eol];
            }
            provider.write(textToWrite, severity);
        });
    }
    _serializeFormattableTextSegments(segments, withColor) {
        const lines = [];
        let segmentsToJoin = [];
        let lastSegmentWasEol = false;
        for (let i = 0; i < segments.length; i++) {
            const segment = Colors_1.Colors._normalizeStringOrColorableSequence(segments[i]);
            lastSegmentWasEol = !!segment.isEol;
            if (lastSegmentWasEol) {
                lines.push(segmentsToJoin.join(''));
                segmentsToJoin = [];
            }
            else {
                if (withColor) {
                    const startColorCodes = [];
                    const endColorCodes = [];
                    switch (segment.foregroundColor) {
                        case Colors_1.ColorValue.Black: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlackForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Red: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.RedForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Green: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GreenForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Yellow: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.YellowForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Blue: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlueForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Magenta: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.MagentaForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Cyan: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.CyanForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.White: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.WhiteForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                        case Colors_1.ColorValue.Gray: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GrayForeground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultForeground);
                            break;
                        }
                    }
                    switch (segment.backgroundColor) {
                        case Colors_1.ColorValue.Black: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlackBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Red: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.RedBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Green: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GreenBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Yellow: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.YellowBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Blue: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.BlueBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Magenta: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.MagentaBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Cyan: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.CyanBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.White: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.WhiteBackground);
                            endColorCodes.push(Colors_1.ConsoleColorCodes.DefaultBackground);
                            break;
                        }
                        case Colors_1.ColorValue.Gray: {
                            startColorCodes.push(Colors_1.ConsoleColorCodes.GrayBackground);
                            endColorCodes.push(49);
                            break;
                        }
                    }
                    if (segment.textAttributes) {
                        for (const textAttribute of segment.textAttributes) {
                            switch (textAttribute) {
                                case Colors_1.TextAttribute.Bold: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Bold);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.NormalColorOrIntensity);
                                    break;
                                }
                                case Colors_1.TextAttribute.Dim: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Dim);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.NormalColorOrIntensity);
                                    break;
                                }
                                case Colors_1.TextAttribute.Underline: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Underline);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.UnderlineOff);
                                    break;
                                }
                                case Colors_1.TextAttribute.Blink: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Blink);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.BlinkOff);
                                    break;
                                }
                                case Colors_1.TextAttribute.InvertColor: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.InvertColor);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.InvertColorOff);
                                    break;
                                }
                                case Colors_1.TextAttribute.Hidden: {
                                    startColorCodes.push(Colors_1.ConsoleColorCodes.Hidden);
                                    endColorCodes.push(Colors_1.ConsoleColorCodes.HiddenOff);
                                    break;
                                }
                            }
                        }
                    }
                    for (let j = 0; j < startColorCodes.length; j++) {
                        const code = startColorCodes[j];
                        segmentsToJoin.push(...['\u001b[', code.toString(), 'm']);
                    }
                    segmentsToJoin.push(segment.text);
                    for (let j = endColorCodes.length - 1; j >= 0; j--) {
                        const code = endColorCodes[j];
                        segmentsToJoin.push(...['\u001b[', code.toString(), 'm']);
                    }
                }
                else {
                    segmentsToJoin.push(segment.text);
                }
            }
        }
        if (segmentsToJoin.length > 0) {
            lines.push(segmentsToJoin.join(''));
        }
        if (lastSegmentWasEol) {
            lines.push('');
        }
        return lines;
    }
}
exports.Terminal = Terminal;
//# sourceMappingURL=Terminal.js.map

/***/ }),

/***/ 67638:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Text = void 0;
const os = __importStar(__webpack_require__(12087));
/**
 * Operations for working with strings that contain text.
 *
 * @remarks
 * The utilities provided by this class are intended to be simple, small, and very
 * broadly applicable.
 *
 * @public
 */
class Text {
    /**
     * Returns the same thing as targetString.replace(searchValue, replaceValue), except that
     * all matches are replaced, rather than just the first match.
     * @param input         - The string to be modified
     * @param searchValue   - The value to search for
     * @param replaceValue  - The replacement text
     */
    static replaceAll(input, searchValue, replaceValue) {
        return input.split(searchValue).join(replaceValue);
    }
    /**
     * Converts all newlines in the provided string to use Windows-style CRLF end of line characters.
     */
    static convertToCrLf(input) {
        return input.replace(Text._newLineRegEx, '\r\n');
    }
    /**
     * Converts all newlines in the provided string to use POSIX-style LF end of line characters.
     *
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    static convertToLf(input) {
        return input.replace(Text._newLineRegEx, '\n');
    }
    /**
     * Converts all newlines in the provided string to use the specified newline type.
     */
    static convertTo(input, newlineKind) {
        return input.replace(Text._newLineRegEx, Text.getNewline(newlineKind));
    }
    /**
     * Returns the newline character sequence for the specified `NewlineKind`.
     */
    static getNewline(newlineKind) {
        switch (newlineKind) {
            case "\r\n" /* CrLf */:
                return '\r\n';
            case "\n" /* Lf */:
                return '\n';
            case "os" /* OsDefault */:
                return os.EOL;
            default:
                throw new Error('Unsupported newline kind');
        }
    }
    /**
     * Append characters to the end of a string to ensure the result has a minimum length.
     * @remarks
     * If the string length already exceeds the minimum length, then the string is unchanged.
     * The string is not truncated.
     */
    static padEnd(s, minimumLength, paddingCharacter = ' ') {
        if (paddingCharacter.length !== 1) {
            throw new Error('The paddingCharacter parameter must be a single character.');
        }
        if (s.length < minimumLength) {
            const paddingArray = new Array(minimumLength - s.length);
            paddingArray.unshift(s);
            return paddingArray.join(paddingCharacter);
        }
        else {
            return s;
        }
    }
    /**
     * Append characters to the start of a string to ensure the result has a minimum length.
     * @remarks
     * If the string length already exceeds the minimum length, then the string is unchanged.
     * The string is not truncated.
     */
    static padStart(s, minimumLength, paddingCharacter = ' ') {
        if (paddingCharacter.length !== 1) {
            throw new Error('The paddingCharacter parameter must be a single character.');
        }
        if (s.length < minimumLength) {
            const paddingArray = new Array(minimumLength - s.length);
            paddingArray.push(s);
            return paddingArray.join(paddingCharacter);
        }
        else {
            return s;
        }
    }
    /**
     * If the string is longer than maximumLength characters, truncate it to that length
     * using "..." to indicate the truncation.
     *
     * @remarks
     * For example truncateWithEllipsis('1234578', 5) would produce '12...'.
     */
    static truncateWithEllipsis(s, maximumLength) {
        if (maximumLength < 0) {
            throw new Error('The maximumLength cannot be a negative number');
        }
        if (s.length <= maximumLength) {
            return s;
        }
        if (s.length <= 3) {
            return s.substring(0, maximumLength);
        }
        return s.substring(0, maximumLength - 3) + '...';
    }
    /**
     * Returns the input string with a trailing `\n` character appended, if not already present.
     */
    static ensureTrailingNewline(s, newlineKind = "\n" /* Lf */) {
        // Is there already a newline?
        if (Text._newLineAtEndRegEx.test(s)) {
            return s; // yes, no change
        }
        return s + newlineKind; // no, add it
    }
}
exports.Text = Text;
Text._newLineRegEx = /\r\n|\n\r|\r|\n/g;
Text._newLineAtEndRegEx = /(\r\n|\n\r|\r|\n)$/;
//# sourceMappingURL=Text.js.map

/***/ }),

/***/ 51567:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeUuid = void 0;
const InternalError_1 = __webpack_require__(20318);
const classPrototypeUuidSymbol = Symbol.for('TypeUuid.classPrototypeUuid');
/**
 * Provides a version-independent implementation of the JavaScript `instanceof` operator.
 *
 * @remarks
 * The JavaScript `instanceof` operator normally only identifies objects from a particular library instance.
 * For example, suppose the NPM package `example-lib` has two published versions 1.2.0 and 1.3.0, and
 * it exports a class called `A`.  Suppose some code consumes version `1.3.0` of the library, but it receives
 * an object that was constructed using version `1.2.0`.  In this situation `a instanceof A` will return `false`,
 * even though `a` is an instance of `A`.  The reason is that there are two prototypes for `A`; one for each
 * version.
 *
 * The `TypeUuid` facility provides a way to make `a instanceof A` return true for both prototypes of `A`,
 * by instead using a universally unique identifier (UUID) to detect object instances.
 *
 * You can use `Symbol.hasInstance` to enable the system `instanceof` operator to recognize type UUID equivalence:
 * ```ts
 * const uuidWidget: string = '9c340ef0-d29f-4e2e-a09f-42bacc59024b';
 * class Widget {
 *   public static [Symbol.hasInstance](instance: object): boolean {
 *     return TypeUuid.isInstanceOf(instance, uuidWidget);
 *   }
 * }
 * ```
 * // Example usage:
 * ```ts
 * import { Widget as Widget1 } from 'v1-of-library';
 * import { Widget as Widget2 } from 'v2-of-library';
 * const widget = new Widget2();
 * console.log(widget instanceof Widget1); // prints true
 * ```
 *
 * @public
 */
class TypeUuid {
    /**
     * Registers a JavaScript class as having a type identified by the specified UUID.
     * @privateRemarks
     * We cannot use a construct signature for `targetClass` because it may be an abstract class.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static registerClass(targetClass, typeUuid) {
        if (typeof targetClass !== 'function') {
            throw new Error('The targetClass parameter must be a JavaScript class');
        }
        if (!TypeUuid._uuidRegExp.test(typeUuid)) {
            throw new Error(`The type UUID must be specified as lowercase hexadecimal with dashes: "${typeUuid}"`);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const targetClassPrototype = targetClass.prototype;
        if (Object.hasOwnProperty.call(targetClassPrototype, classPrototypeUuidSymbol)) {
            const existingUuid = targetClassPrototype[classPrototypeUuidSymbol];
            throw new InternalError_1.InternalError(`Cannot register the target class ${targetClass.name || ''} typeUuid=${typeUuid}` +
                ` because it was already registered with typeUuid=${existingUuid}`);
        }
        targetClassPrototype[classPrototypeUuidSymbol] = typeUuid;
    }
    /**
     * Returns true if the `targetObject` is an instance of a JavaScript class that was previously
     * registered using the specified `typeUuid`.  Base classes are also considered.
     */
    static isInstanceOf(targetObject, typeUuid) {
        if (targetObject === undefined || targetObject === null) {
            return false;
        }
        let objectPrototype = Object.getPrototypeOf(targetObject);
        while (objectPrototype !== undefined && objectPrototype !== null) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const registeredUuid = objectPrototype[classPrototypeUuidSymbol];
            if (registeredUuid === typeUuid) {
                return true;
            }
            // Walk upwards an examine base class prototypes
            objectPrototype = Object.getPrototypeOf(objectPrototype);
        }
        return false;
    }
}
exports.TypeUuid = TypeUuid;
TypeUuid._uuidRegExp = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
//# sourceMappingURL=TypeUuid.js.map

/***/ }),

/***/ 65919:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeUuid = exports.StringBufferTerminalProvider = exports.ConsoleTerminalProvider = exports.TerminalProviderSeverity = exports.TextAttribute = exports.ColorValue = exports.Colors = exports.Terminal = exports.StringBuilder = exports.LegacyAdapters = exports.FileWriter = exports.FileSystem = exports.Sort = exports.Text = exports.Path = exports.PackageNameParser = exports.PackageName = exports.PackageJsonLookup = exports.ProtectableMap = exports.MapExtensions = exports.LockFile = exports.JsonSchema = exports.JsonFile = exports.InternalError = exports.Import = exports.Executable = exports.EnvironmentMap = exports.Enum = exports.Async = exports.AnsiEscape = exports.AlreadyReportedError = void 0;
/**
 * Core libraries that every NodeJS toolchain project should use.
 *
 * @packageDocumentation
 */
var AlreadyReportedError_1 = __webpack_require__(51050);
Object.defineProperty(exports, "AlreadyReportedError", ({ enumerable: true, get: function () { return AlreadyReportedError_1.AlreadyReportedError; } }));
var AnsiEscape_1 = __webpack_require__(1268);
Object.defineProperty(exports, "AnsiEscape", ({ enumerable: true, get: function () { return AnsiEscape_1.AnsiEscape; } }));
var Async_1 = __webpack_require__(40223);
Object.defineProperty(exports, "Async", ({ enumerable: true, get: function () { return Async_1.Async; } }));
var Enum_1 = __webpack_require__(45008);
Object.defineProperty(exports, "Enum", ({ enumerable: true, get: function () { return Enum_1.Enum; } }));
var EnvironmentMap_1 = __webpack_require__(47897);
Object.defineProperty(exports, "EnvironmentMap", ({ enumerable: true, get: function () { return EnvironmentMap_1.EnvironmentMap; } }));
var Executable_1 = __webpack_require__(14015);
Object.defineProperty(exports, "Executable", ({ enumerable: true, get: function () { return Executable_1.Executable; } }));
var Import_1 = __webpack_require__(40923);
Object.defineProperty(exports, "Import", ({ enumerable: true, get: function () { return Import_1.Import; } }));
var InternalError_1 = __webpack_require__(20318);
Object.defineProperty(exports, "InternalError", ({ enumerable: true, get: function () { return InternalError_1.InternalError; } }));
var JsonFile_1 = __webpack_require__(66768);
Object.defineProperty(exports, "JsonFile", ({ enumerable: true, get: function () { return JsonFile_1.JsonFile; } }));
var JsonSchema_1 = __webpack_require__(64155);
Object.defineProperty(exports, "JsonSchema", ({ enumerable: true, get: function () { return JsonSchema_1.JsonSchema; } }));
var LockFile_1 = __webpack_require__(58954);
Object.defineProperty(exports, "LockFile", ({ enumerable: true, get: function () { return LockFile_1.LockFile; } }));
var MapExtensions_1 = __webpack_require__(54396);
Object.defineProperty(exports, "MapExtensions", ({ enumerable: true, get: function () { return MapExtensions_1.MapExtensions; } }));
var ProtectableMap_1 = __webpack_require__(86027);
Object.defineProperty(exports, "ProtectableMap", ({ enumerable: true, get: function () { return ProtectableMap_1.ProtectableMap; } }));
var PackageJsonLookup_1 = __webpack_require__(87330);
Object.defineProperty(exports, "PackageJsonLookup", ({ enumerable: true, get: function () { return PackageJsonLookup_1.PackageJsonLookup; } }));
var PackageName_1 = __webpack_require__(76737);
Object.defineProperty(exports, "PackageName", ({ enumerable: true, get: function () { return PackageName_1.PackageName; } }));
Object.defineProperty(exports, "PackageNameParser", ({ enumerable: true, get: function () { return PackageName_1.PackageNameParser; } }));
var Path_1 = __webpack_require__(45574);
Object.defineProperty(exports, "Path", ({ enumerable: true, get: function () { return Path_1.Path; } }));
var Text_1 = __webpack_require__(67638);
Object.defineProperty(exports, "Text", ({ enumerable: true, get: function () { return Text_1.Text; } }));
var Sort_1 = __webpack_require__(33551);
Object.defineProperty(exports, "Sort", ({ enumerable: true, get: function () { return Sort_1.Sort; } }));
var FileSystem_1 = __webpack_require__(29371);
Object.defineProperty(exports, "FileSystem", ({ enumerable: true, get: function () { return FileSystem_1.FileSystem; } }));
var FileWriter_1 = __webpack_require__(20830);
Object.defineProperty(exports, "FileWriter", ({ enumerable: true, get: function () { return FileWriter_1.FileWriter; } }));
var LegacyAdapters_1 = __webpack_require__(81941);
Object.defineProperty(exports, "LegacyAdapters", ({ enumerable: true, get: function () { return LegacyAdapters_1.LegacyAdapters; } }));
var StringBuilder_1 = __webpack_require__(26049);
Object.defineProperty(exports, "StringBuilder", ({ enumerable: true, get: function () { return StringBuilder_1.StringBuilder; } }));
var Terminal_1 = __webpack_require__(10437);
Object.defineProperty(exports, "Terminal", ({ enumerable: true, get: function () { return Terminal_1.Terminal; } }));
var Colors_1 = __webpack_require__(35158);
Object.defineProperty(exports, "Colors", ({ enumerable: true, get: function () { return Colors_1.Colors; } }));
Object.defineProperty(exports, "ColorValue", ({ enumerable: true, get: function () { return Colors_1.ColorValue; } }));
Object.defineProperty(exports, "TextAttribute", ({ enumerable: true, get: function () { return Colors_1.TextAttribute; } }));
var ITerminalProvider_1 = __webpack_require__(10924);
Object.defineProperty(exports, "TerminalProviderSeverity", ({ enumerable: true, get: function () { return ITerminalProvider_1.TerminalProviderSeverity; } }));
var ConsoleTerminalProvider_1 = __webpack_require__(51735);
Object.defineProperty(exports, "ConsoleTerminalProvider", ({ enumerable: true, get: function () { return ConsoleTerminalProvider_1.ConsoleTerminalProvider; } }));
var StringBufferTerminalProvider_1 = __webpack_require__(73649);
Object.defineProperty(exports, "StringBufferTerminalProvider", ({ enumerable: true, get: function () { return StringBufferTerminalProvider_1.StringBufferTerminalProvider; } }));
var TypeUuid_1 = __webpack_require__(51567);
Object.defineProperty(exports, "TypeUuid", ({ enumerable: true, get: function () { return TypeUuid_1.TypeUuid; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 70154:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var async = __webpack_require__(30341);
async.core = __webpack_require__(8350);
async.isCore = __webpack_require__(39133);
async.sync = __webpack_require__(68115);

module.exports = async;


/***/ }),

/***/ 30341:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(35747);
var path = __webpack_require__(85622);
var caller = __webpack_require__(71127);
var nodeModulesPaths = __webpack_require__(4609);
var normalizeOptions = __webpack_require__(1750);
var isCore = __webpack_require__(39133);

var realpathFS = fs.realpath && typeof fs.realpath.native === 'function' ? fs.realpath.native : fs.realpath;

var defaultIsFile = function isFile(file, cb) {
    fs.stat(file, function (err, stat) {
        if (!err) {
            return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};

var defaultIsDir = function isDirectory(dir, cb) {
    fs.stat(dir, function (err, stat) {
        if (!err) {
            return cb(null, stat.isDirectory());
        }
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};

var defaultRealpath = function realpath(x, cb) {
    realpathFS(x, function (realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== 'ENOENT') cb(realpathErr);
        else cb(null, realpathErr ? x : realPath);
    });
};

var maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
    } else {
        cb(null, x);
    }
};

var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
};

module.exports = function resolve(x, options, callback) {
    var cb = callback;
    var opts = options;
    if (typeof options === 'function') {
        cb = opts;
        opts = {};
    }
    if (typeof x !== 'string') {
        var err = new TypeError('Path must be a string.');
        return process.nextTick(function () {
            cb(err);
        });
    }

    opts = normalizeOptions(x, opts);

    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile = opts.readFile || fs.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var packageIterator = opts.packageIterator;

    var extensions = opts.extensions || ['.js'];
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || [];

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = path.resolve(basedir);

    maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function (err, realStart) {
            if (err) cb(err);
            else init(realStart);
        }
    );

    var res;
    function init(basedir) {
        if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
            res = path.resolve(basedir, x);
            if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
            if ((/\/$/).test(x) && res === basedir) {
                loadAsDirectory(res, opts.package, onfile);
            } else loadAsFile(res, opts.package, onfile);
        } else if (isCore(x)) {
            return cb(null, x);
        } else loadNodeModules(x, basedir, function (err, n, pkg) {
            if (err) cb(err);
            else if (n) {
                return maybeRealpath(realpath, n, opts, function (err, realN) {
                    if (err) {
                        cb(err);
                    } else {
                        cb(null, realN, pkg);
                    }
                });
            } else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
            }
        });
    }

    function onfile(err, m, pkg) {
        if (err) cb(err);
        else if (m) cb(null, m, pkg);
        else loadAsDirectory(res, function (err, d, pkg) {
            if (err) cb(err);
            else if (d) {
                maybeRealpath(realpath, d, opts, function (err, realD) {
                    if (err) {
                        cb(err);
                    } else {
                        cb(null, realD, pkg);
                    }
                });
            } else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
            }
        });
    }

    function loadAsFile(x, thePackage, callback) {
        var loadAsFilePackage = thePackage;
        var cb = callback;
        if (typeof loadAsFilePackage === 'function') {
            cb = loadAsFilePackage;
            loadAsFilePackage = undefined;
        }

        var exts = [''].concat(extensions);
        load(exts, x, loadAsFilePackage);

        function load(exts, x, loadPackage) {
            if (exts.length === 0) return cb(null, undefined, loadPackage);
            var file = x + exts[0];

            var pkg = loadPackage;
            if (pkg) onpkg(null, pkg);
            else loadpkg(path.dirname(file), onpkg);

            function onpkg(err, pkg_, dir) {
                pkg = pkg_;
                if (err) return cb(err);
                if (dir && pkg && opts.pathFilter) {
                    var rfile = path.relative(dir, file);
                    var rel = rfile.slice(0, rfile.length - exts[0].length);
                    var r = opts.pathFilter(pkg, x, rel);
                    if (r) return load(
                        [''].concat(extensions.slice()),
                        path.resolve(dir, r),
                        pkg
                    );
                }
                isFile(file, onex);
            }
            function onex(err, ex) {
                if (err) return cb(err);
                if (ex) return cb(null, file, pkg);
                load(exts.slice(1), x, pkg);
            }
        }
    }

    function loadpkg(dir, cb) {
        if (dir === '' || dir === '/') return cb(null);
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
            return cb(null);
        }
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return cb(null);

        maybeRealpath(realpath, dir, opts, function (unwrapErr, pkgdir) {
            if (unwrapErr) return loadpkg(path.dirname(dir), cb);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) {
                // on err, ex is false
                if (!ex) return loadpkg(path.dirname(dir), cb);

                readFile(pkgfile, function (err, body) {
                    if (err) cb(err);
                    try { var pkg = JSON.parse(body); } catch (jsonErr) {}

                    if (pkg && opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }
                    cb(null, pkg, dir);
                });
            });
        });
    }

    function loadAsDirectory(x, loadAsDirectoryPackage, callback) {
        var cb = callback;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === 'function') {
            cb = fpkg;
            fpkg = opts.package;
        }

        maybeRealpath(realpath, x, opts, function (unwrapErr, pkgdir) {
            if (unwrapErr) return cb(unwrapErr);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) {
                if (err) return cb(err);
                if (!ex) return loadAsFile(path.join(x, 'index'), fpkg, cb);

                readFile(pkgfile, function (err, body) {
                    if (err) return cb(err);
                    try {
                        var pkg = JSON.parse(body);
                    } catch (jsonErr) {}

                    if (pkg && opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }

                    if (pkg && pkg.main) {
                        if (typeof pkg.main !== 'string') {
                            var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');
                            mainError.code = 'INVALID_PACKAGE_MAIN';
                            return cb(mainError);
                        }
                        if (pkg.main === '.' || pkg.main === './') {
                            pkg.main = 'index';
                        }
                        loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {
                            if (err) return cb(err);
                            if (m) return cb(null, m, pkg);
                            if (!pkg) return loadAsFile(path.join(x, 'index'), pkg, cb);

                            var dir = path.resolve(x, pkg.main);
                            loadAsDirectory(dir, pkg, function (err, n, pkg) {
                                if (err) return cb(err);
                                if (n) return cb(null, n, pkg);
                                loadAsFile(path.join(x, 'index'), pkg, cb);
                            });
                        });
                        return;
                    }

                    loadAsFile(path.join(x, '/index'), pkg, cb);
                });
            });
        });
    }

    function processDirs(cb, dirs) {
        if (dirs.length === 0) return cb(null, undefined);
        var dir = dirs[0];

        isDirectory(path.dirname(dir), isdir);

        function isdir(err, isdir) {
            if (err) return cb(err);
            if (!isdir) return processDirs(cb, dirs.slice(1));
            loadAsFile(dir, opts.package, onfile);
        }

        function onfile(err, m, pkg) {
            if (err) return cb(err);
            if (m) return cb(null, m, pkg);
            loadAsDirectory(dir, opts.package, ondir);
        }

        function ondir(err, n, pkg) {
            if (err) return cb(err);
            if (n) return cb(null, n, pkg);
            processDirs(cb, dirs.slice(1));
        }
    }
    function loadNodeModules(x, start, cb) {
        var thunk = function () { return getPackageCandidates(x, start, opts); };
        processDirs(
            cb,
            packageIterator ? packageIterator(x, start, thunk, opts) : thunk()
        );
    }
};


/***/ }),

/***/ 71127:
/***/ ((module) => {

module.exports = function () {
    // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function (_, stack) { return stack; };
    var stack = (new Error()).stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
};


/***/ }),

/***/ 8350:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var current = (process.versions && process.versions.node && process.versions.node.split('.')) || [];

function specifierIncluded(specifier) {
    var parts = specifier.split(' ');
    var op = parts.length > 1 ? parts[0] : '=';
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');

    for (var i = 0; i < 3; ++i) {
        var cur = Number(current[i] || 0);
        var ver = Number(versionParts[i] || 0);
        if (cur === ver) {
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        }
        if (op === '<') {
            return cur < ver;
        } else if (op === '>=') {
            return cur >= ver;
        } else {
            return false;
        }
    }
    return op === '>=';
}

function matchesRange(range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) { return false; }
    for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(specifiers[i])) { return false; }
    }
    return true;
}

function versionIncluded(specifierValue) {
    if (typeof specifierValue === 'boolean') { return specifierValue; }
    if (specifierValue && typeof specifierValue === 'object') {
        for (var i = 0; i < specifierValue.length; ++i) {
            if (matchesRange(specifierValue[i])) { return true; }
        }
        return false;
    }
    return matchesRange(specifierValue);
}

var data = __webpack_require__(67096);

var core = {};
for (var mod in data) { // eslint-disable-line no-restricted-syntax
    if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core[mod] = versionIncluded(data[mod]);
    }
}
module.exports = core;


/***/ }),

/***/ 39133:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var core = __webpack_require__(8350);

module.exports = function isCore(x) {
    return Object.prototype.hasOwnProperty.call(core, x);
};


/***/ }),

/***/ 4609:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var path = __webpack_require__(85622);
var parse = path.parse || __webpack_require__(5980);

var getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {
    var prefix = '/';
    if ((/^([A-Za-z]:)/).test(absoluteStart)) {
        prefix = '';
    } else if ((/^\\\\/).test(absoluteStart)) {
        prefix = '\\\\';
    }

    var paths = [absoluteStart];
    var parsed = parse(absoluteStart);
    while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
    }

    return paths.reduce(function (dirs, aPath) {
        return dirs.concat(modules.map(function (moduleDir) {
            return path.resolve(prefix, aPath, moduleDir);
        }));
    }, []);
};

module.exports = function nodeModulesPaths(start, opts, request) {
    var modules = opts && opts.moduleDirectory
        ? [].concat(opts.moduleDirectory)
        : ['node_modules'];

    if (opts && typeof opts.paths === 'function') {
        return opts.paths(
            request,
            start,
            function () { return getNodeModulesDirs(start, modules); },
            opts
        );
    }

    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
};


/***/ }),

/***/ 1750:
/***/ ((module) => {

module.exports = function (x, opts) {
    /**
     * This file is purposefully a passthrough. It's expected that third-party
     * environments will override it at runtime in order to inject special logic
     * into `resolve` (by manipulating the options). One such example is the PnP
     * code path in Yarn.
     */

    return opts || {};
};


/***/ }),

/***/ 68115:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCore = __webpack_require__(39133);
var fs = __webpack_require__(35747);
var path = __webpack_require__(85622);
var caller = __webpack_require__(71127);
var nodeModulesPaths = __webpack_require__(4609);
var normalizeOptions = __webpack_require__(1750);

var realpathFS = fs.realpathSync && typeof fs.realpathSync.native === 'function' ? fs.realpathSync.native : fs.realpathSync;

var defaultIsFile = function isFile(file) {
    try {
        var stat = fs.statSync(file);
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return stat.isFile() || stat.isFIFO();
};

var defaultIsDir = function isDirectory(dir) {
    try {
        var stat = fs.statSync(dir);
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return stat.isDirectory();
};

var defaultRealpathSync = function realpathSync(x) {
    try {
        return realpathFS(x);
    } catch (realpathErr) {
        if (realpathErr.code !== 'ENOENT') {
            throw realpathErr;
        }
    }
    return x;
};

var maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {
    if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
    }
    return x;
};

var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
};

module.exports = function resolveSync(x, options) {
    if (typeof x !== 'string') {
        throw new TypeError('Path must be a string.');
    }
    var opts = normalizeOptions(x, options);

    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var packageIterator = opts.packageIterator;

    var extensions = opts.extensions || ['.js'];
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || [];

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);

    if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
        var res = path.resolve(absoluteStart, x);
        if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m) return maybeRealpathSync(realpathSync, m, opts);
    } else if (isCore(x)) {
        return x;
    } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n) return maybeRealpathSync(realpathSync, n, opts);
    }

    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;

    function loadAsFileSync(x) {
        var pkg = loadpkg(path.dirname(x));

        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
            var rfile = path.relative(pkg.dir, x);
            var r = opts.pathFilter(pkg.pkg, x, rfile);
            if (r) {
                x = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign
            }
        }

        if (isFile(x)) {
            return x;
        }

        for (var i = 0; i < extensions.length; i++) {
            var file = x + extensions[i];
            if (isFile(file)) {
                return file;
            }
        }
    }

    function loadpkg(dir) {
        if (dir === '' || dir === '/') return;
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
            return;
        }
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return;

        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), 'package.json');

        if (!isFile(pkgfile)) {
            return loadpkg(path.dirname(dir));
        }

        var body = readFileSync(pkgfile);

        try {
            var pkg = JSON.parse(body);
        } catch (jsonErr) {}

        if (pkg && opts.packageFilter) {
            // v2 will pass pkgfile
            pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment
        }

        return { pkg: pkg, dir: dir };
    }

    function loadAsDirectorySync(x) {
        var pkgfile = path.join(maybeRealpathSync(realpathSync, x, opts), '/package.json');
        if (isFile(pkgfile)) {
            try {
                var body = readFileSync(pkgfile, 'UTF8');
                var pkg = JSON.parse(body);
            } catch (e) {}

            if (pkg && opts.packageFilter) {
                // v2 will pass pkgfile
                pkg = opts.packageFilter(pkg, /*pkgfile,*/ x); // eslint-disable-line spaced-comment
            }

            if (pkg && pkg.main) {
                if (typeof pkg.main !== 'string') {
                    var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');
                    mainError.code = 'INVALID_PACKAGE_MAIN';
                    throw mainError;
                }
                if (pkg.main === '.' || pkg.main === './') {
                    pkg.main = 'index';
                }
                try {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                    var n = loadAsDirectorySync(path.resolve(x, pkg.main));
                    if (n) return n;
                } catch (e) {}
            }
        }

        return loadAsFileSync(path.join(x, '/index'));
    }

    function loadNodeModulesSync(x, start) {
        var thunk = function () { return getPackageCandidates(x, start, opts); };
        var dirs = packageIterator ? packageIterator(x, start, thunk, opts) : thunk();

        for (var i = 0; i < dirs.length; i++) {
            var dir = dirs[i];
            if (isDirectory(path.dirname(dir))) {
                var m = loadAsFileSync(dir);
                if (m) return m;
                var n = loadAsDirectorySync(dir);
                if (n) return n;
            }
        }
    }
};


/***/ }),

/***/ 57475:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandLineHelper = void 0;
/**
 * Helpers for working with the ts-command-line API.
 *
 * @public
 */
class CommandLineHelper {
    /**
     * Returns true if the current command line action is tab-complete.
     *
     * @public
     */
    static isTabCompletionActionRequest(argv) {
        return argv && argv.length > 2 && argv[2] === "tab-complete" /* TabCompletionActionName */;
    }
}
exports.CommandLineHelper = CommandLineHelper;
//# sourceMappingURL=CommandLineHelper.js.map

/***/ }),

/***/ 36972:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandLineHelper = exports.DynamicCommandLineParser = exports.DynamicCommandLineAction = exports.CommandLineParser = exports.CommandLineParameterProvider = exports.CommandLineRemainder = exports.CommandLineChoiceListParameter = exports.CommandLineChoiceParameter = exports.CommandLineIntegerListParameter = exports.CommandLineIntegerParameter = exports.CommandLineStringListParameter = exports.CommandLineStringParameter = exports.CommandLineFlagParameter = exports.CommandLineParameterWithArgument = exports.CommandLineParameter = exports.CommandLineParameterKind = exports.CommandLineAction = void 0;
/**
 * An object-oriented command-line parser for TypeScript projects.
 *
 * @packageDocumentation
 */
var CommandLineAction_1 = __webpack_require__(11920);
Object.defineProperty(exports, "CommandLineAction", ({ enumerable: true, get: function () { return CommandLineAction_1.CommandLineAction; } }));
var BaseClasses_1 = __webpack_require__(86467);
Object.defineProperty(exports, "CommandLineParameterKind", ({ enumerable: true, get: function () { return BaseClasses_1.CommandLineParameterKind; } }));
Object.defineProperty(exports, "CommandLineParameter", ({ enumerable: true, get: function () { return BaseClasses_1.CommandLineParameter; } }));
Object.defineProperty(exports, "CommandLineParameterWithArgument", ({ enumerable: true, get: function () { return BaseClasses_1.CommandLineParameterWithArgument; } }));
var CommandLineFlagParameter_1 = __webpack_require__(58284);
Object.defineProperty(exports, "CommandLineFlagParameter", ({ enumerable: true, get: function () { return CommandLineFlagParameter_1.CommandLineFlagParameter; } }));
var CommandLineStringParameter_1 = __webpack_require__(47578);
Object.defineProperty(exports, "CommandLineStringParameter", ({ enumerable: true, get: function () { return CommandLineStringParameter_1.CommandLineStringParameter; } }));
var CommandLineStringListParameter_1 = __webpack_require__(90536);
Object.defineProperty(exports, "CommandLineStringListParameter", ({ enumerable: true, get: function () { return CommandLineStringListParameter_1.CommandLineStringListParameter; } }));
var CommandLineIntegerParameter_1 = __webpack_require__(6660);
Object.defineProperty(exports, "CommandLineIntegerParameter", ({ enumerable: true, get: function () { return CommandLineIntegerParameter_1.CommandLineIntegerParameter; } }));
var CommandLineIntegerListParameter_1 = __webpack_require__(40299);
Object.defineProperty(exports, "CommandLineIntegerListParameter", ({ enumerable: true, get: function () { return CommandLineIntegerListParameter_1.CommandLineIntegerListParameter; } }));
var CommandLineChoiceParameter_1 = __webpack_require__(85277);
Object.defineProperty(exports, "CommandLineChoiceParameter", ({ enumerable: true, get: function () { return CommandLineChoiceParameter_1.CommandLineChoiceParameter; } }));
var CommandLineChoiceListParameter_1 = __webpack_require__(40374);
Object.defineProperty(exports, "CommandLineChoiceListParameter", ({ enumerable: true, get: function () { return CommandLineChoiceListParameter_1.CommandLineChoiceListParameter; } }));
var CommandLineRemainder_1 = __webpack_require__(20476);
Object.defineProperty(exports, "CommandLineRemainder", ({ enumerable: true, get: function () { return CommandLineRemainder_1.CommandLineRemainder; } }));
var CommandLineParameterProvider_1 = __webpack_require__(54937);
Object.defineProperty(exports, "CommandLineParameterProvider", ({ enumerable: true, get: function () { return CommandLineParameterProvider_1.CommandLineParameterProvider; } }));
var CommandLineParser_1 = __webpack_require__(4115);
Object.defineProperty(exports, "CommandLineParser", ({ enumerable: true, get: function () { return CommandLineParser_1.CommandLineParser; } }));
var DynamicCommandLineAction_1 = __webpack_require__(57943);
Object.defineProperty(exports, "DynamicCommandLineAction", ({ enumerable: true, get: function () { return DynamicCommandLineAction_1.DynamicCommandLineAction; } }));
var DynamicCommandLineParser_1 = __webpack_require__(43827);
Object.defineProperty(exports, "DynamicCommandLineParser", ({ enumerable: true, get: function () { return DynamicCommandLineParser_1.DynamicCommandLineParser; } }));
var CommandLineHelper_1 = __webpack_require__(57475);
Object.defineProperty(exports, "CommandLineHelper", ({ enumerable: true, get: function () { return CommandLineHelper_1.CommandLineHelper; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 86467:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandLineParameterWithArgument = exports.CommandLineParameter = exports.CommandLineParameterKind = void 0;
/**
 * Identifies the kind of a CommandLineParameter.
 * @public
 */
var CommandLineParameterKind;
(function (CommandLineParameterKind) {
    /** Indicates a CommandLineChoiceParameter */
    CommandLineParameterKind[CommandLineParameterKind["Choice"] = 0] = "Choice";
    /** Indicates a CommandLineFlagParameter */
    CommandLineParameterKind[CommandLineParameterKind["Flag"] = 1] = "Flag";
    /** Indicates a CommandLineIntegerParameter */
    CommandLineParameterKind[CommandLineParameterKind["Integer"] = 2] = "Integer";
    /** Indicates a CommandLineStringParameter */
    CommandLineParameterKind[CommandLineParameterKind["String"] = 3] = "String";
    /** Indicates a CommandLineStringListParameter */
    CommandLineParameterKind[CommandLineParameterKind["StringList"] = 4] = "StringList";
    /** Indicates a CommandLineChoiceListParameter */
    CommandLineParameterKind[CommandLineParameterKind["ChoiceList"] = 5] = "ChoiceList";
    /** Indicates a CommandLineIntegerListParameter */
    CommandLineParameterKind[CommandLineParameterKind["IntegerList"] = 6] = "IntegerList";
})(CommandLineParameterKind = exports.CommandLineParameterKind || (exports.CommandLineParameterKind = {}));
/**
 * The base class for the various command-line parameter types.
 * @public
 */
class CommandLineParameter {
    /** @internal */
    constructor(definition) {
        this.longName = definition.parameterLongName;
        this.shortName = definition.parameterShortName;
        this.description = definition.description;
        this.required = !!definition.required;
        this.environmentVariable = definition.environmentVariable;
        this.undocumentedSynonyms = definition.undocumentedSynonyms;
        if (!CommandLineParameter._longNameRegExp.test(this.longName)) {
            throw new Error(`Invalid name: "${this.longName}". The parameter long name must be` +
                ` lower-case and use dash delimiters (e.g. "--do-a-thing")`);
        }
        if (this.shortName) {
            if (!CommandLineParameter._shortNameRegExp.test(this.shortName)) {
                throw new Error(`Invalid name: "${this.shortName}". The parameter short name must be` +
                    ` a dash followed by a single upper-case or lower-case letter (e.g. "-a")`);
            }
        }
        if (this.environmentVariable) {
            if (this.required) {
                // TODO: This constraint is imposed only because argparse enforces "required" parameters, but
                // it does not know about ts-command-line environment variable mappings.  We should fix this.
                throw new Error(`An "environmentVariable" cannot be specified for "${this.longName}"` +
                    ` because it is a required parameter`);
            }
            if (!CommandLineParameter._environmentVariableRegExp.test(this.environmentVariable)) {
                throw new Error(`Invalid environment variable name: "${this.environmentVariable}". The name must` +
                    ` consist only of upper-case letters, numbers, and underscores. It may not start with a number.`);
            }
        }
        if (this.undocumentedSynonyms && this.undocumentedSynonyms.length > 0) {
            if (this.required) {
                throw new Error('Undocumented synonyms are not allowed on required parameters.');
            }
            for (const undocumentedSynonym of this.undocumentedSynonyms) {
                if (this.longName === undocumentedSynonym) {
                    throw new Error(`Invalid name: "${undocumentedSynonym}". Undocumented Synonyms must not be the same` +
                        ` as the the long name.`);
                }
                else if (!CommandLineParameter._longNameRegExp.test(undocumentedSynonym)) {
                    throw new Error(`Invalid name: "${undocumentedSynonym}". All undocumented Synonyms name must be` +
                        ` lower-case and use dash delimiters (e.g. "--do-a-thing")`);
                }
            }
        }
    }
    /**
     * Returns additional text used by the help formatter.
     * @internal
     */
    _getSupplementaryNotes(supplementaryNotes) {
        // virtual
        if (this.environmentVariable !== undefined) {
            supplementaryNotes.push('This parameter may alternatively be specified via the ' +
                this.environmentVariable +
                ' environment variable.');
        }
    }
    /**
     * Internal usage only.  Used to report unexpected output from the argparse library.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    reportInvalidData(data) {
        throw new Error(`Unexpected data object for parameter "${this.longName}": ` + JSON.stringify(data));
    }
    validateDefaultValue(hasDefaultValue) {
        if (this.required && hasDefaultValue) {
            // If a parameter is "required", then the user understands that they always need to
            // specify a value for this parameter (either via the command line or via an environment variable).
            // It would be confusing to allow a default value that sometimes allows the "required" parameter
            // to be omitted.  If you sometimes don't have a suitable default value, then the better approach
            // is to throw a custom error explaining why the parameter is required in that case.
            throw new Error(`A default value cannot be specified for "${this.longName}" because it is a "required" parameter`);
        }
    }
}
exports.CommandLineParameter = CommandLineParameter;
// Example: "--do-something"
CommandLineParameter._longNameRegExp = /^-(-[a-z0-9]+)+$/;
// Example: "-d"
CommandLineParameter._shortNameRegExp = /^-[a-zA-Z]$/;
// "Environment variable names used by the utilities in the Shell and Utilities volume of
// IEEE Std 1003.1-2001 consist solely of uppercase letters, digits, and the '_' (underscore)
// from the characters defined in Portable Character Set and do not begin with a digit."
// Example: "THE_SETTING"
CommandLineParameter._environmentVariableRegExp = /^[A-Z_][A-Z0-9_]*$/;
/**
 * The common base class for parameters types that receive an argument.
 *
 * @remarks
 * An argument is an accompanying command-line token, such as "123" in the
 * example "--max-count 123".
 * @public
 */
class CommandLineParameterWithArgument extends CommandLineParameter {
    /** @internal */
    constructor(definition) {
        super(definition);
        if (definition.argumentName === '') {
            throw new Error('The argument name cannot be an empty string. (For the default name, specify undefined.)');
        }
        if (definition.argumentName.toUpperCase() !== definition.argumentName) {
            throw new Error(`Invalid name: "${definition.argumentName}". The argument name must be all upper case.`);
        }
        const match = definition.argumentName.match(CommandLineParameterWithArgument._invalidArgumentNameRegExp);
        if (match) {
            throw new Error(`The argument name "${definition.argumentName}" contains an invalid character "${match[0]}".` +
                ` Only upper-case letters, numbers, and underscores are allowed.`);
        }
        this.argumentName = definition.argumentName;
        this.completions = definition.completions;
    }
}
exports.CommandLineParameterWithArgument = CommandLineParameterWithArgument;
// Matches the first character that *isn't* part of a valid upper-case argument name such as "URL_2"
CommandLineParameterWithArgument._invalidArgumentNameRegExp = /[^A-Z_0-9]/;
//# sourceMappingURL=BaseClasses.js.map

/***/ }),

/***/ 40374:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandLineChoiceListParameter = void 0;
const BaseClasses_1 = __webpack_require__(86467);
const EnvironmentVariableParser_1 = __webpack_require__(78023);
/**
 * The data type returned by {@link CommandLineParameterProvider.defineChoiceListParameter}.
 * @public
 */
class CommandLineChoiceListParameter extends BaseClasses_1.CommandLineParameter {
    /** @internal */
    constructor(definition) {
        super(definition);
        this._values = [];
        if (definition.alternatives.length < 1) {
            throw new Error(`When defining a choice list parameter, the alternatives list must contain at least one value.`);
        }
        this.alternatives = definition.alternatives;
        this.completions = definition.completions;
    }
    /** {@inheritDoc CommandLineParameter.kind} */
    get kind() {
        return BaseClasses_1.CommandLineParameterKind.ChoiceList;
    }
    /**
     * {@inheritDoc CommandLineParameter._setValue}
     * @internal
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _setValue(data) {
        // If argparse passed us a value, confirm it is valid
        if (data !== null && data !== undefined) {
            if (!Array.isArray(data)) {
                this.reportInvalidData(data);
            }
            for (const arrayItem of data) {
                if (typeof arrayItem !== 'string') {
                    this.reportInvalidData(data);
                }
            }
            this._values = data;
            return;
        }
        if (this.environmentVariable !== undefined) {
            const values = EnvironmentVariableParser_1.EnvironmentVariableParser.parseAsList(this.environmentVariable);
            if (values) {
                for (const value of values) {
                    if (this.alternatives.indexOf(value) < 0) {
                        const choices = '"' + this.alternatives.join('", "') + '"';
                        throw new Error(`Invalid value "${value}" for the environment variable` +
                            ` ${this.environmentVariable}.  Valid choices are: ${choices}`);
                    }
                }
                this._values = values;
                return;
            }
        }
        // (No default value for choice lists)
        this._values = [];
    }
    /**
     * Returns the string arguments for a choice list parameter that was parsed from the command line.
     *
     * @remarks
     * The array will be empty if the command-line has not been parsed yet,
     * or if the parameter was omitted and has no default value.
     */
    get values() {
        return this._values;
    }
    /** {@inheritDoc CommandLineParameter.appendToArgList} @override */
    appendToArgList(argList) {
        if (this.values.length > 0) {
            for (const value of this.values) {
                argList.push(this.longName);
                argList.push(value);
            }
        }
    }
}
exports.CommandLineChoiceListParameter = CommandLineChoiceListParameter;
//# sourceMappingURL=CommandLineChoiceListParameter.js.map

/***/ }),

/***/ 85277:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandLineChoiceParameter = void 0;
const BaseClasses_1 = __webpack_require__(86467);
/**
 * The data type returned by {@link CommandLineParameterProvider.defineChoiceParameter}.
 * @public
 */
class CommandLineChoiceParameter extends BaseClasses_1.CommandLineParameter {
    /** @internal */
    constructor(definition) {
        super(definition);
        this._value = undefined;
        if (definition.alternatives.length < 1) {
            throw new Error(`When defining a choice parameter, the alternatives list must contain at least one value.`);
        }
        if (definition.defaultValue && definition.alternatives.indexOf(definition.defaultValue) === -1) {
            throw new Error(`The specified default value "${definition.defaultValue}"` +
                ` is not one of the available options: ${definition.alternatives.toString()}`);
        }
        this.alternatives = definition.alternatives;
        this.defaultValue = definition.defaultValue;
        this.validateDefaultValue(!!this.defaultValue);
        this.completions = definition.completions;
    }
    /** {@inheritDoc CommandLineParameter.kind} */
    get kind() {
        return BaseClasses_1.CommandLineParameterKind.Choice;
    }
    /**
     * {@inheritDoc CommandLineParameter._setValue}
     * @internal
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _setValue(data) {
        // abstract
        if (data !== null && data !== undefined) {
            if (typeof data !== 'string') {
                this.reportInvalidData(data);
            }
            this._value = data;
            return;
        }
        if (this.environmentVariable !== undefined) {
            // Try reading the environment variable
            const environmentValue = process.env[this.environmentVariable];
            if (environmentValue !== undefined && environmentValue !== '') {
                if (this.alternatives.indexOf(environmentValue) < 0) {
                    const choices = '"' + this.alternatives.join('", "') + '"';
                    throw new Error(`Invalid value "${environmentValue}" for the environment variable` +
                        ` ${this.environmentVariable}.  Valid choices are: ${choices}`);
                }
                this._value = environmentValue;
                return;
            }
        }
        if (this.defaultValue !== undefined) {
            this._value = this.defaultValue;
            return;
        }
        this._value = undefined;
    }
    /**
     * {@inheritDoc CommandLineParameter._getSupplementaryNotes}
     * @internal
     */
    _getSupplementaryNotes(supplementaryNotes) {
        // virtual
        super._getSupplementaryNotes(supplementaryNotes);
        if (this.defaultValue !== undefined) {
            supplementaryNotes.push(`The default value is "${this.defaultValue}".`);
        }
    }
    /**
     * Returns the argument value for a choice parameter that was parsed from the command line.
     *
     * @remarks
     * The return value will be `undefined` if the command-line has not been parsed yet,
     * or if the parameter was omitted and has no default value.
     */
    get value() {
        return this._value;
    }
    /** {@inheritDoc CommandLineParameter.appendToArgList} @override */
    appendToArgList(argList) {
        if (this.value !== undefined) {
            argList.push(this.longName);
            argList.push(this.value);
        }
    }
}
exports.CommandLineChoiceParameter = CommandLineChoiceParameter;
//# sourceMappingURL=CommandLineChoiceParameter.js.map

/***/ }),

/***/ 58284:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandLineFlagParameter = void 0;
const BaseClasses_1 = __webpack_require__(86467);
/**
 * The data type returned by {@link CommandLineParameterProvider.defineFlagParameter}.
 * @public
 */
class CommandLineFlagParameter extends BaseClasses_1.CommandLineParameter {
    /** @internal */
    constructor(definition) {
        super(definition);
        this._value = false;
    }
    /** {@inheritDoc CommandLineParameter.kind} */
    get kind() {
        return BaseClasses_1.CommandLineParameterKind.Flag;
    }
    /**
     * {@inheritDoc CommandLineParameter._setValue}
     * @internal
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _setValue(data) {
        // abstract
        if (data !== null && data !== undefined) {
            if (typeof data !== 'boolean') {
                this.reportInvalidData(data);
            }
            // If the flag is omitted, then argparse sets the data to "false" instead of "undefined".
            // This design prevents a syntax such as "--flag=false", probably because argparse prefers "--no-flag".
            // If we switch to a new CLI parser, we should try to add support for "--flag=false".
            if (data) {
                this._value = data;
                return;
            }
        }
        if (this.environmentVariable !== undefined) {
            // Try reading the environment variable
            const environmentValue = process.env[this.environmentVariable];
            if (environmentValue !== undefined && environmentValue !== '') {
                if (environmentValue !== '0' && environmentValue !== '1') {
                    throw new Error(`Invalid value "${environmentValue}" for the environment variable` +
                        ` ${this.environmentVariable}.  Valid choices are 0 or 1.`);
                }
                this._value = environmentValue === '1';
                return;
            }
        }
        this._value = false;
    }
    /**
     * Returns a boolean indicating whether the parameter was included in the command line.
     *
     * @remarks
     * The return value will be false if the command-line has not been parsed yet,
     * or if the flag was not used.
     */
    get value() {
        return this._value;
    }
    /** {@inheritDoc CommandLineParameter.appendToArgList} @override */
    appendToArgList(argList) {
        if (this.value) {
            argList.push(this.longName);
        }
    }
}
exports.CommandLineFlagParameter = CommandLineFlagParameter;
//# sourceMappingURL=CommandLineFlagParameter.js.map

/***/ }),

/***/ 40299:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandLineIntegerListParameter = void 0;
const BaseClasses_1 = __webpack_require__(86467);
const EnvironmentVariableParser_1 = __webpack_require__(78023);
/**
 * The data type returned by {@link CommandLineParameterProvider.defineIntegerListParameter}.
 * @public
 */
class CommandLineIntegerListParameter extends BaseClasses_1.CommandLineParameterWithArgument {
    /** @internal */
    constructor(definition) {
        super(definition);
        this._values = [];
    }
    /** {@inheritDoc CommandLineParameter.kind} */
    get kind() {
        return BaseClasses_1.CommandLineParameterKind.IntegerList;
    }
    /**
     * {@inheritDoc CommandLineParameter._setValue}
     * @internal
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _setValue(data) {
        // If argparse passed us a value, confirm it is valid
        if (data !== null && data !== undefined) {
            if (!Array.isArray(data)) {
                this.reportInvalidData(data);
            }
            for (const arrayItem of data) {
                if (typeof arrayItem !== 'number') {
                    this.reportInvalidData(data);
                }
            }
            this._values = data;
            return;
        }
        // If an environment variable exists, attempt to parse it as a list
        if (this.environmentVariable !== undefined) {
            const values = EnvironmentVariableParser_1.EnvironmentVariableParser.parseAsList(this.environmentVariable);
            if (values) {
                const parsedValues = [];
                for (const value of values) {
                    const parsed = parseInt(value, 10);
                    if (isNaN(parsed) || value.indexOf('.') >= 0) {
                        throw new Error(`Invalid value "${value}" for the environment variable` +
                            ` ${this.environmentVariable}.  It must be an integer value.`);
                    }
                    parsedValues.push(parsed);
                }
                this._values = parsedValues;
                return;
            }
        }
        // (No default value for integer lists)
        this._values = [];
    }
    /**
     * Returns the integer arguments for an integer list parameter that was parsed from the command line.
     *
     * @remarks
     * The array will be empty if the command-line has not been parsed yet,
     * or if the parameter was omitted and has no default value.
     */
    get values() {
        return this._values;
    }
    /** {@inheritDoc CommandLineParameter.appendToArgList} @override */
    appendToArgList(argList) {
        if (this.values.length > 0) {
            for (const value of this.values) {
                argList.push(this.longName);
                argList.push(String(value));
            }
        }
    }
}
exports.CommandLineIntegerListParameter = CommandLineIntegerListParameter;
//# sourceMappingURL=CommandLineIntegerListParameter.js.map

/***/ }),

/***/ 6660:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandLineIntegerParameter = void 0;
const BaseClasses_1 = __webpack_require__(86467);
/**
 * The data type returned by {@link CommandLineParameterProvider.defineIntegerParameter}.
 * @public
 */
class CommandLineIntegerParameter extends BaseClasses_1.CommandLineParameterWithArgument {
    /** @internal */
    constructor(definition) {
        super(definition);
        this._value = undefined;
        this.defaultValue = definition.defaultValue;
        this.validateDefaultValue(!!this.defaultValue);
    }
    /** {@inheritDoc CommandLineParameter.kind} */
    get kind() {
        return BaseClasses_1.CommandLineParameterKind.Integer;
    }
    /**
     * {@inheritDoc CommandLineParameter._setValue}
     * @internal
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _setValue(data) {
        // abstract
        if (data !== null && data !== undefined) {
            if (typeof data !== 'number') {
                this.reportInvalidData(data);
            }
            this._value = data;
            return;
        }
        if (this.environmentVariable !== undefined) {
            // Try reading the environment variable
            const environmentValue = process.env[this.environmentVariable];
            if (environmentValue !== undefined && environmentValue !== '') {
                const parsed = parseInt(environmentValue, 10);
                if (isNaN(parsed) || environmentValue.indexOf('.') >= 0) {
                    throw new Error(`Invalid value "${environmentValue}" for the environment variable` +
                        ` ${this.environmentVariable}.  It must be an integer value.`);
                }
                this._value = parsed;
                return;
            }
        }
        if (this.defaultValue !== undefined) {
            this._value = this.defaultValue;
            return;
        }
        this._value = undefined;
    }
    /**
     * {@inheritDoc CommandLineParameter._getSupplementaryNotes}
     * @internal
     */
    _getSupplementaryNotes(supplementaryNotes) {
        // virtual
        super._getSupplementaryNotes(supplementaryNotes);
        if (this.defaultValue !== undefined) {
            supplementaryNotes.push(`The default value is ${this.defaultValue}.`);
        }
    }
    /**
     * Returns the argument value for an integer parameter that was parsed from the command line.
     *
     * @remarks
     * The return value will be undefined if the command-line has not been parsed yet,
     * or if the parameter was omitted and has no default value.
     */
    get value() {
        return this._value;
    }
    /** {@inheritDoc CommandLineParameter.appendToArgList} @override */
    appendToArgList(argList) {
        if (this.value !== undefined) {
            argList.push(this.longName);
            argList.push(this.value.toString());
        }
    }
}
exports.CommandLineIntegerParameter = CommandLineIntegerParameter;
//# sourceMappingURL=CommandLineIntegerParameter.js.map

/***/ }),

/***/ 20476:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandLineRemainder = void 0;
/**
 * The data type returned by {@link CommandLineParameterProvider.defineCommandLineRemainder}.
 * @public
 */
class CommandLineRemainder {
    /** @internal */
    constructor(definition) {
        this._values = [];
        this.description = definition.description;
    }
    /**
     * Returns any remaining command line arguments after the recognized portion
     * that was parsed from the command line.
     *
     * @remarks
     * The array will be empty if the command-line has not been parsed yet.
     */
    get values() {
        return this._values;
    }
    /**
     * {@inheritDoc CommandLineParameter._setValue}
     * @internal
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _setValue(data) {
        // abstract
        if (!Array.isArray(data) || !data.every((x) => typeof x === 'string')) {
            throw new Error(`Unexpected data object for remainder: ` + JSON.stringify(data));
        }
        this._values.push(...data);
    }
    /** {@inheritDoc CommandLineParameter.appendToArgList} @override */
    appendToArgList(argList) {
        if (this.values.length > 0) {
            for (const value of this.values) {
                argList.push(value);
            }
        }
    }
}
exports.CommandLineRemainder = CommandLineRemainder;
//# sourceMappingURL=CommandLineRemainder.js.map

/***/ }),

/***/ 90536:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandLineStringListParameter = void 0;
const BaseClasses_1 = __webpack_require__(86467);
const EnvironmentVariableParser_1 = __webpack_require__(78023);
/**
 * The data type returned by {@link CommandLineParameterProvider.defineStringListParameter}.
 * @public
 */
class CommandLineStringListParameter extends BaseClasses_1.CommandLineParameterWithArgument {
    /** @internal */
    constructor(definition) {
        super(definition);
        this._values = [];
    }
    /** {@inheritDoc CommandLineParameter.kind} */
    get kind() {
        return BaseClasses_1.CommandLineParameterKind.StringList;
    }
    /**
     * {@inheritDoc CommandLineParameter._setValue}
     * @internal
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _setValue(data) {
        // If argparse passed us a value, confirm it is valid
        if (data !== null && data !== undefined) {
            if (!Array.isArray(data)) {
                this.reportInvalidData(data);
            }
            for (const arrayItem of data) {
                if (typeof arrayItem !== 'string') {
                    this.reportInvalidData(data);
                }
            }
            this._values = data;
            return;
        }
        // If an environment variable exists, attempt to parse it as a list
        if (this.environmentVariable !== undefined) {
            const values = EnvironmentVariableParser_1.EnvironmentVariableParser.parseAsList(this.environmentVariable);
            if (values) {
                this._values = values;
                return;
            }
        }
        // (No default value for string lists)
        this._values = [];
    }
    /**
     * Returns the string arguments for a string list parameter that was parsed from the command line.
     *
     * @remarks
     * The array will be empty if the command-line has not been parsed yet,
     * or if the parameter was omitted and has no default value.
     */
    get values() {
        return this._values;
    }
    /** {@inheritDoc CommandLineParameter.appendToArgList} @override */
    appendToArgList(argList) {
        if (this.values.length > 0) {
            for (const value of this.values) {
                argList.push(this.longName);
                argList.push(value);
            }
        }
    }
}
exports.CommandLineStringListParameter = CommandLineStringListParameter;
//# sourceMappingURL=CommandLineStringListParameter.js.map

/***/ }),

/***/ 47578:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandLineStringParameter = void 0;
const BaseClasses_1 = __webpack_require__(86467);
/**
 * The data type returned by {@link CommandLineParameterProvider.defineStringParameter}.
 * @public
 */
class CommandLineStringParameter extends BaseClasses_1.CommandLineParameterWithArgument {
    /** @internal */
    constructor(definition) {
        super(definition);
        this._value = undefined;
        this.defaultValue = definition.defaultValue;
        this.validateDefaultValue(!!this.defaultValue);
    }
    /** {@inheritDoc CommandLineParameter.kind} */
    get kind() {
        return BaseClasses_1.CommandLineParameterKind.String;
    }
    /**
     * {@inheritDoc CommandLineParameter._setValue}
     * @internal
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _setValue(data) {
        // abstract
        if (data !== null && data !== undefined) {
            if (typeof data !== 'string') {
                this.reportInvalidData(data);
            }
            this._value = data;
            return;
        }
        if (this.environmentVariable !== undefined) {
            // Try reading the environment variable
            const environmentValue = process.env[this.environmentVariable];
            if (environmentValue !== undefined) {
                // NOTE: If the environment variable is defined as an empty string,
                // here we will accept the empty string as our value.  (For number/flag we don't do that.)
                this._value = environmentValue;
                return;
            }
        }
        if (this.defaultValue !== undefined) {
            this._value = this.defaultValue;
            return;
        }
        this._value = undefined;
    }
    /**
     * {@inheritDoc CommandLineParameter._getSupplementaryNotes}
     * @internal
     */
    _getSupplementaryNotes(supplementaryNotes) {
        // virtual
        super._getSupplementaryNotes(supplementaryNotes);
        if (this.defaultValue !== undefined) {
            if (this.defaultValue.length < 160) {
                supplementaryNotes.push(`The default value is ${JSON.stringify(this.defaultValue)}.`);
            }
        }
    }
    /**
     * Returns the argument value for a string parameter that was parsed from the command line.
     *
     * @remarks
     * The return value will be undefined if the command-line has not been parsed yet,
     * or if the parameter was omitted and has no default value.
     */
    get value() {
        return this._value;
    }
    /** {@inheritDoc CommandLineParameter.appendToArgList} @override */
    appendToArgList(argList) {
        if (this.value !== undefined) {
            argList.push(this.longName);
            argList.push(this.value);
        }
    }
}
exports.CommandLineStringParameter = CommandLineStringParameter;
//# sourceMappingURL=CommandLineStringParameter.js.map

/***/ }),

/***/ 78023:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnvironmentVariableParser = void 0;
/**
 * Some parameter types can receive their values from an environment variable instead of
 * a command line argument. This class provides some utility methods for parsing environment
 * variable values.
 * @internal
 */
class EnvironmentVariableParser {
    static parseAsList(envVarName) {
        const environmentValue = process.env[envVarName];
        if (environmentValue !== undefined) {
            // NOTE: If the environment variable is defined as an empty string,
            // here we will accept the empty string as our value.  (For number/flag we don't do that.)
            if (environmentValue.trimLeft()[0] === '[') {
                // Specifying multiple items in an environment variable is a somewhat rare case.  But environment
                // variables are actually a pretty reliable way for a tool to avoid shell escaping problems
                // when spawning another tool.  For this case, we need a reliable way to pass an array of strings
                // that could contain any character.  For example, if we simply used ";" as the list delimiter,
                // then what to do if a string contains that character?  We'd need to design an escaping mechanism.
                // Since JSON is simple and standard and can escape every possible string, it's a better option
                // than a custom delimiter.
                try {
                    const parsedJson = JSON.parse(environmentValue);
                    if (!Array.isArray(parsedJson) ||
                        !parsedJson.every((x) => typeof x === 'string' || typeof x === 'boolean' || typeof x === 'number')) {
                        throw new Error(`The ${environmentValue} environment variable value must be a JSON ` +
                            ` array containing only strings, numbers, and booleans.`);
                    }
                    return parsedJson.map((x) => x.toString());
                }
                catch (ex) {
                    throw new Error(`The ${environmentValue} environment variable value looks like a JSON array` +
                        ` but failed to parse: ` +
                        ex.message);
                }
            }
            else {
                // As a shorthand, a single value may be specified without JSON encoding, as long as it does not
                // start with the "[" character.
                return [environmentValue];
            }
        }
        return undefined;
    }
}
exports.EnvironmentVariableParser = EnvironmentVariableParser;
//# sourceMappingURL=EnvironmentVariableParser.js.map

/***/ }),

/***/ 11920:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandLineAction = void 0;
const CommandLineParameterProvider_1 = __webpack_require__(54937);
/**
 * Represents a sub-command that is part of the CommandLineParser command line.
 * Applications should create subclasses of CommandLineAction corresponding to
 * each action that they want to expose.
 *
 * The action name should be comprised of lower case words separated by hyphens
 * or colons. The name should include an English verb (e.g. "deploy"). Use a
 * hyphen to separate words (e.g. "upload-docs"). A group of related commands
 * can be prefixed with a colon (e.g. "docs:generate", "docs:deploy",
 * "docs:serve", etc).
 *
 * @public
 */
class CommandLineAction extends CommandLineParameterProvider_1.CommandLineParameterProvider {
    constructor(options) {
        super();
        if (!CommandLineAction._actionNameRegExp.test(options.actionName)) {
            throw new Error(`Invalid action name "${options.actionName}". ` +
                `The name must be comprised of lower-case words optionally separated by hyphens or colons.`);
        }
        this.actionName = options.actionName;
        this.summary = options.summary;
        this.documentation = options.documentation;
        this._argumentParser = undefined;
    }
    /**
     * This is called internally by CommandLineParser.addAction()
     * @internal
     */
    _buildParser(actionsSubParser) {
        this._argumentParser = actionsSubParser.addParser(this.actionName, {
            help: this.summary,
            description: this.documentation
        });
        this.onDefineParameters();
    }
    /**
     * This is called internally by CommandLineParser.execute()
     * @internal
     */
    _processParsedData(data) {
        super._processParsedData(data);
    }
    /**
     * Invoked by CommandLineParser.onExecute().
     * @internal
     */
    _execute() {
        return this.onExecute();
    }
    /**
     * {@inheritDoc CommandLineParameterProvider._getArgumentParser}
     * @internal
     */
    _getArgumentParser() {
        // override
        if (!this._argumentParser) {
            // We will improve this in the future
            throw new Error('The CommandLineAction must be added to a CommandLineParser before it can be used');
        }
        return this._argumentParser;
    }
}
exports.CommandLineAction = CommandLineAction;
// Example: "do-something"
CommandLineAction._actionNameRegExp = /^[a-z][a-z0-9]*([-:][a-z0-9]+)*$/;
//# sourceMappingURL=CommandLineAction.js.map

/***/ }),

/***/ 54937:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandLineParameterProvider = void 0;
const argparse = __importStar(__webpack_require__(36453));
const BaseClasses_1 = __webpack_require__(86467);
const CommandLineChoiceParameter_1 = __webpack_require__(85277);
const CommandLineChoiceListParameter_1 = __webpack_require__(40374);
const CommandLineIntegerParameter_1 = __webpack_require__(6660);
const CommandLineIntegerListParameter_1 = __webpack_require__(40299);
const CommandLineFlagParameter_1 = __webpack_require__(58284);
const CommandLineStringParameter_1 = __webpack_require__(47578);
const CommandLineStringListParameter_1 = __webpack_require__(90536);
const CommandLineRemainder_1 = __webpack_require__(20476);
/**
 * This is the common base class for CommandLineAction and CommandLineParser
 * that provides functionality for defining command-line parameters.
 *
 * @public
 */
class CommandLineParameterProvider {
    /** @internal */
    // Third party code should not inherit subclasses or call this constructor
    constructor() {
        this._parameters = [];
        this._parametersByLongName = new Map();
        this._parametersProcessed = false;
    }
    /**
     * Returns a collection of the parameters that were defined for this object.
     */
    get parameters() {
        return this._parameters;
    }
    /**
     * Informs the caller if the argparse data has been processed into parameters.
     */
    get parametersProcessed() {
        return this._parametersProcessed;
    }
    /**
     * If {@link CommandLineParameterProvider.defineCommandLineRemainder} was called,
     * this object captures any remaining command line arguments after the recognized portion.
     */
    get remainder() {
        return this._remainder;
    }
    /**
     * Defines a command-line parameter whose value must be a string from a fixed set of
     * allowable choices (similar to an enum).
     *
     * @remarks
     * Example of a choice parameter:
     * ```
     * example-tool --log-level warn
     * ```
     */
    defineChoiceParameter(definition) {
        const parameter = new CommandLineChoiceParameter_1.CommandLineChoiceParameter(definition);
        this._defineParameter(parameter);
        return parameter;
    }
    /**
     * Returns the CommandLineChoiceParameter with the specified long name.
     * @remarks
     * This method throws an exception if the parameter is not defined.
     */
    getChoiceParameter(parameterLongName) {
        return this._getParameter(parameterLongName, BaseClasses_1.CommandLineParameterKind.Choice);
    }
    /**
     * Defines a command-line parameter whose value must be a string from a fixed set of
     * allowable choices (similar to an enum). The parameter can be specified multiple times to
     * build a list.
     *
     * @remarks
     * Example of a choice list parameter:
     * ```
     * example-tool --allow-color red --allow-color green
     * ```
     */
    defineChoiceListParameter(definition) {
        const parameter = new CommandLineChoiceListParameter_1.CommandLineChoiceListParameter(definition);
        this._defineParameter(parameter);
        return parameter;
    }
    /**
     * Returns the CommandLineChoiceListParameter with the specified long name.
     * @remarks
     * This method throws an exception if the parameter is not defined.
     */
    getChoiceListParameter(parameterLongName) {
        return this._getParameter(parameterLongName, BaseClasses_1.CommandLineParameterKind.ChoiceList);
    }
    /**
     * Defines a command-line switch whose boolean value is true if the switch is provided,
     * and false otherwise.
     *
     * @remarks
     * Example usage of a flag parameter:
     * ```
     * example-tool --debug
     * ```
     */
    defineFlagParameter(definition) {
        const parameter = new CommandLineFlagParameter_1.CommandLineFlagParameter(definition);
        this._defineParameter(parameter);
        return parameter;
    }
    /**
     * Returns the CommandLineFlagParameter with the specified long name.
     * @remarks
     * This method throws an exception if the parameter is not defined.
     */
    getFlagParameter(parameterLongName) {
        return this._getParameter(parameterLongName, BaseClasses_1.CommandLineParameterKind.Flag);
    }
    /**
     * Defines a command-line parameter whose argument is an integer.
     *
     * @remarks
     * Example usage of an integer parameter:
     * ```
     * example-tool --max-attempts 5
     * ```
     */
    defineIntegerParameter(definition) {
        const parameter = new CommandLineIntegerParameter_1.CommandLineIntegerParameter(definition);
        this._defineParameter(parameter);
        return parameter;
    }
    /**
     * Returns the CommandLineIntegerParameter with the specified long name.
     * @remarks
     * This method throws an exception if the parameter is not defined.
     */
    getIntegerParameter(parameterLongName) {
        return this._getParameter(parameterLongName, BaseClasses_1.CommandLineParameterKind.Integer);
    }
    /**
     * Defines a command-line parameter whose argument is an integer. The parameter can be specified
     * multiple times to build a list.
     *
     * @remarks
     * Example usage of an integer list parameter:
     * ```
     * example-tool --avoid 4 --avoid 13
     * ```
     */
    defineIntegerListParameter(definition) {
        const parameter = new CommandLineIntegerListParameter_1.CommandLineIntegerListParameter(definition);
        this._defineParameter(parameter);
        return parameter;
    }
    /**
     * Returns the CommandLineIntegerParameter with the specified long name.
     * @remarks
     * This method throws an exception if the parameter is not defined.
     */
    getIntegerListParameter(parameterLongName) {
        return this._getParameter(parameterLongName, BaseClasses_1.CommandLineParameterKind.IntegerList);
    }
    /**
     * Defines a command-line parameter whose argument is a single text string.
     *
     * @remarks
     * Example usage of a string parameter:
     * ```
     * example-tool --message "Hello, world!"
     * ```
     */
    defineStringParameter(definition) {
        const parameter = new CommandLineStringParameter_1.CommandLineStringParameter(definition);
        this._defineParameter(parameter);
        return parameter;
    }
    /**
     * Returns the CommandLineStringParameter with the specified long name.
     * @remarks
     * This method throws an exception if the parameter is not defined.
     */
    getStringParameter(parameterLongName) {
        return this._getParameter(parameterLongName, BaseClasses_1.CommandLineParameterKind.String);
    }
    /**
     * Defines a command-line parameter whose argument is a single text string.  The parameter can be
     * specified multiple times to build a list.
     *
     * @remarks
     * Example usage of a string list parameter:
     * ```
     * example-tool --add file1.txt --add file2.txt --add file3.txt
     * ```
     */
    defineStringListParameter(definition) {
        const parameter = new CommandLineStringListParameter_1.CommandLineStringListParameter(definition);
        this._defineParameter(parameter);
        return parameter;
    }
    /**
     * Defines a rule that captures any remaining command line arguments after the recognized portion.
     *
     * @remarks
     * This feature is useful for commands that pass their arguments along to an external tool, relying on
     * that tool to perform validation.  (It could also be used to parse parameters without any validation
     * or documentation, but that is not recommended.)
     *
     * Example of capturing the remainder after an optional flag parameter.
     * ```
     * example-tool --my-flag this is the remainder
     * ```
     *
     * In the "--help" documentation, the remainder rule will be represented as "...".
     */
    defineCommandLineRemainder(definition) {
        if (this._remainder) {
            throw new Error('defineRemainingArguments() has already been called for this provider');
        }
        this._remainder = new CommandLineRemainder_1.CommandLineRemainder(definition);
        const argparseOptions = {
            help: this._remainder.description,
            nargs: argparse.Const.REMAINDER,
            metavar: '"..."'
        };
        this._getArgumentParser().addArgument(argparse.Const.REMAINDER, argparseOptions);
        return this._remainder;
    }
    /**
     * Returns the CommandLineStringListParameter with the specified long name.
     * @remarks
     * This method throws an exception if the parameter is not defined.
     */
    getStringListParameter(parameterLongName) {
        return this._getParameter(parameterLongName, BaseClasses_1.CommandLineParameterKind.StringList);
    }
    /**
     * Generates the command-line help text.
     */
    renderHelpText() {
        return this._getArgumentParser().formatHelp();
    }
    /**
     * Returns a object which maps the long name of each parameter in this.parameters
     * to the stringified form of its value. This is useful for logging telemetry, but
     * it is not the proper way of accessing parameters or their values.
     */
    getParameterStringMap() {
        const parameterMap = {};
        for (const parameter of this.parameters) {
            switch (parameter.kind) {
                case BaseClasses_1.CommandLineParameterKind.Flag:
                case BaseClasses_1.CommandLineParameterKind.Choice:
                case BaseClasses_1.CommandLineParameterKind.String:
                case BaseClasses_1.CommandLineParameterKind.Integer:
                    parameterMap[parameter.longName] = JSON.stringify(parameter.value);
                    break;
                case BaseClasses_1.CommandLineParameterKind.StringList:
                case BaseClasses_1.CommandLineParameterKind.IntegerList:
                case BaseClasses_1.CommandLineParameterKind.ChoiceList:
                    const arrayValue = parameter.values;
                    parameterMap[parameter.longName] = arrayValue ? arrayValue.join(',') : '';
                    break;
            }
        }
        return parameterMap;
    }
    /** @internal */
    _processParsedData(data) {
        if (this._parametersProcessed) {
            throw new Error('Command Line Parser Data was already processed');
        }
        // Fill in the values for the parameters
        for (const parameter of this._parameters) {
            const value = data[parameter._parserKey]; // eslint-disable-line @typescript-eslint/no-explicit-any
            parameter._setValue(value);
        }
        if (this.remainder) {
            this.remainder._setValue(data[argparse.Const.REMAINDER]);
        }
        this._parametersProcessed = true;
    }
    _generateKey() {
        return 'key_' + (CommandLineParameterProvider._keyCounter++).toString();
    }
    _getParameter(parameterLongName, expectedKind) {
        const parameter = this._parametersByLongName.get(parameterLongName);
        if (!parameter) {
            throw new Error(`The parameter "${parameterLongName}" is not defined`);
        }
        if (parameter.kind !== expectedKind) {
            throw new Error(`The parameter "${parameterLongName}" is of type "${BaseClasses_1.CommandLineParameterKind[parameter.kind]}"` +
                ` whereas the caller was expecting "${BaseClasses_1.CommandLineParameterKind[expectedKind]}".`);
        }
        return parameter;
    }
    _defineParameter(parameter) {
        if (this._remainder) {
            throw new Error('defineCommandLineRemainder() was already called for this provider;' +
                ' no further parameters can be defined');
        }
        const names = [];
        if (parameter.shortName) {
            names.push(parameter.shortName);
        }
        names.push(parameter.longName);
        parameter._parserKey = this._generateKey();
        let finalDescription = parameter.description;
        const supplementaryNotes = [];
        parameter._getSupplementaryNotes(supplementaryNotes);
        if (supplementaryNotes.length > 0) {
            // If they left the period off the end of their sentence, then add one.
            if (finalDescription.match(/[a-z0-9]"?\s*$/i)) {
                finalDescription = finalDescription.trimRight() + '.';
            }
            // Append the supplementary text
            finalDescription += ' ' + supplementaryNotes.join(' ');
        }
        // NOTE: Our "environmentVariable" feature takes precedence over argparse's "defaultValue",
        // so we have to reimplement that feature.
        const argparseOptions = {
            help: finalDescription,
            dest: parameter._parserKey,
            metavar: parameter.argumentName || undefined,
            required: parameter.required
        };
        switch (parameter.kind) {
            case BaseClasses_1.CommandLineParameterKind.Choice: {
                const choiceParameter = parameter;
                argparseOptions.choices = choiceParameter.alternatives;
                break;
            }
            case BaseClasses_1.CommandLineParameterKind.ChoiceList: {
                const choiceParameter = parameter;
                argparseOptions.choices = choiceParameter.alternatives;
                argparseOptions.action = 'append';
                break;
            }
            case BaseClasses_1.CommandLineParameterKind.Flag:
                argparseOptions.action = 'storeTrue';
                break;
            case BaseClasses_1.CommandLineParameterKind.Integer:
                argparseOptions.type = 'int';
                break;
            case BaseClasses_1.CommandLineParameterKind.IntegerList:
                argparseOptions.type = 'int';
                argparseOptions.action = 'append';
                break;
            case BaseClasses_1.CommandLineParameterKind.String:
                break;
            case BaseClasses_1.CommandLineParameterKind.StringList:
                argparseOptions.action = 'append';
                break;
        }
        const argumentParser = this._getArgumentParser();
        argumentParser.addArgument(names, Object.assign({}, argparseOptions));
        if (parameter.undocumentedSynonyms && parameter.undocumentedSynonyms.length > 0) {
            argumentParser.addArgument(parameter.undocumentedSynonyms, Object.assign(Object.assign({}, argparseOptions), { help: argparse.Const.SUPPRESS }));
        }
        this._parameters.push(parameter);
        this._parametersByLongName.set(parameter.longName, parameter);
    }
}
exports.CommandLineParameterProvider = CommandLineParameterProvider;
CommandLineParameterProvider._keyCounter = 0;
//# sourceMappingURL=CommandLineParameterProvider.js.map

/***/ }),

/***/ 4115:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandLineParser = void 0;
const colors_1 = __importDefault(__webpack_require__(83045));
const CommandLineParameterProvider_1 = __webpack_require__(54937);
const CommandLineParserExitError_1 = __webpack_require__(1495);
const TabCompletionAction_1 = __webpack_require__(62291);
/**
 * The "argparse" library is a relatively advanced command-line parser with features such
 * as word-wrapping and intelligible error messages (that are lacking in other similar
 * libraries such as commander, yargs, and nomnom).  Unfortunately, its ruby-inspired API
 * is awkward to use.  The abstract base classes CommandLineParser and CommandLineAction
 * provide a wrapper for "argparse" that makes defining and consuming arguments quick
 * and simple, and enforces that appropriate documentation is provided for each parameter.
 *
 * @public
 */
class CommandLineParser extends CommandLineParameterProvider_1.CommandLineParameterProvider {
    constructor(options) {
        super();
        this._executed = false;
        this._tabCompleteActionWasAdded = false;
        this._options = options;
        this._actions = [];
        this._actionsByName = new Map();
        this._argumentParser = new CommandLineParserExitError_1.CustomArgumentParser({
            addHelp: true,
            prog: this._options.toolFilename,
            description: this._options.toolDescription,
            epilog: colors_1.default.bold(`For detailed help about a specific command, use: ${this._options.toolFilename} <command> -h`)
        });
        this.onDefineParameters();
    }
    /**
     * Returns the list of actions that were defined for this CommandLineParser object.
     */
    get actions() {
        return this._actions;
    }
    /**
     * Defines a new action that can be used with the CommandLineParser instance.
     */
    addAction(action) {
        if (!this._actionsSubParser) {
            this._actionsSubParser = this._argumentParser.addSubparsers({
                metavar: '<command>',
                dest: 'action'
            });
        }
        action._buildParser(this._actionsSubParser);
        this._actions.push(action);
        this._actionsByName.set(action.actionName, action);
    }
    /**
     * Retrieves the action with the specified name.  If no matching action is found,
     * an exception is thrown.
     */
    getAction(actionName) {
        const action = this.tryGetAction(actionName);
        if (!action) {
            throw new Error(`The action "${actionName}" was not defined`);
        }
        return action;
    }
    /**
     * Retrieves the action with the specified name.  If no matching action is found,
     * undefined is returned.
     */
    tryGetAction(actionName) {
        return this._actionsByName.get(actionName);
    }
    /**
     * The program entry point will call this method to begin parsing command-line arguments
     * and executing the corresponding action.
     *
     * @remarks
     * The returned promise will never reject:  If an error occurs, it will be printed
     * to stderr, process.exitCode will be set to 1, and the promise will resolve to false.
     * This simplifies the most common usage scenario where the program entry point doesn't
     * want to be involved with the command-line logic, and will discard the promise without
     * a then() or catch() block.
     *
     * If your caller wants to trap and handle errors, use {@link CommandLineParser.executeWithoutErrorHandling}
     * instead.
     *
     * @param args - the command-line arguments to be parsed; if omitted, then
     *               the process.argv will be used
     */
    async execute(args) {
        if (this._options.enableTabCompletionAction && !this._tabCompleteActionWasAdded) {
            this.addAction(new TabCompletionAction_1.TabCompleteAction(this.actions, this.parameters));
            this._tabCompleteActionWasAdded = true;
        }
        try {
            await this.executeWithoutErrorHandling(args);
            return true;
        }
        catch (err) {
            if (err instanceof CommandLineParserExitError_1.CommandLineParserExitError) {
                // executeWithoutErrorHandling() handles the successful cases,
                // so here we can assume err has a nonzero exit code
                if (err.message) {
                    console.error(err.message);
                }
                if (!process.exitCode) {
                    process.exitCode = err.exitCode;
                }
            }
            else {
                let message = (err.message || 'An unknown error occurred').trim();
                // If the message doesn't already start with "Error:" then add a prefix
                if (!/^(error|internal error|warning)\b/i.test(message)) {
                    message = 'Error: ' + message;
                }
                console.error();
                console.error(colors_1.default.red(message));
                if (!process.exitCode) {
                    process.exitCode = 1;
                }
            }
            return false;
        }
    }
    /**
     * This is similar to {@link CommandLineParser.execute}, except that execution errors
     * simply cause the promise to reject.  It is the caller's responsibility to trap
     */
    async executeWithoutErrorHandling(args) {
        try {
            if (this._executed) {
                // In the future we could allow the same parser to be invoked multiple times
                // with different arguments.  We'll do that work as soon as someone encounters
                // a real world need for it.
                throw new Error('execute() was already called for this parser instance');
            }
            this._executed = true;
            this._validateDefinitions();
            if (!args) {
                // 0=node.exe, 1=script name
                args = process.argv.slice(2);
            }
            if (args.length === 0) {
                this._argumentParser.printHelp();
                return;
            }
            const data = this._argumentParser.parseArgs(args);
            this._processParsedData(data);
            for (const action of this._actions) {
                if (action.actionName === data.action) {
                    this.selectedAction = action;
                    action._processParsedData(data);
                    break;
                }
            }
            if (this.actions.length > 0 && !this.selectedAction) {
                const actions = this.actions.map((x) => x.actionName);
                throw new Error(`An action must be specified (${actions.join(', ')})`);
            }
            return this.onExecute();
        }
        catch (err) {
            if (err instanceof CommandLineParserExitError_1.CommandLineParserExitError) {
                if (!err.exitCode) {
                    // non-error exit modeled using exception handling
                    if (err.message) {
                        console.log(err.message);
                    }
                    return;
                }
            }
            throw err;
        }
    }
    _validateDefinitions() {
        if (this.remainder && this.actions.length > 0) {
            // This is apparently not supported by argparse
            throw new Error('defineCommandLineRemainder() cannot be called for a CommandLineParser with actions');
        }
    }
    /**
     * {@inheritDoc CommandLineParameterProvider._getArgumentParser}
     * @internal
     */
    _getArgumentParser() {
        // override
        return this._argumentParser;
    }
    /**
     * This hook allows the subclass to perform additional operations before or after
     * the chosen action is executed.
     */
    async onExecute() {
        if (this.selectedAction) {
            await this.selectedAction._execute();
        }
    }
}
exports.CommandLineParser = CommandLineParser;
//# sourceMappingURL=CommandLineParser.js.map

/***/ }),

/***/ 1495:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CustomArgumentParser = exports.CommandLineParserExitError = void 0;
const argparse = __importStar(__webpack_require__(36453));
class CommandLineParserExitError extends Error {
    constructor(exitCode, message) {
        super(message);
        // Manually set the prototype, as we can no longer extend built-in classes like Error, Array, Map, etc
        // https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        //
        // Note: the prototype must also be set on any classes which extend this one
        this.__proto__ = CommandLineParserExitError.prototype; // eslint-disable-line @typescript-eslint/no-explicit-any
        this.exitCode = exitCode;
    }
}
exports.CommandLineParserExitError = CommandLineParserExitError;
class CustomArgumentParser extends argparse.ArgumentParser {
    exit(status, message) {
        // override
        throw new CommandLineParserExitError(status, message);
    }
    error(err) {
        // override
        // Ensure the ParserExitError bubbles up to the top without any special processing
        if (err instanceof CommandLineParserExitError) {
            throw err;
        }
        super.error(err);
    }
}
exports.CustomArgumentParser = CustomArgumentParser;
//# sourceMappingURL=CommandLineParserExitError.js.map

/***/ }),

/***/ 57943:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DynamicCommandLineAction = void 0;
const CommandLineAction_1 = __webpack_require__(11920);
/**
 * @public
 */
class DynamicCommandLineAction extends CommandLineAction_1.CommandLineAction {
    onDefineParameters() {
        // abstract
        // (handled by the external code)
    }
    async onExecute() {
        // abstract
        // (handled by the external code)
    }
}
exports.DynamicCommandLineAction = DynamicCommandLineAction;
//# sourceMappingURL=DynamicCommandLineAction.js.map

/***/ }),

/***/ 43827:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DynamicCommandLineParser = void 0;
const CommandLineParser_1 = __webpack_require__(4115);
/**
 * @public
 */
class DynamicCommandLineParser extends CommandLineParser_1.CommandLineParser {
    onDefineParameters() {
        // abstract
    }
}
exports.DynamicCommandLineParser = DynamicCommandLineParser;
//# sourceMappingURL=DynamicCommandLineParser.js.map

/***/ }),

/***/ 62291:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncDelegator = (this && this.__asyncDelegator) || function (o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
};
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TabCompleteAction = void 0;
const string_argv_1 = __importDefault(__webpack_require__(9453));
const BaseClasses_1 = __webpack_require__(86467);
const CommandLineAction_1 = __webpack_require__(11920);
const __1 = __webpack_require__(36972);
const DEFAULT_WORD_TO_AUTOCOMPLETE = '';
const DEFAULT_POSITION = 0;
class TabCompleteAction extends CommandLineAction_1.CommandLineAction {
    constructor(actions, globalParameters) {
        super({
            actionName: "tab-complete" /* TabCompletionActionName */,
            summary: 'Provides tab completion.',
            documentation: 'Provides tab completion.'
        });
        this._actions = new Map();
        for (const action of actions) {
            const parameterNameToParameterInfoMap = new Map();
            for (const parameter of action.parameters) {
                parameterNameToParameterInfoMap.set(parameter.longName, parameter);
                if (parameter.shortName) {
                    parameterNameToParameterInfoMap.set(parameter.shortName, parameter);
                }
            }
            this._actions.set(action.actionName, parameterNameToParameterInfoMap);
        }
        this._globalParameters = new Map();
        for (const parameter of globalParameters) {
            this._globalParameters.set(parameter.longName, parameter);
            if (parameter.shortName) {
                this._globalParameters.set(parameter.shortName, parameter);
            }
        }
    }
    onDefineParameters() {
        this._wordToCompleteParameter = this.defineStringParameter({
            parameterLongName: '--word',
            argumentName: 'WORD',
            description: `The word to complete.`,
            defaultValue: DEFAULT_WORD_TO_AUTOCOMPLETE
        });
        this._positionParameter = this.defineIntegerParameter({
            parameterLongName: '--position',
            argumentName: 'INDEX',
            description: `The position in the word to be completed.`,
            defaultValue: DEFAULT_POSITION
        });
    }
    async onExecute() {
        var e_1, _a;
        const commandLine = this._wordToCompleteParameter.value || '';
        const caretPosition = this._positionParameter.value || (commandLine && commandLine.length) || 0;
        try {
            for (var _b = __asyncValues(this.getCompletions(commandLine, caretPosition)), _c; _c = await _b.next(), !_c.done;) {
                const value = _c.value;
                console.log(value);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    getCompletions(commandLine, caretPosition = commandLine.length) {
        return __asyncGenerator(this, arguments, function* getCompletions_1() {
            const actions = this._actions;
            if (!commandLine || !caretPosition) {
                yield __await(yield* __asyncDelegator(__asyncValues(this._getAllActions())));
                return yield __await(void 0);
            }
            const tokens = Array.from(this.tokenizeCommandLine(commandLine));
            // offset arguments by the number of global params in the input
            const globalParameterOffset = this._getGlobalParameterOffset(tokens);
            if (tokens.length < 2 + globalParameterOffset) {
                yield __await(yield* __asyncDelegator(__asyncValues(this._getAllActions())));
                return yield __await(void 0);
            }
            const lastToken = tokens[tokens.length - 1];
            const secondLastToken = tokens[tokens.length - 2];
            const completePartialWord = caretPosition === commandLine.length;
            if (completePartialWord && tokens.length === 2 + globalParameterOffset) {
                for (const actionName of actions.keys()) {
                    if (actionName.indexOf(tokens[1 + globalParameterOffset]) === 0) {
                        yield yield __await(actionName);
                    }
                }
            }
            else {
                for (const actionName of actions.keys()) {
                    if (actionName === tokens[1 + globalParameterOffset]) {
                        const parameterNameMap = actions.get(actionName);
                        const parameterNames = Array.from(parameterNameMap.keys());
                        if (completePartialWord) {
                            for (const parameterName of parameterNames) {
                                if (parameterName === secondLastToken) {
                                    const values = yield __await(this._getParameterValueCompletions(parameterNameMap.get(parameterName)));
                                    if (values.length > 0) {
                                        yield __await(yield* __asyncDelegator(__asyncValues(this._completeParameterValues(values, lastToken))));
                                        return yield __await(void 0);
                                    }
                                }
                            }
                            yield __await(yield* __asyncDelegator(__asyncValues(this._completeParameterValues(parameterNames, lastToken))));
                        }
                        else {
                            for (const parameterName of parameterNames) {
                                if (parameterName === lastToken) {
                                    const values = yield __await(this._getParameterValueCompletions(parameterNameMap.get(parameterName)));
                                    if (values.length > 0) {
                                        yield __await(yield* __asyncDelegator(__asyncValues(values)));
                                        return yield __await(void 0);
                                    }
                                }
                            }
                            for (const parameterName of parameterNames) {
                                if (parameterName === lastToken &&
                                    parameterNameMap.get(parameterName).kind !== BaseClasses_1.CommandLineParameterKind.Flag) {
                                    // The parameter is expecting a value, so don't suggest parameter names again
                                    return yield __await(void 0);
                                }
                            }
                            yield __await(yield* __asyncDelegator(__asyncValues(parameterNames)));
                        }
                        break;
                    }
                }
            }
        });
    }
    *_getAllActions() {
        yield* this._actions.keys();
        yield* this._globalParameters.keys();
    }
    tokenizeCommandLine(commandLine) {
        return (0, string_argv_1.default)(commandLine);
    }
    async _getParameterValueCompletions(parameter) {
        let choiceParameterValues = [];
        if (parameter.kind === BaseClasses_1.CommandLineParameterKind.Choice) {
            choiceParameterValues = parameter.alternatives;
        }
        else if (parameter.kind !== BaseClasses_1.CommandLineParameterKind.Flag) {
            let parameterWithArgumentOrChoices = undefined;
            if (parameter instanceof BaseClasses_1.CommandLineParameterWithArgument) {
                parameterWithArgumentOrChoices = parameter;
            }
            else if (parameter instanceof __1.CommandLineChoiceParameter) {
                parameterWithArgumentOrChoices = parameter;
            }
            if (parameterWithArgumentOrChoices && parameterWithArgumentOrChoices.completions) {
                choiceParameterValues = await parameterWithArgumentOrChoices.completions();
            }
        }
        return choiceParameterValues;
    }
    _getGlobalParameterOffset(tokens) {
        const globalParameters = this._globalParameters;
        let count = 0;
        outer: for (let i = 1; i < tokens.length; i++) {
            for (const globalParameter of globalParameters.values()) {
                if (tokens[i] !== globalParameter.longName && tokens[i] !== globalParameter.shortName) {
                    break outer;
                }
            }
            count++;
        }
        return count;
    }
    *_completeParameterValues(choiceParameterValues, lastToken) {
        for (const choiceParameterValue of choiceParameterValues) {
            if (choiceParameterValue.indexOf(lastToken) === 0) {
                yield choiceParameterValue;
            }
        }
    }
}
exports.TabCompleteAction = TabCompleteAction;
//# sourceMappingURL=TabCompletionAction.js.map

/***/ }),

/***/ 36453:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(7831);


/***/ }),

/***/ 60225:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * class Action
 *
 * Base class for all actions
 * Do not call in your code, use this class only for inherits your own action
 *
 * Information about how to convert command line strings to Javascript objects.
 * Action objects are used by an ArgumentParser to represent the information
 * needed to parse a single argument from one or more strings from the command
 * line. The keyword arguments to the Action constructor are also all attributes
 * of Action instances.
 *
 * ##### Allowed keywords:
 *
 * - `store`
 * - `storeConstant`
 * - `storeTrue`
 * - `storeFalse`
 * - `append`
 * - `appendConstant`
 * - `count`
 * - `help`
 * - `version`
 *
 * Information about action options see [[Action.new]]
 *
 * See also [original guide](http://docs.python.org/dev/library/argparse.html#action)
 *
 **/




// Constants
var c = __webpack_require__(87815);


/**
 * new Action(options)
 *
 * Base class for all actions. Used only for inherits
 *
 *
 * ##### Options:
 *
 * - `optionStrings`  A list of command-line option strings for the action.
 * - `dest`  Attribute to hold the created object(s)
 * - `nargs`  The number of command-line arguments that should be consumed.
 * By default, one argument will be consumed and a single value will be
 * produced.
 * - `constant`  Default value for an action with no value.
 * - `defaultValue`  The value to be produced if the option is not specified.
 * - `type`  Cast to 'string'|'int'|'float'|'complex'|function (string). If
 * None, 'string'.
 * - `choices`  The choices available.
 * - `required`  True if the action must always be specified at the command
 * line.
 * - `help`  The help describing the argument.
 * - `metavar`  The name to be used for the option's argument with the help
 * string. If None, the 'dest' value will be used as the name.
 *
 * ##### nargs supported values:
 *
 * - `N` (an integer) consumes N arguments (and produces a list)
 * - `?`  consumes zero or one arguments
 * - `*` consumes zero or more arguments (and produces a list)
 * - `+` consumes one or more arguments (and produces a list)
 *
 * Note: that the difference between the default and nargs=1 is that with the
 * default, a single value will be produced, while with nargs=1, a list
 * containing a single value will be produced.
 **/
var Action = module.exports = function Action(options) {
  options = options || {};
  this.optionStrings = options.optionStrings || [];
  this.dest = options.dest;
  this.nargs = typeof options.nargs !== 'undefined' ? options.nargs : null;
  this.constant = typeof options.constant !== 'undefined' ? options.constant : null;
  this.defaultValue = options.defaultValue;
  this.type = typeof options.type !== 'undefined' ? options.type : null;
  this.choices = typeof options.choices !== 'undefined' ? options.choices : null;
  this.required = typeof options.required !== 'undefined' ? options.required : false;
  this.help = typeof options.help !== 'undefined' ? options.help : null;
  this.metavar = typeof options.metavar !== 'undefined' ? options.metavar : null;

  if (!(this.optionStrings instanceof Array)) {
    throw new Error('optionStrings should be an array');
  }
  if (typeof this.required !== 'undefined' && typeof this.required !== 'boolean') {
    throw new Error('required should be a boolean');
  }
};

/**
 * Action#getName -> String
 *
 * Tells action name
 **/
Action.prototype.getName = function () {
  if (this.optionStrings.length > 0) {
    return this.optionStrings.join('/');
  } else if (this.metavar !== null && this.metavar !== c.SUPPRESS) {
    return this.metavar;
  } else if (typeof this.dest !== 'undefined' && this.dest !== c.SUPPRESS) {
    return this.dest;
  }
  return null;
};

/**
 * Action#isOptional -> Boolean
 *
 * Return true if optional
 **/
Action.prototype.isOptional = function () {
  return !this.isPositional();
};

/**
 * Action#isPositional -> Boolean
 *
 * Return true if positional
 **/
Action.prototype.isPositional = function () {
  return (this.optionStrings.length === 0);
};

/**
 * Action#call(parser, namespace, values, optionString) -> Void
 * - parser (ArgumentParser): current parser
 * - namespace (Namespace): namespace for output data
 * - values (Array): parsed values
 * - optionString (Array): input option string(not parsed)
 *
 * Call the action. Should be implemented in inherited classes
 *
 * ##### Example
 *
 *      ActionCount.prototype.call = function (parser, namespace, values, optionString) {
 *        namespace.set(this.dest, (namespace[this.dest] || 0) + 1);
 *      };
 *
 **/
Action.prototype.call = function () {
  throw new Error('.call() not defined');// Not Implemented error
};


/***/ }),

/***/ 56052:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*:nodoc:*
 * class ActionAppend
 *
 * This action stores a list, and appends each argument value to the list.
 * This is useful to allow an option to be specified multiple times.
 * This class inherided from [[Action]]
 *
 **/



var util = __webpack_require__(31669);

var Action = __webpack_require__(60225);

// Constants
var c = __webpack_require__(87815);

/*:nodoc:*
 * new ActionAppend(options)
 * - options (object): options hash see [[Action.new]]
 *
 * Note: options.nargs should be optional for constants
 * and more then zero for other
 **/
var ActionAppend = module.exports = function ActionAppend(options) {
  options = options || {};
  if (this.nargs <= 0) {
    throw new Error('nargs for append actions must be > 0; if arg ' +
        'strings are not supplying the value to append, ' +
        'the append const action may be more appropriate');
  }
  if (!!this.constant && this.nargs !== c.OPTIONAL) {
    throw new Error('nargs must be OPTIONAL to supply const');
  }
  Action.call(this, options);
};
util.inherits(ActionAppend, Action);

/*:nodoc:*
 * ActionAppend#call(parser, namespace, values, optionString) -> Void
 * - parser (ArgumentParser): current parser
 * - namespace (Namespace): namespace for output data
 * - values (Array): parsed values
 * - optionString (Array): input option string(not parsed)
 *
 * Call the action. Save result in namespace object
 **/
ActionAppend.prototype.call = function (parser, namespace, values) {
  var items = (namespace[this.dest] || []).slice();
  items.push(values);
  namespace.set(this.dest, items);
};


/***/ }),

/***/ 92478:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*:nodoc:*
 * class ActionAppendConstant
 *
 * This stores a list, and appends the value specified by
 * the const keyword argument to the list.
 * (Note that the const keyword argument defaults to null.)
 * The 'appendConst' action is typically useful when multiple
 * arguments need to store constants to the same list.
 *
 * This class inherited from [[Action]]
 **/



var util = __webpack_require__(31669);

var Action = __webpack_require__(60225);

/*:nodoc:*
 * new ActionAppendConstant(options)
 * - options (object): options hash see [[Action.new]]
 *
 **/
var ActionAppendConstant = module.exports = function ActionAppendConstant(options) {
  options = options || {};
  options.nargs = 0;
  if (typeof options.constant === 'undefined') {
    throw new Error('constant option is required for appendAction');
  }
  Action.call(this, options);
};
util.inherits(ActionAppendConstant, Action);

/*:nodoc:*
 * ActionAppendConstant#call(parser, namespace, values, optionString) -> Void
 * - parser (ArgumentParser): current parser
 * - namespace (Namespace): namespace for output data
 * - values (Array): parsed values
 * - optionString (Array): input option string(not parsed)
 *
 * Call the action. Save result in namespace object
 **/
ActionAppendConstant.prototype.call = function (parser, namespace) {
  var items = [].concat(namespace[this.dest] || []);
  items.push(this.constant);
  namespace.set(this.dest, items);
};


/***/ }),

/***/ 35543:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*:nodoc:*
 * class ActionCount
 *
 * This counts the number of times a keyword argument occurs.
 * For example, this is useful for increasing verbosity levels
 *
 * This class inherided from [[Action]]
 *
 **/


var util = __webpack_require__(31669);

var Action = __webpack_require__(60225);

/*:nodoc:*
 * new ActionCount(options)
 * - options (object): options hash see [[Action.new]]
 *
 **/
var ActionCount = module.exports = function ActionCount(options) {
  options = options || {};
  options.nargs = 0;

  Action.call(this, options);
};
util.inherits(ActionCount, Action);

/*:nodoc:*
 * ActionCount#call(parser, namespace, values, optionString) -> Void
 * - parser (ArgumentParser): current parser
 * - namespace (Namespace): namespace for output data
 * - values (Array): parsed values
 * - optionString (Array): input option string(not parsed)
 *
 * Call the action. Save result in namespace object
 **/
ActionCount.prototype.call = function (parser, namespace) {
  namespace.set(this.dest, (namespace[this.dest] || 0) + 1);
};


/***/ }),

/***/ 6600:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*:nodoc:*
 * class ActionHelp
 *
 * Support action for printing help
 * This class inherided from [[Action]]
 **/


var util = __webpack_require__(31669);

var Action = __webpack_require__(60225);

// Constants
var c  = __webpack_require__(87815);

/*:nodoc:*
 * new ActionHelp(options)
 * - options (object): options hash see [[Action.new]]
 *
 **/
var ActionHelp = module.exports = function ActionHelp(options) {
  options = options || {};
  if (options.defaultValue !== null) {
    options.defaultValue = options.defaultValue;
  } else {
    options.defaultValue = c.SUPPRESS;
  }
  options.dest = (options.dest !== null ? options.dest : c.SUPPRESS);
  options.nargs = 0;
  Action.call(this, options);

};
util.inherits(ActionHelp, Action);

/*:nodoc:*
 * ActionHelp#call(parser, namespace, values, optionString)
 * - parser (ArgumentParser): current parser
 * - namespace (Namespace): namespace for output data
 * - values (Array): parsed values
 * - optionString (Array): input option string(not parsed)
 *
 * Print help and exit
 **/
ActionHelp.prototype.call = function (parser) {
  parser.printHelp();
  parser.exit();
};


/***/ }),

/***/ 17229:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*:nodoc:*
 * class ActionStore
 *
 * This action just stores the arguments value. This is the default action.
 *
 * This class inherited from [[Action]]
 *
 **/


var util = __webpack_require__(31669);

var Action = __webpack_require__(60225);

// Constants
var c = __webpack_require__(87815);


/*:nodoc:*
 * new ActionStore(options)
 * - options (object): options hash see [[Action.new]]
 *
 **/
var ActionStore = module.exports = function ActionStore(options) {
  options = options || {};
  if (this.nargs <= 0) {
    throw new Error('nargs for store actions must be > 0; if you ' +
        'have nothing to store, actions such as store ' +
        'true or store const may be more appropriate');

  }
  if (typeof this.constant !== 'undefined' && this.nargs !== c.OPTIONAL) {
    throw new Error('nargs must be OPTIONAL to supply const');
  }
  Action.call(this, options);
};
util.inherits(ActionStore, Action);

/*:nodoc:*
 * ActionStore#call(parser, namespace, values, optionString) -> Void
 * - parser (ArgumentParser): current parser
 * - namespace (Namespace): namespace for output data
 * - values (Array): parsed values
 * - optionString (Array): input option string(not parsed)
 *
 * Call the action. Save result in namespace object
 **/
ActionStore.prototype.call = function (parser, namespace, values) {
  namespace.set(this.dest, values);
};


/***/ }),

/***/ 43741:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*:nodoc:*
 * class ActionStoreConstant
 *
 * This action stores the value specified by the const keyword argument.
 * (Note that the const keyword argument defaults to the rather unhelpful null.)
 * The 'store_const' action is most commonly used with optional
 * arguments that specify some sort of flag.
 *
 * This class inherited from [[Action]]
 **/


var util = __webpack_require__(31669);

var Action = __webpack_require__(60225);

/*:nodoc:*
 * new ActionStoreConstant(options)
 * - options (object): options hash see [[Action.new]]
 *
 **/
var ActionStoreConstant = module.exports = function ActionStoreConstant(options) {
  options = options || {};
  options.nargs = 0;
  if (typeof options.constant === 'undefined') {
    throw new Error('constant option is required for storeAction');
  }
  Action.call(this, options);
};
util.inherits(ActionStoreConstant, Action);

/*:nodoc:*
 * ActionStoreConstant#call(parser, namespace, values, optionString) -> Void
 * - parser (ArgumentParser): current parser
 * - namespace (Namespace): namespace for output data
 * - values (Array): parsed values
 * - optionString (Array): input option string(not parsed)
 *
 * Call the action. Save result in namespace object
 **/
ActionStoreConstant.prototype.call = function (parser, namespace) {
  namespace.set(this.dest, this.constant);
};


/***/ }),

/***/ 37656:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*:nodoc:*
 * class ActionStoreFalse
 *
 * This action store the values False respectively.
 * This is special cases of 'storeConst'
 *
 * This class inherited from [[Action]]
 **/



var util = __webpack_require__(31669);

var ActionStoreConstant = __webpack_require__(43741);

/*:nodoc:*
 * new ActionStoreFalse(options)
 * - options (object): hash of options see [[Action.new]]
 *
 **/
var ActionStoreFalse = module.exports = function ActionStoreFalse(options) {
  options = options || {};
  options.constant = false;
  options.defaultValue = options.defaultValue !== null ? options.defaultValue : true;
  ActionStoreConstant.call(this, options);
};
util.inherits(ActionStoreFalse, ActionStoreConstant);


/***/ }),

/***/ 99773:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*:nodoc:*
 * class ActionStoreTrue
 *
 * This action store the values True respectively.
 * This isspecial cases of 'storeConst'
 *
 * This class inherited from [[Action]]
 **/


var util = __webpack_require__(31669);

var ActionStoreConstant = __webpack_require__(43741);

/*:nodoc:*
 * new ActionStoreTrue(options)
 * - options (object): options hash see [[Action.new]]
 *
 **/
var ActionStoreTrue = module.exports = function ActionStoreTrue(options) {
  options = options || {};
  options.constant = true;
  options.defaultValue = options.defaultValue !== null ? options.defaultValue : false;
  ActionStoreConstant.call(this, options);
};
util.inherits(ActionStoreTrue, ActionStoreConstant);


/***/ }),

/***/ 36809:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/** internal
 * class ActionSubparsers
 *
 * Support the creation of such sub-commands with the addSubparsers()
 *
 * This class inherited from [[Action]]
 **/


var util    = __webpack_require__(31669);
var format  = __webpack_require__(31669).format;


var Action = __webpack_require__(60225);

// Constants
var c = __webpack_require__(87815);

// Errors
var argumentErrorHelper = __webpack_require__(69435);


/*:nodoc:*
 * new ChoicesPseudoAction(name, help)
 *
 * Create pseudo action for correct help text
 *
 **/
function ChoicesPseudoAction(name, help) {
  var options = {
    optionStrings: [],
    dest: name,
    help: help
  };

  Action.call(this, options);
}

util.inherits(ChoicesPseudoAction, Action);

/**
 * new ActionSubparsers(options)
 * - options (object): options hash see [[Action.new]]
 *
 **/
function ActionSubparsers(options) {
  options = options || {};
  options.dest = options.dest || c.SUPPRESS;
  options.nargs = c.PARSER;

  this.debug = (options.debug === true);

  this._progPrefix = options.prog;
  this._parserClass = options.parserClass;
  this._nameParserMap = {};
  this._choicesActions = [];

  options.choices = this._nameParserMap;
  Action.call(this, options);
}

util.inherits(ActionSubparsers, Action);

/*:nodoc:*
 * ActionSubparsers#addParser(name, options) -> ArgumentParser
 * - name (string): sub-command name
 * - options (object): see [[ArgumentParser.new]]
 *
 *  Note:
 *  addParser supports an additional aliases option,
 *  which allows multiple strings to refer to the same subparser.
 *  This example, like svn, aliases co as a shorthand for checkout
 *
 **/
ActionSubparsers.prototype.addParser = function (name, options) {
  var parser;

  var self = this;

  options = options || {};

  options.debug = (this.debug === true);

  // set program from the existing prefix
  if (!options.prog) {
    options.prog = this._progPrefix + ' ' + name;
  }

  var aliases = options.aliases || [];

  // create a pseudo-action to hold the choice help
  if (!!options.help || typeof options.help === 'string') {
    var help = options.help;
    delete options.help;

    var choiceAction = new ChoicesPseudoAction(name, help);
    this._choicesActions.push(choiceAction);
  }

  // create the parser and add it to the map
  parser = new this._parserClass(options);
  this._nameParserMap[name] = parser;

  // make parser available under aliases also
  aliases.forEach(function (alias) {
    self._nameParserMap[alias] = parser;
  });

  return parser;
};

ActionSubparsers.prototype._getSubactions = function () {
  return this._choicesActions;
};

/*:nodoc:*
 * ActionSubparsers#call(parser, namespace, values, optionString) -> Void
 * - parser (ArgumentParser): current parser
 * - namespace (Namespace): namespace for output data
 * - values (Array): parsed values
 * - optionString (Array): input option string(not parsed)
 *
 * Call the action. Parse input aguments
 **/
ActionSubparsers.prototype.call = function (parser, namespace, values) {
  var parserName = values[0];
  var argStrings = values.slice(1);

  // set the parser name if requested
  if (this.dest !== c.SUPPRESS) {
    namespace[this.dest] = parserName;
  }

  // select the parser
  if (this._nameParserMap[parserName]) {
    parser = this._nameParserMap[parserName];
  } else {
    throw argumentErrorHelper(format(
      'Unknown parser "%s" (choices: [%s]).',
        parserName,
        Object.keys(this._nameParserMap).join(', ')
    ));
  }

  // parse all the remaining options into the namespace
  parser.parseArgs(argStrings, namespace);
};

module.exports = ActionSubparsers;


/***/ }),

/***/ 59182:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*:nodoc:*
 * class ActionVersion
 *
 * Support action for printing program version
 * This class inherited from [[Action]]
 **/


var util = __webpack_require__(31669);

var Action = __webpack_require__(60225);

//
// Constants
//
var c = __webpack_require__(87815);

/*:nodoc:*
 * new ActionVersion(options)
 * - options (object): options hash see [[Action.new]]
 *
 **/
var ActionVersion = module.exports = function ActionVersion(options) {
  options = options || {};
  options.defaultValue = (options.defaultValue ? options.defaultValue : c.SUPPRESS);
  options.dest = (options.dest || c.SUPPRESS);
  options.nargs = 0;
  this.version = options.version;
  Action.call(this, options);
};
util.inherits(ActionVersion, Action);

/*:nodoc:*
 * ActionVersion#call(parser, namespace, values, optionString) -> Void
 * - parser (ArgumentParser): current parser
 * - namespace (Namespace): namespace for output data
 * - values (Array): parsed values
 * - optionString (Array): input option string(not parsed)
 *
 * Print version and exit
 **/
ActionVersion.prototype.call = function (parser) {
  var version = this.version || parser.version;
  var formatter = parser._getFormatter();
  formatter.addText(version);
  parser.exit(0, formatter.formatHelp());
};


/***/ }),

/***/ 37556:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/** internal
 * class ActionContainer
 *
 * Action container. Parent for [[ArgumentParser]] and [[ArgumentGroup]]
 **/



var format = __webpack_require__(31669).format;

// Constants
var c = __webpack_require__(87815);

var $$ = __webpack_require__(40965);

//Actions
var ActionHelp = __webpack_require__(6600);
var ActionAppend = __webpack_require__(56052);
var ActionAppendConstant = __webpack_require__(92478);
var ActionCount = __webpack_require__(35543);
var ActionStore = __webpack_require__(17229);
var ActionStoreConstant = __webpack_require__(43741);
var ActionStoreTrue = __webpack_require__(99773);
var ActionStoreFalse = __webpack_require__(37656);
var ActionVersion = __webpack_require__(59182);
var ActionSubparsers = __webpack_require__(36809);

// Errors
var argumentErrorHelper = __webpack_require__(69435);

/**
 * new ActionContainer(options)
 *
 * Action container. Parent for [[ArgumentParser]] and [[ArgumentGroup]]
 *
 * ##### Options:
 *
 * - `description` -- A description of what the program does
 * - `prefixChars`  -- Characters that prefix optional arguments
 * - `argumentDefault`  -- The default value for all arguments
 * - `conflictHandler` -- The conflict handler to use for duplicate arguments
 **/
var ActionContainer = module.exports = function ActionContainer(options) {
  options = options || {};

  this.description = options.description;
  this.argumentDefault = options.argumentDefault;
  this.prefixChars = options.prefixChars || '';
  this.conflictHandler = options.conflictHandler;

  // set up registries
  this._registries = {};

  // register actions
  this.register('action', null, ActionStore);
  this.register('action', 'store', ActionStore);
  this.register('action', 'storeConst', ActionStoreConstant);
  this.register('action', 'storeTrue', ActionStoreTrue);
  this.register('action', 'storeFalse', ActionStoreFalse);
  this.register('action', 'append', ActionAppend);
  this.register('action', 'appendConst', ActionAppendConstant);
  this.register('action', 'count', ActionCount);
  this.register('action', 'help', ActionHelp);
  this.register('action', 'version', ActionVersion);
  this.register('action', 'parsers', ActionSubparsers);

  // raise an exception if the conflict handler is invalid
  this._getHandler();

  // action storage
  this._actions = [];
  this._optionStringActions = {};

  // groups
  this._actionGroups = [];
  this._mutuallyExclusiveGroups = [];

  // defaults storage
  this._defaults = {};

  // determines whether an "option" looks like a negative number
  // -1, -1.5 -5e+4
  this._regexpNegativeNumber = new RegExp('^[-]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$');

  // whether or not there are any optionals that look like negative
  // numbers -- uses a list so it can be shared and edited
  this._hasNegativeNumberOptionals = [];
};

// Groups must be required, then ActionContainer already defined
var ArgumentGroup = __webpack_require__(90413);
var MutuallyExclusiveGroup = __webpack_require__(32908);

//
// Registration methods
//

/**
 * ActionContainer#register(registryName, value, object) -> Void
 * - registryName (String) : object type action|type
 * - value (string) : keyword
 * - object (Object|Function) : handler
 *
 *  Register handlers
 **/
ActionContainer.prototype.register = function (registryName, value, object) {
  this._registries[registryName] = this._registries[registryName] || {};
  this._registries[registryName][value] = object;
};

ActionContainer.prototype._registryGet = function (registryName, value, defaultValue) {
  if (arguments.length < 3) {
    defaultValue = null;
  }
  return this._registries[registryName][value] || defaultValue;
};

//
// Namespace default accessor methods
//

/**
 * ActionContainer#setDefaults(options) -> Void
 * - options (object):hash of options see [[Action.new]]
 *
 * Set defaults
 **/
ActionContainer.prototype.setDefaults = function (options) {
  options = options || {};
  for (var property in options) {
    if ($$.has(options, property)) {
      this._defaults[property] = options[property];
    }
  }

  // if these defaults match any existing arguments, replace the previous
  // default on the object with the new one
  this._actions.forEach(function (action) {
    if ($$.has(options, action.dest)) {
      action.defaultValue = options[action.dest];
    }
  });
};

/**
 * ActionContainer#getDefault(dest) -> Mixed
 * - dest (string): action destination
 *
 * Return action default value
 **/
ActionContainer.prototype.getDefault = function (dest) {
  var result = $$.has(this._defaults, dest) ? this._defaults[dest] : null;

  this._actions.forEach(function (action) {
    if (action.dest === dest && $$.has(action, 'defaultValue')) {
      result = action.defaultValue;
    }
  });

  return result;
};
//
// Adding argument actions
//

/**
 * ActionContainer#addArgument(args, options) -> Object
 * - args (String|Array): argument key, or array of argument keys
 * - options (Object): action objects see [[Action.new]]
 *
 * #### Examples
 * - addArgument([ '-f', '--foo' ], { action: 'store', defaultValue: 1, ... })
 * - addArgument([ 'bar' ], { action: 'store', nargs: 1, ... })
 * - addArgument('--baz', { action: 'store', nargs: 1, ... })
 **/
ActionContainer.prototype.addArgument = function (args, options) {
  args = args;
  options = options || {};

  if (typeof args === 'string') {
    args = [ args ];
  }
  if (!Array.isArray(args)) {
    throw new TypeError('addArgument first argument should be a string or an array');
  }
  if (typeof options !== 'object' || Array.isArray(options)) {
    throw new TypeError('addArgument second argument should be a hash');
  }

  // if no positional args are supplied or only one is supplied and
  // it doesn't look like an option string, parse a positional argument
  if (!args || args.length === 1 && this.prefixChars.indexOf(args[0][0]) < 0) {
    if (args && !!options.dest) {
      throw new Error('dest supplied twice for positional argument');
    }
    options = this._getPositional(args, options);

    // otherwise, we're adding an optional argument
  } else {
    options = this._getOptional(args, options);
  }

  // if no default was supplied, use the parser-level default
  if (typeof options.defaultValue === 'undefined') {
    var dest = options.dest;
    if ($$.has(this._defaults, dest)) {
      options.defaultValue = this._defaults[dest];
    } else if (typeof this.argumentDefault !== 'undefined') {
      options.defaultValue = this.argumentDefault;
    }
  }

  // create the action object, and add it to the parser
  var ActionClass = this._popActionClass(options);
  if (typeof ActionClass !== 'function') {
    throw new Error(format('Unknown action "%s".', ActionClass));
  }
  var action = new ActionClass(options);

  // throw an error if the action type is not callable
  var typeFunction = this._registryGet('type', action.type, action.type);
  if (typeof typeFunction !== 'function') {
    throw new Error(format('"%s" is not callable', typeFunction));
  }

  return this._addAction(action);
};

/**
 * ActionContainer#addArgumentGroup(options) -> ArgumentGroup
 * - options (Object): hash of options see [[ArgumentGroup.new]]
 *
 * Create new arguments groups
 **/
ActionContainer.prototype.addArgumentGroup = function (options) {
  var group = new ArgumentGroup(this, options);
  this._actionGroups.push(group);
  return group;
};

/**
 * ActionContainer#addMutuallyExclusiveGroup(options) -> ArgumentGroup
 * - options (Object): {required: false}
 *
 * Create new mutual exclusive groups
 **/
ActionContainer.prototype.addMutuallyExclusiveGroup = function (options) {
  var group = new MutuallyExclusiveGroup(this, options);
  this._mutuallyExclusiveGroups.push(group);
  return group;
};

ActionContainer.prototype._addAction = function (action) {
  var self = this;

  // resolve any conflicts
  this._checkConflict(action);

  // add to actions list
  this._actions.push(action);
  action.container = this;

  // index the action by any option strings it has
  action.optionStrings.forEach(function (optionString) {
    self._optionStringActions[optionString] = action;
  });

  // set the flag if any option strings look like negative numbers
  action.optionStrings.forEach(function (optionString) {
    if (optionString.match(self._regexpNegativeNumber)) {
      if (!self._hasNegativeNumberOptionals.some(Boolean)) {
        self._hasNegativeNumberOptionals.push(true);
      }
    }
  });

  // return the created action
  return action;
};

ActionContainer.prototype._removeAction = function (action) {
  var actionIndex = this._actions.indexOf(action);
  if (actionIndex >= 0) {
    this._actions.splice(actionIndex, 1);
  }
};

ActionContainer.prototype._addContainerActions = function (container) {
  // collect groups by titles
  var titleGroupMap = {};
  this._actionGroups.forEach(function (group) {
    if (titleGroupMap[group.title]) {
      throw new Error(format('Cannot merge actions - two groups are named "%s".', group.title));
    }
    titleGroupMap[group.title] = group;
  });

  // map each action to its group
  var groupMap = {};
  function actionHash(action) {
    // unique (hopefully?) string suitable as dictionary key
    return action.getName();
  }
  container._actionGroups.forEach(function (group) {
    // if a group with the title exists, use that, otherwise
    // create a new group matching the container's group
    if (!titleGroupMap[group.title]) {
      titleGroupMap[group.title] = this.addArgumentGroup({
        title: group.title,
        description: group.description
      });
    }

    // map the actions to their new group
    group._groupActions.forEach(function (action) {
      groupMap[actionHash(action)] = titleGroupMap[group.title];
    });
  }, this);

  // add container's mutually exclusive groups
  // NOTE: if add_mutually_exclusive_group ever gains title= and
  // description= then this code will need to be expanded as above
  var mutexGroup;
  container._mutuallyExclusiveGroups.forEach(function (group) {
    mutexGroup = this.addMutuallyExclusiveGroup({
      required: group.required
    });
    // map the actions to their new mutex group
    group._groupActions.forEach(function (action) {
      groupMap[actionHash(action)] = mutexGroup;
    });
  }, this);  // forEach takes a 'this' argument

  // add all actions to this container or their group
  container._actions.forEach(function (action) {
    var key = actionHash(action);
    if (groupMap[key]) {
      groupMap[key]._addAction(action);
    } else {
      this._addAction(action);
    }
  });
};

ActionContainer.prototype._getPositional = function (dest, options) {
  if (Array.isArray(dest)) {
    dest = dest[0];
  }
  // make sure required is not specified
  if (options.required) {
    throw new Error('"required" is an invalid argument for positionals.');
  }

  // mark positional arguments as required if at least one is
  // always required
  if (options.nargs !== c.OPTIONAL && options.nargs !== c.ZERO_OR_MORE) {
    options.required = true;
  }
  if (options.nargs === c.ZERO_OR_MORE && typeof options.defaultValue === 'undefined') {
    options.required = true;
  }

  // return the keyword arguments with no option strings
  options.dest = dest;
  options.optionStrings = [];
  return options;
};

ActionContainer.prototype._getOptional = function (args, options) {
  var prefixChars = this.prefixChars;
  var optionStrings = [];
  var optionStringsLong = [];

  // determine short and long option strings
  args.forEach(function (optionString) {
    // error on strings that don't start with an appropriate prefix
    if (prefixChars.indexOf(optionString[0]) < 0) {
      throw new Error(format('Invalid option string "%s": must start with a "%s".',
        optionString,
        prefixChars
      ));
    }

    // strings starting with two prefix characters are long options
    optionStrings.push(optionString);
    if (optionString.length > 1 && prefixChars.indexOf(optionString[1]) >= 0) {
      optionStringsLong.push(optionString);
    }
  });

  // infer dest, '--foo-bar' -> 'foo_bar' and '-x' -> 'x'
  var dest = options.dest || null;
  delete options.dest;

  if (!dest) {
    var optionStringDest = optionStringsLong.length ? optionStringsLong[0] : optionStrings[0];
    dest = $$.trimChars(optionStringDest, this.prefixChars);

    if (dest.length === 0) {
      throw new Error(
        format('dest= is required for options like "%s"', optionStrings.join(', '))
      );
    }
    dest = dest.replace(/-/g, '_');
  }

  // return the updated keyword arguments
  options.dest = dest;
  options.optionStrings = optionStrings;

  return options;
};

ActionContainer.prototype._popActionClass = function (options, defaultValue) {
  defaultValue = defaultValue || null;

  var action = (options.action || defaultValue);
  delete options.action;

  var actionClass = this._registryGet('action', action, action);
  return actionClass;
};

ActionContainer.prototype._getHandler = function () {
  var handlerString = this.conflictHandler;
  var handlerFuncName = '_handleConflict' + $$.capitalize(handlerString);
  var func = this[handlerFuncName];
  if (typeof func === 'undefined') {
    var msg = 'invalid conflict resolution value: ' + handlerString;
    throw new Error(msg);
  } else {
    return func;
  }
};

ActionContainer.prototype._checkConflict = function (action) {
  var optionStringActions = this._optionStringActions;
  var conflictOptionals = [];

  // find all options that conflict with this option
  // collect pairs, the string, and an existing action that it conflicts with
  action.optionStrings.forEach(function (optionString) {
    var conflOptional = optionStringActions[optionString];
    if (typeof conflOptional !== 'undefined') {
      conflictOptionals.push([ optionString, conflOptional ]);
    }
  });

  if (conflictOptionals.length > 0) {
    var conflictHandler = this._getHandler();
    conflictHandler.call(this, action, conflictOptionals);
  }
};

ActionContainer.prototype._handleConflictError = function (action, conflOptionals) {
  var conflicts = conflOptionals.map(function (pair) { return pair[0]; });
  conflicts = conflicts.join(', ');
  throw argumentErrorHelper(
    action,
    format('Conflicting option string(s): %s', conflicts)
  );
};

ActionContainer.prototype._handleConflictResolve = function (action, conflOptionals) {
  // remove all conflicting options
  var self = this;
  conflOptionals.forEach(function (pair) {
    var optionString = pair[0];
    var conflictingAction = pair[1];
    // remove the conflicting option string
    var i = conflictingAction.optionStrings.indexOf(optionString);
    if (i >= 0) {
      conflictingAction.optionStrings.splice(i, 1);
    }
    delete self._optionStringActions[optionString];
    // if the option now has no option string, remove it from the
    // container holding it
    if (conflictingAction.optionStrings.length === 0) {
      conflictingAction.container._removeAction(conflictingAction);
    }
  });
};


/***/ }),

/***/ 7831:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports.ArgumentParser = __webpack_require__(97081);
module.exports.Namespace = __webpack_require__(89824);
module.exports.Action = __webpack_require__(60225);
module.exports.HelpFormatter = __webpack_require__(41829);
module.exports.Const = __webpack_require__(87815);

module.exports.ArgumentDefaultsHelpFormatter = __webpack_require__(11072).ArgumentDefaultsHelpFormatter;
module.exports.RawDescriptionHelpFormatter = __webpack_require__(11072).RawDescriptionHelpFormatter;
module.exports.RawTextHelpFormatter = __webpack_require__(11072).RawTextHelpFormatter;


/***/ }),

/***/ 69435:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



var format  = __webpack_require__(31669).format;


var ERR_CODE = 'ARGError';

/*:nodoc:*
 * argumentError(argument, message) -> TypeError
 * - argument (Object): action with broken argument
 * - message (String): error message
 *
 * Error format helper. An error from creating or using an argument
 * (optional or positional). The string value of this exception
 * is the message, augmented with information
 * about the argument that caused it.
 *
 * #####Example
 *
 *      var argumentErrorHelper = require('./argument/error');
 *      if (conflictOptionals.length > 0) {
 *        throw argumentErrorHelper(
 *          action,
 *          format('Conflicting option string(s): %s', conflictOptionals.join(', '))
 *        );
 *      }
 *
 **/
module.exports = function (argument, message) {
  var argumentName = null;
  var errMessage;
  var err;

  if (argument.getName) {
    argumentName = argument.getName();
  } else {
    argumentName = '' + argument;
  }

  if (!argumentName) {
    errMessage = message;
  } else {
    errMessage = format('argument "%s": %s', argumentName, message);
  }

  err = new TypeError(errMessage);
  err.code = ERR_CODE;
  return err;
};


/***/ }),

/***/ 32908:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/** internal
 * class MutuallyExclusiveGroup
 *
 * Group arguments.
 * By default, ArgumentParser groups command-line arguments
 * into positional arguments and optional arguments
 * when displaying help messages. When there is a better
 * conceptual grouping of arguments than this default one,
 * appropriate groups can be created using the addArgumentGroup() method
 *
 * This class inherited from [[ArgumentContainer]]
 **/


var util = __webpack_require__(31669);

var ArgumentGroup = __webpack_require__(90413);

/**
 * new MutuallyExclusiveGroup(container, options)
 * - container (object): main container
 * - options (object): options.required -> true/false
 *
 * `required` could be an argument itself, but making it a property of
 * the options argument is more consistent with the JS adaptation of the Python)
 **/
var MutuallyExclusiveGroup = module.exports = function MutuallyExclusiveGroup(container, options) {
  var required;
  options = options || {};
  required = options.required || false;
  ArgumentGroup.call(this, container);
  this.required = required;

};
util.inherits(MutuallyExclusiveGroup, ArgumentGroup);


MutuallyExclusiveGroup.prototype._addAction = function (action) {
  var msg;
  if (action.required) {
    msg = 'mutually exclusive arguments must be optional';
    throw new Error(msg);
  }
  action = this._container._addAction(action);
  this._groupActions.push(action);
  return action;
};


MutuallyExclusiveGroup.prototype._removeAction = function (action) {
  this._container._removeAction(action);
  this._groupActions.remove(action);
};



/***/ }),

/***/ 90413:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/** internal
 * class ArgumentGroup
 *
 * Group arguments.
 * By default, ArgumentParser groups command-line arguments
 * into positional arguments and optional arguments
 * when displaying help messages. When there is a better
 * conceptual grouping of arguments than this default one,
 * appropriate groups can be created using the addArgumentGroup() method
 *
 * This class inherited from [[ArgumentContainer]]
 **/


var util = __webpack_require__(31669);

var ActionContainer = __webpack_require__(37556);


/**
 * new ArgumentGroup(container, options)
 * - container (object): main container
 * - options (object): hash of group options
 *
 * #### options
 * - **prefixChars**  group name prefix
 * - **argumentDefault**  default argument value
 * - **title**  group title
 * - **description** group description
 *
 **/
var ArgumentGroup = module.exports = function ArgumentGroup(container, options) {

  options = options || {};

  // add any missing keyword arguments by checking the container
  options.conflictHandler = (options.conflictHandler || container.conflictHandler);
  options.prefixChars = (options.prefixChars || container.prefixChars);
  options.argumentDefault = (options.argumentDefault || container.argumentDefault);

  ActionContainer.call(this, options);

  // group attributes
  this.title = options.title;
  this._groupActions = [];

  // share most attributes with the container
  this._container = container;
  this._registries = container._registries;
  this._actions = container._actions;
  this._optionStringActions = container._optionStringActions;
  this._defaults = container._defaults;
  this._hasNegativeNumberOptionals = container._hasNegativeNumberOptionals;
  this._mutuallyExclusiveGroups = container._mutuallyExclusiveGroups;
};
util.inherits(ArgumentGroup, ActionContainer);


ArgumentGroup.prototype._addAction = function (action) {
  // Parent add action
  action = ActionContainer.prototype._addAction.call(this, action);
  this._groupActions.push(action);
  return action;
};


ArgumentGroup.prototype._removeAction = function (action) {
  // Parent remove action
  ActionContainer.prototype._removeAction.call(this, action);
  var actionIndex = this._groupActions.indexOf(action);
  if (actionIndex >= 0) {
    this._groupActions.splice(actionIndex, 1);
  }
};



/***/ }),

/***/ 97081:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * class ArgumentParser
 *
 * Object for parsing command line strings into js objects.
 *
 * Inherited from [[ActionContainer]]
 **/


var util    = __webpack_require__(31669);
var format  = __webpack_require__(31669).format;
var Path    = __webpack_require__(85622);
var sprintf = __webpack_require__(33988).sprintf;

// Constants
var c = __webpack_require__(87815);

var $$ = __webpack_require__(40965);

var ActionContainer = __webpack_require__(37556);

// Errors
var argumentErrorHelper = __webpack_require__(69435);

var HelpFormatter = __webpack_require__(41829);

var Namespace = __webpack_require__(89824);


/**
 * new ArgumentParser(options)
 *
 * Create a new ArgumentParser object.
 *
 * ##### Options:
 * - `prog`  The name of the program (default: Path.basename(process.argv[1]))
 * - `usage`  A usage message (default: auto-generated from arguments)
 * - `description`  A description of what the program does
 * - `epilog`  Text following the argument descriptions
 * - `parents`  Parsers whose arguments should be copied into this one
 * - `formatterClass`  HelpFormatter class for printing help messages
 * - `prefixChars`  Characters that prefix optional arguments
 * - `fromfilePrefixChars` Characters that prefix files containing additional arguments
 * - `argumentDefault`  The default value for all arguments
 * - `addHelp`  Add a -h/-help option
 * - `conflictHandler`  Specifies how to handle conflicting argument names
 * - `debug`  Enable debug mode. Argument errors throw exception in
 *   debug mode and process.exit in normal. Used for development and
 *   testing (default: false)
 *
 * See also [original guide][1]
 *
 * [1]:http://docs.python.org/dev/library/argparse.html#argumentparser-objects
 **/
function ArgumentParser(options) {
  if (!(this instanceof ArgumentParser)) {
    return new ArgumentParser(options);
  }
  var self = this;
  options = options || {};

  options.description = (options.description || null);
  options.argumentDefault = (options.argumentDefault || null);
  options.prefixChars = (options.prefixChars || '-');
  options.conflictHandler = (options.conflictHandler || 'error');
  ActionContainer.call(this, options);

  options.addHelp = typeof options.addHelp === 'undefined' || !!options.addHelp;
  options.parents = options.parents || [];
  // default program name
  options.prog = (options.prog || Path.basename(process.argv[1]));
  this.prog = options.prog;
  this.usage = options.usage;
  this.epilog = options.epilog;
  this.version = options.version;

  this.debug = (options.debug === true);

  this.formatterClass = (options.formatterClass || HelpFormatter);
  this.fromfilePrefixChars = options.fromfilePrefixChars || null;
  this._positionals = this.addArgumentGroup({ title: 'Positional arguments' });
  this._optionals = this.addArgumentGroup({ title: 'Optional arguments' });
  this._subparsers = null;

  // register types
  function FUNCTION_IDENTITY(o) {
    return o;
  }
  this.register('type', 'auto', FUNCTION_IDENTITY);
  this.register('type', null, FUNCTION_IDENTITY);
  this.register('type', 'int', function (x) {
    var result = parseInt(x, 10);
    if (isNaN(result)) {
      throw new Error(x + ' is not a valid integer.');
    }
    return result;
  });
  this.register('type', 'float', function (x) {
    var result = parseFloat(x);
    if (isNaN(result)) {
      throw new Error(x + ' is not a valid float.');
    }
    return result;
  });
  this.register('type', 'string', function (x) {
    return '' + x;
  });

  // add help and version arguments if necessary
  var defaultPrefix = (this.prefixChars.indexOf('-') > -1) ? '-' : this.prefixChars[0];
  if (options.addHelp) {
    this.addArgument(
      [ defaultPrefix + 'h', defaultPrefix + defaultPrefix + 'help' ],
      {
        action: 'help',
        defaultValue: c.SUPPRESS,
        help: 'Show this help message and exit.'
      }
    );
  }
  if (typeof this.version !== 'undefined') {
    this.addArgument(
      [ defaultPrefix + 'v', defaultPrefix + defaultPrefix + 'version' ],
      {
        action: 'version',
        version: this.version,
        defaultValue: c.SUPPRESS,
        help: "Show program's version number and exit."
      }
    );
  }

  // add parent arguments and defaults
  options.parents.forEach(function (parent) {
    self._addContainerActions(parent);
    if (typeof parent._defaults !== 'undefined') {
      for (var defaultKey in parent._defaults) {
        if (parent._defaults.hasOwnProperty(defaultKey)) {
          self._defaults[defaultKey] = parent._defaults[defaultKey];
        }
      }
    }
  });
}

util.inherits(ArgumentParser, ActionContainer);

/**
 * ArgumentParser#addSubparsers(options) -> [[ActionSubparsers]]
 * - options (object): hash of options see [[ActionSubparsers.new]]
 *
 * See also [subcommands][1]
 *
 * [1]:http://docs.python.org/dev/library/argparse.html#sub-commands
 **/
ArgumentParser.prototype.addSubparsers = function (options) {
  if (this._subparsers) {
    this.error('Cannot have multiple subparser arguments.');
  }

  options = options || {};
  options.debug = (this.debug === true);
  options.optionStrings = [];
  options.parserClass = (options.parserClass || ArgumentParser);


  if (!!options.title || !!options.description) {

    this._subparsers = this.addArgumentGroup({
      title: (options.title || 'subcommands'),
      description: options.description
    });
    delete options.title;
    delete options.description;

  } else {
    this._subparsers = this._positionals;
  }

  // prog defaults to the usage message of this parser, skipping
  // optional arguments and with no "usage:" prefix
  if (!options.prog) {
    var formatter = this._getFormatter();
    var positionals = this._getPositionalActions();
    var groups = this._mutuallyExclusiveGroups;
    formatter.addUsage(this.usage, positionals, groups, '');
    options.prog = formatter.formatHelp().trim();
  }

  // create the parsers action and add it to the positionals list
  var ParsersClass = this._popActionClass(options, 'parsers');
  var action = new ParsersClass(options);
  this._subparsers._addAction(action);

  // return the created parsers action
  return action;
};

ArgumentParser.prototype._addAction = function (action) {
  if (action.isOptional()) {
    this._optionals._addAction(action);
  } else {
    this._positionals._addAction(action);
  }
  return action;
};

ArgumentParser.prototype._getOptionalActions = function () {
  return this._actions.filter(function (action) {
    return action.isOptional();
  });
};

ArgumentParser.prototype._getPositionalActions = function () {
  return this._actions.filter(function (action) {
    return action.isPositional();
  });
};


/**
 * ArgumentParser#parseArgs(args, namespace) -> Namespace|Object
 * - args (array): input elements
 * - namespace (Namespace|Object): result object
 *
 * Parsed args and throws error if some arguments are not recognized
 *
 * See also [original guide][1]
 *
 * [1]:http://docs.python.org/dev/library/argparse.html#the-parse-args-method
 **/
ArgumentParser.prototype.parseArgs = function (args, namespace) {
  var argv;
  var result = this.parseKnownArgs(args, namespace);

  args = result[0];
  argv = result[1];
  if (argv && argv.length > 0) {
    this.error(
      format('Unrecognized arguments: %s.', argv.join(' '))
    );
  }
  return args;
};

/**
 * ArgumentParser#parseKnownArgs(args, namespace) -> array
 * - args (array): input options
 * - namespace (Namespace|Object): result object
 *
 * Parse known arguments and return tuple of result object
 * and unknown args
 *
 * See also [original guide][1]
 *
 * [1]:http://docs.python.org/dev/library/argparse.html#partial-parsing
 **/
ArgumentParser.prototype.parseKnownArgs = function (args, namespace) {
  var self = this;

  // args default to the system args
  args = args || process.argv.slice(2);

  // default Namespace built from parser defaults
  namespace = namespace || new Namespace();

  self._actions.forEach(function (action) {
    if (action.dest !== c.SUPPRESS) {
      if (!$$.has(namespace, action.dest)) {
        if (action.defaultValue !== c.SUPPRESS) {
          var defaultValue = action.defaultValue;
          if (typeof action.defaultValue === 'string') {
            defaultValue = self._getValue(action, defaultValue);
          }
          namespace[action.dest] = defaultValue;
        }
      }
    }
  });

  Object.keys(self._defaults).forEach(function (dest) {
    namespace[dest] = self._defaults[dest];
  });

  // parse the arguments and exit if there are any errors
  try {
    var res = this._parseKnownArgs(args, namespace);

    namespace = res[0];
    args = res[1];
    if ($$.has(namespace, c._UNRECOGNIZED_ARGS_ATTR)) {
      args = $$.arrayUnion(args, namespace[c._UNRECOGNIZED_ARGS_ATTR]);
      delete namespace[c._UNRECOGNIZED_ARGS_ATTR];
    }
    return [ namespace, args ];
  } catch (e) {
    this.error(e);
  }
};

ArgumentParser.prototype._parseKnownArgs = function (argStrings, namespace) {
  var self = this;

  var extras = [];

  // replace arg strings that are file references
  if (this.fromfilePrefixChars !== null) {
    argStrings = this._readArgsFromFiles(argStrings);
  }
  // map all mutually exclusive arguments to the other arguments
  // they can't occur with
  // Python has 'conflicts = action_conflicts.setdefault(mutex_action, [])'
  // though I can't conceive of a way in which an action could be a member
  // of two different mutually exclusive groups.

  function actionHash(action) {
    // some sort of hashable key for this action
    // action itself cannot be a key in actionConflicts
    // I think getName() (join of optionStrings) is unique enough
    return action.getName();
  }

  var conflicts, key;
  var actionConflicts = {};

  this._mutuallyExclusiveGroups.forEach(function (mutexGroup) {
    mutexGroup._groupActions.forEach(function (mutexAction, i, groupActions) {
      key = actionHash(mutexAction);
      if (!$$.has(actionConflicts, key)) {
        actionConflicts[key] = [];
      }
      conflicts = actionConflicts[key];
      conflicts.push.apply(conflicts, groupActions.slice(0, i));
      conflicts.push.apply(conflicts, groupActions.slice(i + 1));
    });
  });

  // find all option indices, and determine the arg_string_pattern
  // which has an 'O' if there is an option at an index,
  // an 'A' if there is an argument, or a '-' if there is a '--'
  var optionStringIndices = {};

  var argStringPatternParts = [];

  argStrings.forEach(function (argString, argStringIndex) {
    if (argString === '--') {
      argStringPatternParts.push('-');
      while (argStringIndex < argStrings.length) {
        argStringPatternParts.push('A');
        argStringIndex++;
      }
    } else {
      // otherwise, add the arg to the arg strings
      // and note the index if it was an option
      var pattern;
      var optionTuple = self._parseOptional(argString);
      if (!optionTuple) {
        pattern = 'A';
      } else {
        optionStringIndices[argStringIndex] = optionTuple;
        pattern = 'O';
      }
      argStringPatternParts.push(pattern);
    }
  });
  var argStringsPattern = argStringPatternParts.join('');

  var seenActions = [];
  var seenNonDefaultActions = [];


  function takeAction(action, argumentStrings, optionString) {
    seenActions.push(action);
    var argumentValues = self._getValues(action, argumentStrings);

    // error if this argument is not allowed with other previously
    // seen arguments, assuming that actions that use the default
    // value don't really count as "present"
    if (argumentValues !== action.defaultValue) {
      seenNonDefaultActions.push(action);
      if (actionConflicts[actionHash(action)]) {
        actionConflicts[actionHash(action)].forEach(function (actionConflict) {
          if (seenNonDefaultActions.indexOf(actionConflict) >= 0) {
            throw argumentErrorHelper(
              action,
              format('Not allowed with argument "%s".', actionConflict.getName())
            );
          }
        });
      }
    }

    if (argumentValues !== c.SUPPRESS) {
      action.call(self, namespace, argumentValues, optionString);
    }
  }

  function consumeOptional(startIndex) {
    // get the optional identified at this index
    var optionTuple = optionStringIndices[startIndex];
    var action = optionTuple[0];
    var optionString = optionTuple[1];
    var explicitArg = optionTuple[2];

    // identify additional optionals in the same arg string
    // (e.g. -xyz is the same as -x -y -z if no args are required)
    var actionTuples = [];

    var args, argCount, start, stop;

    for (;;) {
      if (!action) {
        extras.push(argStrings[startIndex]);
        return startIndex + 1;
      }
      if (explicitArg) {
        argCount = self._matchArgument(action, 'A');

        // if the action is a single-dash option and takes no
        // arguments, try to parse more single-dash options out
        // of the tail of the option string
        var chars = self.prefixChars;
        if (argCount === 0 && chars.indexOf(optionString[1]) < 0) {
          actionTuples.push([ action, [], optionString ]);
          optionString = optionString[0] + explicitArg[0];
          var newExplicitArg = explicitArg.slice(1) || null;
          var optionalsMap = self._optionStringActions;

          if (Object.keys(optionalsMap).indexOf(optionString) >= 0) {
            action = optionalsMap[optionString];
            explicitArg = newExplicitArg;
          } else {
            throw argumentErrorHelper(action, sprintf('ignored explicit argument %r', explicitArg));
          }
        } else if (argCount === 1) {
          // if the action expect exactly one argument, we've
          // successfully matched the option; exit the loop
          stop = startIndex + 1;
          args = [ explicitArg ];
          actionTuples.push([ action, args, optionString ]);
          break;
        } else {
          // error if a double-dash option did not use the
          // explicit argument
          throw argumentErrorHelper(action, sprintf('ignored explicit argument %r', explicitArg));
        }
      } else {
        // if there is no explicit argument, try to match the
        // optional's string arguments with the following strings
        // if successful, exit the loop

        start = startIndex + 1;
        var selectedPatterns = argStringsPattern.substr(start);

        argCount = self._matchArgument(action, selectedPatterns);
        stop = start + argCount;


        args = argStrings.slice(start, stop);

        actionTuples.push([ action, args, optionString ]);
        break;
      }

    }

    // add the Optional to the list and return the index at which
    // the Optional's string args stopped
    if (actionTuples.length < 1) {
      throw new Error('length should be > 0');
    }
    for (var i = 0; i < actionTuples.length; i++) {
      takeAction.apply(self, actionTuples[i]);
    }
    return stop;
  }

  // the list of Positionals left to be parsed; this is modified
  // by consume_positionals()
  var positionals = self._getPositionalActions();

  function consumePositionals(startIndex) {
    // match as many Positionals as possible
    var selectedPattern = argStringsPattern.substr(startIndex);
    var argCounts = self._matchArgumentsPartial(positionals, selectedPattern);

    // slice off the appropriate arg strings for each Positional
    // and add the Positional and its args to the list
    for (var i = 0; i < positionals.length; i++) {
      var action = positionals[i];
      var argCount = argCounts[i];
      if (typeof argCount === 'undefined') {
        continue;
      }
      var args = argStrings.slice(startIndex, startIndex + argCount);

      startIndex += argCount;
      takeAction(action, args);
    }

    // slice off the Positionals that we just parsed and return the
    // index at which the Positionals' string args stopped
    positionals = positionals.slice(argCounts.length);
    return startIndex;
  }

  // consume Positionals and Optionals alternately, until we have
  // passed the last option string
  var startIndex = 0;
  var position;

  var maxOptionStringIndex = -1;

  Object.keys(optionStringIndices).forEach(function (position) {
    maxOptionStringIndex = Math.max(maxOptionStringIndex, parseInt(position, 10));
  });

  var positionalsEndIndex, nextOptionStringIndex;

  while (startIndex <= maxOptionStringIndex) {
    // consume any Positionals preceding the next option
    nextOptionStringIndex = null;
    for (position in optionStringIndices) {
      if (!optionStringIndices.hasOwnProperty(position)) { continue; }

      position = parseInt(position, 10);
      if (position >= startIndex) {
        if (nextOptionStringIndex !== null) {
          nextOptionStringIndex = Math.min(nextOptionStringIndex, position);
        } else {
          nextOptionStringIndex = position;
        }
      }
    }

    if (startIndex !== nextOptionStringIndex) {
      positionalsEndIndex = consumePositionals(startIndex);
      // only try to parse the next optional if we didn't consume
      // the option string during the positionals parsing
      if (positionalsEndIndex > startIndex) {
        startIndex = positionalsEndIndex;
        continue;
      } else {
        startIndex = positionalsEndIndex;
      }
    }

    // if we consumed all the positionals we could and we're not
    // at the index of an option string, there were extra arguments
    if (!optionStringIndices[startIndex]) {
      var strings = argStrings.slice(startIndex, nextOptionStringIndex);
      extras = extras.concat(strings);
      startIndex = nextOptionStringIndex;
    }
    // consume the next optional and any arguments for it
    startIndex = consumeOptional(startIndex);
  }

  // consume any positionals following the last Optional
  var stopIndex = consumePositionals(startIndex);

  // if we didn't consume all the argument strings, there were extras
  extras = extras.concat(argStrings.slice(stopIndex));

  // if we didn't use all the Positional objects, there were too few
  // arg strings supplied.
  if (positionals.length > 0) {
    self.error('too few arguments');
  }

  // make sure all required actions were present
  self._actions.forEach(function (action) {
    if (action.required) {
      if (seenActions.indexOf(action) < 0) {
        self.error(format('Argument "%s" is required', action.getName()));
      }
    }
  });

  // make sure all required groups have one option present
  var actionUsed = false;
  self._mutuallyExclusiveGroups.forEach(function (group) {
    if (group.required) {
      actionUsed = group._groupActions.some(function (action) {
        return seenNonDefaultActions.indexOf(action) !== -1;
      });

      // if no actions were used, report the error
      if (!actionUsed) {
        var names = [];
        group._groupActions.forEach(function (action) {
          if (action.help !== c.SUPPRESS) {
            names.push(action.getName());
          }
        });
        names = names.join(' ');
        var msg = 'one of the arguments ' + names + ' is required';
        self.error(msg);
      }
    }
  });

  // return the updated namespace and the extra arguments
  return [ namespace, extras ];
};

ArgumentParser.prototype._readArgsFromFiles = function (argStrings) {
  // expand arguments referencing files
  var self = this;
  var fs = __webpack_require__(35747);
  var newArgStrings = [];
  argStrings.forEach(function (argString) {
    if (self.fromfilePrefixChars.indexOf(argString[0]) < 0) {
      // for regular arguments, just add them back into the list
      newArgStrings.push(argString);
    } else {
      // replace arguments referencing files with the file content
      try {
        var argstrs = [];
        var filename = argString.slice(1);
        var content = fs.readFileSync(filename, 'utf8');
        content = content.trim().split('\n');
        content.forEach(function (argLine) {
          self.convertArgLineToArgs(argLine).forEach(function (arg) {
            argstrs.push(arg);
          });
          argstrs = self._readArgsFromFiles(argstrs);
        });
        newArgStrings.push.apply(newArgStrings, argstrs);
      } catch (error) {
        return self.error(error.message);
      }
    }
  });
  return newArgStrings;
};

ArgumentParser.prototype.convertArgLineToArgs = function (argLine) {
  return [ argLine ];
};

ArgumentParser.prototype._matchArgument = function (action, regexpArgStrings) {

  // match the pattern for this action to the arg strings
  var regexpNargs = new RegExp('^' + this._getNargsPattern(action));
  var matches = regexpArgStrings.match(regexpNargs);
  var message;

  // throw an exception if we weren't able to find a match
  if (!matches) {
    switch (action.nargs) {
      /*eslint-disable no-undefined*/
      case undefined:
      case null:
        message = 'Expected one argument.';
        break;
      case c.OPTIONAL:
        message = 'Expected at most one argument.';
        break;
      case c.ONE_OR_MORE:
        message = 'Expected at least one argument.';
        break;
      default:
        message = 'Expected %s argument(s)';
    }

    throw argumentErrorHelper(
      action,
      format(message, action.nargs)
    );
  }
  // return the number of arguments matched
  return matches[1].length;
};

ArgumentParser.prototype._matchArgumentsPartial = function (actions, regexpArgStrings) {
  // progressively shorten the actions list by slicing off the
  // final actions until we find a match
  var self = this;
  var result = [];
  var actionSlice, pattern, matches;
  var i, j;

  function getLength(string) {
    return string.length;
  }

  for (i = actions.length; i > 0; i--) {
    pattern = '';
    actionSlice = actions.slice(0, i);
    for (j = 0; j < actionSlice.length; j++) {
      pattern += self._getNargsPattern(actionSlice[j]);
    }

    pattern = new RegExp('^' + pattern);
    matches = regexpArgStrings.match(pattern);

    if (matches && matches.length > 0) {
      // need only groups
      matches = matches.splice(1);
      result = result.concat(matches.map(getLength));
      break;
    }
  }

  // return the list of arg string counts
  return result;
};

ArgumentParser.prototype._parseOptional = function (argString) {
  var action, optionString, argExplicit, optionTuples;

  // if it's an empty string, it was meant to be a positional
  if (!argString) {
    return null;
  }

  // if it doesn't start with a prefix, it was meant to be positional
  if (this.prefixChars.indexOf(argString[0]) < 0) {
    return null;
  }

  // if the option string is present in the parser, return the action
  if (this._optionStringActions[argString]) {
    return [ this._optionStringActions[argString], argString, null ];
  }

  // if it's just a single character, it was meant to be positional
  if (argString.length === 1) {
    return null;
  }

  // if the option string before the "=" is present, return the action
  if (argString.indexOf('=') >= 0) {
    optionString = argString.split('=', 1)[0];
    argExplicit = argString.slice(optionString.length + 1);

    if (this._optionStringActions[optionString]) {
      action = this._optionStringActions[optionString];
      return [ action, optionString, argExplicit ];
    }
  }

  // search through all possible prefixes of the option string
  // and all actions in the parser for possible interpretations
  optionTuples = this._getOptionTuples(argString);

  // if multiple actions match, the option string was ambiguous
  if (optionTuples.length > 1) {
    var optionStrings = optionTuples.map(function (optionTuple) {
      return optionTuple[1];
    });
    this.error(format(
          'Ambiguous option: "%s" could match %s.',
          argString, optionStrings.join(', ')
    ));
  // if exactly one action matched, this segmentation is good,
  // so return the parsed action
  } else if (optionTuples.length === 1) {
    return optionTuples[0];
  }

  // if it was not found as an option, but it looks like a negative
  // number, it was meant to be positional
  // unless there are negative-number-like options
  if (argString.match(this._regexpNegativeNumber)) {
    if (!this._hasNegativeNumberOptionals.some(Boolean)) {
      return null;
    }
  }
  // if it contains a space, it was meant to be a positional
  if (argString.search(' ') >= 0) {
    return null;
  }

  // it was meant to be an optional but there is no such option
  // in this parser (though it might be a valid option in a subparser)
  return [ null, argString, null ];
};

ArgumentParser.prototype._getOptionTuples = function (optionString) {
  var result = [];
  var chars = this.prefixChars;
  var optionPrefix;
  var argExplicit;
  var action;
  var actionOptionString;

  // option strings starting with two prefix characters are only split at
  // the '='
  if (chars.indexOf(optionString[0]) >= 0 && chars.indexOf(optionString[1]) >= 0) {
    if (optionString.indexOf('=') >= 0) {
      var optionStringSplit = optionString.split('=', 1);

      optionPrefix = optionStringSplit[0];
      argExplicit = optionStringSplit[1];
    } else {
      optionPrefix = optionString;
      argExplicit = null;
    }

    for (actionOptionString in this._optionStringActions) {
      if (actionOptionString.substr(0, optionPrefix.length) === optionPrefix) {
        action = this._optionStringActions[actionOptionString];
        result.push([ action, actionOptionString, argExplicit ]);
      }
    }

  // single character options can be concatenated with their arguments
  // but multiple character options always have to have their argument
  // separate
  } else if (chars.indexOf(optionString[0]) >= 0 && chars.indexOf(optionString[1]) < 0) {
    optionPrefix = optionString;
    argExplicit = null;
    var optionPrefixShort = optionString.substr(0, 2);
    var argExplicitShort = optionString.substr(2);

    for (actionOptionString in this._optionStringActions) {
      if (!$$.has(this._optionStringActions, actionOptionString)) continue;

      action = this._optionStringActions[actionOptionString];
      if (actionOptionString === optionPrefixShort) {
        result.push([ action, actionOptionString, argExplicitShort ]);
      } else if (actionOptionString.substr(0, optionPrefix.length) === optionPrefix) {
        result.push([ action, actionOptionString, argExplicit ]);
      }
    }

  // shouldn't ever get here
  } else {
    throw new Error(format('Unexpected option string: %s.', optionString));
  }
  // return the collected option tuples
  return result;
};

ArgumentParser.prototype._getNargsPattern = function (action) {
  // in all examples below, we have to allow for '--' args
  // which are represented as '-' in the pattern
  var regexpNargs;

  switch (action.nargs) {
    // the default (null) is assumed to be a single argument
    case undefined:
    case null:
      regexpNargs = '(-*A-*)';
      break;
    // allow zero or more arguments
    case c.OPTIONAL:
      regexpNargs = '(-*A?-*)';
      break;
    // allow zero or more arguments
    case c.ZERO_OR_MORE:
      regexpNargs = '(-*[A-]*)';
      break;
    // allow one or more arguments
    case c.ONE_OR_MORE:
      regexpNargs = '(-*A[A-]*)';
      break;
    // allow any number of options or arguments
    case c.REMAINDER:
      regexpNargs = '([-AO]*)';
      break;
    // allow one argument followed by any number of options or arguments
    case c.PARSER:
      regexpNargs = '(-*A[-AO]*)';
      break;
    // all others should be integers
    default:
      regexpNargs = '(-*' + $$.repeat('-*A', action.nargs) + '-*)';
  }

  // if this is an optional action, -- is not allowed
  if (action.isOptional()) {
    regexpNargs = regexpNargs.replace(/-\*/g, '');
    regexpNargs = regexpNargs.replace(/-/g, '');
  }

  // return the pattern
  return regexpNargs;
};

//
// Value conversion methods
//

ArgumentParser.prototype._getValues = function (action, argStrings) {
  var self = this;

  // for everything but PARSER args, strip out '--'
  if (action.nargs !== c.PARSER && action.nargs !== c.REMAINDER) {
    argStrings = argStrings.filter(function (arrayElement) {
      return arrayElement !== '--';
    });
  }

  var value, argString;

  // optional argument produces a default when not present
  if (argStrings.length === 0 && action.nargs === c.OPTIONAL) {

    value = (action.isOptional()) ? action.constant : action.defaultValue;

    if (typeof (value) === 'string') {
      value = this._getValue(action, value);
      this._checkValue(action, value);
    }

  // when nargs='*' on a positional, if there were no command-line
  // args, use the default if it is anything other than None
  } else if (argStrings.length === 0 && action.nargs === c.ZERO_OR_MORE &&
    action.optionStrings.length === 0) {

    value = (action.defaultValue || argStrings);
    this._checkValue(action, value);

  // single argument or optional argument produces a single value
  } else if (argStrings.length === 1 &&
        (!action.nargs || action.nargs === c.OPTIONAL)) {

    argString = argStrings[0];
    value = this._getValue(action, argString);
    this._checkValue(action, value);

  // REMAINDER arguments convert all values, checking none
  } else if (action.nargs === c.REMAINDER) {
    value = argStrings.map(function (v) {
      return self._getValue(action, v);
    });

  // PARSER arguments convert all values, but check only the first
  } else if (action.nargs === c.PARSER) {
    value = argStrings.map(function (v) {
      return self._getValue(action, v);
    });
    this._checkValue(action, value[0]);

  // all other types of nargs produce a list
  } else {
    value = argStrings.map(function (v) {
      return self._getValue(action, v);
    });
    value.forEach(function (v) {
      self._checkValue(action, v);
    });
  }

  // return the converted value
  return value;
};

ArgumentParser.prototype._getValue = function (action, argString) {
  var result;

  var typeFunction = this._registryGet('type', action.type, action.type);
  if (typeof typeFunction !== 'function') {
    var message = format('%s is not callable', typeFunction);
    throw argumentErrorHelper(action, message);
  }

  // convert the value to the appropriate type
  try {
    result = typeFunction(argString);

    // ArgumentTypeErrors indicate errors
    // If action.type is not a registered string, it is a function
    // Try to deduce its name for inclusion in the error message
    // Failing that, include the error message it raised.
  } catch (e) {
    var name = null;
    if (typeof action.type === 'string') {
      name = action.type;
    } else {
      name = action.type.name || action.type.displayName || '<function>';
    }
    var msg = format('Invalid %s value: %s', name, argString);
    if (name === '<function>') { msg += '\n' + e.message; }
    throw argumentErrorHelper(action, msg);
  }
  // return the converted value
  return result;
};

ArgumentParser.prototype._checkValue = function (action, value) {
  // converted value must be one of the choices (if specified)
  var choices = action.choices;
  if (choices) {
    // choise for argument can by array or string
    if ((typeof choices === 'string' || Array.isArray(choices)) &&
        choices.indexOf(value) !== -1) {
      return;
    }
    // choise for subparsers can by only hash
    if (typeof choices === 'object' && !Array.isArray(choices) && choices[value]) {
      return;
    }

    if (typeof choices === 'string') {
      choices = choices.split('').join(', ');
    } else if (Array.isArray(choices)) {
      choices =  choices.join(', ');
    } else {
      choices =  Object.keys(choices).join(', ');
    }
    var message = format('Invalid choice: %s (choose from [%s])', value, choices);
    throw argumentErrorHelper(action, message);
  }
};

//
// Help formatting methods
//

/**
 * ArgumentParser#formatUsage -> string
 *
 * Return usage string
 *
 * See also [original guide][1]
 *
 * [1]:http://docs.python.org/dev/library/argparse.html#printing-help
 **/
ArgumentParser.prototype.formatUsage = function () {
  var formatter = this._getFormatter();
  formatter.addUsage(this.usage, this._actions, this._mutuallyExclusiveGroups);
  return formatter.formatHelp();
};

/**
 * ArgumentParser#formatHelp -> string
 *
 * Return help
 *
 * See also [original guide][1]
 *
 * [1]:http://docs.python.org/dev/library/argparse.html#printing-help
 **/
ArgumentParser.prototype.formatHelp = function () {
  var formatter = this._getFormatter();

  // usage
  formatter.addUsage(this.usage, this._actions, this._mutuallyExclusiveGroups);

  // description
  formatter.addText(this.description);

  // positionals, optionals and user-defined groups
  this._actionGroups.forEach(function (actionGroup) {
    formatter.startSection(actionGroup.title);
    formatter.addText(actionGroup.description);
    formatter.addArguments(actionGroup._groupActions);
    formatter.endSection();
  });

  // epilog
  formatter.addText(this.epilog);

  // determine help from format above
  return formatter.formatHelp();
};

ArgumentParser.prototype._getFormatter = function () {
  var FormatterClass = this.formatterClass;
  var formatter = new FormatterClass({ prog: this.prog });
  return formatter;
};

//
//  Print functions
//

/**
 * ArgumentParser#printUsage() -> Void
 *
 * Print usage
 *
 * See also [original guide][1]
 *
 * [1]:http://docs.python.org/dev/library/argparse.html#printing-help
 **/
ArgumentParser.prototype.printUsage = function () {
  this._printMessage(this.formatUsage());
};

/**
 * ArgumentParser#printHelp() -> Void
 *
 * Print help
 *
 * See also [original guide][1]
 *
 * [1]:http://docs.python.org/dev/library/argparse.html#printing-help
 **/
ArgumentParser.prototype.printHelp = function () {
  this._printMessage(this.formatHelp());
};

ArgumentParser.prototype._printMessage = function (message, stream) {
  if (!stream) {
    stream = process.stdout;
  }
  if (message) {
    stream.write('' + message);
  }
};

//
//  Exit functions
//

/**
 * ArgumentParser#exit(status=0, message) -> Void
 * - status (int): exit status
 * - message (string): message
 *
 * Print message in stderr/stdout and exit program
 **/
ArgumentParser.prototype.exit = function (status, message) {
  if (message) {
    if (status === 0) {
      this._printMessage(message);
    } else {
      this._printMessage(message, process.stderr);
    }
  }

  process.exit(status);
};

/**
 * ArgumentParser#error(message) -> Void
 * - err (Error|string): message
 *
 * Error method Prints a usage message incorporating the message to stderr and
 * exits. If you override this in a subclass,
 * it should not return -- it should
 * either exit or throw an exception.
 *
 **/
ArgumentParser.prototype.error = function (err) {
  var message;
  if (err instanceof Error) {
    if (this.debug === true) {
      throw err;
    }
    message = err.message;
  } else {
    message = err;
  }
  var msg = format('%s: error: %s', this.prog, message) + c.EOL;

  if (this.debug === true) {
    throw new Error(msg);
  }

  this.printUsage(process.stderr);

  return this.exit(2, msg);
};

module.exports = ArgumentParser;


/***/ }),

/***/ 87815:
/***/ ((module) => {

"use strict";
//
// Constants
//



module.exports.EOL = '\n';

module.exports.SUPPRESS = '==SUPPRESS==';

module.exports.OPTIONAL = '?';

module.exports.ZERO_OR_MORE = '*';

module.exports.ONE_OR_MORE = '+';

module.exports.PARSER = 'A...';

module.exports.REMAINDER = '...';

module.exports._UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args';


/***/ }),

/***/ 11072:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var util    = __webpack_require__(31669);

// Constants
var c = __webpack_require__(87815);

var $$ = __webpack_require__(40965);
var HelpFormatter = __webpack_require__(41829);

/**
 * new RawDescriptionHelpFormatter(options)
 * new ArgumentParser({formatterClass: argparse.RawDescriptionHelpFormatter, ...})
 *
 * Help message formatter which adds default values to argument help.
 *
 * Only the name of this class is considered a public API. All the methods
 * provided by the class are considered an implementation detail.
 **/

function ArgumentDefaultsHelpFormatter(options) {
  HelpFormatter.call(this, options);
}

util.inherits(ArgumentDefaultsHelpFormatter, HelpFormatter);

ArgumentDefaultsHelpFormatter.prototype._getHelpString = function (action) {
  var help = action.help;
  if (action.help.indexOf('%(defaultValue)s') === -1) {
    if (action.defaultValue !== c.SUPPRESS) {
      var defaulting_nargs = [ c.OPTIONAL, c.ZERO_OR_MORE ];
      if (action.isOptional() || (defaulting_nargs.indexOf(action.nargs) >= 0)) {
        help += ' (default: %(defaultValue)s)';
      }
    }
  }
  return help;
};

module.exports.ArgumentDefaultsHelpFormatter = ArgumentDefaultsHelpFormatter;

/**
 * new RawDescriptionHelpFormatter(options)
 * new ArgumentParser({formatterClass: argparse.RawDescriptionHelpFormatter, ...})
 *
 * Help message formatter which retains any formatting in descriptions.
 *
 * Only the name of this class is considered a public API. All the methods
 * provided by the class are considered an implementation detail.
 **/

function RawDescriptionHelpFormatter(options) {
  HelpFormatter.call(this, options);
}

util.inherits(RawDescriptionHelpFormatter, HelpFormatter);

RawDescriptionHelpFormatter.prototype._fillText = function (text, width, indent) {
  var lines = text.split('\n');
  lines = lines.map(function (line) {
    return $$.trimEnd(indent + line);
  });
  return lines.join('\n');
};
module.exports.RawDescriptionHelpFormatter = RawDescriptionHelpFormatter;

/**
 * new RawTextHelpFormatter(options)
 * new ArgumentParser({formatterClass: argparse.RawTextHelpFormatter, ...})
 *
 * Help message formatter which retains formatting of all help text.
 *
 * Only the name of this class is considered a public API. All the methods
 * provided by the class are considered an implementation detail.
 **/

function RawTextHelpFormatter(options) {
  RawDescriptionHelpFormatter.call(this, options);
}

util.inherits(RawTextHelpFormatter, RawDescriptionHelpFormatter);

RawTextHelpFormatter.prototype._splitLines = function (text) {
  return text.split('\n');
};

module.exports.RawTextHelpFormatter = RawTextHelpFormatter;


/***/ }),

/***/ 41829:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * class HelpFormatter
 *
 * Formatter for generating usage messages and argument help strings. Only the
 * name of this class is considered a public API. All the methods provided by
 * the class are considered an implementation detail.
 *
 * Do not call in your code, use this class only for inherits your own forvatter
 *
 * ToDo add [additonal formatters][1]
 *
 * [1]:http://docs.python.org/dev/library/argparse.html#formatter-class
 **/


var sprintf = __webpack_require__(33988).sprintf;

// Constants
var c = __webpack_require__(87815);

var $$ = __webpack_require__(40965);


/*:nodoc:* internal
 * new Support(parent, heding)
 * - parent (object): parent section
 * - heading (string): header string
 *
 **/
function Section(parent, heading) {
  this._parent = parent;
  this._heading = heading;
  this._items = [];
}

/*:nodoc:* internal
 * Section#addItem(callback) -> Void
 * - callback (array): tuple with function and args
 *
 * Add function for single element
 **/
Section.prototype.addItem = function (callback) {
  this._items.push(callback);
};

/*:nodoc:* internal
 * Section#formatHelp(formatter) -> string
 * - formatter (HelpFormatter): current formatter
 *
 * Form help section string
 *
 **/
Section.prototype.formatHelp = function (formatter) {
  var itemHelp, heading;

  // format the indented section
  if (this._parent) {
    formatter._indent();
  }

  itemHelp = this._items.map(function (item) {
    var obj, func, args;

    obj = formatter;
    func = item[0];
    args = item[1];
    return func.apply(obj, args);
  });
  itemHelp = formatter._joinParts(itemHelp);

  if (this._parent) {
    formatter._dedent();
  }

  // return nothing if the section was empty
  if (!itemHelp) {
    return '';
  }

  // add the heading if the section was non-empty
  heading = '';
  if (this._heading && this._heading !== c.SUPPRESS) {
    var currentIndent = formatter.currentIndent;
    heading = $$.repeat(' ', currentIndent) + this._heading + ':' + c.EOL;
  }

  // join the section-initialize newline, the heading and the help
  return formatter._joinParts([ c.EOL, heading, itemHelp, c.EOL ]);
};

/**
 * new HelpFormatter(options)
 *
 * #### Options:
 * - `prog`: program name
 * - `indentIncriment`: indent step, default value 2
 * - `maxHelpPosition`: max help position, default value = 24
 * - `width`: line width
 *
 **/
var HelpFormatter = module.exports = function HelpFormatter(options) {
  options = options || {};

  this._prog = options.prog;

  this._maxHelpPosition = options.maxHelpPosition || 24;
  this._width = (options.width || ((process.env.COLUMNS || 80) - 2));

  this._currentIndent = 0;
  this._indentIncriment = options.indentIncriment || 2;
  this._level = 0;
  this._actionMaxLength = 0;

  this._rootSection = new Section(null);
  this._currentSection = this._rootSection;

  this._whitespaceMatcher = new RegExp('\\s+', 'g');
  this._longBreakMatcher = new RegExp(c.EOL + c.EOL + c.EOL + '+', 'g');
};

HelpFormatter.prototype._indent = function () {
  this._currentIndent += this._indentIncriment;
  this._level += 1;
};

HelpFormatter.prototype._dedent = function () {
  this._currentIndent -= this._indentIncriment;
  this._level -= 1;
  if (this._currentIndent < 0) {
    throw new Error('Indent decreased below 0.');
  }
};

HelpFormatter.prototype._addItem = function (func, args) {
  this._currentSection.addItem([ func, args ]);
};

//
// Message building methods
//

/**
 * HelpFormatter#startSection(heading) -> Void
 * - heading (string): header string
 *
 * Start new help section
 *
 * See alse [code example][1]
 *
 * ##### Example
 *
 *      formatter.startSection(actionGroup.title);
 *      formatter.addText(actionGroup.description);
 *      formatter.addArguments(actionGroup._groupActions);
 *      formatter.endSection();
 *
 **/
HelpFormatter.prototype.startSection = function (heading) {
  this._indent();
  var section = new Section(this._currentSection, heading);
  var func = section.formatHelp.bind(section);
  this._addItem(func, [ this ]);
  this._currentSection = section;
};

/**
 * HelpFormatter#endSection -> Void
 *
 * End help section
 *
 * ##### Example
 *
 *      formatter.startSection(actionGroup.title);
 *      formatter.addText(actionGroup.description);
 *      formatter.addArguments(actionGroup._groupActions);
 *      formatter.endSection();
 **/
HelpFormatter.prototype.endSection = function () {
  this._currentSection = this._currentSection._parent;
  this._dedent();
};

/**
 * HelpFormatter#addText(text) -> Void
 * - text (string): plain text
 *
 * Add plain text into current section
 *
 * ##### Example
 *
 *      formatter.startSection(actionGroup.title);
 *      formatter.addText(actionGroup.description);
 *      formatter.addArguments(actionGroup._groupActions);
 *      formatter.endSection();
 *
 **/
HelpFormatter.prototype.addText = function (text) {
  if (text && text !== c.SUPPRESS) {
    this._addItem(this._formatText, [ text ]);
  }
};

/**
 * HelpFormatter#addUsage(usage, actions, groups, prefix) -> Void
 * - usage (string): usage text
 * - actions (array): actions list
 * - groups (array): groups list
 * - prefix (string): usage prefix
 *
 * Add usage data into current section
 *
 * ##### Example
 *
 *      formatter.addUsage(this.usage, this._actions, []);
 *      return formatter.formatHelp();
 *
 **/
HelpFormatter.prototype.addUsage = function (usage, actions, groups, prefix) {
  if (usage !== c.SUPPRESS) {
    this._addItem(this._formatUsage, [ usage, actions, groups, prefix ]);
  }
};

/**
 * HelpFormatter#addArgument(action) -> Void
 * - action (object): action
 *
 * Add argument into current section
 *
 * Single variant of [[HelpFormatter#addArguments]]
 **/
HelpFormatter.prototype.addArgument = function (action) {
  if (action.help !== c.SUPPRESS) {
    var self = this;

    // find all invocations
    var invocations = [ this._formatActionInvocation(action) ];
    var invocationLength = invocations[0].length;

    var actionLength;

    if (action._getSubactions) {
      this._indent();
      action._getSubactions().forEach(function (subaction) {

        var invocationNew = self._formatActionInvocation(subaction);
        invocations.push(invocationNew);
        invocationLength = Math.max(invocationLength, invocationNew.length);

      });
      this._dedent();
    }

    // update the maximum item length
    actionLength = invocationLength + this._currentIndent;
    this._actionMaxLength = Math.max(this._actionMaxLength, actionLength);

    // add the item to the list
    this._addItem(this._formatAction, [ action ]);
  }
};

/**
 * HelpFormatter#addArguments(actions) -> Void
 * - actions (array): actions list
 *
 * Mass add arguments into current section
 *
 * ##### Example
 *
 *      formatter.startSection(actionGroup.title);
 *      formatter.addText(actionGroup.description);
 *      formatter.addArguments(actionGroup._groupActions);
 *      formatter.endSection();
 *
 **/
HelpFormatter.prototype.addArguments = function (actions) {
  var self = this;
  actions.forEach(function (action) {
    self.addArgument(action);
  });
};

//
// Help-formatting methods
//

/**
 * HelpFormatter#formatHelp -> string
 *
 * Format help
 *
 * ##### Example
 *
 *      formatter.addText(this.epilog);
 *      return formatter.formatHelp();
 *
 **/
HelpFormatter.prototype.formatHelp = function () {
  var help = this._rootSection.formatHelp(this);
  if (help) {
    help = help.replace(this._longBreakMatcher, c.EOL + c.EOL);
    help = $$.trimChars(help, c.EOL) + c.EOL;
  }
  return help;
};

HelpFormatter.prototype._joinParts = function (partStrings) {
  return partStrings.filter(function (part) {
    return (part && part !== c.SUPPRESS);
  }).join('');
};

HelpFormatter.prototype._formatUsage = function (usage, actions, groups, prefix) {
  if (!prefix && typeof prefix !== 'string') {
    prefix = 'usage: ';
  }

  actions = actions || [];
  groups = groups || [];


  // if usage is specified, use that
  if (usage) {
    usage = sprintf(usage, { prog: this._prog });

    // if no optionals or positionals are available, usage is just prog
  } else if (!usage && actions.length === 0) {
    usage = this._prog;

    // if optionals and positionals are available, calculate usage
  } else if (!usage) {
    var prog = this._prog;
    var optionals = [];
    var positionals = [];
    var actionUsage;
    var textWidth;

    // split optionals from positionals
    actions.forEach(function (action) {
      if (action.isOptional()) {
        optionals.push(action);
      } else {
        positionals.push(action);
      }
    });

    // build full usage string
    actionUsage = this._formatActionsUsage([].concat(optionals, positionals), groups);
    usage = [ prog, actionUsage ].join(' ');

    // wrap the usage parts if it's too long
    textWidth = this._width - this._currentIndent;
    if ((prefix.length + usage.length) > textWidth) {

      // break usage into wrappable parts
      var regexpPart = new RegExp('\\(.*?\\)+|\\[.*?\\]+|\\S+', 'g');
      var optionalUsage = this._formatActionsUsage(optionals, groups);
      var positionalUsage = this._formatActionsUsage(positionals, groups);


      var optionalParts = optionalUsage.match(regexpPart);
      var positionalParts = positionalUsage.match(regexpPart) || [];

      if (optionalParts.join(' ') !== optionalUsage) {
        throw new Error('assert "optionalParts.join(\' \') === optionalUsage"');
      }
      if (positionalParts.join(' ') !== positionalUsage) {
        throw new Error('assert "positionalParts.join(\' \') === positionalUsage"');
      }

      // helper for wrapping lines
      /*eslint-disable func-style*/ // node 0.10 compat
      var _getLines = function (parts, indent, prefix) {
        var lines = [];
        var line = [];

        var lineLength = prefix ? prefix.length - 1 : indent.length - 1;

        parts.forEach(function (part) {
          if (lineLength + 1 + part.length > textWidth) {
            lines.push(indent + line.join(' '));
            line = [];
            lineLength = indent.length - 1;
          }
          line.push(part);
          lineLength += part.length + 1;
        });

        if (line) {
          lines.push(indent + line.join(' '));
        }
        if (prefix) {
          lines[0] = lines[0].substr(indent.length);
        }
        return lines;
      };

      var lines, indent, parts;
      // if prog is short, follow it with optionals or positionals
      if (prefix.length + prog.length <= 0.75 * textWidth) {
        indent = $$.repeat(' ', (prefix.length + prog.length + 1));
        if (optionalParts) {
          lines = [].concat(
            _getLines([ prog ].concat(optionalParts), indent, prefix),
            _getLines(positionalParts, indent)
          );
        } else if (positionalParts) {
          lines = _getLines([ prog ].concat(positionalParts), indent, prefix);
        } else {
          lines = [ prog ];
        }

        // if prog is long, put it on its own line
      } else {
        indent = $$.repeat(' ', prefix.length);
        parts = optionalParts.concat(positionalParts);
        lines = _getLines(parts, indent);
        if (lines.length > 1) {
          lines = [].concat(
            _getLines(optionalParts, indent),
            _getLines(positionalParts, indent)
          );
        }
        lines = [ prog ].concat(lines);
      }
      // join lines into usage
      usage = lines.join(c.EOL);
    }
  }

  // prefix with 'usage:'
  return prefix + usage + c.EOL + c.EOL;
};

HelpFormatter.prototype._formatActionsUsage = function (actions, groups) {
  // find group indices and identify actions in groups
  var groupActions = [];
  var inserts = [];
  var self = this;

  groups.forEach(function (group) {
    var end;
    var i;

    var start = actions.indexOf(group._groupActions[0]);
    if (start >= 0) {
      end = start + group._groupActions.length;

      //if (actions.slice(start, end) === group._groupActions) {
      if ($$.arrayEqual(actions.slice(start, end), group._groupActions)) {
        group._groupActions.forEach(function (action) {
          groupActions.push(action);
        });

        if (!group.required) {
          if (inserts[start]) {
            inserts[start] += ' [';
          } else {
            inserts[start] = '[';
          }
          inserts[end] = ']';
        } else {
          if (inserts[start]) {
            inserts[start] += ' (';
          } else {
            inserts[start] = '(';
          }
          inserts[end] = ')';
        }
        for (i = start + 1; i < end; i += 1) {
          inserts[i] = '|';
        }
      }
    }
  });

  // collect all actions format strings
  var parts = [];

  actions.forEach(function (action, actionIndex) {
    var part;
    var optionString;
    var argsDefault;
    var argsString;

    // suppressed arguments are marked with None
    // remove | separators for suppressed arguments
    if (action.help === c.SUPPRESS) {
      parts.push(null);
      if (inserts[actionIndex] === '|') {
        inserts.splice(actionIndex, actionIndex);
      } else if (inserts[actionIndex + 1] === '|') {
        inserts.splice(actionIndex + 1, actionIndex + 1);
      }

      // produce all arg strings
    } else if (!action.isOptional()) {
      part = self._formatArgs(action, action.dest);

      // if it's in a group, strip the outer []
      if (groupActions.indexOf(action) >= 0) {
        if (part[0] === '[' && part[part.length - 1] === ']') {
          part = part.slice(1, -1);
        }
      }
      // add the action string to the list
      parts.push(part);

    // produce the first way to invoke the option in brackets
    } else {
      optionString = action.optionStrings[0];

      // if the Optional doesn't take a value, format is: -s or --long
      if (action.nargs === 0) {
        part = '' + optionString;

      // if the Optional takes a value, format is: -s ARGS or --long ARGS
      } else {
        argsDefault = action.dest.toUpperCase();
        argsString = self._formatArgs(action, argsDefault);
        part = optionString + ' ' + argsString;
      }
      // make it look optional if it's not required or in a group
      if (!action.required && groupActions.indexOf(action) < 0) {
        part = '[' + part + ']';
      }
      // add the action string to the list
      parts.push(part);
    }
  });

  // insert things at the necessary indices
  for (var i = inserts.length - 1; i >= 0; --i) {
    if (inserts[i] !== null) {
      parts.splice(i, 0, inserts[i]);
    }
  }

  // join all the action items with spaces
  var text = parts.filter(function (part) {
    return !!part;
  }).join(' ');

  // clean up separators for mutually exclusive groups
  text = text.replace(/([\[(]) /g, '$1'); // remove spaces
  text = text.replace(/ ([\])])/g, '$1');
  text = text.replace(/\[ *\]/g, ''); // remove empty groups
  text = text.replace(/\( *\)/g, '');
  text = text.replace(/\(([^|]*)\)/g, '$1'); // remove () from single action groups

  text = text.trim();

  // return the text
  return text;
};

HelpFormatter.prototype._formatText = function (text) {
  text = sprintf(text, { prog: this._prog });
  var textWidth = this._width - this._currentIndent;
  var indentIncriment = $$.repeat(' ', this._currentIndent);
  return this._fillText(text, textWidth, indentIncriment) + c.EOL + c.EOL;
};

HelpFormatter.prototype._formatAction = function (action) {
  var self = this;

  var helpText;
  var helpLines;
  var parts;
  var indentFirst;

  // determine the required width and the entry label
  var helpPosition = Math.min(this._actionMaxLength + 2, this._maxHelpPosition);
  var helpWidth = this._width - helpPosition;
  var actionWidth = helpPosition - this._currentIndent - 2;
  var actionHeader = this._formatActionInvocation(action);

  // no help; start on same line and add a final newline
  if (!action.help) {
    actionHeader = $$.repeat(' ', this._currentIndent) + actionHeader + c.EOL;

  // short action name; start on the same line and pad two spaces
  } else if (actionHeader.length <= actionWidth) {
    actionHeader = $$.repeat(' ', this._currentIndent) +
        actionHeader +
        '  ' +
        $$.repeat(' ', actionWidth - actionHeader.length);
    indentFirst = 0;

  // long action name; start on the next line
  } else {
    actionHeader = $$.repeat(' ', this._currentIndent) + actionHeader + c.EOL;
    indentFirst = helpPosition;
  }

  // collect the pieces of the action help
  parts = [ actionHeader ];

  // if there was help for the action, add lines of help text
  if (action.help) {
    helpText = this._expandHelp(action);
    helpLines = this._splitLines(helpText, helpWidth);
    parts.push($$.repeat(' ', indentFirst) + helpLines[0] + c.EOL);
    helpLines.slice(1).forEach(function (line) {
      parts.push($$.repeat(' ', helpPosition) + line + c.EOL);
    });

  // or add a newline if the description doesn't end with one
  } else if (actionHeader.charAt(actionHeader.length - 1) !== c.EOL) {
    parts.push(c.EOL);
  }
  // if there are any sub-actions, add their help as well
  if (action._getSubactions) {
    this._indent();
    action._getSubactions().forEach(function (subaction) {
      parts.push(self._formatAction(subaction));
    });
    this._dedent();
  }
  // return a single string
  return this._joinParts(parts);
};

HelpFormatter.prototype._formatActionInvocation = function (action) {
  if (!action.isOptional()) {
    var format_func = this._metavarFormatter(action, action.dest);
    var metavars = format_func(1);
    return metavars[0];
  }

  var parts = [];
  var argsDefault;
  var argsString;

  // if the Optional doesn't take a value, format is: -s, --long
  if (action.nargs === 0) {
    parts = parts.concat(action.optionStrings);

  // if the Optional takes a value, format is: -s ARGS, --long ARGS
  } else {
    argsDefault = action.dest.toUpperCase();
    argsString = this._formatArgs(action, argsDefault);
    action.optionStrings.forEach(function (optionString) {
      parts.push(optionString + ' ' + argsString);
    });
  }
  return parts.join(', ');
};

HelpFormatter.prototype._metavarFormatter = function (action, metavarDefault) {
  var result;

  if (action.metavar || action.metavar === '') {
    result = action.metavar;
  } else if (action.choices) {
    var choices = action.choices;

    if (typeof choices === 'string') {
      choices = choices.split('').join(', ');
    } else if (Array.isArray(choices)) {
      choices = choices.join(',');
    } else {
      choices = Object.keys(choices).join(',');
    }
    result = '{' + choices + '}';
  } else {
    result = metavarDefault;
  }

  return function (size) {
    if (Array.isArray(result)) {
      return result;
    }

    var metavars = [];
    for (var i = 0; i < size; i += 1) {
      metavars.push(result);
    }
    return metavars;
  };
};

HelpFormatter.prototype._formatArgs = function (action, metavarDefault) {
  var result;
  var metavars;

  var buildMetavar = this._metavarFormatter(action, metavarDefault);

  switch (action.nargs) {
    /*eslint-disable no-undefined*/
    case undefined:
    case null:
      metavars = buildMetavar(1);
      result = '' + metavars[0];
      break;
    case c.OPTIONAL:
      metavars = buildMetavar(1);
      result = '[' + metavars[0] + ']';
      break;
    case c.ZERO_OR_MORE:
      metavars = buildMetavar(2);
      result = '[' + metavars[0] + ' [' + metavars[1] + ' ...]]';
      break;
    case c.ONE_OR_MORE:
      metavars = buildMetavar(2);
      result = '' + metavars[0] + ' [' + metavars[1] + ' ...]';
      break;
    case c.REMAINDER:
      result = '...';
      break;
    case c.PARSER:
      metavars = buildMetavar(1);
      result = metavars[0] + ' ...';
      break;
    default:
      metavars = buildMetavar(action.nargs);
      result = metavars.join(' ');
  }
  return result;
};

HelpFormatter.prototype._expandHelp = function (action) {
  var params = { prog: this._prog };

  Object.keys(action).forEach(function (actionProperty) {
    var actionValue = action[actionProperty];

    if (actionValue !== c.SUPPRESS) {
      params[actionProperty] = actionValue;
    }
  });

  if (params.choices) {
    if (typeof params.choices === 'string') {
      params.choices = params.choices.split('').join(', ');
    } else if (Array.isArray(params.choices)) {
      params.choices = params.choices.join(', ');
    } else {
      params.choices = Object.keys(params.choices).join(', ');
    }
  }

  return sprintf(this._getHelpString(action), params);
};

HelpFormatter.prototype._splitLines = function (text, width) {
  var lines = [];
  var delimiters = [ ' ', '.', ',', '!', '?' ];
  var re = new RegExp('[' + delimiters.join('') + '][^' + delimiters.join('') + ']*$');

  text = text.replace(/[\n\|\t]/g, ' ');

  text = text.trim();
  text = text.replace(this._whitespaceMatcher, ' ');

  // Wraps the single paragraph in text (a string) so every line
  // is at most width characters long.
  text.split(c.EOL).forEach(function (line) {
    if (width >= line.length) {
      lines.push(line);
      return;
    }

    var wrapStart = 0;
    var wrapEnd = width;
    var delimiterIndex = 0;
    while (wrapEnd <= line.length) {
      if (wrapEnd !== line.length && delimiters.indexOf(line[wrapEnd] < -1)) {
        delimiterIndex = (re.exec(line.substring(wrapStart, wrapEnd)) || {}).index;
        wrapEnd = wrapStart + delimiterIndex + 1;
      }
      lines.push(line.substring(wrapStart, wrapEnd));
      wrapStart = wrapEnd;
      wrapEnd += width;
    }
    if (wrapStart < line.length) {
      lines.push(line.substring(wrapStart, wrapEnd));
    }
  });

  return lines;
};

HelpFormatter.prototype._fillText = function (text, width, indent) {
  var lines = this._splitLines(text, width);
  lines = lines.map(function (line) {
    return indent + line;
  });
  return lines.join(c.EOL);
};

HelpFormatter.prototype._getHelpString = function (action) {
  return action.help;
};


/***/ }),

/***/ 89824:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * class Namespace
 *
 * Simple object for storing attributes. Implements equality by attribute names
 * and values, and provides a simple string representation.
 *
 * See also [original guide][1]
 *
 * [1]:http://docs.python.org/dev/library/argparse.html#the-namespace-object
 **/


var $$ = __webpack_require__(40965);

/**
 * new Namespace(options)
 * - options(object): predefined propertis for result object
 *
 **/
var Namespace = module.exports = function Namespace(options) {
  $$.extend(this, options);
};

/**
 * Namespace#isset(key) -> Boolean
 * - key (string|number): property name
 *
 * Tells whenever `namespace` contains given `key` or not.
 **/
Namespace.prototype.isset = function (key) {
  return $$.has(this, key);
};

/**
 * Namespace#set(key, value) -> self
 * -key (string|number|object): propery name
 * -value (mixed): new property value
 *
 * Set the property named key with value.
 * If key object then set all key properties to namespace object
 **/
Namespace.prototype.set = function (key, value) {
  if (typeof (key) === 'object') {
    $$.extend(this, key);
  } else {
    this[key] = value;
  }
  return this;
};

/**
 * Namespace#get(key, defaultValue) -> mixed
 * - key (string|number): property name
 * - defaultValue (mixed): default value
 *
 * Return the property key or defaulValue if not set
 **/
Namespace.prototype.get = function (key, defaultValue) {
  return !this[key] ? defaultValue : this[key];
};

/**
 * Namespace#unset(key, defaultValue) -> mixed
 * - key (string|number): property name
 * - defaultValue (mixed): default value
 *
 * Return data[key](and delete it) or defaultValue
 **/
Namespace.prototype.unset = function (key, defaultValue) {
  var value = this[key];
  if (value !== null) {
    delete this[key];
    return value;
  }
  return defaultValue;
};


/***/ }),

/***/ 40965:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.repeat = function (str, num) {
  var result = '';
  for (var i = 0; i < num; i++) { result += str; }
  return result;
};

exports.arrayEqual = function (a, b) {
  if (a.length !== b.length) { return false; }
  for (var i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) { return false; }
  }
  return true;
};

exports.trimChars = function (str, chars) {
  var start = 0;
  var end = str.length - 1;
  while (chars.indexOf(str.charAt(start)) >= 0) { start++; }
  while (chars.indexOf(str.charAt(end)) >= 0) { end--; }
  return str.slice(start, end + 1);
};

exports.capitalize = function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
};

exports.arrayUnion = function () {
  var result = [];
  for (var i = 0, values = {}; i < arguments.length; i++) {
    var arr = arguments[i];
    for (var j = 0; j < arr.length; j++) {
      if (!values[arr[j]]) {
        values[arr[j]] = true;
        result.push(arr[j]);
      }
    }
  }
  return result;
};

function has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.has = has;

exports.extend = function (dest, src) {
  for (var i in src) {
    if (has(src, i)) { dest[i] = src[i]; }
  }
};

exports.trimEnd = function (str) {
  return str.replace(/\s+$/g, '');
};


/***/ }),

/***/ 83682:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var register = __webpack_require__(44670)
var addHook = __webpack_require__(5549)
var removeHook = __webpack_require__(6819)

// bind with array of arguments: https://stackoverflow.com/a/21792913
var bind = Function.bind
var bindable = bind.bind(bind)

function bindApi (hook, state, name) {
  var removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state])
  hook.api = { remove: removeHookRef }
  hook.remove = removeHookRef

  ;['before', 'error', 'after', 'wrap'].forEach(function (kind) {
    var args = name ? [state, kind, name] : [state, kind]
    hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args)
  })
}

function HookSingular () {
  var singularHookName = 'h'
  var singularHookState = {
    registry: {}
  }
  var singularHook = register.bind(null, singularHookState, singularHookName)
  bindApi(singularHook, singularHookState, singularHookName)
  return singularHook
}

function HookCollection () {
  var state = {
    registry: {}
  }

  var hook = register.bind(null, state)
  bindApi(hook, state)

  return hook
}

var collectionHookDeprecationMessageDisplayed = false
function Hook () {
  if (!collectionHookDeprecationMessageDisplayed) {
    console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4')
    collectionHookDeprecationMessageDisplayed = true
  }
  return HookCollection()
}

Hook.Singular = HookSingular.bind()
Hook.Collection = HookCollection.bind()

module.exports = Hook
// expose constructors as a named property for TypeScript
module.exports.Hook = Hook
module.exports.Singular = Hook.Singular
module.exports.Collection = Hook.Collection


/***/ }),

/***/ 5549:
/***/ ((module) => {

module.exports = addHook;

function addHook(state, kind, name, hook) {
  var orig = hook;
  if (!state.registry[name]) {
    state.registry[name] = [];
  }

  if (kind === "before") {
    hook = function (method, options) {
      return Promise.resolve()
        .then(orig.bind(null, options))
        .then(method.bind(null, options));
    };
  }

  if (kind === "after") {
    hook = function (method, options) {
      var result;
      return Promise.resolve()
        .then(method.bind(null, options))
        .then(function (result_) {
          result = result_;
          return orig(result, options);
        })
        .then(function () {
          return result;
        });
    };
  }

  if (kind === "error") {
    hook = function (method, options) {
      return Promise.resolve()
        .then(method.bind(null, options))
        .catch(function (error) {
          return orig(error, options);
        });
    };
  }

  state.registry[name].push({
    hook: hook,
    orig: orig,
  });
}


/***/ }),

/***/ 44670:
/***/ ((module) => {

module.exports = register;

function register(state, name, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }

  if (!options) {
    options = {};
  }

  if (Array.isArray(name)) {
    return name.reverse().reduce(function (callback, name) {
      return register.bind(null, state, name, callback, options);
    }, method)();
  }

  return Promise.resolve().then(function () {
    if (!state.registry[name]) {
      return method(options);
    }

    return state.registry[name].reduce(function (method, registered) {
      return registered.hook.bind(null, method, options);
    }, method)();
  });
}


/***/ }),

/***/ 6819:
/***/ ((module) => {

module.exports = removeHook;

function removeHook(state, name, method) {
  if (!state.registry[name]) {
    return;
  }

  var index = state.registry[name]
    .map(function (registered) {
      return registered.orig;
    })
    .indexOf(method);

  if (index === -1) {
    return;
  }

  state.registry[name].splice(index, 1);
}


/***/ }),

/***/ 980:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {builtinModules} = __webpack_require__(32282);

const blacklist = [
	'sys'
];

// eslint-disable-next-line node/no-deprecated-api
module.exports = (builtinModules || Object.keys(process.binding('natives')))
	.filter(x => !/^_|^(internal|v8|node-inspect)\/|\//.test(x) && !blacklist.includes(x))
	.sort();


/***/ }),

/***/ 59051:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fs = __webpack_require__(35747)
const path = __webpack_require__(85622)

/* istanbul ignore next */
const LCHOWN = fs.lchown ? 'lchown' : 'chown'
/* istanbul ignore next */
const LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync'

/* istanbul ignore next */
const needEISDIRHandled = fs.lchown &&
  !process.version.match(/v1[1-9]+\./) &&
  !process.version.match(/v10\.[6-9]/)

const lchownSync = (path, uid, gid) => {
  try {
    return fs[LCHOWNSYNC](path, uid, gid)
  } catch (er) {
    if (er.code !== 'ENOENT')
      throw er
  }
}

/* istanbul ignore next */
const chownSync = (path, uid, gid) => {
  try {
    return fs.chownSync(path, uid, gid)
  } catch (er) {
    if (er.code !== 'ENOENT')
      throw er
  }
}

/* istanbul ignore next */
const handleEISDIR =
  needEISDIRHandled ? (path, uid, gid, cb) => er => {
    // Node prior to v10 had a very questionable implementation of
    // fs.lchown, which would always try to call fs.open on a directory
    // Fall back to fs.chown in those cases.
    if (!er || er.code !== 'EISDIR')
      cb(er)
    else
      fs.chown(path, uid, gid, cb)
  }
  : (_, __, ___, cb) => cb

/* istanbul ignore next */
const handleEISDirSync =
  needEISDIRHandled ? (path, uid, gid) => {
    try {
      return lchownSync(path, uid, gid)
    } catch (er) {
      if (er.code !== 'EISDIR')
        throw er
      chownSync(path, uid, gid)
    }
  }
  : (path, uid, gid) => lchownSync(path, uid, gid)

// fs.readdir could only accept an options object as of node v6
const nodeVersion = process.version
let readdir = (path, options, cb) => fs.readdir(path, options, cb)
let readdirSync = (path, options) => fs.readdirSync(path, options)
/* istanbul ignore next */
if (/^v4\./.test(nodeVersion))
  readdir = (path, options, cb) => fs.readdir(path, cb)

const chown = (cpath, uid, gid, cb) => {
  fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, er => {
    // Skip ENOENT error
    cb(er && er.code !== 'ENOENT' ? er : null)
  }))
}

const chownrKid = (p, child, uid, gid, cb) => {
  if (typeof child === 'string')
    return fs.lstat(path.resolve(p, child), (er, stats) => {
      // Skip ENOENT error
      if (er)
        return cb(er.code !== 'ENOENT' ? er : null)
      stats.name = child
      chownrKid(p, stats, uid, gid, cb)
    })

  if (child.isDirectory()) {
    chownr(path.resolve(p, child.name), uid, gid, er => {
      if (er)
        return cb(er)
      const cpath = path.resolve(p, child.name)
      chown(cpath, uid, gid, cb)
    })
  } else {
    const cpath = path.resolve(p, child.name)
    chown(cpath, uid, gid, cb)
  }
}


const chownr = (p, uid, gid, cb) => {
  readdir(p, { withFileTypes: true }, (er, children) => {
    // any error other than ENOTDIR or ENOTSUP means it's not readable,
    // or doesn't exist.  give up.
    if (er) {
      if (er.code === 'ENOENT')
        return cb()
      else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')
        return cb(er)
    }
    if (er || !children.length)
      return chown(p, uid, gid, cb)

    let len = children.length
    let errState = null
    const then = er => {
      if (errState)
        return
      if (er)
        return cb(errState = er)
      if (-- len === 0)
        return chown(p, uid, gid, cb)
    }

    children.forEach(child => chownrKid(p, child, uid, gid, then))
  })
}

const chownrKidSync = (p, child, uid, gid) => {
  if (typeof child === 'string') {
    try {
      const stats = fs.lstatSync(path.resolve(p, child))
      stats.name = child
      child = stats
    } catch (er) {
      if (er.code === 'ENOENT')
        return
      else
        throw er
    }
  }

  if (child.isDirectory())
    chownrSync(path.resolve(p, child.name), uid, gid)

  handleEISDirSync(path.resolve(p, child.name), uid, gid)
}

const chownrSync = (p, uid, gid) => {
  let children
  try {
    children = readdirSync(p, { withFileTypes: true })
  } catch (er) {
    if (er.code === 'ENOENT')
      return
    else if (er.code === 'ENOTDIR' || er.code === 'ENOTSUP')
      return handleEISDirSync(p, uid, gid)
    else
      throw er
  }

  if (children && children.length)
    children.forEach(child => chownrKidSync(p, child, uid, gid))

  return handleEISDirSync(p, uid, gid)
}

module.exports = chownr
chownr.sync = chownrSync


/***/ }),

/***/ 43595:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*

The MIT License (MIT)

Original Library
  - Copyright (c) Marak Squires

Additional functionality
 - Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var colors = {};
module['exports'] = colors;

colors.themes = {};

var util = __webpack_require__(31669);
var ansiStyles = colors.styles = __webpack_require__(73104);
var defineProps = Object.defineProperties;
var newLineRegex = new RegExp(/[\r\n]+/g);

colors.supportsColor = __webpack_require__(10662).supportsColor;

if (typeof colors.enabled === 'undefined') {
  colors.enabled = colors.supportsColor() !== false;
}

colors.enable = function() {
  colors.enabled = true;
};

colors.disable = function() {
  colors.enabled = false;
};

colors.stripColors = colors.strip = function(str) {
  return ('' + str).replace(/\x1B\[\d+m/g, '');
};

// eslint-disable-next-line no-unused-vars
var stylize = colors.stylize = function stylize(str, style) {
  if (!colors.enabled) {
    return str+'';
  }

  return ansiStyles[style].open + str + ansiStyles[style].close;
};

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
var escapeStringRegexp = function(str) {
  if (typeof str !== 'string') {
    throw new TypeError('Expected a string');
  }
  return str.replace(matchOperatorsRe, '\\$&');
};

function build(_styles) {
  var builder = function builder() {
    return applyStyle.apply(builder, arguments);
  };
  builder._styles = _styles;
  // __proto__ is used because we must return a function, but there is
  // no way to create a function with a different prototype.
  builder.__proto__ = proto;
  return builder;
}

var styles = (function() {
  var ret = {};
  ansiStyles.grey = ansiStyles.gray;
  Object.keys(ansiStyles).forEach(function(key) {
    ansiStyles[key].closeRe =
      new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
    ret[key] = {
      get: function() {
        return build(this._styles.concat(key));
      },
    };
  });
  return ret;
})();

var proto = defineProps(function colors() {}, styles);

function applyStyle() {
  var args = Array.prototype.slice.call(arguments);

  var str = args.map(function(arg) {
    if (arg !== undefined && arg.constructor === String) {
      return arg;
    } else {
      return util.inspect(arg);
    }
  }).join(' ');

  if (!colors.enabled || !str) {
    return str;
  }

  var newLinesPresent = str.indexOf('\n') != -1;

  var nestedStyles = this._styles;

  var i = nestedStyles.length;
  while (i--) {
    var code = ansiStyles[nestedStyles[i]];
    str = code.open + str.replace(code.closeRe, code.open) + code.close;
    if (newLinesPresent) {
      str = str.replace(newLineRegex, code.close + '\n' + code.open);
    }
  }

  return str;
}

colors.setTheme = function(theme) {
  if (typeof theme === 'string') {
    console.log('colors.setTheme now only accepts an object, not a string.  ' +
      'If you are trying to set a theme from a file, it is now your (the ' +
      'caller\'s) responsibility to require the file.  The old syntax ' +
      'looked like colors.setTheme(__dirname + ' +
      '\'/../themes/generic-logging.js\'); The new syntax looks like '+
      'colors.setTheme(require(__dirname + ' +
      '\'/../themes/generic-logging.js\'));');
    return;
  }
  for (var style in theme) {
    (function(style) {
      colors[style] = function(str) {
        if (typeof theme[style] === 'object') {
          var out = str;
          for (var i in theme[style]) {
            out = colors[theme[style][i]](out);
          }
          return out;
        }
        return colors[theme[style]](str);
      };
    })(style);
  }
};

function init() {
  var ret = {};
  Object.keys(styles).forEach(function(name) {
    ret[name] = {
      get: function() {
        return build([name]);
      },
    };
  });
  return ret;
}

var sequencer = function sequencer(map, str) {
  var exploded = str.split('');
  exploded = exploded.map(map);
  return exploded.join('');
};

// custom formatter methods
colors.trap = __webpack_require__(31302);
colors.zalgo = __webpack_require__(97743);

// maps
colors.maps = {};
colors.maps.america = __webpack_require__(76936);
colors.maps.zebra = __webpack_require__(12989);
colors.maps.rainbow = __webpack_require__(75210);
colors.maps.random = __webpack_require__(13441);

for (var map in colors.maps) {
  (function(map) {
    colors[map] = function(str) {
      return sequencer(colors.maps[map], str);
    };
  })(map);
}

defineProps(colors, init());


/***/ }),

/***/ 31302:
/***/ ((module) => {

module['exports'] = function runTheTrap(text, options) {
  var result = '';
  text = text || 'Run the trap, drop the bass';
  text = text.split('');
  var trap = {
    a: ['\u0040', '\u0104', '\u023a', '\u0245', '\u0394', '\u039b', '\u0414'],
    b: ['\u00df', '\u0181', '\u0243', '\u026e', '\u03b2', '\u0e3f'],
    c: ['\u00a9', '\u023b', '\u03fe'],
    d: ['\u00d0', '\u018a', '\u0500', '\u0501', '\u0502', '\u0503'],
    e: ['\u00cb', '\u0115', '\u018e', '\u0258', '\u03a3', '\u03be', '\u04bc',
         '\u0a6c'],
    f: ['\u04fa'],
    g: ['\u0262'],
    h: ['\u0126', '\u0195', '\u04a2', '\u04ba', '\u04c7', '\u050a'],
    i: ['\u0f0f'],
    j: ['\u0134'],
    k: ['\u0138', '\u04a0', '\u04c3', '\u051e'],
    l: ['\u0139'],
    m: ['\u028d', '\u04cd', '\u04ce', '\u0520', '\u0521', '\u0d69'],
    n: ['\u00d1', '\u014b', '\u019d', '\u0376', '\u03a0', '\u048a'],
    o: ['\u00d8', '\u00f5', '\u00f8', '\u01fe', '\u0298', '\u047a', '\u05dd',
         '\u06dd', '\u0e4f'],
    p: ['\u01f7', '\u048e'],
    q: ['\u09cd'],
    r: ['\u00ae', '\u01a6', '\u0210', '\u024c', '\u0280', '\u042f'],
    s: ['\u00a7', '\u03de', '\u03df', '\u03e8'],
    t: ['\u0141', '\u0166', '\u0373'],
    u: ['\u01b1', '\u054d'],
    v: ['\u05d8'],
    w: ['\u0428', '\u0460', '\u047c', '\u0d70'],
    x: ['\u04b2', '\u04fe', '\u04fc', '\u04fd'],
    y: ['\u00a5', '\u04b0', '\u04cb'],
    z: ['\u01b5', '\u0240'],
  };
  text.forEach(function(c) {
    c = c.toLowerCase();
    var chars = trap[c] || [' '];
    var rand = Math.floor(Math.random() * chars.length);
    if (typeof trap[c] !== 'undefined') {
      result += trap[c][rand];
    } else {
      result += c;
    }
  });
  return result;
};


/***/ }),

/***/ 97743:
/***/ ((module) => {

// please no
module['exports'] = function zalgo(text, options) {
  text = text || '   he is here   ';
  var soul = {
    'up': [
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '',
    ],
    'down': [
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
    ],
    'mid': [
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '',
      '', '', '', '',
      '', '', ' ',
    ],
  };
  var all = [].concat(soul.up, soul.down, soul.mid);

  function randomNumber(range) {
    var r = Math.floor(Math.random() * range);
    return r;
  }

  function isChar(character) {
    var bool = false;
    all.filter(function(i) {
      bool = (i === character);
    });
    return bool;
  }


  function heComes(text, options) {
    var result = '';
    var counts;
    var l;
    options = options || {};
    options['up'] =
      typeof options['up'] !== 'undefined' ? options['up'] : true;
    options['mid'] =
      typeof options['mid'] !== 'undefined' ? options['mid'] : true;
    options['down'] =
      typeof options['down'] !== 'undefined' ? options['down'] : true;
    options['size'] =
      typeof options['size'] !== 'undefined' ? options['size'] : 'maxi';
    text = text.split('');
    for (l in text) {
      if (isChar(l)) {
        continue;
      }
      result = result + text[l];
      counts = {'up': 0, 'down': 0, 'mid': 0};
      switch (options.size) {
      case 'mini':
        counts.up = randomNumber(8);
        counts.mid = randomNumber(2);
        counts.down = randomNumber(8);
        break;
      case 'maxi':
        counts.up = randomNumber(16) + 3;
        counts.mid = randomNumber(4) + 1;
        counts.down = randomNumber(64) + 3;
        break;
      default:
        counts.up = randomNumber(8) + 1;
        counts.mid = randomNumber(6) / 2;
        counts.down = randomNumber(8) + 1;
        break;
      }

      var arr = ['up', 'mid', 'down'];
      for (var d in arr) {
        var index = arr[d];
        for (var i = 0; i <= counts[index]; i++) {
          if (options[index]) {
            result = result + soul[index][randomNumber(soul[index].length)];
          }
        }
      }
    }
    return result;
  }
  // don't summon him
  return heComes(text, options);
};



/***/ }),

/***/ 2857:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var colors = __webpack_require__(43595);

module['exports'] = function() {
  //
  // Extends prototype of native string object to allow for "foo".red syntax
  //
  var addProperty = function(color, func) {
    String.prototype.__defineGetter__(color, func);
  };

  addProperty('strip', function() {
    return colors.strip(this);
  });

  addProperty('stripColors', function() {
    return colors.strip(this);
  });

  addProperty('trap', function() {
    return colors.trap(this);
  });

  addProperty('zalgo', function() {
    return colors.zalgo(this);
  });

  addProperty('zebra', function() {
    return colors.zebra(this);
  });

  addProperty('rainbow', function() {
    return colors.rainbow(this);
  });

  addProperty('random', function() {
    return colors.random(this);
  });

  addProperty('america', function() {
    return colors.america(this);
  });

  //
  // Iterate through all default styles and colors
  //
  var x = Object.keys(colors.styles);
  x.forEach(function(style) {
    addProperty(style, function() {
      return colors.stylize(this, style);
    });
  });

  function applyTheme(theme) {
    //
    // Remark: This is a list of methods that exist
    // on String that you should not overwrite.
    //
    var stringPrototypeBlacklist = [
      '__defineGetter__', '__defineSetter__', '__lookupGetter__',
      '__lookupSetter__', 'charAt', 'constructor', 'hasOwnProperty',
      'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString',
      'valueOf', 'charCodeAt', 'indexOf', 'lastIndexOf', 'length',
      'localeCompare', 'match', 'repeat', 'replace', 'search', 'slice',
      'split', 'substring', 'toLocaleLowerCase', 'toLocaleUpperCase',
      'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight',
    ];

    Object.keys(theme).forEach(function(prop) {
      if (stringPrototypeBlacklist.indexOf(prop) !== -1) {
        console.log('warn: '.red + ('String.prototype' + prop).magenta +
          ' is probably something you don\'t want to override.  ' +
          'Ignoring style name');
      } else {
        if (typeof(theme[prop]) === 'string') {
          colors[prop] = colors[theme[prop]];
          addProperty(prop, function() {
            return colors[theme[prop]](this);
          });
        } else {
          addProperty(prop, function() {
            var ret = this;
            for (var t = 0; t < theme[prop].length; t++) {
              ret = colors[theme[prop][t]](ret);
            }
            return ret;
          });
        }
      }
    });
  }

  colors.setTheme = function(theme) {
    if (typeof theme === 'string') {
      try {
        colors.themes[theme] = require(theme);
        applyTheme(colors.themes[theme]);
        return colors.themes[theme];
      } catch (err) {
        console.log(err);
        return err;
      }
    } else {
      applyTheme(theme);
    }
  };
};


/***/ }),

/***/ 83045:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var colors = __webpack_require__(43595);
module['exports'] = colors;

// Remark: By default, colors will add style properties to String.prototype.
//
// If you don't wish to extend String.prototype, you can do this instead and
// native String will not be touched:
//
//   var colors = require('colors/safe);
//   colors.red("foo")
//
//
__webpack_require__(2857)();


/***/ }),

/***/ 76936:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var colors = __webpack_require__(43595);

module['exports'] = (function() {
  return function(letter, i, exploded) {
    if (letter === ' ') return letter;
    switch (i%3) {
      case 0: return colors.red(letter);
      case 1: return colors.white(letter);
      case 2: return colors.blue(letter);
    }
  };
})();


/***/ }),

/***/ 75210:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var colors = __webpack_require__(43595);

module['exports'] = (function() {
  // RoY G BiV
  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta'];
  return function(letter, i, exploded) {
    if (letter === ' ') {
      return letter;
    } else {
      return colors[rainbowColors[i++ % rainbowColors.length]](letter);
    }
  };
})();



/***/ }),

/***/ 13441:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var colors = __webpack_require__(43595);

module['exports'] = (function() {
  var available = ['underline', 'inverse', 'grey', 'yellow', 'red', 'green',
    'blue', 'white', 'cyan', 'magenta'];
  return function(letter, i, exploded) {
    return letter === ' ' ? letter :
      colors[
        available[Math.round(Math.random() * (available.length - 2))]
      ](letter);
  };
})();


/***/ }),

/***/ 12989:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var colors = __webpack_require__(43595);

module['exports'] = function(letter, i, exploded) {
  return i % 2 === 0 ? letter : colors.inverse(letter);
};


/***/ }),

/***/ 73104:
/***/ ((module) => {

/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var styles = {};
module['exports'] = styles;

var codes = {
  reset: [0, 0],

  bold: [1, 22],
  dim: [2, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],

  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  grey: [90, 39],

  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],

  // legacy styles for colors pre v1.0.0
  blackBG: [40, 49],
  redBG: [41, 49],
  greenBG: [42, 49],
  yellowBG: [43, 49],
  blueBG: [44, 49],
  magentaBG: [45, 49],
  cyanBG: [46, 49],
  whiteBG: [47, 49],

};

Object.keys(codes).forEach(function(key) {
  var val = codes[key];
  var style = styles[key] = [];
  style.open = '\u001b[' + val[0] + 'm';
  style.close = '\u001b[' + val[1] + 'm';
});


/***/ }),

/***/ 10223:
/***/ ((module) => {

"use strict";
/*
MIT License

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



module.exports = function(flag, argv) {
  argv = argv || process.argv;

  var terminatorPos = argv.indexOf('--');
  var prefix = /^-{1,2}/.test(flag) ? '' : '--';
  var pos = argv.indexOf(prefix + flag);

  return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
};


/***/ }),

/***/ 10662:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/



var os = __webpack_require__(12087);
var hasFlag = __webpack_require__(10223);

var env = process.env;

var forceColor = void 0;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {
  forceColor = false;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true')
           || hasFlag('color=always')) {
  forceColor = true;
}
if ('FORCE_COLOR' in env) {
  forceColor = env.FORCE_COLOR.length === 0
    || parseInt(env.FORCE_COLOR, 10) !== 0;
}

function translateLevel(level) {
  if (level === 0) {
    return false;
  }

  return {
    level: level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3,
  };
}

function supportsColor(stream) {
  if (forceColor === false) {
    return 0;
  }

  if (hasFlag('color=16m') || hasFlag('color=full')
      || hasFlag('color=truecolor')) {
    return 3;
  }

  if (hasFlag('color=256')) {
    return 2;
  }

  if (stream && !stream.isTTY && forceColor !== true) {
    return 0;
  }

  var min = forceColor ? 1 : 0;

  if (process.platform === 'win32') {
    // Node.js 7.5.0 is the first version of Node.js to include a patch to
    // libuv that enables 256 color output on Windows. Anything earlier and it
    // won't work. However, here we target Node.js 8 at minimum as it is an LTS
    // release, and Node.js 7 is not. Windows 10 build 10586 is the first
    // Windows release that supports 256 colors. Windows 10 build 14931 is the
    // first release that supports 16m/TrueColor.
    var osRelease = os.release().split('.');
    if (Number(process.versions.node.split('.')[0]) >= 8
        && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }

    return 1;
  }

  if ('CI' in env) {
    if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(function(sign) {
      return sign in env;
    }) || env.CI_NAME === 'codeship') {
      return 1;
    }

    return min;
  }

  if ('TEAMCITY_VERSION' in env) {
    return (/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0
    );
  }

  if ('TERM_PROGRAM' in env) {
    var version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

    switch (env.TERM_PROGRAM) {
      case 'iTerm.app':
        return version >= 3 ? 3 : 2;
      case 'Hyper':
        return 3;
      case 'Apple_Terminal':
        return 2;
      // No default
    }
  }

  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }

  if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }

  if ('COLORTERM' in env) {
    return 1;
  }

  if (env.TERM === 'dumb') {
    return min;
  }

  return min;
}

function getSupportLevel(stream) {
  var level = supportsColor(stream);
  return translateLevel(level);
}

module.exports = {
  supportsColor: getSupportLevel,
  stdout: getSupportLevel(process.stdout),
  stderr: getSupportLevel(process.stderr),
};


/***/ }),

/***/ 41997:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// Remark: Requiring this file will use the "safe" colors API,
// which will not touch String.prototype.
//
//   var colors = require('colors/safe');
//   colors.red("foo")
//
//
var colors = __webpack_require__(43595);
module['exports'] = colors;


/***/ }),

/***/ 58932:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class Deprecation extends Error {
  constructor(message) {
    super(message); // Maintains proper stack trace (only available on V8)

    /* istanbul ignore next */

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    this.name = 'Deprecation';
  }

}

exports.Deprecation = Deprecation;


/***/ }),

/***/ 43338:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(77758)
const path = __webpack_require__(85622)
const mkdirpSync = __webpack_require__(98605).mkdirsSync
const utimesSync = __webpack_require__(52548).utimesMillisSync

const notExist = Symbol('notExist')

function copySync (src, dest, opts) {
  if (typeof opts === 'function') {
    opts = {filter: opts}
  }

  opts = opts || {}
  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`)
  }

  const destStat = checkPaths(src, dest)

  if (opts.filter && !opts.filter(src, dest)) return

  const destParent = path.dirname(dest)
  if (!fs.existsSync(destParent)) mkdirpSync(destParent)
  return startCopy(destStat, src, dest, opts)
}

function startCopy (destStat, src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return
  return getStats(destStat, src, dest, opts)
}

function getStats (destStat, src, dest, opts) {
  const statSync = opts.dereference ? fs.statSync : fs.lstatSync
  const srcStat = statSync(src)

  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)
  else if (srcStat.isFile() ||
           srcStat.isCharacterDevice() ||
           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)
  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)
}

function onFile (srcStat, destStat, src, dest, opts) {
  if (destStat === notExist) return copyFile(srcStat, src, dest, opts)
  return mayCopyFile(srcStat, src, dest, opts)
}

function mayCopyFile (srcStat, src, dest, opts) {
  if (opts.overwrite) {
    fs.unlinkSync(dest)
    return copyFile(srcStat, src, dest, opts)
  } else if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`)
  }
}

function copyFile (srcStat, src, dest, opts) {
  if (typeof fs.copyFileSync === 'function') {
    fs.copyFileSync(src, dest)
    fs.chmodSync(dest, srcStat.mode)
    if (opts.preserveTimestamps) {
      return utimesSync(dest, srcStat.atime, srcStat.mtime)
    }
    return
  }
  return copyFileFallback(srcStat, src, dest, opts)
}

function copyFileFallback (srcStat, src, dest, opts) {
  const BUF_LENGTH = 64 * 1024
  const _buff = __webpack_require__(47696)(BUF_LENGTH)

  const fdr = fs.openSync(src, 'r')
  const fdw = fs.openSync(dest, 'w', srcStat.mode)
  let pos = 0

  while (pos < srcStat.size) {
    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)
    fs.writeSync(fdw, _buff, 0, bytesRead)
    pos += bytesRead
  }

  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime)

  fs.closeSync(fdr)
  fs.closeSync(fdw)
}

function onDir (srcStat, destStat, src, dest, opts) {
  if (destStat === notExist) return mkDirAndCopy(srcStat, src, dest, opts)
  if (destStat && !destStat.isDirectory()) {
    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)
  }
  return copyDir(src, dest, opts)
}

function mkDirAndCopy (srcStat, src, dest, opts) {
  fs.mkdirSync(dest)
  copyDir(src, dest, opts)
  return fs.chmodSync(dest, srcStat.mode)
}

function copyDir (src, dest, opts) {
  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))
}

function copyDirItem (item, src, dest, opts) {
  const srcItem = path.join(src, item)
  const destItem = path.join(dest, item)
  const destStat = checkPaths(srcItem, destItem)
  return startCopy(destStat, srcItem, destItem, opts)
}

function onLink (destStat, src, dest, opts) {
  let resolvedSrc = fs.readlinkSync(src)

  if (opts.dereference) {
    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)
  }

  if (destStat === notExist) {
    return fs.symlinkSync(resolvedSrc, dest)
  } else {
    let resolvedDest
    try {
      resolvedDest = fs.readlinkSync(dest)
    } catch (err) {
      // dest exists and is a regular file or directory,
      // Windows may throw UNKNOWN error. If dest already exists,
      // fs throws error anyway, so no need to guard against it here.
      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)
      throw err
    }
    if (opts.dereference) {
      resolvedDest = path.resolve(process.cwd(), resolvedDest)
    }
    if (isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)
    }

    // prevent copy if src is a subdir of dest since unlinking
    // dest in this case would result in removing src contents
    // and therefore a broken symlink would be created.
    if (fs.statSync(dest).isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)
    }
    return copyLink(resolvedSrc, dest)
  }
}

function copyLink (resolvedSrc, dest) {
  fs.unlinkSync(dest)
  return fs.symlinkSync(resolvedSrc, dest)
}

// return true if dest is a subdir of src, otherwise false.
function isSrcSubdir (src, dest) {
  const srcArray = path.resolve(src).split(path.sep)
  const destArray = path.resolve(dest).split(path.sep)
  return srcArray.reduce((acc, current, i) => acc && destArray[i] === current, true)
}

function checkStats (src, dest) {
  const srcStat = fs.statSync(src)
  let destStat
  try {
    destStat = fs.statSync(dest)
  } catch (err) {
    if (err.code === 'ENOENT') return {srcStat, destStat: notExist}
    throw err
  }
  return {srcStat, destStat}
}

function checkPaths (src, dest) {
  const {srcStat, destStat} = checkStats(src, dest)
  if (destStat.ino && destStat.ino === srcStat.ino) {
    throw new Error('Source and destination must not be the same.')
  }
  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`)
  }
  return destStat
}

module.exports = copySync


/***/ }),

/***/ 11135:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = {
  copySync: __webpack_require__(43338)
}


/***/ }),

/***/ 38834:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(77758)
const path = __webpack_require__(85622)
const mkdirp = __webpack_require__(98605).mkdirs
const pathExists = __webpack_require__(43835).pathExists
const utimes = __webpack_require__(52548).utimesMillis

const notExist = Symbol('notExist')

function copy (src, dest, opts, cb) {
  if (typeof opts === 'function' && !cb) {
    cb = opts
    opts = {}
  } else if (typeof opts === 'function') {
    opts = {filter: opts}
  }

  cb = cb || function () {}
  opts = opts || {}

  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`)
  }

  checkPaths(src, dest, (err, destStat) => {
    if (err) return cb(err)
    if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)
    return checkParentDir(destStat, src, dest, opts, cb)
  })
}

function checkParentDir (destStat, src, dest, opts, cb) {
  const destParent = path.dirname(dest)
  pathExists(destParent, (err, dirExists) => {
    if (err) return cb(err)
    if (dirExists) return startCopy(destStat, src, dest, opts, cb)
    mkdirp(destParent, err => {
      if (err) return cb(err)
      return startCopy(destStat, src, dest, opts, cb)
    })
  })
}

function handleFilter (onInclude, destStat, src, dest, opts, cb) {
  Promise.resolve(opts.filter(src, dest)).then(include => {
    if (include) {
      if (destStat) return onInclude(destStat, src, dest, opts, cb)
      return onInclude(src, dest, opts, cb)
    }
    return cb()
  }, error => cb(error))
}

function startCopy (destStat, src, dest, opts, cb) {
  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)
  return getStats(destStat, src, dest, opts, cb)
}

function getStats (destStat, src, dest, opts, cb) {
  const stat = opts.dereference ? fs.stat : fs.lstat
  stat(src, (err, srcStat) => {
    if (err) return cb(err)

    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)
    else if (srcStat.isFile() ||
             srcStat.isCharacterDevice() ||
             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)
    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)
  })
}

function onFile (srcStat, destStat, src, dest, opts, cb) {
  if (destStat === notExist) return copyFile(srcStat, src, dest, opts, cb)
  return mayCopyFile(srcStat, src, dest, opts, cb)
}

function mayCopyFile (srcStat, src, dest, opts, cb) {
  if (opts.overwrite) {
    fs.unlink(dest, err => {
      if (err) return cb(err)
      return copyFile(srcStat, src, dest, opts, cb)
    })
  } else if (opts.errorOnExist) {
    return cb(new Error(`'${dest}' already exists`))
  } else return cb()
}

function copyFile (srcStat, src, dest, opts, cb) {
  if (typeof fs.copyFile === 'function') {
    return fs.copyFile(src, dest, err => {
      if (err) return cb(err)
      return setDestModeAndTimestamps(srcStat, dest, opts, cb)
    })
  }
  return copyFileFallback(srcStat, src, dest, opts, cb)
}

function copyFileFallback (srcStat, src, dest, opts, cb) {
  const rs = fs.createReadStream(src)
  rs.on('error', err => cb(err)).once('open', () => {
    const ws = fs.createWriteStream(dest, { mode: srcStat.mode })
    ws.on('error', err => cb(err))
      .on('open', () => rs.pipe(ws))
      .once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb))
  })
}

function setDestModeAndTimestamps (srcStat, dest, opts, cb) {
  fs.chmod(dest, srcStat.mode, err => {
    if (err) return cb(err)
    if (opts.preserveTimestamps) {
      return utimes(dest, srcStat.atime, srcStat.mtime, cb)
    }
    return cb()
  })
}

function onDir (srcStat, destStat, src, dest, opts, cb) {
  if (destStat === notExist) return mkDirAndCopy(srcStat, src, dest, opts, cb)
  if (destStat && !destStat.isDirectory()) {
    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))
  }
  return copyDir(src, dest, opts, cb)
}

function mkDirAndCopy (srcStat, src, dest, opts, cb) {
  fs.mkdir(dest, err => {
    if (err) return cb(err)
    copyDir(src, dest, opts, err => {
      if (err) return cb(err)
      return fs.chmod(dest, srcStat.mode, cb)
    })
  })
}

function copyDir (src, dest, opts, cb) {
  fs.readdir(src, (err, items) => {
    if (err) return cb(err)
    return copyDirItems(items, src, dest, opts, cb)
  })
}

function copyDirItems (items, src, dest, opts, cb) {
  const item = items.pop()
  if (!item) return cb()
  return copyDirItem(items, item, src, dest, opts, cb)
}

function copyDirItem (items, item, src, dest, opts, cb) {
  const srcItem = path.join(src, item)
  const destItem = path.join(dest, item)
  checkPaths(srcItem, destItem, (err, destStat) => {
    if (err) return cb(err)
    startCopy(destStat, srcItem, destItem, opts, err => {
      if (err) return cb(err)
      return copyDirItems(items, src, dest, opts, cb)
    })
  })
}

function onLink (destStat, src, dest, opts, cb) {
  fs.readlink(src, (err, resolvedSrc) => {
    if (err) return cb(err)

    if (opts.dereference) {
      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)
    }

    if (destStat === notExist) {
      return fs.symlink(resolvedSrc, dest, cb)
    } else {
      fs.readlink(dest, (err, resolvedDest) => {
        if (err) {
          // dest exists and is a regular file or directory,
          // Windows may throw UNKNOWN error. If dest already exists,
          // fs throws error anyway, so no need to guard against it here.
          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)
          return cb(err)
        }
        if (opts.dereference) {
          resolvedDest = path.resolve(process.cwd(), resolvedDest)
        }
        if (isSrcSubdir(resolvedSrc, resolvedDest)) {
          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))
        }

        // do not copy if src is a subdir of dest since unlinking
        // dest in this case would result in removing src contents
        // and therefore a broken symlink would be created.
        if (destStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {
          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))
        }
        return copyLink(resolvedSrc, dest, cb)
      })
    }
  })
}

function copyLink (resolvedSrc, dest, cb) {
  fs.unlink(dest, err => {
    if (err) return cb(err)
    return fs.symlink(resolvedSrc, dest, cb)
  })
}

// return true if dest is a subdir of src, otherwise false.
function isSrcSubdir (src, dest) {
  const srcArray = path.resolve(src).split(path.sep)
  const destArray = path.resolve(dest).split(path.sep)
  return srcArray.reduce((acc, current, i) => acc && destArray[i] === current, true)
}

function checkStats (src, dest, cb) {
  fs.stat(src, (err, srcStat) => {
    if (err) return cb(err)
    fs.stat(dest, (err, destStat) => {
      if (err) {
        if (err.code === 'ENOENT') return cb(null, {srcStat, destStat: notExist})
        return cb(err)
      }
      return cb(null, {srcStat, destStat})
    })
  })
}

function checkPaths (src, dest, cb) {
  checkStats(src, dest, (err, stats) => {
    if (err) return cb(err)
    const {srcStat, destStat} = stats
    if (destStat.ino && destStat.ino === srcStat.ino) {
      return cb(new Error('Source and destination must not be the same.'))
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`))
    }
    return cb(null, destStat)
  })
}

module.exports = copy


/***/ }),

/***/ 61335:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = __webpack_require__(9046)/* .fromCallback */ .E
module.exports = {
  copy: u(__webpack_require__(38834))
}


/***/ }),

/***/ 96970:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = __webpack_require__(9046)/* .fromCallback */ .E
const fs = __webpack_require__(35747)
const path = __webpack_require__(85622)
const mkdir = __webpack_require__(98605)
const remove = __webpack_require__(47357)

const emptyDir = u(function emptyDir (dir, callback) {
  callback = callback || function () {}
  fs.readdir(dir, (err, items) => {
    if (err) return mkdir.mkdirs(dir, callback)

    items = items.map(item => path.join(dir, item))

    deleteItem()

    function deleteItem () {
      const item = items.pop()
      if (!item) return callback()
      remove.remove(item, err => {
        if (err) return callback(err)
        deleteItem()
      })
    }
  })
})

function emptyDirSync (dir) {
  let items
  try {
    items = fs.readdirSync(dir)
  } catch (err) {
    return mkdir.mkdirsSync(dir)
  }

  items.forEach(item => {
    item = path.join(dir, item)
    remove.removeSync(item)
  })
}

module.exports = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
}


/***/ }),

/***/ 2164:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = __webpack_require__(9046)/* .fromCallback */ .E
const path = __webpack_require__(85622)
const fs = __webpack_require__(77758)
const mkdir = __webpack_require__(98605)
const pathExists = __webpack_require__(43835).pathExists

function createFile (file, callback) {
  function makeFile () {
    fs.writeFile(file, '', err => {
      if (err) return callback(err)
      callback()
    })
  }

  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err
    if (!err && stats.isFile()) return callback()
    const dir = path.dirname(file)
    pathExists(dir, (err, dirExists) => {
      if (err) return callback(err)
      if (dirExists) return makeFile()
      mkdir.mkdirs(dir, err => {
        if (err) return callback(err)
        makeFile()
      })
    })
  })
}

function createFileSync (file) {
  let stats
  try {
    stats = fs.statSync(file)
  } catch (e) {}
  if (stats && stats.isFile()) return

  const dir = path.dirname(file)
  if (!fs.existsSync(dir)) {
    mkdir.mkdirsSync(dir)
  }

  fs.writeFileSync(file, '')
}

module.exports = {
  createFile: u(createFile),
  createFileSync
}


/***/ }),

/***/ 40055:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const file = __webpack_require__(2164)
const link = __webpack_require__(53797)
const symlink = __webpack_require__(72549)

module.exports = {
  // file
  createFile: file.createFile,
  createFileSync: file.createFileSync,
  ensureFile: file.createFile,
  ensureFileSync: file.createFileSync,
  // link
  createLink: link.createLink,
  createLinkSync: link.createLinkSync,
  ensureLink: link.createLink,
  ensureLinkSync: link.createLinkSync,
  // symlink
  createSymlink: symlink.createSymlink,
  createSymlinkSync: symlink.createSymlinkSync,
  ensureSymlink: symlink.createSymlink,
  ensureSymlinkSync: symlink.createSymlinkSync
}


/***/ }),

/***/ 53797:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = __webpack_require__(9046)/* .fromCallback */ .E
const path = __webpack_require__(85622)
const fs = __webpack_require__(77758)
const mkdir = __webpack_require__(98605)
const pathExists = __webpack_require__(43835).pathExists

function createLink (srcpath, dstpath, callback) {
  function makeLink (srcpath, dstpath) {
    fs.link(srcpath, dstpath, err => {
      if (err) return callback(err)
      callback(null)
    })
  }

  pathExists(dstpath, (err, destinationExists) => {
    if (err) return callback(err)
    if (destinationExists) return callback(null)
    fs.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureLink')
        return callback(err)
      }

      const dir = path.dirname(dstpath)
      pathExists(dir, (err, dirExists) => {
        if (err) return callback(err)
        if (dirExists) return makeLink(srcpath, dstpath)
        mkdir.mkdirs(dir, err => {
          if (err) return callback(err)
          makeLink(srcpath, dstpath)
        })
      })
    })
  })
}

function createLinkSync (srcpath, dstpath) {
  const destinationExists = fs.existsSync(dstpath)
  if (destinationExists) return undefined

  try {
    fs.lstatSync(srcpath)
  } catch (err) {
    err.message = err.message.replace('lstat', 'ensureLink')
    throw err
  }

  const dir = path.dirname(dstpath)
  const dirExists = fs.existsSync(dir)
  if (dirExists) return fs.linkSync(srcpath, dstpath)
  mkdir.mkdirsSync(dir)

  return fs.linkSync(srcpath, dstpath)
}

module.exports = {
  createLink: u(createLink),
  createLinkSync
}


/***/ }),

/***/ 53727:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(85622)
const fs = __webpack_require__(77758)
const pathExists = __webpack_require__(43835).pathExists

/**
 * Function that returns two types of paths, one relative to symlink, and one
 * relative to the current working directory. Checks if path is absolute or
 * relative. If the path is relative, this function checks if the path is
 * relative to symlink or relative to current working directory. This is an
 * initiative to find a smarter `srcpath` to supply when building symlinks.
 * This allows you to determine which path to use out of one of three possible
 * types of source paths. The first is an absolute path. This is detected by
 * `path.isAbsolute()`. When an absolute path is provided, it is checked to
 * see if it exists. If it does it's used, if not an error is returned
 * (callback)/ thrown (sync). The other two options for `srcpath` are a
 * relative url. By default Node's `fs.symlink` works by creating a symlink
 * using `dstpath` and expects the `srcpath` to be relative to the newly
 * created symlink. If you provide a `srcpath` that does not exist on the file
 * system it results in a broken symlink. To minimize this, the function
 * checks to see if the 'relative to symlink' source file exists, and if it
 * does it will use it. If it does not, it checks if there's a file that
 * exists that is relative to the current working directory, if does its used.
 * This preserves the expectations of the original fs.symlink spec and adds
 * the ability to pass in `relative to current working direcotry` paths.
 */

function symlinkPaths (srcpath, dstpath, callback) {
  if (path.isAbsolute(srcpath)) {
    return fs.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureSymlink')
        return callback(err)
      }
      return callback(null, {
        'toCwd': srcpath,
        'toDst': srcpath
      })
    })
  } else {
    const dstdir = path.dirname(dstpath)
    const relativeToDst = path.join(dstdir, srcpath)
    return pathExists(relativeToDst, (err, exists) => {
      if (err) return callback(err)
      if (exists) {
        return callback(null, {
          'toCwd': relativeToDst,
          'toDst': srcpath
        })
      } else {
        return fs.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace('lstat', 'ensureSymlink')
            return callback(err)
          }
          return callback(null, {
            'toCwd': srcpath,
            'toDst': path.relative(dstdir, srcpath)
          })
        })
      }
    })
  }
}

function symlinkPathsSync (srcpath, dstpath) {
  let exists
  if (path.isAbsolute(srcpath)) {
    exists = fs.existsSync(srcpath)
    if (!exists) throw new Error('absolute srcpath does not exist')
    return {
      'toCwd': srcpath,
      'toDst': srcpath
    }
  } else {
    const dstdir = path.dirname(dstpath)
    const relativeToDst = path.join(dstdir, srcpath)
    exists = fs.existsSync(relativeToDst)
    if (exists) {
      return {
        'toCwd': relativeToDst,
        'toDst': srcpath
      }
    } else {
      exists = fs.existsSync(srcpath)
      if (!exists) throw new Error('relative srcpath does not exist')
      return {
        'toCwd': srcpath,
        'toDst': path.relative(dstdir, srcpath)
      }
    }
  }
}

module.exports = {
  symlinkPaths,
  symlinkPathsSync
}


/***/ }),

/***/ 18254:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(77758)

function symlinkType (srcpath, type, callback) {
  callback = (typeof type === 'function') ? type : callback
  type = (typeof type === 'function') ? false : type
  if (type) return callback(null, type)
  fs.lstat(srcpath, (err, stats) => {
    if (err) return callback(null, 'file')
    type = (stats && stats.isDirectory()) ? 'dir' : 'file'
    callback(null, type)
  })
}

function symlinkTypeSync (srcpath, type) {
  let stats

  if (type) return type
  try {
    stats = fs.lstatSync(srcpath)
  } catch (e) {
    return 'file'
  }
  return (stats && stats.isDirectory()) ? 'dir' : 'file'
}

module.exports = {
  symlinkType,
  symlinkTypeSync
}


/***/ }),

/***/ 72549:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = __webpack_require__(9046)/* .fromCallback */ .E
const path = __webpack_require__(85622)
const fs = __webpack_require__(77758)
const _mkdirs = __webpack_require__(98605)
const mkdirs = _mkdirs.mkdirs
const mkdirsSync = _mkdirs.mkdirsSync

const _symlinkPaths = __webpack_require__(53727)
const symlinkPaths = _symlinkPaths.symlinkPaths
const symlinkPathsSync = _symlinkPaths.symlinkPathsSync

const _symlinkType = __webpack_require__(18254)
const symlinkType = _symlinkType.symlinkType
const symlinkTypeSync = _symlinkType.symlinkTypeSync

const pathExists = __webpack_require__(43835).pathExists

function createSymlink (srcpath, dstpath, type, callback) {
  callback = (typeof type === 'function') ? type : callback
  type = (typeof type === 'function') ? false : type

  pathExists(dstpath, (err, destinationExists) => {
    if (err) return callback(err)
    if (destinationExists) return callback(null)
    symlinkPaths(srcpath, dstpath, (err, relative) => {
      if (err) return callback(err)
      srcpath = relative.toDst
      symlinkType(relative.toCwd, type, (err, type) => {
        if (err) return callback(err)
        const dir = path.dirname(dstpath)
        pathExists(dir, (err, dirExists) => {
          if (err) return callback(err)
          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)
          mkdirs(dir, err => {
            if (err) return callback(err)
            fs.symlink(srcpath, dstpath, type, callback)
          })
        })
      })
    })
  })
}

function createSymlinkSync (srcpath, dstpath, type) {
  const destinationExists = fs.existsSync(dstpath)
  if (destinationExists) return undefined

  const relative = symlinkPathsSync(srcpath, dstpath)
  srcpath = relative.toDst
  type = symlinkTypeSync(relative.toCwd, type)
  const dir = path.dirname(dstpath)
  const exists = fs.existsSync(dir)
  if (exists) return fs.symlinkSync(srcpath, dstpath, type)
  mkdirsSync(dir)
  return fs.symlinkSync(srcpath, dstpath, type)
}

module.exports = {
  createSymlink: u(createSymlink),
  createSymlinkSync
}


/***/ }),

/***/ 61176:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// This is adapted from https://github.com/normalize/mz
// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
const u = __webpack_require__(9046)/* .fromCallback */ .E
const fs = __webpack_require__(77758)

const api = [
  'access',
  'appendFile',
  'chmod',
  'chown',
  'close',
  'copyFile',
  'fchmod',
  'fchown',
  'fdatasync',
  'fstat',
  'fsync',
  'ftruncate',
  'futimes',
  'lchown',
  'lchmod',
  'link',
  'lstat',
  'mkdir',
  'mkdtemp',
  'open',
  'readFile',
  'readdir',
  'readlink',
  'realpath',
  'rename',
  'rmdir',
  'stat',
  'symlink',
  'truncate',
  'unlink',
  'utimes',
  'writeFile'
].filter(key => {
  // Some commands are not available on some systems. Ex:
  // fs.copyFile was added in Node.js v8.5.0
  // fs.mkdtemp was added in Node.js v5.10.0
  // fs.lchown is not available on at least some Linux
  return typeof fs[key] === 'function'
})

// Export all keys:
Object.keys(fs).forEach(key => {
  if (key === 'promises') {
    // fs.promises is a getter property that triggers ExperimentalWarning
    // Don't re-export it here, the getter is defined in "lib/index.js"
    return
  }
  exports[key] = fs[key]
})

// Universalify async methods:
api.forEach(method => {
  exports[method] = u(fs[method])
})

// We differ from mz/fs in that we still ship the old, broken, fs.exists()
// since we are a drop-in replacement for the native module
exports.exists = function (filename, callback) {
  if (typeof callback === 'function') {
    return fs.exists(filename, callback)
  }
  return new Promise(resolve => {
    return fs.exists(filename, resolve)
  })
}

// fs.read() & fs.write need special treatment due to multiple callback args

exports.read = function (fd, buffer, offset, length, position, callback) {
  if (typeof callback === 'function') {
    return fs.read(fd, buffer, offset, length, position, callback)
  }
  return new Promise((resolve, reject) => {
    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
      if (err) return reject(err)
      resolve({ bytesRead, buffer })
    })
  })
}

// Function signature can be
// fs.write(fd, buffer[, offset[, length[, position]]], callback)
// OR
// fs.write(fd, string[, position[, encoding]], callback)
// We need to handle both cases, so we use ...args
exports.write = function (fd, buffer, ...args) {
  if (typeof args[args.length - 1] === 'function') {
    return fs.write(fd, buffer, ...args)
  }

  return new Promise((resolve, reject) => {
    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
      if (err) return reject(err)
      resolve({ bytesWritten, buffer })
    })
  })
}


/***/ }),

/***/ 5630:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = Object.assign(
  {},
  // Export promiseified graceful-fs:
  __webpack_require__(61176),
  // Export extra methods:
  __webpack_require__(11135),
  __webpack_require__(61335),
  __webpack_require__(96970),
  __webpack_require__(40055),
  __webpack_require__(40213),
  __webpack_require__(98605),
  __webpack_require__(69665),
  __webpack_require__(41497),
  __webpack_require__(16570),
  __webpack_require__(43835),
  __webpack_require__(47357)
)

// Export fs.promises as a getter property so that we don't trigger
// ExperimentalWarning before fs.promises is actually accessed.
const fs = __webpack_require__(35747)
if (Object.getOwnPropertyDescriptor(fs, 'promises')) {
  Object.defineProperty(module.exports, "promises", ({
    get () { return fs.promises }
  }))
}


/***/ }),

/***/ 40213:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = __webpack_require__(9046)/* .fromCallback */ .E
const jsonFile = __webpack_require__(18970)

jsonFile.outputJson = u(__webpack_require__(60531))
jsonFile.outputJsonSync = __webpack_require__(19421)
// aliases
jsonFile.outputJSON = jsonFile.outputJson
jsonFile.outputJSONSync = jsonFile.outputJsonSync
jsonFile.writeJSON = jsonFile.writeJson
jsonFile.writeJSONSync = jsonFile.writeJsonSync
jsonFile.readJSON = jsonFile.readJson
jsonFile.readJSONSync = jsonFile.readJsonSync

module.exports = jsonFile


/***/ }),

/***/ 18970:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = __webpack_require__(9046)/* .fromCallback */ .E
const jsonFile = __webpack_require__(26160)

module.exports = {
  // jsonfile exports
  readJson: u(jsonFile.readFile),
  readJsonSync: jsonFile.readFileSync,
  writeJson: u(jsonFile.writeFile),
  writeJsonSync: jsonFile.writeFileSync
}


/***/ }),

/***/ 19421:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(77758)
const path = __webpack_require__(85622)
const mkdir = __webpack_require__(98605)
const jsonFile = __webpack_require__(18970)

function outputJsonSync (file, data, options) {
  const dir = path.dirname(file)

  if (!fs.existsSync(dir)) {
    mkdir.mkdirsSync(dir)
  }

  jsonFile.writeJsonSync(file, data, options)
}

module.exports = outputJsonSync


/***/ }),

/***/ 60531:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(85622)
const mkdir = __webpack_require__(98605)
const pathExists = __webpack_require__(43835).pathExists
const jsonFile = __webpack_require__(18970)

function outputJson (file, data, options, callback) {
  if (typeof options === 'function') {
    callback = options
    options = {}
  }

  const dir = path.dirname(file)

  pathExists(dir, (err, itDoes) => {
    if (err) return callback(err)
    if (itDoes) return jsonFile.writeJson(file, data, options, callback)

    mkdir.mkdirs(dir, err => {
      if (err) return callback(err)
      jsonFile.writeJson(file, data, options, callback)
    })
  })
}

module.exports = outputJson


/***/ }),

/***/ 98605:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const u = __webpack_require__(9046)/* .fromCallback */ .E
const mkdirs = u(__webpack_require__(59677))
const mkdirsSync = __webpack_require__(30684)

module.exports = {
  mkdirs,
  mkdirsSync,
  // alias
  mkdirp: mkdirs,
  mkdirpSync: mkdirsSync,
  ensureDir: mkdirs,
  ensureDirSync: mkdirsSync
}


/***/ }),

/***/ 30684:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(77758)
const path = __webpack_require__(85622)
const invalidWin32Path = __webpack_require__(71590).invalidWin32Path

const o777 = parseInt('0777', 8)

function mkdirsSync (p, opts, made) {
  if (!opts || typeof opts !== 'object') {
    opts = { mode: opts }
  }

  let mode = opts.mode
  const xfs = opts.fs || fs

  if (process.platform === 'win32' && invalidWin32Path(p)) {
    const errInval = new Error(p + ' contains invalid WIN32 path characters.')
    errInval.code = 'EINVAL'
    throw errInval
  }

  if (mode === undefined) {
    mode = o777 & (~process.umask())
  }
  if (!made) made = null

  p = path.resolve(p)

  try {
    xfs.mkdirSync(p, mode)
    made = made || p
  } catch (err0) {
    if (err0.code === 'ENOENT') {
      if (path.dirname(p) === p) throw err0
      made = mkdirsSync(path.dirname(p), opts, made)
      mkdirsSync(p, opts, made)
    } else {
      // In the case of any other error, just see if there's a dir there
      // already. If so, then hooray!  If not, then something is borked.
      let stat
      try {
        stat = xfs.statSync(p)
      } catch (err1) {
        throw err0
      }
      if (!stat.isDirectory()) throw err0
    }
  }

  return made
}

module.exports = mkdirsSync


/***/ }),

/***/ 59677:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(77758)
const path = __webpack_require__(85622)
const invalidWin32Path = __webpack_require__(71590).invalidWin32Path

const o777 = parseInt('0777', 8)

function mkdirs (p, opts, callback, made) {
  if (typeof opts === 'function') {
    callback = opts
    opts = {}
  } else if (!opts || typeof opts !== 'object') {
    opts = { mode: opts }
  }

  if (process.platform === 'win32' && invalidWin32Path(p)) {
    const errInval = new Error(p + ' contains invalid WIN32 path characters.')
    errInval.code = 'EINVAL'
    return callback(errInval)
  }

  let mode = opts.mode
  const xfs = opts.fs || fs

  if (mode === undefined) {
    mode = o777 & (~process.umask())
  }
  if (!made) made = null

  callback = callback || function () {}
  p = path.resolve(p)

  xfs.mkdir(p, mode, er => {
    if (!er) {
      made = made || p
      return callback(null, made)
    }
    switch (er.code) {
      case 'ENOENT':
        if (path.dirname(p) === p) return callback(er)
        mkdirs(path.dirname(p), opts, (er, made) => {
          if (er) callback(er, made)
          else mkdirs(p, opts, callback, made)
        })
        break

      // In the case of any other error, just see if there's a dir
      // there already.  If so, then hooray!  If not, then something
      // is borked.
      default:
        xfs.stat(p, (er2, stat) => {
          // if the stat fails, then that's super weird.
          // let the original error be the failure reason.
          if (er2 || !stat.isDirectory()) callback(er, made)
          else callback(null, made)
        })
        break
    }
  })
}

module.exports = mkdirs


/***/ }),

/***/ 71590:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(85622)

// get drive on windows
function getRootPath (p) {
  p = path.normalize(path.resolve(p)).split(path.sep)
  if (p.length > 0) return p[0]
  return null
}

// http://stackoverflow.com/a/62888/10333 contains more accurate
// TODO: expand to include the rest
const INVALID_PATH_CHARS = /[<>:"|?*]/

function invalidWin32Path (p) {
  const rp = getRootPath(p)
  p = p.replace(rp, '')
  return INVALID_PATH_CHARS.test(p)
}

module.exports = {
  getRootPath,
  invalidWin32Path
}


/***/ }),

/***/ 69665:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(77758)
const path = __webpack_require__(85622)
const copySync = __webpack_require__(11135).copySync
const removeSync = __webpack_require__(47357).removeSync
const mkdirpSync = __webpack_require__(98605).mkdirsSync
const buffer = __webpack_require__(47696)

function moveSync (src, dest, options) {
  options = options || {}
  const overwrite = options.overwrite || options.clobber || false

  src = path.resolve(src)
  dest = path.resolve(dest)

  if (src === dest) return fs.accessSync(src)

  if (isSrcSubdir(src, dest)) throw new Error(`Cannot move '${src}' into itself '${dest}'.`)

  mkdirpSync(path.dirname(dest))
  tryRenameSync()

  function tryRenameSync () {
    if (overwrite) {
      try {
        return fs.renameSync(src, dest)
      } catch (err) {
        if (err.code === 'ENOTEMPTY' || err.code === 'EEXIST' || err.code === 'EPERM') {
          removeSync(dest)
          options.overwrite = false // just overwriteed it, no need to do it again
          return moveSync(src, dest, options)
        }

        if (err.code !== 'EXDEV') throw err
        return moveSyncAcrossDevice(src, dest, overwrite)
      }
    } else {
      try {
        fs.linkSync(src, dest)
        return fs.unlinkSync(src)
      } catch (err) {
        if (err.code === 'EXDEV' || err.code === 'EISDIR' || err.code === 'EPERM' || err.code === 'ENOTSUP') {
          return moveSyncAcrossDevice(src, dest, overwrite)
        }
        throw err
      }
    }
  }
}

function moveSyncAcrossDevice (src, dest, overwrite) {
  const stat = fs.statSync(src)

  if (stat.isDirectory()) {
    return moveDirSyncAcrossDevice(src, dest, overwrite)
  } else {
    return moveFileSyncAcrossDevice(src, dest, overwrite)
  }
}

function moveFileSyncAcrossDevice (src, dest, overwrite) {
  const BUF_LENGTH = 64 * 1024
  const _buff = buffer(BUF_LENGTH)

  const flags = overwrite ? 'w' : 'wx'

  const fdr = fs.openSync(src, 'r')
  const stat = fs.fstatSync(fdr)
  const fdw = fs.openSync(dest, flags, stat.mode)
  let pos = 0

  while (pos < stat.size) {
    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)
    fs.writeSync(fdw, _buff, 0, bytesRead)
    pos += bytesRead
  }

  fs.closeSync(fdr)
  fs.closeSync(fdw)
  return fs.unlinkSync(src)
}

function moveDirSyncAcrossDevice (src, dest, overwrite) {
  const options = {
    overwrite: false
  }

  if (overwrite) {
    removeSync(dest)
    tryCopySync()
  } else {
    tryCopySync()
  }

  function tryCopySync () {
    copySync(src, dest, options)
    return removeSync(src)
  }
}

// return true if dest is a subdir of src, otherwise false.
// extract dest base dir and check if that is the same as src basename
function isSrcSubdir (src, dest) {
  try {
    return fs.statSync(src).isDirectory() &&
           src !== dest &&
           dest.indexOf(src) > -1 &&
           dest.split(path.dirname(src) + path.sep)[1].split(path.sep)[0] === path.basename(src)
  } catch (e) {
    return false
  }
}

module.exports = {
  moveSync
}


/***/ }),

/***/ 41497:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = __webpack_require__(9046)/* .fromCallback */ .E
const fs = __webpack_require__(77758)
const path = __webpack_require__(85622)
const copy = __webpack_require__(61335).copy
const remove = __webpack_require__(47357).remove
const mkdirp = __webpack_require__(98605).mkdirp
const pathExists = __webpack_require__(43835).pathExists

function move (src, dest, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }

  const overwrite = opts.overwrite || opts.clobber || false

  src = path.resolve(src)
  dest = path.resolve(dest)

  if (src === dest) return fs.access(src, cb)

  fs.stat(src, (err, st) => {
    if (err) return cb(err)

    if (st.isDirectory() && isSrcSubdir(src, dest)) {
      return cb(new Error(`Cannot move '${src}' to a subdirectory of itself, '${dest}'.`))
    }
    mkdirp(path.dirname(dest), err => {
      if (err) return cb(err)
      return doRename(src, dest, overwrite, cb)
    })
  })
}

function doRename (src, dest, overwrite, cb) {
  if (overwrite) {
    return remove(dest, err => {
      if (err) return cb(err)
      return rename(src, dest, overwrite, cb)
    })
  }
  pathExists(dest, (err, destExists) => {
    if (err) return cb(err)
    if (destExists) return cb(new Error('dest already exists.'))
    return rename(src, dest, overwrite, cb)
  })
}

function rename (src, dest, overwrite, cb) {
  fs.rename(src, dest, err => {
    if (!err) return cb()
    if (err.code !== 'EXDEV') return cb(err)
    return moveAcrossDevice(src, dest, overwrite, cb)
  })
}

function moveAcrossDevice (src, dest, overwrite, cb) {
  const opts = {
    overwrite,
    errorOnExist: true
  }

  copy(src, dest, opts, err => {
    if (err) return cb(err)
    return remove(src, cb)
  })
}

function isSrcSubdir (src, dest) {
  const srcArray = src.split(path.sep)
  const destArray = dest.split(path.sep)

  return srcArray.reduce((acc, current, i) => {
    return acc && destArray[i] === current
  }, true)
}

module.exports = {
  move: u(move)
}


/***/ }),

/***/ 16570:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = __webpack_require__(9046)/* .fromCallback */ .E
const fs = __webpack_require__(77758)
const path = __webpack_require__(85622)
const mkdir = __webpack_require__(98605)
const pathExists = __webpack_require__(43835).pathExists

function outputFile (file, data, encoding, callback) {
  if (typeof encoding === 'function') {
    callback = encoding
    encoding = 'utf8'
  }

  const dir = path.dirname(file)
  pathExists(dir, (err, itDoes) => {
    if (err) return callback(err)
    if (itDoes) return fs.writeFile(file, data, encoding, callback)

    mkdir.mkdirs(dir, err => {
      if (err) return callback(err)

      fs.writeFile(file, data, encoding, callback)
    })
  })
}

function outputFileSync (file, ...args) {
  const dir = path.dirname(file)
  if (fs.existsSync(dir)) {
    return fs.writeFileSync(file, ...args)
  }
  mkdir.mkdirsSync(dir)
  fs.writeFileSync(file, ...args)
}

module.exports = {
  outputFile: u(outputFile),
  outputFileSync
}


/***/ }),

/***/ 43835:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const u = __webpack_require__(9046)/* .fromPromise */ .p
const fs = __webpack_require__(61176)

function pathExists (path) {
  return fs.access(path).then(() => true).catch(() => false)
}

module.exports = {
  pathExists: u(pathExists),
  pathExistsSync: fs.existsSync
}


/***/ }),

/***/ 47357:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = __webpack_require__(9046)/* .fromCallback */ .E
const rimraf = __webpack_require__(38761)

module.exports = {
  remove: u(rimraf),
  removeSync: rimraf.sync
}


/***/ }),

/***/ 38761:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(77758)
const path = __webpack_require__(85622)
const assert = __webpack_require__(42357)

const isWindows = (process.platform === 'win32')

function defaults (options) {
  const methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ]
  methods.forEach(m => {
    options[m] = options[m] || fs[m]
    m = m + 'Sync'
    options[m] = options[m] || fs[m]
  })

  options.maxBusyTries = options.maxBusyTries || 3
}

function rimraf (p, options, cb) {
  let busyTries = 0

  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  assert(p, 'rimraf: missing path')
  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')
  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')
  assert(options, 'rimraf: invalid options argument provided')
  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')

  defaults(options)

  rimraf_(p, options, function CB (er) {
    if (er) {
      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&
          busyTries < options.maxBusyTries) {
        busyTries++
        const time = busyTries * 100
        // try again, with the same exact callback as this one.
        return setTimeout(() => rimraf_(p, options, CB), time)
      }

      // already gone
      if (er.code === 'ENOENT') er = null
    }

    cb(er)
  })
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_ (p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, (er, st) => {
    if (er && er.code === 'ENOENT') {
      return cb(null)
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === 'EPERM' && isWindows) {
      return fixWinEPERM(p, options, er, cb)
    }

    if (st && st.isDirectory()) {
      return rmdir(p, options, er, cb)
    }

    options.unlink(p, er => {
      if (er) {
        if (er.code === 'ENOENT') {
          return cb(null)
        }
        if (er.code === 'EPERM') {
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        }
        if (er.code === 'EISDIR') {
          return rmdir(p, options, er, cb)
        }
      }
      return cb(er)
    })
  })
}

function fixWinEPERM (p, options, er, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')
  if (er) {
    assert(er instanceof Error)
  }

  options.chmod(p, 0o666, er2 => {
    if (er2) {
      cb(er2.code === 'ENOENT' ? null : er)
    } else {
      options.stat(p, (er3, stats) => {
        if (er3) {
          cb(er3.code === 'ENOENT' ? null : er)
        } else if (stats.isDirectory()) {
          rmdir(p, options, er, cb)
        } else {
          options.unlink(p, cb)
        }
      })
    }
  })
}

function fixWinEPERMSync (p, options, er) {
  let stats

  assert(p)
  assert(options)
  if (er) {
    assert(er instanceof Error)
  }

  try {
    options.chmodSync(p, 0o666)
  } catch (er2) {
    if (er2.code === 'ENOENT') {
      return
    } else {
      throw er
    }
  }

  try {
    stats = options.statSync(p)
  } catch (er3) {
    if (er3.code === 'ENOENT') {
      return
    } else {
      throw er
    }
  }

  if (stats.isDirectory()) {
    rmdirSync(p, options, er)
  } else {
    options.unlinkSync(p)
  }
}

function rmdir (p, options, originalEr, cb) {
  assert(p)
  assert(options)
  if (originalEr) {
    assert(originalEr instanceof Error)
  }
  assert(typeof cb === 'function')

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, er => {
    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {
      rmkids(p, options, cb)
    } else if (er && er.code === 'ENOTDIR') {
      cb(originalEr)
    } else {
      cb(er)
    }
  })
}

function rmkids (p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.readdir(p, (er, files) => {
    if (er) return cb(er)

    let n = files.length
    let errState

    if (n === 0) return options.rmdir(p, cb)

    files.forEach(f => {
      rimraf(path.join(p, f), options, er => {
        if (errState) {
          return
        }
        if (er) return cb(errState = er)
        if (--n === 0) {
          options.rmdir(p, cb)
        }
      })
    })
  })
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync (p, options) {
  let st

  options = options || {}
  defaults(options)

  assert(p, 'rimraf: missing path')
  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')
  assert(options, 'rimraf: missing options')
  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')

  try {
    st = options.lstatSync(p)
  } catch (er) {
    if (er.code === 'ENOENT') {
      return
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er.code === 'EPERM' && isWindows) {
      fixWinEPERMSync(p, options, er)
    }
  }

  try {
    // sunos lets the root user unlink directories, which is... weird.
    if (st && st.isDirectory()) {
      rmdirSync(p, options, null)
    } else {
      options.unlinkSync(p)
    }
  } catch (er) {
    if (er.code === 'ENOENT') {
      return
    } else if (er.code === 'EPERM') {
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
    } else if (er.code !== 'EISDIR') {
      throw er
    }
    rmdirSync(p, options, er)
  }
}

function rmdirSync (p, options, originalEr) {
  assert(p)
  assert(options)
  if (originalEr) {
    assert(originalEr instanceof Error)
  }

  try {
    options.rmdirSync(p)
  } catch (er) {
    if (er.code === 'ENOTDIR') {
      throw originalEr
    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {
      rmkidsSync(p, options)
    } else if (er.code !== 'ENOENT') {
      throw er
    }
  }
}

function rmkidsSync (p, options) {
  assert(p)
  assert(options)
  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))

  if (isWindows) {
    // We only end up here once we got ENOTEMPTY at least once, and
    // at this point, we are guaranteed to have removed all the kids.
    // So, we know that it won't be ENOENT or ENOTDIR or anything else.
    // try really hard to delete stuff on windows, because it has a
    // PROFOUNDLY annoying habit of not closing handles promptly when
    // files are deleted, resulting in spurious ENOTEMPTY errors.
    const startTime = Date.now()
    do {
      try {
        const ret = options.rmdirSync(p, options)
        return ret
      } catch (er) { }
    } while (Date.now() - startTime < 500) // give up after 500ms
  } else {
    const ret = options.rmdirSync(p, options)
    return ret
  }
}

module.exports = rimraf
rimraf.sync = rimrafSync


/***/ }),

/***/ 47696:
/***/ ((module) => {

"use strict";

/* eslint-disable node/no-deprecated-api */
module.exports = function (size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    try {
      return Buffer.allocUnsafe(size)
    } catch (e) {
      return new Buffer(size)
    }
  }
  return new Buffer(size)
}


/***/ }),

/***/ 52548:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(77758)
const os = __webpack_require__(12087)
const path = __webpack_require__(85622)

// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not
function hasMillisResSync () {
  let tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2))
  tmpfile = path.join(os.tmpdir(), tmpfile)

  // 550 millis past UNIX epoch
  const d = new Date(1435410243862)
  fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141')
  const fd = fs.openSync(tmpfile, 'r+')
  fs.futimesSync(fd, d, d)
  fs.closeSync(fd)
  return fs.statSync(tmpfile).mtime > 1435410243000
}

function hasMillisRes (callback) {
  let tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2))
  tmpfile = path.join(os.tmpdir(), tmpfile)

  // 550 millis past UNIX epoch
  const d = new Date(1435410243862)
  fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', err => {
    if (err) return callback(err)
    fs.open(tmpfile, 'r+', (err, fd) => {
      if (err) return callback(err)
      fs.futimes(fd, d, d, err => {
        if (err) return callback(err)
        fs.close(fd, err => {
          if (err) return callback(err)
          fs.stat(tmpfile, (err, stats) => {
            if (err) return callback(err)
            callback(null, stats.mtime > 1435410243000)
          })
        })
      })
    })
  })
}

function timeRemoveMillis (timestamp) {
  if (typeof timestamp === 'number') {
    return Math.floor(timestamp / 1000) * 1000
  } else if (timestamp instanceof Date) {
    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)
  } else {
    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')
  }
}

function utimesMillis (path, atime, mtime, callback) {
  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
  fs.open(path, 'r+', (err, fd) => {
    if (err) return callback(err)
    fs.futimes(fd, atime, mtime, futimesErr => {
      fs.close(fd, closeErr => {
        if (callback) callback(futimesErr || closeErr)
      })
    })
  })
}

function utimesMillisSync (path, atime, mtime) {
  const fd = fs.openSync(path, 'r+')
  fs.futimesSync(fd, atime, mtime)
  return fs.closeSync(fd)
}

module.exports = {
  hasMillisRes,
  hasMillisResSync,
  timeRemoveMillis,
  utimesMillis,
  utimesMillisSync
}


/***/ }),

/***/ 27714:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

const MiniPass = __webpack_require__(41077)
const EE = __webpack_require__(28614).EventEmitter
const fs = __webpack_require__(35747)

let writev = fs.writev
/* istanbul ignore next */
if (!writev) {
  // This entire block can be removed if support for earlier than Node.js
  // 12.9.0 is not needed.
  const binding = process.binding('fs')
  const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback

  writev = (fd, iovec, pos, cb) => {
    const done = (er, bw) => cb(er, bw, iovec)
    const req = new FSReqWrap()
    req.oncomplete = done
    binding.writeBuffers(fd, iovec, pos, req)
  }
}

const _autoClose = Symbol('_autoClose')
const _close = Symbol('_close')
const _ended = Symbol('_ended')
const _fd = Symbol('_fd')
const _finished = Symbol('_finished')
const _flags = Symbol('_flags')
const _flush = Symbol('_flush')
const _handleChunk = Symbol('_handleChunk')
const _makeBuf = Symbol('_makeBuf')
const _mode = Symbol('_mode')
const _needDrain = Symbol('_needDrain')
const _onerror = Symbol('_onerror')
const _onopen = Symbol('_onopen')
const _onread = Symbol('_onread')
const _onwrite = Symbol('_onwrite')
const _open = Symbol('_open')
const _path = Symbol('_path')
const _pos = Symbol('_pos')
const _queue = Symbol('_queue')
const _read = Symbol('_read')
const _readSize = Symbol('_readSize')
const _reading = Symbol('_reading')
const _remain = Symbol('_remain')
const _size = Symbol('_size')
const _write = Symbol('_write')
const _writing = Symbol('_writing')
const _defaultFlag = Symbol('_defaultFlag')
const _errored = Symbol('_errored')

class ReadStream extends MiniPass {
  constructor (path, opt) {
    opt = opt || {}
    super(opt)

    this.readable = true
    this.writable = false

    if (typeof path !== 'string')
      throw new TypeError('path must be a string')

    this[_errored] = false
    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null
    this[_path] = path
    this[_readSize] = opt.readSize || 16*1024*1024
    this[_reading] = false
    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity
    this[_remain] = this[_size]
    this[_autoClose] = typeof opt.autoClose === 'boolean' ?
      opt.autoClose : true

    if (typeof this[_fd] === 'number')
      this[_read]()
    else
      this[_open]()
  }

  get fd () { return this[_fd] }
  get path () { return this[_path] }

  write () {
    throw new TypeError('this is a readable stream')
  }

  end () {
    throw new TypeError('this is a readable stream')
  }

  [_open] () {
    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd))
  }

  [_onopen] (er, fd) {
    if (er)
      this[_onerror](er)
    else {
      this[_fd] = fd
      this.emit('open', fd)
      this[_read]()
    }
  }

  [_makeBuf] () {
    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]))
  }

  [_read] () {
    if (!this[_reading]) {
      this[_reading] = true
      const buf = this[_makeBuf]()
      /* istanbul ignore if */
      if (buf.length === 0)
        return process.nextTick(() => this[_onread](null, 0, buf))
      fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) =>
        this[_onread](er, br, buf))
    }
  }

  [_onread] (er, br, buf) {
    this[_reading] = false
    if (er)
      this[_onerror](er)
    else if (this[_handleChunk](br, buf))
      this[_read]()
  }

  [_close] () {
    if (this[_autoClose] && typeof this[_fd] === 'number') {
      const fd = this[_fd]
      this[_fd] = null
      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))
    }
  }

  [_onerror] (er) {
    this[_reading] = true
    this[_close]()
    this.emit('error', er)
  }

  [_handleChunk] (br, buf) {
    let ret = false
    // no effect if infinite
    this[_remain] -= br
    if (br > 0)
      ret = super.write(br < buf.length ? buf.slice(0, br) : buf)

    if (br === 0 || this[_remain] <= 0) {
      ret = false
      this[_close]()
      super.end()
    }

    return ret
  }

  emit (ev, data) {
    switch (ev) {
      case 'prefinish':
      case 'finish':
        break

      case 'drain':
        if (typeof this[_fd] === 'number')
          this[_read]()
        break

      case 'error':
        if (this[_errored])
          return
        this[_errored] = true
        return super.emit(ev, data)

      default:
        return super.emit(ev, data)
    }
  }
}

class ReadStreamSync extends ReadStream {
  [_open] () {
    let threw = true
    try {
      this[_onopen](null, fs.openSync(this[_path], 'r'))
      threw = false
    } finally {
      if (threw)
        this[_close]()
    }
  }

  [_read] () {
    let threw = true
    try {
      if (!this[_reading]) {
        this[_reading] = true
        do {
          const buf = this[_makeBuf]()
          /* istanbul ignore next */
          const br = buf.length === 0 ? 0
            : fs.readSync(this[_fd], buf, 0, buf.length, null)
          if (!this[_handleChunk](br, buf))
            break
        } while (true)
        this[_reading] = false
      }
      threw = false
    } finally {
      if (threw)
        this[_close]()
    }
  }

  [_close] () {
    if (this[_autoClose] && typeof this[_fd] === 'number') {
      const fd = this[_fd]
      this[_fd] = null
      fs.closeSync(fd)
      this.emit('close')
    }
  }
}

class WriteStream extends EE {
  constructor (path, opt) {
    opt = opt || {}
    super(opt)
    this.readable = false
    this.writable = true
    this[_errored] = false
    this[_writing] = false
    this[_ended] = false
    this[_needDrain] = false
    this[_queue] = []
    this[_path] = path
    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null
    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode
    this[_pos] = typeof opt.start === 'number' ? opt.start : null
    this[_autoClose] = typeof opt.autoClose === 'boolean' ?
      opt.autoClose : true

    // truncating makes no sense when writing into the middle
    const defaultFlag = this[_pos] !== null ? 'r+' : 'w'
    this[_defaultFlag] = opt.flags === undefined
    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags

    if (this[_fd] === null)
      this[_open]()
  }

  emit (ev, data) {
    if (ev === 'error') {
      if (this[_errored])
        return
      this[_errored] = true
    }
    return super.emit(ev, data)
  }


  get fd () { return this[_fd] }
  get path () { return this[_path] }

  [_onerror] (er) {
    this[_close]()
    this[_writing] = true
    this.emit('error', er)
  }

  [_open] () {
    fs.open(this[_path], this[_flags], this[_mode],
      (er, fd) => this[_onopen](er, fd))
  }

  [_onopen] (er, fd) {
    if (this[_defaultFlag] &&
        this[_flags] === 'r+' &&
        er && er.code === 'ENOENT') {
      this[_flags] = 'w'
      this[_open]()
    } else if (er)
      this[_onerror](er)
    else {
      this[_fd] = fd
      this.emit('open', fd)
      this[_flush]()
    }
  }

  end (buf, enc) {
    if (buf)
      this.write(buf, enc)

    this[_ended] = true

    // synthetic after-write logic, where drain/finish live
    if (!this[_writing] && !this[_queue].length &&
        typeof this[_fd] === 'number')
      this[_onwrite](null, 0)
    return this
  }

  write (buf, enc) {
    if (typeof buf === 'string')
      buf = Buffer.from(buf, enc)

    if (this[_ended]) {
      this.emit('error', new Error('write() after end()'))
      return false
    }

    if (this[_fd] === null || this[_writing] || this[_queue].length) {
      this[_queue].push(buf)
      this[_needDrain] = true
      return false
    }

    this[_writing] = true
    this[_write](buf)
    return true
  }

  [_write] (buf) {
    fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) =>
      this[_onwrite](er, bw))
  }

  [_onwrite] (er, bw) {
    if (er)
      this[_onerror](er)
    else {
      if (this[_pos] !== null)
        this[_pos] += bw
      if (this[_queue].length)
        this[_flush]()
      else {
        this[_writing] = false

        if (this[_ended] && !this[_finished]) {
          this[_finished] = true
          this[_close]()
          this.emit('finish')
        } else if (this[_needDrain]) {
          this[_needDrain] = false
          this.emit('drain')
        }
      }
    }
  }

  [_flush] () {
    if (this[_queue].length === 0) {
      if (this[_ended])
        this[_onwrite](null, 0)
    } else if (this[_queue].length === 1)
      this[_write](this[_queue].pop())
    else {
      const iovec = this[_queue]
      this[_queue] = []
      writev(this[_fd], iovec, this[_pos],
        (er, bw) => this[_onwrite](er, bw))
    }
  }

  [_close] () {
    if (this[_autoClose] && typeof this[_fd] === 'number') {
      const fd = this[_fd]
      this[_fd] = null
      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))
    }
  }
}

class WriteStreamSync extends WriteStream {
  [_open] () {
    let fd
    // only wrap in a try{} block if we know we'll retry, to avoid
    // the rethrow obscuring the error's source frame in most cases.
    if (this[_defaultFlag] && this[_flags] === 'r+') {
      try {
        fd = fs.openSync(this[_path], this[_flags], this[_mode])
      } catch (er) {
        if (er.code === 'ENOENT') {
          this[_flags] = 'w'
          return this[_open]()
        } else
          throw er
      }
    } else
      fd = fs.openSync(this[_path], this[_flags], this[_mode])

    this[_onopen](null, fd)
  }

  [_close] () {
    if (this[_autoClose] && typeof this[_fd] === 'number') {
      const fd = this[_fd]
      this[_fd] = null
      fs.closeSync(fd)
      this.emit('close')
    }
  }

  [_write] (buf) {
    // throw the original, but try to close if it fails
    let threw = true
    try {
      this[_onwrite](null,
        fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]))
      threw = false
    } finally {
      if (threw)
        try { this[_close]() } catch (_) {}
    }
  }
}

exports.ReadStream = ReadStream
exports.ReadStreamSync = ReadStreamSync

exports.WriteStream = WriteStream
exports.WriteStreamSync = WriteStreamSync


/***/ }),

/***/ 57640:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var fs   = __webpack_require__(35747);
var path = __webpack_require__(85622);
var zlib = __webpack_require__(78761);

var GIT_DIR = '.git';

function changeGitDir(newDirName) {
  GIT_DIR = newDirName;
}

function findRepoHandleLinkedWorktree(gitPath) {
  var stat = fs.statSync(gitPath);
  var root = path.dirname(path.resolve(gitPath));
  if (stat.isDirectory()) {
    return {
      // for the base (non-linked) dir, there is no distinction between where we
      // find the HEAD file and where we find the rest of .git
      worktreeGitDir: gitPath,
      commonGitDir: gitPath,
      root: root,
    };
  } else {
    // We have a file that tells us where to find the worktree git dir.  Once we
    // look there we'll know how to find the common git dir, depending on
    // whether it's a linked worktree git dir, or a submodule dir

    var linkedGitDir = fs.readFileSync(gitPath).toString();
    var absolutePath=path.resolve(path.dirname(gitPath));
    var worktreeGitDirUnresolved = /gitdir: (.*)/.exec(linkedGitDir)[1];
    var worktreeGitDir = path.resolve(absolutePath,worktreeGitDirUnresolved);
    var commonDirPath = path.join(worktreeGitDir, 'commondir');
    if (fs.existsSync(commonDirPath)) {
      // this directory contains a `commondir` file; we're in a linked worktree

      var commonDirRelative = fs.readFileSync(commonDirPath).toString().replace(/\r?\n$/, '');
      var commonDir = path.resolve(path.join(worktreeGitDir, commonDirRelative));

      return {
        worktreeGitDir: worktreeGitDir,
        commonGitDir: commonDir,
        root: path.dirname(commonDir),
      };
    } else {
      // there is no `commondir` file; we're in a submodule
      return {
        worktreeGitDir: worktreeGitDir,
        commonGitDir: worktreeGitDir,
        root: root,
      };
    }
  }
}

function findRepo(startingPath) {
  var gitPath, lastPath;
  var currentPath = startingPath;

  if (!currentPath) { currentPath = process.cwd(); }

  do {
    gitPath = path.join(currentPath, GIT_DIR);

    if (fs.existsSync(gitPath)) {
      return findRepoHandleLinkedWorktree(gitPath);
    }

    lastPath = currentPath;
    currentPath = path.resolve(currentPath, '..');
  } while (lastPath !== currentPath);

  return null;
}

function findPackedTags(gitPath, refPath) {
  return getPackedRefsForType(gitPath, refPath, 'tag');
}

function findPackedCommit(gitPath, refPath) {
  return getPackedRefsForType(gitPath, refPath, 'commit')[0];
}

function getPackedRefsForType(gitPath, refPath, type) {
  var packedRefsFile = getPackedRefsFile(gitPath);
  if (packedRefsFile) {
    return getLinesForRefPath(packedRefsFile, type, refPath).map(function(shaLine) {
      return getShaBasedOnType(type, shaLine);
    });
  }
  return [];
}

function getPackedRefsFile(gitPath) {
  var packedRefsFilePath = path.join(gitPath, 'packed-refs');
  return fs.existsSync(packedRefsFilePath) ? fs.readFileSync(packedRefsFilePath, { encoding: 'utf8' }) : false;
}

function getLinesForRefPath(packedRefsFile, type, refPath) {
  return packedRefsFile.split(/\r?\n/).reduce(function(acc, line, idx, arr) {
    var targetLine = line.indexOf('^') > -1 ? arr[idx-1] : line;
    return doesLineMatchRefPath(type, line, refPath) ? acc.concat(targetLine) : acc;
  }, []);
}

function doesLineMatchRefPath(type, line, refPath) {
  var refPrefix = type === 'tag' ? 'refs/tags' : 'refs/heads';
  return (line.indexOf(refPrefix) > -1 || line.indexOf('^') > -1) && line.indexOf(refPath) > -1;
}

function getShaBasedOnType(type, shaLine) {
  var shaResult = '';
  if (type === 'tag') {
    shaResult = shaLine.split('tags/')[1];
  } else if (type === 'commit') {
    shaResult = shaLine.split(' ')[0];
  }

  return shaResult;
}

function commitForTag(gitPath, tag) {
  var tagPath = path.join(gitPath, 'refs', 'tags', tag);
  var taggedObject = fs.readFileSync(tagPath, { encoding: 'utf8' }).trim();
  var objectPath = path.join(gitPath, 'objects', taggedObject.slice(0, 2), taggedObject.slice(2));

  if (!zlib.inflateSync || !fs.existsSync(objectPath)) {
    // we cannot support annotated tags on node v0.10 because
    // zlib does not allow sync access
    return taggedObject;
  }

  var objectContents = zlib.inflateSync(fs.readFileSync(objectPath)).toString();

  // 'tag 172\u0000object c1ee41c325d54f410b133e0018c7a6b1316f6cda\ntype commit\ntag awesome-tag\ntagger Robert Jackson
  // <robert.w.jackson@me.com> 1429100021 -0400\n\nI am making an annotated tag.\n'
  if (objectContents.slice(0,3) === 'tag') {
    var sections = objectContents.split(/\0|\r?\n/);
    var sha = sections[1].slice(7);

    return sha;
  } else {
    // this will return the tag for lightweight tags
    return taggedObject;
  }
}

function findTag(gitPath, sha) {
  var tags = findPackedTags(gitPath, sha)
    .concat(findUnpackedTags(gitPath, sha));
  tags.sort();
  return tags.length ? tags[0] : false;
}

var LAST_TAG_CACHE = {};

function findLastTagCached(gitPath, sha, commitsSinceLastTag) {
  if(!LAST_TAG_CACHE[gitPath]) {
    LAST_TAG_CACHE[gitPath] = {};
  }

  if(!LAST_TAG_CACHE[gitPath][sha]) {
    LAST_TAG_CACHE[gitPath][sha] = findLastTag(gitPath, sha, commitsSinceLastTag);
  }

  return LAST_TAG_CACHE[gitPath][sha];
}

function findLastTag(gitPath, sha, commitsSinceLastTag) {
  commitsSinceLastTag = commitsSinceLastTag || 0;
  var tag = findTag(gitPath, sha);
  if(!tag) {
    var commitData = getCommitData(gitPath, sha);
    if(!commitData) {
      return { tag: null, commitsSinceLastTag: Infinity };
    }
    return commitData.parents
      .map(parent => findLastTag(gitPath, parent, commitsSinceLastTag + 1))
      .reduce((a,b) => {
        return a.commitsSinceLastTag < b.commitsSinceLastTag ? a : b;
      }, { commitsSinceLastTag: Infinity });
  }
  return {
    tag: tag,
    commitsSinceLastTag: commitsSinceLastTag
  };
}

function findUnpackedTags(gitPath, sha) {
  var unpackedTags = [];
  var tags = findLooseRefsForType(gitPath, 'tags');
  for (var i = 0, l = tags.length; i < l; i++) {
    var commitAtTag = commitForTag(gitPath, tags[i]);
    if (commitAtTag === sha) {
      unpackedTags.push(tags[i]);
    }
  }
  return unpackedTags;
}

function findLooseRefsForType(gitPath, type) {
  var refsPath = path.join(gitPath, 'refs', type);
  return fs.existsSync(refsPath) ? fs.readdirSync(refsPath) : [];
}

module.exports = function(gitPath) {
  var gitPathInfo = findRepo(gitPath);

  var result = {
    sha: null,
    abbreviatedSha: null,
    branch: null,
    tag: null,
    committer: null,
    committerDate: null,
    author: null,
    authorDate: null,
    commitMessage: null,
    root: null,
    commonGitDir: null,
    worktreeGitDir: null,
    lastTag: null,
    commitsSinceLastTag: 0,
  };

  if (!gitPathInfo) { return result; }

  try {
    result.root = gitPathInfo.root;
    result.commonGitDir = gitPathInfo.commonGitDir;
    result.worktreeGitDir = gitPathInfo.worktreeGitDir;

    var headFilePath = path.join(gitPathInfo.worktreeGitDir, 'HEAD');

    if (fs.existsSync(headFilePath)) {
      var headFile = fs.readFileSync(headFilePath, {encoding: 'utf8'});
      var branchName = headFile.split('/').slice(2).join('/').trim();
      if (!branchName) {
        branchName = headFile.split('/').slice(-1)[0].trim();
      }
      var refPath = headFile.split(' ')[1];

      // Find branch and SHA
      if (refPath) {
        refPath = refPath.trim();
        var branchPath = path.join(gitPathInfo.commonGitDir, refPath);

        result.branch  = branchName;
        if (fs.existsSync(branchPath)) {
          result.sha = fs.readFileSync(branchPath, { encoding: 'utf8' }).trim();
        } else {
          result.sha = findPackedCommit(gitPathInfo.commonGitDir, refPath);
        }
      } else {
        result.sha = branchName;
      }

      result.abbreviatedSha = result.sha.slice(0,10);

      // Find commit data
      var commitData = getCommitData(gitPathInfo.commonGitDir, result.sha);
      if (commitData) {
        result = Object.keys(commitData).reduce(function(r, key) {
          result[key] = commitData[key];
          return result;
        }, result);
      }

      // Find tag
      var tag = findTag(gitPathInfo.commonGitDir, result.sha);
      if (tag) {
        result.tag = tag;
      }

      var lastTagInfo = findLastTagCached(gitPathInfo.commonGitDir, result.sha);
      result.lastTag = lastTagInfo.tag;
      result.commitsSinceLastTag = lastTagInfo.commitsSinceLastTag;
    }
  } catch (e) {
    if (!module.exports._suppressErrors) {
      throw e; // helps with testing and scenarios where we do not expect errors
    } else {
      // eat the error
    }
  }

  return result;
};

module.exports._suppressErrors = true;
module.exports._findRepo     = findRepo;
module.exports._changeGitDir = changeGitDir;

function getCommitData(gitPath, sha) {
  var objectPath = path.join(gitPath, 'objects', sha.slice(0, 2), sha.slice(2));

  if (zlib.inflateSync && fs.existsSync(objectPath)) {
    var objectContents = zlib.inflateSync(fs.readFileSync(objectPath)).toString();

    return objectContents.split(/\0|\r?\n/)
      .filter(function(item) {
        return !!item;
      })
      .reduce(function(data, section) {
        var part = section.slice(0, section.indexOf(' ')).trim();

        switch(part) {
          case 'commit':
          case 'tag':
          case 'object':
          case 'type':
          case 'tree':
            //ignore these for now
            break;
          case 'author':
          case 'committer':
            var parts = section.match(/^(?:author|committer)\s(.+)\s(\d+\s(?:\+|\-)\d{4})$/);

            if (parts) {
              data[part] = parts[1];
              data[part + 'Date'] = parseDate(parts[2]);
            }
            break;
          case 'parent':
            data.parents = section.split(/\r?\n/).map(p => p.split(' ')[1]);
            break;
          default:
            //should just be the commit message left
            data.commitMessage = section;
        }

        return data;
      }, {});
  }
}

function parseDate(d) {
  var epoch = d.split(' ')[0];
  return new Date(epoch * 1000).toISOString();
}


/***/ }),

/***/ 67356:
/***/ ((module) => {

"use strict";


module.exports = clone

var getPrototypeOf = Object.getPrototypeOf || function (obj) {
  return obj.__proto__
}

function clone (obj) {
  if (obj === null || typeof obj !== 'object')
    return obj

  if (obj instanceof Object)
    var copy = { __proto__: getPrototypeOf(obj) }
  else
    var copy = Object.create(null)

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))
  })

  return copy
}


/***/ }),

/***/ 77758:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(35747)
var polyfills = __webpack_require__(20263)
var legacy = __webpack_require__(73086)
var clone = __webpack_require__(67356)

var util = __webpack_require__(31669)

/* istanbul ignore next - node 0.x polyfill */
var gracefulQueue
var previousSymbol

/* istanbul ignore else - node 0.x polyfill */
if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
  gracefulQueue = Symbol.for('graceful-fs.queue')
  // This is used in testing by future versions
  previousSymbol = Symbol.for('graceful-fs.previous')
} else {
  gracefulQueue = '___graceful-fs.queue'
  previousSymbol = '___graceful-fs.previous'
}

function noop () {}

function publishQueue(context, queue) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue
    }
  })
}

var debug = noop
if (util.debuglog)
  debug = util.debuglog('gfs4')
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
  debug = function() {
    var m = util.format.apply(util, arguments)
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ')
    console.error(m)
  }

// Once time initialization
if (!fs[gracefulQueue]) {
  // This queue can be shared by multiple loaded instances
  var queue = global[gracefulQueue] || []
  publishQueue(fs, queue)

  // Patch fs.close/closeSync to shared queue version, because we need
  // to retry() whenever a close happens *anywhere* in the program.
  // This is essential when multiple graceful-fs instances are
  // in play at the same time.
  fs.close = (function (fs$close) {
    function close (fd, cb) {
      return fs$close.call(fs, fd, function (err) {
        // This function uses the graceful-fs shared queue
        if (!err) {
          retry()
        }

        if (typeof cb === 'function')
          cb.apply(this, arguments)
      })
    }

    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    })
    return close
  })(fs.close)

  fs.closeSync = (function (fs$closeSync) {
    function closeSync (fd) {
      // This function uses the graceful-fs shared queue
      fs$closeSync.apply(fs, arguments)
      retry()
    }

    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    })
    return closeSync
  })(fs.closeSync)

  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
    process.on('exit', function() {
      debug(fs[gracefulQueue])
      __webpack_require__(42357).equal(fs[gracefulQueue].length, 0)
    })
  }
}

if (!global[gracefulQueue]) {
  publishQueue(global, fs[gracefulQueue]);
}

module.exports = patch(clone(fs))
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs)
    fs.__patched = true;
}

function patch (fs) {
  // Everything that references the open() function needs to be in here
  polyfills(fs)
  fs.gracefulify = patch

  fs.createReadStream = createReadStream
  fs.createWriteStream = createWriteStream
  var fs$readFile = fs.readFile
  fs.readFile = readFile
  function readFile (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$readFile(path, options, cb)

    function go$readFile (path, options, cb) {
      return fs$readFile(path, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$readFile, [path, options, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  var fs$writeFile = fs.writeFile
  fs.writeFile = writeFile
  function writeFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$writeFile(path, data, options, cb)

    function go$writeFile (path, data, options, cb) {
      return fs$writeFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$writeFile, [path, data, options, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  var fs$appendFile = fs.appendFile
  if (fs$appendFile)
    fs.appendFile = appendFile
  function appendFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$appendFile(path, data, options, cb)

    function go$appendFile (path, data, options, cb) {
      return fs$appendFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$appendFile, [path, data, options, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  var fs$copyFile = fs.copyFile
  if (fs$copyFile)
    fs.copyFile = copyFile
  function copyFile (src, dest, flags, cb) {
    if (typeof flags === 'function') {
      cb = flags
      flags = 0
    }
    return fs$copyFile(src, dest, flags, function (err) {
      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
        enqueue([fs$copyFile, [src, dest, flags, cb]])
      else {
        if (typeof cb === 'function')
          cb.apply(this, arguments)
        retry()
      }
    })
  }

  var fs$readdir = fs.readdir
  fs.readdir = readdir
  function readdir (path, options, cb) {
    var args = [path]
    if (typeof options !== 'function') {
      args.push(options)
    } else {
      cb = options
    }
    args.push(go$readdir$cb)

    return go$readdir(args)

    function go$readdir$cb (err, files) {
      if (files && files.sort)
        files.sort()

      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
        enqueue([go$readdir, [args]])

      else {
        if (typeof cb === 'function')
          cb.apply(this, arguments)
        retry()
      }
    }
  }

  function go$readdir (args) {
    return fs$readdir.apply(fs, args)
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacy(fs)
    ReadStream = legStreams.ReadStream
    WriteStream = legStreams.WriteStream
  }

  var fs$ReadStream = fs.ReadStream
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype)
    ReadStream.prototype.open = ReadStream$open
  }

  var fs$WriteStream = fs.WriteStream
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype)
    WriteStream.prototype.open = WriteStream$open
  }

  Object.defineProperty(fs, 'ReadStream', {
    get: function () {
      return ReadStream
    },
    set: function (val) {
      ReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  Object.defineProperty(fs, 'WriteStream', {
    get: function () {
      return WriteStream
    },
    set: function (val) {
      WriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  // legacy names
  var FileReadStream = ReadStream
  Object.defineProperty(fs, 'FileReadStream', {
    get: function () {
      return FileReadStream
    },
    set: function (val) {
      FileReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  var FileWriteStream = WriteStream
  Object.defineProperty(fs, 'FileWriteStream', {
    get: function () {
      return FileWriteStream
    },
    set: function (val) {
      FileWriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  function ReadStream (path, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
  }

  function ReadStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy()

        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
        that.read()
      }
    })
  }

  function WriteStream (path, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
  }

  function WriteStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy()
        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
      }
    })
  }

  function createReadStream (path, options) {
    return new fs.ReadStream(path, options)
  }

  function createWriteStream (path, options) {
    return new fs.WriteStream(path, options)
  }

  var fs$open = fs.open
  fs.open = open
  function open (path, flags, mode, cb) {
    if (typeof mode === 'function')
      cb = mode, mode = null

    return go$open(path, flags, mode, cb)

    function go$open (path, flags, mode, cb) {
      return fs$open(path, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$open, [path, flags, mode, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  return fs
}

function enqueue (elem) {
  debug('ENQUEUE', elem[0].name, elem[1])
  fs[gracefulQueue].push(elem)
}

function retry () {
  var elem = fs[gracefulQueue].shift()
  if (elem) {
    debug('RETRY', elem[0].name, elem[1])
    elem[0].apply(null, elem[1])
  }
}


/***/ }),

/***/ 73086:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stream = __webpack_require__(92413).Stream

module.exports = legacy

function legacy (fs) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  }

  function ReadStream (path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function() {
        self._read();
      });
      return;
    }

    fs.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    })
  }

  function WriteStream (path, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}


/***/ }),

/***/ 20263:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constants = __webpack_require__(27619)

var origCwd = process.cwd
var cwd = null

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform

process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process)
  return cwd
}
try {
  process.cwd()
} catch (er) {}

// This check is needed until node.js 12 is required
if (typeof process.chdir === 'function') {
  var chdir = process.chdir
  process.chdir = function (d) {
    cwd = null
    chdir.call(process, d)
  }
  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir)
}

module.exports = patch

function patch (fs) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants.hasOwnProperty('O_SYMLINK') &&
      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs)
  }

  // lutimes implementation, or no-op
  if (!fs.lutimes) {
    patchLutimes(fs)
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs.chown = chownFix(fs.chown)
  fs.fchown = chownFix(fs.fchown)
  fs.lchown = chownFix(fs.lchown)

  fs.chmod = chmodFix(fs.chmod)
  fs.fchmod = chmodFix(fs.fchmod)
  fs.lchmod = chmodFix(fs.lchmod)

  fs.chownSync = chownFixSync(fs.chownSync)
  fs.fchownSync = chownFixSync(fs.fchownSync)
  fs.lchownSync = chownFixSync(fs.lchownSync)

  fs.chmodSync = chmodFixSync(fs.chmodSync)
  fs.fchmodSync = chmodFixSync(fs.fchmodSync)
  fs.lchmodSync = chmodFixSync(fs.lchmodSync)

  fs.stat = statFix(fs.stat)
  fs.fstat = statFix(fs.fstat)
  fs.lstat = statFix(fs.lstat)

  fs.statSync = statFixSync(fs.statSync)
  fs.fstatSync = statFixSync(fs.fstatSync)
  fs.lstatSync = statFixSync(fs.lstatSync)

  // if lchmod/lchown do not exist, then make them no-ops
  if (!fs.lchmod) {
    fs.lchmod = function (path, mode, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchmodSync = function () {}
  }
  if (!fs.lchown) {
    fs.lchown = function (path, uid, gid, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchownSync = function () {}
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") {
    fs.rename = (function (fs$rename) { return function (from, to, cb) {
      var start = Date.now()
      var backoff = 0;
      fs$rename(from, to, function CB (er) {
        if (er
            && (er.code === "EACCES" || er.code === "EPERM")
            && Date.now() - start < 60000) {
          setTimeout(function() {
            fs.stat(to, function (stater, st) {
              if (stater && stater.code === "ENOENT")
                fs$rename(from, to, CB);
              else
                cb(er)
            })
          }, backoff)
          if (backoff < 100)
            backoff += 10;
          return;
        }
        if (cb) cb(er)
      })
    }})(fs.rename)
  }

  // if read() returns EAGAIN, then just try it again.
  fs.read = (function (fs$read) {
    function read (fd, buffer, offset, length, position, callback_) {
      var callback
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter ++
            return fs$read.call(fs, fd, buffer, offset, length, position, callback)
          }
          callback_.apply(this, arguments)
        }
      }
      return fs$read.call(fs, fd, buffer, offset, length, position, callback)
    }

    // This ensures `util.promisify` works as it does for native `fs.read`.
    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read)
    return read
  })(fs.read)

  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
    var eagCounter = 0
    while (true) {
      try {
        return fs$readSync.call(fs, fd, buffer, offset, length, position)
      } catch (er) {
        if (er.code === 'EAGAIN' && eagCounter < 10) {
          eagCounter ++
          continue
        }
        throw er
      }
    }
  }})(fs.readSync)

  function patchLchmod (fs) {
    fs.lchmod = function (path, mode, callback) {
      fs.open( path
             , constants.O_WRONLY | constants.O_SYMLINK
             , mode
             , function (err, fd) {
        if (err) {
          if (callback) callback(err)
          return
        }
        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        fs.fchmod(fd, mode, function (err) {
          fs.close(fd, function(err2) {
            if (callback) callback(err || err2)
          })
        })
      })
    }

    fs.lchmodSync = function (path, mode) {
      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)

      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      var threw = true
      var ret
      try {
        ret = fs.fchmodSync(fd, mode)
        threw = false
      } finally {
        if (threw) {
          try {
            fs.closeSync(fd)
          } catch (er) {}
        } else {
          fs.closeSync(fd)
        }
      }
      return ret
    }
  }

  function patchLutimes (fs) {
    if (constants.hasOwnProperty("O_SYMLINK")) {
      fs.lutimes = function (path, at, mt, cb) {
        fs.open(path, constants.O_SYMLINK, function (er, fd) {
          if (er) {
            if (cb) cb(er)
            return
          }
          fs.futimes(fd, at, mt, function (er) {
            fs.close(fd, function (er2) {
              if (cb) cb(er || er2)
            })
          })
        })
      }

      fs.lutimesSync = function (path, at, mt) {
        var fd = fs.openSync(path, constants.O_SYMLINK)
        var ret
        var threw = true
        try {
          ret = fs.futimesSync(fd, at, mt)
          threw = false
        } finally {
          if (threw) {
            try {
              fs.closeSync(fd)
            } catch (er) {}
          } else {
            fs.closeSync(fd)
          }
        }
        return ret
      }

    } else {
      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }
      fs.lutimesSync = function () {}
    }
  }

  function chmodFix (orig) {
    if (!orig) return orig
    return function (target, mode, cb) {
      return orig.call(fs, target, mode, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chmodFixSync (orig) {
    if (!orig) return orig
    return function (target, mode) {
      try {
        return orig.call(fs, target, mode)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }


  function chownFix (orig) {
    if (!orig) return orig
    return function (target, uid, gid, cb) {
      return orig.call(fs, target, uid, gid, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chownFixSync (orig) {
    if (!orig) return orig
    return function (target, uid, gid) {
      try {
        return orig.call(fs, target, uid, gid)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }

  function statFix (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = null
      }
      function callback (er, stats) {
        if (stats) {
          if (stats.uid < 0) stats.uid += 0x100000000
          if (stats.gid < 0) stats.gid += 0x100000000
        }
        if (cb) cb.apply(this, arguments)
      }
      return options ? orig.call(fs, target, options, callback)
        : orig.call(fs, target, callback)
    }
  }

  function statFixSync (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options) {
      var stats = options ? orig.call(fs, target, options)
        : orig.call(fs, target)
      if (stats.uid < 0) stats.uid += 0x100000000
      if (stats.gid < 0) stats.gid += 0x100000000
      return stats;
    }
  }

  // ENOSYS means that the fs doesn't support the op. Just ignore
  // that, because it doesn't matter.
  //
  // if there's no getuid, or if getuid() is something other
  // than 0, and the error is EINVAL or EPERM, then just ignore
  // it.
  //
  // This specific case is a silent failure in cp, install, tar,
  // and most other unix tools that manage permissions.
  //
  // When running as root, or if other types of errors are
  // encountered, then it's strict.
  function chownErOk (er) {
    if (!er)
      return true

    if (er.code === "ENOSYS")
      return true

    var nonroot = !process.getuid || process.getuid() !== 0
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true
    }

    return false
  }
}


/***/ }),

/***/ 30135:
/***/ ((module) => {

"use strict";


var gitHosts = module.exports = {
  github: {
    // First two are insecure and generally shouldn't be used any more, but
    // they are still supported.
    'protocols': [ 'git', 'http', 'git+ssh', 'git+https', 'ssh', 'https' ],
    'domain': 'github.com',
    'treepath': 'tree',
    'filetemplate': 'https://{auth@}raw.githubusercontent.com/{user}/{project}/{committish}/{path}',
    'bugstemplate': 'https://{domain}/{user}/{project}/issues',
    'gittemplate': 'git://{auth@}{domain}/{user}/{project}.git{#committish}',
    'tarballtemplate': 'https://codeload.{domain}/{user}/{project}/tar.gz/{committish}'
  },
  bitbucket: {
    'protocols': [ 'git+ssh', 'git+https', 'ssh', 'https' ],
    'domain': 'bitbucket.org',
    'treepath': 'src',
    'tarballtemplate': 'https://{domain}/{user}/{project}/get/{committish}.tar.gz'
  },
  gitlab: {
    'protocols': [ 'git+ssh', 'git+https', 'ssh', 'https' ],
    'domain': 'gitlab.com',
    'treepath': 'tree',
    'bugstemplate': 'https://{domain}/{user}/{project}/issues',
    'httpstemplate': 'git+https://{auth@}{domain}/{user}/{projectPath}.git{#committish}',
    'tarballtemplate': 'https://{domain}/{user}/{project}/repository/archive.tar.gz?ref={committish}',
    'pathmatch': /^[/]([^/]+)[/]((?!.*(\/-\/|\/repository\/archive\.tar\.gz\?=.*|\/repository\/[^/]+\/archive.tar.gz$)).*?)(?:[.]git|[/])?$/
  },
  gist: {
    'protocols': [ 'git', 'git+ssh', 'git+https', 'ssh', 'https' ],
    'domain': 'gist.github.com',
    'pathmatch': /^[/](?:([^/]+)[/])?([a-z0-9]{32,})(?:[.]git)?$/,
    'filetemplate': 'https://gist.githubusercontent.com/{user}/{project}/raw{/committish}/{path}',
    'bugstemplate': 'https://{domain}/{project}',
    'gittemplate': 'git://{domain}/{project}.git{#committish}',
    'sshtemplate': 'git@{domain}:/{project}.git{#committish}',
    'sshurltemplate': 'git+ssh://git@{domain}/{project}.git{#committish}',
    'browsetemplate': 'https://{domain}/{project}{/committish}',
    'browsefiletemplate': 'https://{domain}/{project}{/committish}{#path}',
    'docstemplate': 'https://{domain}/{project}{/committish}',
    'httpstemplate': 'git+https://{domain}/{project}.git{#committish}',
    'shortcuttemplate': '{type}:{project}{#committish}',
    'pathtemplate': '{project}{#committish}',
    'tarballtemplate': 'https://codeload.github.com/gist/{project}/tar.gz/{committish}',
    'hashformat': function (fragment) {
      return 'file-' + formatHashFragment(fragment)
    }
  }
}

var gitHostDefaults = {
  'sshtemplate': 'git@{domain}:{user}/{project}.git{#committish}',
  'sshurltemplate': 'git+ssh://git@{domain}/{user}/{project}.git{#committish}',
  'browsetemplate': 'https://{domain}/{user}/{project}{/tree/committish}',
  'browsefiletemplate': 'https://{domain}/{user}/{project}/{treepath}/{committish}/{path}{#fragment}',
  'docstemplate': 'https://{domain}/{user}/{project}{/tree/committish}#readme',
  'httpstemplate': 'git+https://{auth@}{domain}/{user}/{project}.git{#committish}',
  'filetemplate': 'https://{domain}/{user}/{project}/raw/{committish}/{path}',
  'shortcuttemplate': '{type}:{user}/{project}{#committish}',
  'pathtemplate': '{user}/{project}{#committish}',
  'pathmatch': /^[/]([^/]+)[/]([^/]+?)(?:[.]git|[/])?$/,
  'hashformat': formatHashFragment
}

Object.keys(gitHosts).forEach(function (name) {
  Object.keys(gitHostDefaults).forEach(function (key) {
    if (gitHosts[name][key]) return
    gitHosts[name][key] = gitHostDefaults[key]
  })
  gitHosts[name].protocols_re = RegExp('^(' +
    gitHosts[name].protocols.map(function (protocol) {
      return protocol.replace(/([\\+*{}()[\]$^|])/g, '\\$1')
    }).join('|') + '):$')
})

function formatHashFragment (fragment) {
  return fragment.toLowerCase().replace(/^\W+|\/|\W+$/g, '').replace(/\W+/g, '-')
}


/***/ }),

/***/ 18145:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var gitHosts = __webpack_require__(30135)
/* eslint-disable node/no-deprecated-api */

// copy-pasta util._extend from node's source, to avoid pulling
// the whole util module into peoples' webpack bundles.
/* istanbul ignore next */
var extend = Object.assign || function _extend (target, source) {
  // Don't do anything if source isn't an object
  if (source === null || typeof source !== 'object') return target

  var keys = Object.keys(source)
  var i = keys.length
  while (i--) {
    target[keys[i]] = source[keys[i]]
  }
  return target
}

module.exports = GitHost
function GitHost (type, user, auth, project, committish, defaultRepresentation, opts) {
  var gitHostInfo = this
  gitHostInfo.type = type
  Object.keys(gitHosts[type]).forEach(function (key) {
    gitHostInfo[key] = gitHosts[type][key]
  })
  gitHostInfo.user = user
  gitHostInfo.auth = auth
  gitHostInfo.project = project
  gitHostInfo.committish = committish
  gitHostInfo.default = defaultRepresentation
  gitHostInfo.opts = opts || {}
}

GitHost.prototype.hash = function () {
  return this.committish ? '#' + this.committish : ''
}

GitHost.prototype._fill = function (template, opts) {
  if (!template) return
  var vars = extend({}, opts)
  vars.path = vars.path ? vars.path.replace(/^[/]+/g, '') : ''
  opts = extend(extend({}, this.opts), opts)
  var self = this
  Object.keys(this).forEach(function (key) {
    if (self[key] != null && vars[key] == null) vars[key] = self[key]
  })
  var rawAuth = vars.auth
  var rawcommittish = vars.committish
  var rawFragment = vars.fragment
  var rawPath = vars.path
  var rawProject = vars.project
  Object.keys(vars).forEach(function (key) {
    var value = vars[key]
    if ((key === 'path' || key === 'project') && typeof value === 'string') {
      vars[key] = value.split('/').map(function (pathComponent) {
        return encodeURIComponent(pathComponent)
      }).join('/')
    } else {
      vars[key] = encodeURIComponent(value)
    }
  })
  vars['auth@'] = rawAuth ? rawAuth + '@' : ''
  vars['#fragment'] = rawFragment ? '#' + this.hashformat(rawFragment) : ''
  vars.fragment = vars.fragment ? vars.fragment : ''
  vars['#path'] = rawPath ? '#' + this.hashformat(rawPath) : ''
  vars['/path'] = vars.path ? '/' + vars.path : ''
  vars.projectPath = rawProject.split('/').map(encodeURIComponent).join('/')
  if (opts.noCommittish) {
    vars['#committish'] = ''
    vars['/tree/committish'] = ''
    vars['/committish'] = ''
    vars.committish = ''
  } else {
    vars['#committish'] = rawcommittish ? '#' + rawcommittish : ''
    vars['/tree/committish'] = vars.committish
      ? '/' + vars.treepath + '/' + vars.committish
      : ''
    vars['/committish'] = vars.committish ? '/' + vars.committish : ''
    vars.committish = vars.committish || 'master'
  }
  var res = template
  Object.keys(vars).forEach(function (key) {
    res = res.replace(new RegExp('[{]' + key + '[}]', 'g'), vars[key])
  })
  if (opts.noGitPlus) {
    return res.replace(/^git[+]/, '')
  } else {
    return res
  }
}

GitHost.prototype.ssh = function (opts) {
  return this._fill(this.sshtemplate, opts)
}

GitHost.prototype.sshurl = function (opts) {
  return this._fill(this.sshurltemplate, opts)
}

GitHost.prototype.browse = function (P, F, opts) {
  if (typeof P === 'string') {
    if (typeof F !== 'string') {
      opts = F
      F = null
    }
    return this._fill(this.browsefiletemplate, extend({
      fragment: F,
      path: P
    }, opts))
  } else {
    return this._fill(this.browsetemplate, P)
  }
}

GitHost.prototype.docs = function (opts) {
  return this._fill(this.docstemplate, opts)
}

GitHost.prototype.bugs = function (opts) {
  return this._fill(this.bugstemplate, opts)
}

GitHost.prototype.https = function (opts) {
  return this._fill(this.httpstemplate, opts)
}

GitHost.prototype.git = function (opts) {
  return this._fill(this.gittemplate, opts)
}

GitHost.prototype.shortcut = function (opts) {
  return this._fill(this.shortcuttemplate, opts)
}

GitHost.prototype.path = function (opts) {
  return this._fill(this.pathtemplate, opts)
}

GitHost.prototype.tarball = function (opts_) {
  var opts = extend({}, opts_, { noCommittish: false })
  return this._fill(this.tarballtemplate, opts)
}

GitHost.prototype.file = function (P, opts) {
  return this._fill(this.filetemplate, extend({ path: P }, opts))
}

GitHost.prototype.getDefaultRepresentation = function () {
  return this.default
}

GitHost.prototype.toString = function (opts) {
  if (this.default && typeof this[this.default] === 'function') return this[this.default](opts)
  return this.sshurl(opts)
}


/***/ }),

/***/ 88869:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var url = __webpack_require__(78835)
var gitHosts = __webpack_require__(30135)
var GitHost = module.exports = __webpack_require__(18145)

var protocolToRepresentationMap = {
  'git+ssh:': 'sshurl',
  'git+https:': 'https',
  'ssh:': 'sshurl',
  'git:': 'git'
}

function protocolToRepresentation (protocol) {
  return protocolToRepresentationMap[protocol] || protocol.slice(0, -1)
}

var authProtocols = {
  'git:': true,
  'https:': true,
  'git+https:': true,
  'http:': true,
  'git+http:': true
}

var cache = {}

module.exports.fromUrl = function (giturl, opts) {
  if (typeof giturl !== 'string') return
  var key = giturl + JSON.stringify(opts || {})

  if (!(key in cache)) {
    cache[key] = fromUrl(giturl, opts)
  }

  return cache[key]
}

function fromUrl (giturl, opts) {
  if (giturl == null || giturl === '') return
  var url = fixupUnqualifiedGist(
    isGitHubShorthand(giturl) ? 'github:' + giturl : giturl
  )
  var parsed = parseGitUrl(url)
  var shortcutMatch = url.match(/^([^:]+):(?:[^@]+@)?(?:([^/]*)\/)?([^#]+)/)
  var matches = Object.keys(gitHosts).map(function (gitHostName) {
    try {
      var gitHostInfo = gitHosts[gitHostName]
      var auth = null
      if (parsed.auth && authProtocols[parsed.protocol]) {
        auth = parsed.auth
      }
      var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null
      var user = null
      var project = null
      var defaultRepresentation = null
      if (shortcutMatch && shortcutMatch[1] === gitHostName) {
        user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2])
        project = decodeURIComponent(shortcutMatch[3].replace(/\.git$/, ''))
        defaultRepresentation = 'shortcut'
      } else {
        if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, '') !== gitHostInfo.domain) return
        if (!gitHostInfo.protocols_re.test(parsed.protocol)) return
        if (!parsed.path) return
        var pathmatch = gitHostInfo.pathmatch
        var matched = parsed.path.match(pathmatch)
        if (!matched) return
        /* istanbul ignore else */
        if (matched[1] !== null && matched[1] !== undefined) {
          user = decodeURIComponent(matched[1].replace(/^:/, ''))
        }
        project = decodeURIComponent(matched[2])
        defaultRepresentation = protocolToRepresentation(parsed.protocol)
      }
      return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts)
    } catch (ex) {
      /* istanbul ignore else */
      if (ex instanceof URIError) {
      } else throw ex
    }
  }).filter(function (gitHostInfo) { return gitHostInfo })
  if (matches.length !== 1) return
  return matches[0]
}

function isGitHubShorthand (arg) {
  // Note: This does not fully test the git ref format.
  // See https://www.kernel.org/pub/software/scm/git/docs/git-check-ref-format.html
  //
  // The only way to do this properly would be to shell out to
  // git-check-ref-format, and as this is a fast sync function,
  // we don't want to do that.  Just let git fail if it turns
  // out that the commit-ish is invalid.
  // GH usernames cannot start with . or -
  return /^[^:@%/\s.-][^:@%/\s]*[/][^:@\s/%]+(?:#.*)?$/.test(arg)
}

function fixupUnqualifiedGist (giturl) {
  // necessary for round-tripping gists
  var parsed = url.parse(giturl)
  if (parsed.protocol === 'gist:' && parsed.host && !parsed.path) {
    return parsed.protocol + '/' + parsed.host
  } else {
    return giturl
  }
}

function parseGitUrl (giturl) {
  var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/)
  if (!matched) {
    var legacy = url.parse(giturl)
    // If we don't have url.URL, then sorry, this is just not fixable.
    // This affects Node <= 6.12.
    if (legacy.auth && typeof url.URL === 'function') {
      // git urls can be in the form of scp-style/ssh-connect strings, like
      // git+ssh://user@host.com:some/path, which the legacy url parser
      // supports, but WhatWG url.URL class does not.  However, the legacy
      // parser de-urlencodes the username and password, so something like
      // https://user%3An%40me:p%40ss%3Aword@x.com/ becomes
      // https://user:n@me:p@ss:word@x.com/ which is all kinds of wrong.
      // Pull off just the auth and host, so we dont' get the confusing
      // scp-style URL, then pass that to the WhatWG parser to get the
      // auth properly escaped.
      var authmatch = giturl.match(/[^@]+@[^:/]+/)
      /* istanbul ignore else - this should be impossible */
      if (authmatch) {
        var whatwg = new url.URL(authmatch[0])
        legacy.auth = whatwg.username || ''
        if (whatwg.password) legacy.auth += ':' + whatwg.password
      }
    }
    return legacy
  }
  return {
    protocol: 'git+ssh:',
    slashes: true,
    auth: matched[1],
    host: matched[2],
    port: null,
    hostname: matched[2],
    hash: matched[4],
    search: null,
    query: null,
    pathname: '/' + matched[3],
    path: '/' + matched[3],
    href: 'git+ssh://' + matched[1] + '@' + matched[2] +
          '/' + matched[3] + (matched[4] || '')
  }
}


/***/ }),

/***/ 41239:
/***/ ((module) => {

"use strict";

const lazy = (importedModule, importFn, moduleId) =>
	importedModule === undefined ? importFn(moduleId) : importedModule;

module.exports = importFn => {
	return moduleId => {
		let importedModule;

		const handler = {
			get: (target, property) => {
				importedModule = lazy(importedModule, importFn, moduleId);
				return Reflect.get(importedModule, property);
			},
			apply: (target, thisArgument, argumentsList) => {
				importedModule = lazy(importedModule, importFn, moduleId);
				return Reflect.apply(importedModule, thisArgument, argumentsList);
			},
			construct: (target, argumentsList) => {
				importedModule = lazy(importedModule, importFn, moduleId);
				return Reflect.construct(importedModule, argumentsList);
			}
		};

		// eslint-disable-next-line prefer-arrow-callback
		return new Proxy(function () {}, handler);
	};
};


/***/ }),

/***/ 63287:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

function isObject(o) {
  return Object.prototype.toString.call(o) === '[object Object]';
}

function isPlainObject(o) {
  var ctor,prot;

  if (isObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (ctor === undefined) return true;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
}

exports.isPlainObject = isPlainObject;


/***/ }),

/***/ 93304:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


module.exports.__defineGetter__('parse', function() {
	return __webpack_require__(7770).parse
})

module.exports.__defineGetter__('stringify', function() {
	return __webpack_require__(54361)/* .stringify */ .P
})

module.exports.__defineGetter__('tokenize', function() {
	return __webpack_require__(7770).tokenize
})

module.exports.__defineGetter__('update', function() {
	return __webpack_require__(6728)/* .update */ .V
})

module.exports.__defineGetter__('analyze', function() {
	return __webpack_require__(98415)/* .analyze */ .B
})

module.exports.__defineGetter__('utils', function() {
	return __webpack_require__(72577)
})

/**package
{ "name": "jju",
  "version": "0.0.0",
  "dependencies": {"js-yaml": "*"},
  "scripts": {"postinstall": "js-yaml package.yaml > package.json ; npm install"}
}
**/


/***/ }),

/***/ 98415:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var tokenize = __webpack_require__(7770).tokenize

module.exports.B = function analyzeJSON(input, options) {
  if (options == null) options = {}

  if (!Array.isArray(input)) {
    input = tokenize(input, options)
  }

  var result = {
    has_whitespace: false,
    has_comments: false,
    has_newlines: false,
    has_trailing_comma: false,
    indent: '',
    newline: '\n',
    quote: '"',
    quote_keys: true,
  }

  var stats = {
    indent: {},
    newline: {},
    quote: {},
  }

  for (var i=0; i<input.length; i++) {
    if (input[i].type === 'newline') {
      if (input[i+1] && input[i+1].type === 'whitespace') {
        if (input[i+1].raw[0] === '\t') {
          // if first is tab, then indent is tab
          stats.indent['\t'] = (stats.indent['\t'] || 0) + 1
        }
        if (input[i+1].raw.match(/^\x20+$/)) {
          // if all are spaces, then indent is space
          // this can fail with mixed indent (4, 2 would display 3)
          var ws_len = input[i+1].raw.length
          var indent_len = input[i+1].stack.length + 1
          if (ws_len % indent_len === 0) {
            var t = Array(ws_len / indent_len + 1).join(' ')
            stats.indent[t] = (stats.indent[t] || 0) + 1
          }
        }
      }

      stats.newline[input[i].raw] = (stats.newline[input[i].raw] || 0) + 1
    }

    if (input[i].type === 'newline') {
      result.has_newlines = true
    }
    if (input[i].type === 'whitespace') {
      result.has_whitespace = true
    }
    if (input[i].type === 'comment') {
      result.has_comments = true
    }
    if (input[i].type === 'key') {
      if (input[i].raw[0] !== '"' && input[i].raw[0] !== "'") result.quote_keys = false
    }

    if (input[i].type === 'key' || input[i].type === 'literal') {
      if (input[i].raw[0] === '"' || input[i].raw[0] === "'") {
        stats.quote[input[i].raw[0]] = (stats.quote[input[i].raw[0]] || 0) + 1
      }
    }

    if (input[i].type === 'separator' && input[i].raw === ',') {
      for (var j=i+1; j<input.length; j++) {
        if (input[j].type === 'literal' || input[j].type === 'key') break
        if (input[j].type === 'separator') result.has_trailing_comma = true
      }
    }
  }

  for (var k in stats) {
    if (Object.keys(stats[k]).length) {
      result[k] = Object.keys(stats[k]).reduce(function(a, b) {
        return stats[k][a] > stats[k][b] ? a : b
      })
    }
  }

  return result
}



/***/ }),

/***/ 6728:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var __webpack_unused_export__;

var assert = __webpack_require__(42357)
var tokenize = __webpack_require__(7770).tokenize
var stringify = __webpack_require__(54361)/* .stringify */ .P
var analyze = __webpack_require__(98415)/* .analyze */ .B

function isObject(x) {
  return typeof(x) === 'object' && x !== null
}

function value_to_tokenlist(value, stack, options, is_key, indent) {
  options = Object.create(options)
  options._stringify_key = !!is_key

  if (indent) {
    options._prefix = indent.prefix.map(function(x) {
      return x.raw
    }).join('')
  }

  if (options._splitMin == null) options._splitMin = 0
  if (options._splitMax == null) options._splitMax = 0

  var stringified = stringify(value, options)

  if (is_key) {
    return [ { raw: stringified, type: 'key', stack: stack, value: value } ]
  }

  options._addstack = stack
  var result = tokenize(stringified, {
    _addstack: stack,
  })
  result.data = null
  return result
}

// '1.2.3' -> ['1','2','3']
function arg_to_path(path) {
  // array indexes
  if (typeof(path) === 'number') path = String(path)

  if (path === '') path = []
  if (typeof(path) === 'string') path = path.split('.')

  if (!Array.isArray(path)) throw Error('Invalid path type, string or array expected')
  return path
}

// returns new [begin, end] or false if not found
//
//          {x:3, xxx: 111, y: [111,  {q: 1, e: 2}  ,333]  }
// f('y',0) returns this       B^^^^^^^^^^^^^^^^^^^^^^^^E
// then f('1',1) would reduce it to   B^^^^^^^^^^E
function find_element_in_tokenlist(element, lvl, tokens, begin, end) {
  while(tokens[begin].stack[lvl] != element) {
    if (begin++ >= end) return false
  }
  while(tokens[end].stack[lvl] != element) {
    if (end-- < begin) return false
  }
  return [begin, end]
}

function is_whitespace(token_type) {
  return token_type === 'whitespace'
      || token_type === 'newline'
      || token_type === 'comment'
}

function find_first_non_ws_token(tokens, begin, end) {
  while(is_whitespace(tokens[begin].type)) {
    if (begin++ >= end) return false
  }
  return begin
}

function find_last_non_ws_token(tokens, begin, end) {
  while(is_whitespace(tokens[end].type)) {
    if (end-- < begin) return false
  }
  return end
}

/*
 * when appending a new element of an object/array, we are trying to
 * figure out the style used on the previous element
 *
 * return {prefix, sep1, sep2, suffix}
 *
 *      '    "key" :  "element"    \r\n'
 * prefix^^^^ sep1^ ^^sep2     ^^^^^^^^suffix
 *
 * begin - the beginning of the object/array
 * end - last token of the last element (value or comma usually)
 */
function detect_indent_style(tokens, is_array, begin, end, level) {
  var result = {
    sep1: [],
    sep2: [],
    suffix: [],
    prefix: [],
    newline: [],
  }

  if (tokens[end].type === 'separator' && tokens[end].stack.length !== level+1 && tokens[end].raw !== ',') {
    // either a beginning of the array (no last element) or other weird situation
    //
    // just return defaults
    return result
  }

  //                              ' "key"  : "value"  ,'
  // skipping last separator, we're now here        ^^
  if (tokens[end].type === 'separator')
    end = find_last_non_ws_token(tokens, begin, end - 1)
  if (end === false) return result

  //                              ' "key"  : "value"  ,'
  // skipping value                          ^^^^^^^
  while(tokens[end].stack.length > level) end--

  if (!is_array) {
    while(is_whitespace(tokens[end].type)) {
      if (end < begin) return result
      if (tokens[end].type === 'whitespace') {
        result.sep2.unshift(tokens[end])
      } else {
        // newline, comment or other unrecognized codestyle
        return result
      }
      end--
    }

    //                              ' "key"  : "value"  ,'
    // skipping separator                    ^
    assert.equal(tokens[end].type, 'separator')
    assert.equal(tokens[end].raw, ':')
    while(is_whitespace(tokens[--end].type)) {
      if (end < begin) return result
      if (tokens[end].type === 'whitespace') {
        result.sep1.unshift(tokens[end])
      } else {
        // newline, comment or other unrecognized codestyle
        return result
      }
    }

    assert.equal(tokens[end].type, 'key')
    end--
  }

  //                              ' "key"  : "value"  ,'
  // skipping key                   ^^^^^
  while(is_whitespace(tokens[end].type)) {
    if (end < begin) return result
    if (tokens[end].type === 'whitespace') {
      result.prefix.unshift(tokens[end])
    } else if (tokens[end].type === 'newline') {
      result.newline.unshift(tokens[end])
      return result
    } else {
      // comment or other unrecognized codestyle
      return result
    }
    end--
  }

  return result
}

function Document(text, options) {
  var self = Object.create(Document.prototype)

  if (options == null) options = {}
  //options._structure = true
  var tokens = self._tokens = tokenize(text, options)
  self._data = tokens.data
  tokens.data = null
  self._options = options

  var stats = analyze(text, options)
  if (options.indent == null) {
    options.indent = stats.indent
  }
  if (options.quote == null) {
    options.quote = stats.quote
  }
  if (options.quote_keys == null) {
    options.quote_keys = stats.quote_keys
  }
  if (options.no_trailing_comma == null) {
    options.no_trailing_comma = !stats.has_trailing_comma
  }
  return self
}

// return true if it's a proper object
//        throw otherwise
function check_if_can_be_placed(key, object, is_unset) {
  //if (object == null) return false
  function error(add) {
    return Error("You can't " + (is_unset ? 'unset' : 'set') + " key '" + key + "'" + add)
  }

  if (!isObject(object)) {
    throw error(' of an non-object')
  }
  if (Array.isArray(object)) {
    // array, check boundary
    if (String(key).match(/^\d+$/)) {
      key = Number(String(key))
      if (object.length < key || (is_unset && object.length === key)) {
        throw error(', out of bounds')
      } else if (is_unset && object.length !== key+1) {
        throw error(' in the middle of an array')
      } else {
        return true
      }
    } else {
      throw error(' of an array')
    }
  } else {
    // object
    return true
  }
}

// usage: document.set('path.to.something', 'value')
//    or: document.set(['path','to','something'], 'value')
Document.prototype.set = function(path, value) {
  path = arg_to_path(path)

  // updating this._data and check for errors
  if (path.length === 0) {
    if (value === undefined) throw Error("can't remove root document")
    this._data = value
    var new_key = false

  } else {
    var data = this._data

    for (var i=0; i<path.length-1; i++) {
      check_if_can_be_placed(path[i], data, false)
      data = data[path[i]]
    }
    if (i === path.length-1) {
      check_if_can_be_placed(path[i], data, value === undefined)
    }

    var new_key = !(path[i] in data)

    if (value === undefined) {
      if (Array.isArray(data)) {
        data.pop()
      } else {
        delete data[path[i]]
      }
    } else {
      data[path[i]] = value
    }
  }

  // for inserting document
  if (!this._tokens.length)
    this._tokens = [ { raw: '', type: 'literal', stack: [], value: undefined } ]

  var position = [
    find_first_non_ws_token(this._tokens, 0, this._tokens.length - 1),
    find_last_non_ws_token(this._tokens, 0, this._tokens.length - 1),
  ]
  for (var i=0; i<path.length-1; i++) {
    position = find_element_in_tokenlist(path[i], i, this._tokens, position[0], position[1])
    if (position == false) throw Error('internal error, please report this')
  }
  // assume that i == path.length-1 here

  if (path.length === 0) {
    var newtokens = value_to_tokenlist(value, path, this._options)
    // all good

  } else if (!new_key) {
    // replace old value with a new one (or deleting something)
    var pos_old = position
    position = find_element_in_tokenlist(path[i], i, this._tokens, position[0], position[1])

    if (value === undefined && position !== false) {
      // deleting element (position !== false ensures there's something)
      var newtokens = []

      if (!Array.isArray(data)) {
        // removing element from an object, `{x:1, key:CURRENT} -> {x:1}`
        // removing sep, literal and optional sep
        // ':'
        var pos2 = find_last_non_ws_token(this._tokens, pos_old[0], position[0] - 1)
        assert.equal(this._tokens[pos2].type, 'separator')
        assert.equal(this._tokens[pos2].raw, ':')
        position[0] = pos2

        // key
        var pos2 = find_last_non_ws_token(this._tokens, pos_old[0], position[0] - 1)
        assert.equal(this._tokens[pos2].type, 'key')
        assert.equal(this._tokens[pos2].value, path[path.length-1])
        position[0] = pos2
      }

      // removing comma in arrays and objects
      var pos2 = find_last_non_ws_token(this._tokens, pos_old[0], position[0] - 1)
      assert.equal(this._tokens[pos2].type, 'separator')
      if (this._tokens[pos2].raw === ',') {
        position[0] = pos2
      } else {
        // beginning of the array/object, so we should remove trailing comma instead
        pos2 = find_first_non_ws_token(this._tokens, position[1] + 1, pos_old[1])
        assert.equal(this._tokens[pos2].type, 'separator')
        if (this._tokens[pos2].raw === ',') {
          position[1] = pos2
        }
      }

    } else {
      var indent = pos2 !== false
                 ? detect_indent_style(this._tokens, Array.isArray(data), pos_old[0], position[1] - 1, i)
                 : {}
      var newtokens = value_to_tokenlist(value, path, this._options, false, indent)
    }

  } else {
    // insert new key, that's tricky
    var path_1 = path.slice(0, i)

    //  find a last separator after which we're inserting it
    var pos2 = find_last_non_ws_token(this._tokens, position[0] + 1, position[1] - 1)
    assert(pos2 !== false)

    var indent = pos2 !== false
               ? detect_indent_style(this._tokens, Array.isArray(data), position[0] + 1, pos2, i)
               : {}

    var newtokens = value_to_tokenlist(value, path, this._options, false, indent)

    // adding leading whitespaces according to detected codestyle
    var prefix = []
    if (indent.newline && indent.newline.length)
      prefix = prefix.concat(indent.newline)
    if (indent.prefix && indent.prefix.length)
      prefix = prefix.concat(indent.prefix)

    // adding '"key":' (as in "key":"value") to object values
    if (!Array.isArray(data)) {
      prefix = prefix.concat(value_to_tokenlist(path[path.length-1], path_1, this._options, true))
      if (indent.sep1 && indent.sep1.length)
        prefix = prefix.concat(indent.sep1)
      prefix.push({raw: ':', type: 'separator', stack: path_1})
      if (indent.sep2 && indent.sep2.length)
        prefix = prefix.concat(indent.sep2)
    }

    newtokens.unshift.apply(newtokens, prefix)

    // check if prev token is a separator AND they're at the same level
    if (this._tokens[pos2].type === 'separator' && this._tokens[pos2].stack.length === path.length-1) {
      // previous token is either , or [ or {
      if (this._tokens[pos2].raw === ',') {
        // restore ending comma
        newtokens.push({raw: ',', type: 'separator', stack: path_1})
      }
    } else {
      // previous token isn't a separator, so need to insert one
      newtokens.unshift({raw: ',', type: 'separator', stack: path_1})
    }

    if (indent.suffix && indent.suffix.length)
      newtokens.push.apply(newtokens, indent.suffix)

    assert.equal(this._tokens[position[1]].type, 'separator')
    position[0] = pos2+1
    position[1] = pos2
  }

  newtokens.unshift(position[1] - position[0] + 1)
  newtokens.unshift(position[0])
  this._tokens.splice.apply(this._tokens, newtokens)

  return this
}

// convenience method
Document.prototype.unset = function(path) {
  return this.set(path, undefined)
}

Document.prototype.get = function(path) {
  path = arg_to_path(path)

  var data = this._data
  for (var i=0; i<path.length; i++) {
    if (!isObject(data)) return undefined
    data = data[path[i]]
  }
  return data
}

Document.prototype.has = function(path) {
  path = arg_to_path(path)

  var data = this._data
  for (var i=0; i<path.length; i++) {
    if (!isObject(data)) return false
    data = data[path[i]]
  }
  return data !== undefined
}

// compare old object and new one, and change differences only
Document.prototype.update = function(value) {
  var self = this
  change([], self._data, value)
  return self

  function change(path, old_data, new_data) {
    if (!isObject(new_data) || !isObject(old_data)) {
      // if source or dest is primitive, just replace
      if (new_data !== old_data)
        self.set(path, new_data)

    } else if (Array.isArray(new_data) != Array.isArray(old_data)) {
      // old data is an array XOR new data is an array, replace as well
      self.set(path, new_data)

    } else if (Array.isArray(new_data)) {
      // both values are arrays here

      if (new_data.length > old_data.length) {
        // adding new elements, so going forward
        for (var i=0; i<new_data.length; i++) {
          path.push(String(i))
          change(path, old_data[i], new_data[i])
          path.pop()
        }

      } else {
        // removing something, so going backward
        for (var i=old_data.length-1; i>=0; i--) {
          path.push(String(i))
          change(path, old_data[i], new_data[i])
          path.pop()
        }
      }

    } else {
      // both values are objects here
      for (var i in new_data) {
        path.push(String(i))
        change(path, old_data[i], new_data[i])
        path.pop()
      }

      for (var i in old_data) {
        if (i in new_data) continue
        path.push(String(i))
        change(path, old_data[i], new_data[i])
        path.pop()
      }
    }
  }
}

Document.prototype.toString = function() {
  return this._tokens.map(function(x) {
    return x.raw
  }).join('')
}

__webpack_unused_export__ = Document

module.exports.V = function updateJSON(source, new_value, options) {
  return Document(source, options).update(new_value).toString()
}



/***/ }),

/***/ 7770:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


// RTFM: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf

var Uni = __webpack_require__(69527)

function isHexDigit(x) {
  return (x >= '0' && x <= '9')
      || (x >= 'A' && x <= 'F')
      || (x >= 'a' && x <= 'f')
}

function isOctDigit(x) {
  return x >= '0' && x <= '7'
}

function isDecDigit(x) {
  return x >= '0' && x <= '9'
}

var unescapeMap = {
  '\'': '\'',
  '"' : '"',
  '\\': '\\',
  'b' : '\b',
  'f' : '\f',
  'n' : '\n',
  'r' : '\r',
  't' : '\t',
  'v' : '\v',
  '/' : '/',
}

function formatError(input, msg, position, lineno, column, json5) {
  var result = msg + ' at ' + (lineno + 1) + ':' + (column + 1)
    , tmppos = position - column - 1
    , srcline = ''
    , underline = ''

  var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON

  // output no more than 70 characters before the wrong ones
  if (tmppos < position - 70) {
    tmppos = position - 70
  }

  while (1) {
    var chr = input[++tmppos]

    if (isLineTerminator(chr) || tmppos === input.length) {
      if (position >= tmppos) {
        // ending line error, so show it after the last char
        underline += '^'
      }
      break
    }
    srcline += chr

    if (position === tmppos) {
      underline += '^'
    } else if (position > tmppos) {
      underline += input[tmppos] === '\t' ? '\t' : ' '
    }

    // output no more than 78 characters on the string
    if (srcline.length > 78) break
  }

  return result + '\n' + srcline + '\n' + underline
}

function parse(input, options) {
  // parse as a standard JSON mode
  var json5 = false
  var cjson = false

  if (options.legacy || options.mode === 'json') {
    // use json
  } else if (options.mode === 'cjson') {
    cjson = true
  } else if (options.mode === 'json5') {
    json5 = true
  } else {
    // use it by default
    json5 = true
  }

  var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON
  var isWhiteSpace     = json5 ? Uni.isWhiteSpace     : Uni.isWhiteSpaceJSON

  var length = input.length
    , lineno = 0
    , linestart = 0
    , position = 0
    , stack = []

  var tokenStart = function() {}
  var tokenEnd = function(v) {return v}

  /* tokenize({
       raw: '...',
       type: 'whitespace'|'comment'|'key'|'literal'|'separator'|'newline',
       value: 'number'|'string'|'whatever',
       path: [...],
     })
  */
  if (options._tokenize) {
    ;(function() {
      var start = null
      tokenStart = function() {
        if (start !== null) throw Error('internal error, token overlap')
        start = position
      }

      tokenEnd = function(v, type) {
        if (start != position) {
          var hash = {
            raw: input.substr(start, position-start),
            type: type,
            stack: stack.slice(0),
          }
          if (v !== undefined) hash.value = v
          options._tokenize.call(null, hash)
        }
        start = null
        return v
      }
    })()
  }

  function fail(msg) {
    var column = position - linestart

    if (!msg) {
      if (position < length) {
        var token = '\'' +
          JSON
            .stringify(input[position])
            .replace(/^"|"$/g, '')
            .replace(/'/g, "\\'")
            .replace(/\\"/g, '"')
          + '\''

        if (!msg) msg = 'Unexpected token ' + token
      } else {
        if (!msg) msg = 'Unexpected end of input'
      }
    }

    var error = SyntaxError(formatError(input, msg, position, lineno, column, json5))
    error.row = lineno + 1
    error.column = column + 1
    throw error
  }

  function newline(chr) {
    // account for <cr><lf>
    if (chr === '\r' && input[position] === '\n') position++
    linestart = position
    lineno++
  }

  function parseGeneric() {
    var result

    while (position < length) {
      tokenStart()
      var chr = input[position++]

      if (chr === '"' || (chr === '\'' && json5)) {
        return tokenEnd(parseString(chr), 'literal')

      } else if (chr === '{') {
        tokenEnd(undefined, 'separator')
        return parseObject()

      } else if (chr === '[') {
        tokenEnd(undefined, 'separator')
        return parseArray()

      } else if (chr === '-'
             ||  chr === '.'
             ||  isDecDigit(chr)
                 //           + number       Infinity          NaN
             ||  (json5 && (chr === '+' || chr === 'I' || chr === 'N'))
      ) {
        return tokenEnd(parseNumber(), 'literal')

      } else if (chr === 'n') {
        parseKeyword('null')
        return tokenEnd(null, 'literal')

      } else if (chr === 't') {
        parseKeyword('true')
        return tokenEnd(true, 'literal')

      } else if (chr === 'f') {
        parseKeyword('false')
        return tokenEnd(false, 'literal')

      } else {
        position--
        return tokenEnd(undefined)
      }
    }
  }

  function parseKey() {
    var result

    while (position < length) {
      tokenStart()
      var chr = input[position++]

      if (chr === '"' || (chr === '\'' && json5)) {
        return tokenEnd(parseString(chr), 'key')

      } else if (chr === '{') {
        tokenEnd(undefined, 'separator')
        return parseObject()

      } else if (chr === '[') {
        tokenEnd(undefined, 'separator')
        return parseArray()

      } else if (chr === '.'
             ||  isDecDigit(chr)
      ) {
        return tokenEnd(parseNumber(true), 'key')

      } else if (json5
             &&  Uni.isIdentifierStart(chr) || (chr === '\\' && input[position] === 'u')) {
        // unicode char or a unicode sequence
        var rollback = position - 1
        var result = parseIdentifier()

        if (result === undefined) {
          position = rollback
          return tokenEnd(undefined)
        } else {
          return tokenEnd(result, 'key')
        }

      } else {
        position--
        return tokenEnd(undefined)
      }
    }
  }

  function skipWhiteSpace() {
    tokenStart()
    while (position < length) {
      var chr = input[position++]

      if (isLineTerminator(chr)) {
        position--
        tokenEnd(undefined, 'whitespace')
        tokenStart()
        position++
        newline(chr)
        tokenEnd(undefined, 'newline')
        tokenStart()

      } else if (isWhiteSpace(chr)) {
        // nothing

      } else if (chr === '/'
             && (json5 || cjson)
             && (input[position] === '/' || input[position] === '*')
      ) {
        position--
        tokenEnd(undefined, 'whitespace')
        tokenStart()
        position++
        skipComment(input[position++] === '*')
        tokenEnd(undefined, 'comment')
        tokenStart()

      } else {
        position--
        break
      }
    }
    return tokenEnd(undefined, 'whitespace')
  }

  function skipComment(multi) {
    while (position < length) {
      var chr = input[position++]

      if (isLineTerminator(chr)) {
        // LineTerminator is an end of singleline comment
        if (!multi) {
          // let parent function deal with newline
          position--
          return
        }

        newline(chr)

      } else if (chr === '*' && multi) {
        // end of multiline comment
        if (input[position] === '/') {
          position++
          return
        }

      } else {
        // nothing
      }
    }

    if (multi) {
      fail('Unclosed multiline comment')
    }
  }

  function parseKeyword(keyword) {
    // keyword[0] is not checked because it should've checked earlier
    var _pos = position
    var len = keyword.length
    for (var i=1; i<len; i++) {
      if (position >= length || keyword[i] != input[position]) {
        position = _pos-1
        fail()
      }
      position++
    }
  }

  function parseObject() {
    var result = options.null_prototype ? Object.create(null) : {}
      , empty_object = {}
      , is_non_empty = false

    while (position < length) {
      skipWhiteSpace()
      var item1 = parseKey()
      skipWhiteSpace()
      tokenStart()
      var chr = input[position++]
      tokenEnd(undefined, 'separator')

      if (chr === '}' && item1 === undefined) {
        if (!json5 && is_non_empty) {
          position--
          fail('Trailing comma in object')
        }
        return result

      } else if (chr === ':' && item1 !== undefined) {
        skipWhiteSpace()
        stack.push(item1)
        var item2 = parseGeneric()
        stack.pop()

        if (item2 === undefined) fail('No value found for key ' + item1)
        if (typeof(item1) !== 'string') {
          if (!json5 || typeof(item1) !== 'number') {
            fail('Wrong key type: ' + item1)
          }
        }

        if ((item1 in empty_object || empty_object[item1] != null) && options.reserved_keys !== 'replace') {
          if (options.reserved_keys === 'throw') {
            fail('Reserved key: ' + item1)
          } else {
            // silently ignore it
          }
        } else {
          if (typeof(options.reviver) === 'function') {
            item2 = options.reviver.call(null, item1, item2)
          }

          if (item2 !== undefined) {
            is_non_empty = true
            Object.defineProperty(result, item1, {
              value: item2,
              enumerable: true,
              configurable: true,
              writable: true,
            })
          }
        }

        skipWhiteSpace()

        tokenStart()
        var chr = input[position++]
        tokenEnd(undefined, 'separator')

        if (chr === ',') {
          continue

        } else if (chr === '}') {
          return result

        } else {
          fail()
        }

      } else {
        position--
        fail()
      }
    }

    fail()
  }

  function parseArray() {
    var result = []

    while (position < length) {
      skipWhiteSpace()
      stack.push(result.length)
      var item = parseGeneric()
      stack.pop()
      skipWhiteSpace()
      tokenStart()
      var chr = input[position++]
      tokenEnd(undefined, 'separator')

      if (item !== undefined) {
        if (typeof(options.reviver) === 'function') {
          item = options.reviver.call(null, String(result.length), item)
        }
        if (item === undefined) {
          result.length++
          item = true // hack for check below, not included into result
        } else {
          result.push(item)
        }
      }

      if (chr === ',') {
        if (item === undefined) {
          fail('Elisions are not supported')
        }

      } else if (chr === ']') {
        if (!json5 && item === undefined && result.length) {
          position--
          fail('Trailing comma in array')
        }
        return result

      } else {
        position--
        fail()
      }
    }
  }

  function parseNumber() {
    // rewind because we don't know first char
    position--

    var start = position
      , chr = input[position++]
      , t

    var to_num = function(is_octal) {
      var str = input.substr(start, position - start)

      if (is_octal) {
        var result = parseInt(str.replace(/^0o?/, ''), 8)
      } else {
        var result = Number(str)
      }

      if (Number.isNaN(result)) {
        position--
        fail('Bad numeric literal - "' + input.substr(start, position - start + 1) + '"')
      } else if (!json5 && !str.match(/^-?(0|[1-9][0-9]*)(\.[0-9]+)?(e[+-]?[0-9]+)?$/i)) {
        // additional restrictions imposed by json
        position--
        fail('Non-json numeric literal - "' + input.substr(start, position - start + 1) + '"')
      } else {
        return result
      }
    }

    // ex: -5982475.249875e+29384
    //     ^ skipping this
    if (chr === '-' || (chr === '+' && json5)) chr = input[position++]

    if (chr === 'N' && json5) {
      parseKeyword('NaN')
      return NaN
    }

    if (chr === 'I' && json5) {
      parseKeyword('Infinity')

      // returning +inf or -inf
      return to_num()
    }

    if (chr >= '1' && chr <= '9') {
      // ex: -5982475.249875e+29384
      //        ^^^ skipping these
      while (position < length && isDecDigit(input[position])) position++
      chr = input[position++]
    }

    // special case for leading zero: 0.123456
    if (chr === '0') {
      chr = input[position++]

      //             new syntax, "0o777"           old syntax, "0777"
      var is_octal = chr === 'o' || chr === 'O' || isOctDigit(chr)
      var is_hex = chr === 'x' || chr === 'X'

      if (json5 && (is_octal || is_hex)) {
        while (position < length
           &&  (is_hex ? isHexDigit : isOctDigit)( input[position] )
        ) position++

        var sign = 1
        if (input[start] === '-') {
          sign = -1
          start++
        } else if (input[start] === '+') {
          start++
        }

        return sign * to_num(is_octal)
      }
    }

    if (chr === '.') {
      // ex: -5982475.249875e+29384
      //                ^^^ skipping these
      while (position < length && isDecDigit(input[position])) position++
      chr = input[position++]
    }

    if (chr === 'e' || chr === 'E') {
      chr = input[position++]
      if (chr === '-' || chr === '+') position++
      // ex: -5982475.249875e+29384
      //                       ^^^ skipping these
      while (position < length && isDecDigit(input[position])) position++
      chr = input[position++]
    }

    // we have char in the buffer, so count for it
    position--
    return to_num()
  }

  function parseIdentifier() {
    // rewind because we don't know first char
    position--

    var result = ''

    while (position < length) {
      var chr = input[position++]

      if (chr === '\\'
      &&  input[position] === 'u'
      &&  isHexDigit(input[position+1])
      &&  isHexDigit(input[position+2])
      &&  isHexDigit(input[position+3])
      &&  isHexDigit(input[position+4])
      ) {
        // UnicodeEscapeSequence
        chr = String.fromCharCode(parseInt(input.substr(position+1, 4), 16))
        position += 5
      }

      if (result.length) {
        // identifier started
        if (Uni.isIdentifierPart(chr)) {
          result += chr
        } else {
          position--
          return result
        }

      } else {
        if (Uni.isIdentifierStart(chr)) {
          result += chr
        } else {
          return undefined
        }
      }
    }

    fail()
  }

  function parseString(endChar) {
    // 7.8.4 of ES262 spec
    var result = ''

    while (position < length) {
      var chr = input[position++]

      if (chr === endChar) {
        return result

      } else if (chr === '\\') {
        if (position >= length) fail()
        chr = input[position++]

        if (unescapeMap[chr] && (json5 || (chr != 'v' && chr != "'"))) {
          result += unescapeMap[chr]

        } else if (json5 && isLineTerminator(chr)) {
          // line continuation
          newline(chr)

        } else if (chr === 'u' || (chr === 'x' && json5)) {
          // unicode/character escape sequence
          var off = chr === 'u' ? 4 : 2

          // validation for \uXXXX
          for (var i=0; i<off; i++) {
            if (position >= length) fail()
            if (!isHexDigit(input[position])) fail('Bad escape sequence')
            position++
          }

          result += String.fromCharCode(parseInt(input.substr(position-off, off), 16))
        } else if (json5 && isOctDigit(chr)) {
          if (chr < '4' && isOctDigit(input[position]) && isOctDigit(input[position+1])) {
            // three-digit octal
            var digits = 3
          } else if (isOctDigit(input[position])) {
            // two-digit octal
            var digits = 2
          } else {
            var digits = 1
          }
          position += digits - 1
          result += String.fromCharCode(parseInt(input.substr(position-digits, digits), 8))
          /*if (!isOctDigit(input[position])) {
            // \0 is allowed still
            result += '\0'
          } else {
            fail('Octal literals are not supported')
          }*/

        } else if (json5) {
          // \X -> x
          result += chr

        } else {
          position--
          fail()
        }

      } else if (isLineTerminator(chr)) {
        fail()

      } else {
        if (!json5 && chr.charCodeAt(0) < 32) {
          position--
          fail('Unexpected control character')
        }

        // SourceCharacter but not one of " or \ or LineTerminator
        result += chr
      }
    }

    fail()
  }

  skipWhiteSpace()
  var return_value = parseGeneric()
  if (return_value !== undefined || position < length) {
    skipWhiteSpace()

    if (position >= length) {
      if (typeof(options.reviver) === 'function') {
        return_value = options.reviver.call(null, '', return_value)
      }
      return return_value
    } else {
      fail()
    }

  } else {
    if (position) {
      fail('No data, only a whitespace')
    } else {
      fail('No data, empty input')
    }
  }
}

/*
 * parse(text, options)
 * or
 * parse(text, reviver)
 *
 * where:
 * text - string
 * options - object
 * reviver - function
 */
module.exports.parse = function parseJSON(input, options) {
  // support legacy functions
  if (typeof(options) === 'function') {
    options = {
      reviver: options
    }
  }

  if (input === undefined) {
    // parse(stringify(x)) should be equal x
    // with JSON functions it is not 'cause of undefined
    // so we're fixing it
    return undefined
  }

  // JSON.parse compat
  if (typeof(input) !== 'string') input = String(input)
  if (options == null) options = {}
  if (options.reserved_keys == null) options.reserved_keys = 'ignore'

  if (options.reserved_keys === 'throw' || options.reserved_keys === 'ignore') {
    if (options.null_prototype == null) {
      options.null_prototype = true
    }
  }

  try {
    return parse(input, options)
  } catch(err) {
    // jju is a recursive parser, so JSON.parse("{{{{{{{") could blow up the stack
    //
    // this catch is used to skip all those internal calls
    if (err instanceof SyntaxError && err.row != null && err.column != null) {
      var old_err = err
      err = SyntaxError(old_err.message)
      err.column = old_err.column
      err.row = old_err.row
    }
    throw err
  }
}

module.exports.tokenize = function tokenizeJSON(input, options) {
  if (options == null) options = {}

  options._tokenize = function(smth) {
    if (options._addstack) smth.stack.unshift.apply(smth.stack, options._addstack)
    tokens.push(smth)
  }

  var tokens = []
  tokens.data = module.exports.parse(input, options)
  return tokens
}



/***/ }),

/***/ 54361:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var Uni = __webpack_require__(69527)

// Fix Function#name on browsers that do not support it (IE)
// http://stackoverflow.com/questions/6903762/function-name-not-supported-in-ie
if (!(function f(){}).name) {
  Object.defineProperty((function(){}).constructor.prototype, 'name', {
    get: function() {
      var name = this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1]
      // For better performance only parse once, and then cache the
      // result through a new accessor for repeated access.
      Object.defineProperty(this, 'name', { value: name })
      return name
    }
  })
}

var special_chars = {
  0: '\\0', // this is not an octal literal
  8: '\\b',
  9: '\\t',
  10: '\\n',
  11: '\\v',
  12: '\\f',
  13: '\\r',
  92: '\\\\',
}

// for oddballs
var hasOwnProperty = Object.prototype.hasOwnProperty

// some people escape those, so I'd copy this to be safe
var escapable = /[\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/

function _stringify(object, options, recursiveLvl, currentKey) {
  var json5 = (options.mode === 'json5' || !options.mode)
  /*
   * Opinionated decision warning:
   *
   * Objects are serialized in the following form:
   * { type: 'Class', data: DATA }
   *
   * Class is supposed to be a function, and new Class(DATA) is
   * supposed to be equivalent to the original value
   */
  /*function custom_type() {
    return stringify({
      type: object.constructor.name,
      data: object.toString()
    })
  }*/

  // if add, it's an internal indentation, so we add 1 level and a eol
  // if !add, it's an ending indentation, so we just indent
  function indent(str, add) {
    var prefix = options._prefix ? options._prefix : ''
    if (!options.indent) return prefix + str
    var result = ''
    var count = recursiveLvl + (add || 0)
    for (var i=0; i<count; i++) result += options.indent
    return prefix + result + str + (add ? '\n' : '')
  }

  function _stringify_key(key) {
    if (options.quote_keys) return _stringify_str(key)
    if (String(Number(key)) == key && key[0] != '-') return key
    if (key == '') return _stringify_str(key)

    var result = ''
    for (var i=0; i<key.length; i++) {
      if (i > 0) {
        if (!Uni.isIdentifierPart(key[i]))
          return _stringify_str(key)

      } else {
        if (!Uni.isIdentifierStart(key[i]))
          return _stringify_str(key)
      }

      var chr = key.charCodeAt(i)

      if (options.ascii) {
        if (chr < 0x80) {
          result += key[i]

        } else {
          result += '\\u' + ('0000' + chr.toString(16)).slice(-4)
        }

      } else {
        if (escapable.exec(key[i])) {
          result += '\\u' + ('0000' + chr.toString(16)).slice(-4)

        } else {
          result += key[i]
        }
      }
    }

    return result
  }

  function _stringify_str(key) {
    var quote = options.quote
    var quoteChr = quote.charCodeAt(0)

    var result = ''
    for (var i=0; i<key.length; i++) {
      var chr = key.charCodeAt(i)

      if (chr < 0x10) {
        if (chr === 0 && json5) {
          result += '\\0'
        } else if (chr >= 8 && chr <= 13 && (json5 || chr !== 11)) {
          result += special_chars[chr]
        } else if (json5) {
          result += '\\x0' + chr.toString(16)
        } else {
          result += '\\u000' + chr.toString(16)
        }

      } else if (chr < 0x20) {
        if (json5) {
          result += '\\x' + chr.toString(16)
        } else {
          result += '\\u00' + chr.toString(16)
        }

      } else if (chr >= 0x20 && chr < 0x80) {
        // ascii range
        if (chr === 47 && i && key[i-1] === '<') {
          // escaping slashes in </script>
          result += '\\' + key[i]

        } else if (chr === 92) {
          result += '\\\\'

        } else if (chr === quoteChr) {
          result += '\\' + quote

        } else {
          result += key[i]
        }

      } else if (options.ascii || Uni.isLineTerminator(key[i]) || escapable.exec(key[i])) {
        if (chr < 0x100) {
          if (json5) {
            result += '\\x' + chr.toString(16)
          } else {
            result += '\\u00' + chr.toString(16)
          }

        } else if (chr < 0x1000) {
          result += '\\u0' + chr.toString(16)

        } else if (chr < 0x10000) {
          result += '\\u' + chr.toString(16)

        } else {
          throw Error('weird codepoint')
        }
      } else {
        result += key[i]
      }
    }
    return quote + result + quote
  }

  function _stringify_object() {
    if (object === null) return 'null'
    var result = []
      , len = 0
      , braces

    if (Array.isArray(object)) {
      braces = '[]'
      for (var i=0; i<object.length; i++) {
        var s = _stringify(object[i], options, recursiveLvl+1, String(i))
        if (s === undefined) s = 'null'
        len += s.length + 2
        result.push(s + ',')
      }

    } else {
      braces = '{}'
      var fn = function(key) {
        var t = _stringify(object[key], options, recursiveLvl+1, key)
        if (t !== undefined) {
          t = _stringify_key(key) + ':' + (options.indent ? ' ' : '') + t + ','
          len += t.length + 1
          result.push(t)
        }
      }

      if (Array.isArray(options.replacer)) {
        for (var i=0; i<options.replacer.length; i++)
          if (hasOwnProperty.call(object, options.replacer[i]))
            fn(options.replacer[i])
      } else {
        var keys = Object.keys(object)
        if (options.sort_keys)
          keys = keys.sort(typeof(options.sort_keys) === 'function'
                           ? options.sort_keys : undefined)
        keys.forEach(fn)
      }
    }

    // objects shorter than 30 characters are always inlined
    // objects longer than 60 characters are always splitted to multiple lines
    // anything in the middle depends on indentation level
    len -= 2
    if (options.indent && (len > options._splitMax - recursiveLvl * options.indent.length || len > options._splitMin) ) {
      // remove trailing comma in multiline if asked to
      if (options.no_trailing_comma && result.length) {
        result[result.length-1] = result[result.length-1].substring(0, result[result.length-1].length-1)
      }

      var innerStuff = result.map(function(x) {return indent(x, 1)}).join('')
      return braces[0]
          + (options.indent ? '\n' : '')
          + innerStuff
          + indent(braces[1])
    } else {
      // always remove trailing comma in one-lined arrays
      if (result.length) {
        result[result.length-1] = result[result.length-1].substring(0, result[result.length-1].length-1)
      }

      var innerStuff = result.join(options.indent ? ' ' : '')
      return braces[0]
          + innerStuff
          + braces[1]
    }
  }

  function _stringify_nonobject(object) {
    if (typeof(options.replacer) === 'function') {
      object = options.replacer.call(null, currentKey, object)
    }

    switch(typeof(object)) {
      case 'string':
        return _stringify_str(object)

      case 'number':
        if (object === 0 && 1/object < 0) {
          // Opinionated decision warning:
          //
          // I want cross-platform negative zero in all js engines
          // I know they're equal, but why lose that tiny bit of
          // information needlessly?
          return '-0'
        }
        if (!json5 && !Number.isFinite(object)) {
          // json don't support infinity (= sucks)
          return 'null'
        }
        return object.toString()

      case 'boolean':
        return object.toString()

      case 'undefined':
        return undefined

      case 'function':
//        return custom_type()

      default:
        // fallback for something weird
        return JSON.stringify(object)
    }
  }

  if (options._stringify_key) {
    return _stringify_key(object)
  }

  if (typeof(object) === 'object') {
    if (object === null) return 'null'

    var str
    if (typeof(str = object.toJSON5) === 'function' && options.mode !== 'json') {
      object = str.call(object, currentKey)

    } else if (typeof(str = object.toJSON) === 'function') {
      object = str.call(object, currentKey)
    }

    if (object === null) return 'null'
    if (typeof(object) !== 'object') return _stringify_nonobject(object)

    if (object.constructor === Number || object.constructor === Boolean || object.constructor === String) {
      object = object.valueOf()
      return _stringify_nonobject(object)

    } else if (object.constructor === Date) {
      // only until we can't do better
      return _stringify_nonobject(object.toISOString())

    } else {
      if (typeof(options.replacer) === 'function') {
        object = options.replacer.call(null, currentKey, object)
        if (typeof(object) !== 'object') return _stringify_nonobject(object)
      }

      return _stringify_object(object)
    }
  } else {
    return _stringify_nonobject(object)
  }
}

/*
 * stringify(value, options)
 * or
 * stringify(value, replacer, space)
 *
 * where:
 * value - anything
 * options - object
 * replacer - function or array
 * space - boolean or number or string
 */
module.exports.P = function stringifyJSON(object, options, _space) {
  // support legacy syntax
  if (typeof(options) === 'function' || Array.isArray(options)) {
    options = {
      replacer: options
    }
  } else if (typeof(options) === 'object' && options !== null) {
    // nothing to do
  } else {
    options = {}
  }
  if (_space != null) options.indent = _space

  if (options.indent == null) options.indent = '\t'
  if (options.quote == null) options.quote = "'"
  if (options.ascii == null) options.ascii = false
  if (options.mode == null) options.mode = 'json5'

  if (options.mode === 'json' || options.mode === 'cjson') {
    // json only supports double quotes (= sucks)
    options.quote = '"'

    // json don't support trailing commas (= sucks)
    options.no_trailing_comma = true

    // json don't support unquoted property names (= sucks)
    options.quote_keys = true
  }

  // why would anyone use such objects?
  if (typeof(options.indent) === 'object') {
    if (options.indent.constructor === Number
    ||  options.indent.constructor === Boolean
    ||  options.indent.constructor === String)
      options.indent = options.indent.valueOf()
  }

  // gap is capped at 10 characters
  if (typeof(options.indent) === 'number') {
    if (options.indent >= 0) {
      options.indent = Array(Math.min(~~options.indent, 10) + 1).join(' ')
    } else {
      options.indent = false
    }
  } else if (typeof(options.indent) === 'string') {
    options.indent = options.indent.substr(0, 10)
  }

  if (options._splitMin == null) options._splitMin = 50
  if (options._splitMax == null) options._splitMax = 70

  return _stringify(object, options, 0, '')
}



/***/ }),

/***/ 69527:
/***/ ((module) => {


// This is autogenerated with esprima tools, see:
// https://github.com/ariya/esprima/blob/master/esprima.js
//
// PS: oh God, I hate Unicode

// ECMAScript 5.1/Unicode v6.3.0 NonAsciiIdentifierStart:

var Uni = module.exports

module.exports.isWhiteSpace = function isWhiteSpace(x) {
  // section 7.2, table 2
  return x === '\u0020'
      || x === '\u00A0'
      || x === '\uFEFF' // <-- this is not a Unicode WS, only a JS one
      || (x >= '\u0009' && x <= '\u000D') // 9 A B C D

      // + whitespace characters from unicode, category Zs
      || x === '\u1680'
      || (x >= '\u2000' && x <= '\u200A') // 0 1 2 3 4 5 6 7 8 9 A
      || x === '\u2028'
      || x === '\u2029'
      || x === '\u202F'
      || x === '\u205F'
      || x === '\u3000'
}

module.exports.isWhiteSpaceJSON = function isWhiteSpaceJSON(x) {
  return x === '\u0020'
      || x === '\u0009'
      || x === '\u000A'
      || x === '\u000D'
}

module.exports.isLineTerminator = function isLineTerminator(x) {
  // ok, here is the part when JSON is wrong
  // section 7.3, table 3
  return x === '\u000A'
      || x === '\u000D'
      || x === '\u2028'
      || x === '\u2029'
}

module.exports.isLineTerminatorJSON = function isLineTerminatorJSON(x) {
  return x === '\u000A'
      || x === '\u000D'
}

module.exports.isIdentifierStart = function isIdentifierStart(x) {
  return x === '$'
      || x === '_'
      || (x >= 'A' && x <= 'Z')
      || (x >= 'a' && x <= 'z')
      || (x >= '\u0080' && Uni.NonAsciiIdentifierStart.test(x))
}

module.exports.isIdentifierPart = function isIdentifierPart(x) {
  return x === '$'
      || x === '_'
      || (x >= 'A' && x <= 'Z')
      || (x >= 'a' && x <= 'z')
      || (x >= '0' && x <= '9') // <-- addition to Start
      || (x >= '\u0080' && Uni.NonAsciiIdentifierPart.test(x))
}

module.exports.NonAsciiIdentifierStart = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/

// ECMAScript 5.1/Unicode v6.3.0 NonAsciiIdentifierPart:

module.exports.NonAsciiIdentifierPart = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/


/***/ }),

/***/ 72577:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var FS  = __webpack_require__(35747)
var jju = __webpack_require__(93304)

// this function registers json5 extension, so you
// can do `require("./config.json5")` kind of thing
module.exports.register = function() {
  var r = require, e = 'extensions'
  r[e]['.json5'] = function(m, f) {
    /*eslint no-sync:0*/
    m.exports = jju.parse(FS.readFileSync(f, 'utf8'))
  }
}

// this function monkey-patches JSON.parse, so it
// will return an exact position of error in case
// of parse failure
module.exports.patch_JSON_parse = function() {
  var _parse = JSON.parse
  JSON.parse = function(text, rev) {
    try {
      return _parse(text, rev)
    } catch(err) {
      // this call should always throw
      __webpack_require__(93304).parse(text, {
        mode: 'json',
        legacy: true,
        reviver: rev,
        reserved_keys: 'replace',
        null_prototype: false,
      })

      // if it didn't throw, but original parser did,
      // this is an error in this library and should be reported
      throw err
    }
  }
}

// this function is an express/connect middleware
// that accepts uploads in application/json5 format
module.exports.middleware = function() {
  return function(req, res, next) {
    throw Error('this function is removed, use express-json5 instead')
  }
}



/***/ }),

/***/ 26160:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _fs
try {
  _fs = __webpack_require__(77758)
} catch (_) {
  _fs = __webpack_require__(35747)
}

function readFile (file, options, callback) {
  if (callback == null) {
    callback = options
    options = {}
  }

  if (typeof options === 'string') {
    options = {encoding: options}
  }

  options = options || {}
  var fs = options.fs || _fs

  var shouldThrow = true
  if ('throws' in options) {
    shouldThrow = options.throws
  }

  fs.readFile(file, options, function (err, data) {
    if (err) return callback(err)

    data = stripBom(data)

    var obj
    try {
      obj = JSON.parse(data, options ? options.reviver : null)
    } catch (err2) {
      if (shouldThrow) {
        err2.message = file + ': ' + err2.message
        return callback(err2)
      } else {
        return callback(null, null)
      }
    }

    callback(null, obj)
  })
}

function readFileSync (file, options) {
  options = options || {}
  if (typeof options === 'string') {
    options = {encoding: options}
  }

  var fs = options.fs || _fs

  var shouldThrow = true
  if ('throws' in options) {
    shouldThrow = options.throws
  }

  try {
    var content = fs.readFileSync(file, options)
    content = stripBom(content)
    return JSON.parse(content, options.reviver)
  } catch (err) {
    if (shouldThrow) {
      err.message = file + ': ' + err.message
      throw err
    } else {
      return null
    }
  }
}

function stringify (obj, options) {
  var spaces
  var EOL = '\n'
  if (typeof options === 'object' && options !== null) {
    if (options.spaces) {
      spaces = options.spaces
    }
    if (options.EOL) {
      EOL = options.EOL
    }
  }

  var str = JSON.stringify(obj, options ? options.replacer : null, spaces)

  return str.replace(/\n/g, EOL) + EOL
}

function writeFile (file, obj, options, callback) {
  if (callback == null) {
    callback = options
    options = {}
  }
  options = options || {}
  var fs = options.fs || _fs

  var str = ''
  try {
    str = stringify(obj, options)
  } catch (err) {
    // Need to return whether a callback was passed or not
    if (callback) callback(err, null)
    return
  }

  fs.writeFile(file, str, options, callback)
}

function writeFileSync (file, obj, options) {
  options = options || {}
  var fs = options.fs || _fs

  var str = stringify(obj, options)
  // not sure if fs.writeFileSync returns anything, but just in case
  return fs.writeFileSync(file, str, options)
}

function stripBom (content) {
  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
  if (Buffer.isBuffer(content)) content = content.toString('utf8')
  content = content.replace(/^\uFEFF/, '')
  return content
}

var jsonfile = {
  readFile: readFile,
  readFileSync: readFileSync,
  writeFile: writeFile,
  writeFileSync: writeFileSync
}

module.exports = jsonfile


/***/ }),

/***/ 63269:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

(function (global, factory) {
   true ? factory(exports) :
  0;
}(this, (function (exports) { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    return function () {
      var Super = _getPrototypeOf(Derived),
          result;

      if (_isNativeReflectConstruct()) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o) {
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var it,
        normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = o[Symbol.iterator]();
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  /* eslint-disable prefer-named-capture-group */
  // Disabled `prefer-named-capture-group` due to https://github.com/babel/babel/issues/8951#issuecomment-508045524
  // Only Node.JS has a process variable that is of [[Class]] process
  var supportsNodeVM = function supportsNodeVM() {
    try {
      return Object.prototype.toString.call(global.process) === '[object process]';
    } catch (e) {
      return false;
    }
  };

  var hasOwnProp = Object.prototype.hasOwnProperty;
  /**
  * @typedef {null|boolean|number|string|PlainObject|GenericArray} JSONObject
  */

  /**
  * @callback ConditionCallback
  * @param {any} item
  * @returns {boolean}
  */

  /**
   * Copy items out of one array into another.
   * @param {GenericArray} source Array with items to copy
   * @param {GenericArray} target Array to which to copy
   * @param {ConditionCallback} conditionCb Callback passed the current item;
   *     will move item if evaluates to `true`
   * @returns {void}
   */

  var moveToAnotherArray = function moveToAnotherArray(source, target, conditionCb) {
    var il = source.length;

    for (var i = 0; i < il; i++) {
      var item = source[i];

      if (conditionCb(item)) {
        target.push(source.splice(i--, 1)[0]);
      }
    }
  };

  JSONPath.nodeVMSupported = supportsNodeVM();
  var vm = JSONPath.nodeVMSupported ? __webpack_require__(92184) : {
    /**
     * @param {string} expr Expression to evaluate
     * @param {PlainObject} context Object whose items will be added
     *   to evaluation
     * @returns {any} Result of evaluated code
     */
    runInNewContext: function runInNewContext(expr, context) {
      var keys = Object.keys(context);
      var funcs = [];
      moveToAnotherArray(keys, funcs, function (key) {
        return typeof context[key] === 'function';
      });
      var values = keys.map(function (vr, i) {
        return context[vr];
      });
      var funcString = funcs.reduce(function (s, func) {
        var fString = context[func].toString();

        if (!/function/.test(fString)) {
          fString = 'function ' + fString;
        }

        return 'var ' + func + '=' + fString + ';' + s;
      }, '');
      expr = funcString + expr; // Mitigate http://perfectionkills.com/global-eval-what-are-the-options/#new_function

      if (!expr.match(/(["'])use strict\1/) && !keys.includes('arguments')) {
        expr = 'var arguments = undefined;' + expr;
      } // Remove last semi so `return` will be inserted before
      //  the previous one instead, allowing for the return
      //  of a bare ending expression


      expr = expr.replace(/;[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*$/, ''); // Insert `return`

      var lastStatementEnd = expr.lastIndexOf(';');
      var code = lastStatementEnd > -1 ? expr.slice(0, lastStatementEnd + 1) + ' return ' + expr.slice(lastStatementEnd + 1) : ' return ' + expr; // eslint-disable-next-line no-new-func

      return _construct(Function, _toConsumableArray(keys).concat([code])).apply(void 0, _toConsumableArray(values));
    }
  };
  /**
   * Copies array and then pushes item into it.
   * @param {GenericArray} arr Array to copy and into which to push
   * @param {any} item Array item to add (to end)
   * @returns {GenericArray} Copy of the original array
   */

  function push(arr, item) {
    arr = arr.slice();
    arr.push(item);
    return arr;
  }
  /**
   * Copies array and then unshifts item into it.
   * @param {any} item Array item to add (to beginning)
   * @param {GenericArray} arr Array to copy and into which to unshift
   * @returns {GenericArray} Copy of the original array
   */


  function unshift(item, arr) {
    arr = arr.slice();
    arr.unshift(item);
    return arr;
  }
  /**
   * Caught when JSONPath is used without `new` but rethrown if with `new`
   * @extends Error
   */


  var NewError = /*#__PURE__*/function (_Error) {
    _inherits(NewError, _Error);

    var _super = _createSuper(NewError);

    /**
     * @param {any} value The evaluated scalar value
     */
    function NewError(value) {
      var _this;

      _classCallCheck(this, NewError);

      _this = _super.call(this, 'JSONPath should not be called with "new" (it prevents return ' + 'of (unwrapped) scalar values)');
      _this.avoidNew = true;
      _this.value = value;
      _this.name = 'NewError';
      return _this;
    }

    return NewError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  /**
  * @typedef {PlainObject} ReturnObject
  * @property {string} path
  * @property {JSONObject} value
  * @property {PlainObject|GenericArray} parent
  * @property {string} parentProperty
  */

  /**
  * @callback JSONPathCallback
  * @param {string|PlainObject} preferredOutput
  * @param {"value"|"property"} type
  * @param {ReturnObject} fullRetObj
  * @returns {void}
  */

  /**
  * @callback OtherTypeCallback
  * @param {JSONObject} val
  * @param {string} path
  * @param {PlainObject|GenericArray} parent
  * @param {string} parentPropName
  * @returns {boolean}
  */

  /**
   * @typedef {PlainObject} JSONPathOptions
   * @property {JSON} json
   * @property {string|string[]} path
   * @property {"value"|"path"|"pointer"|"parent"|"parentProperty"|"all"}
   *   [resultType="value"]
   * @property {boolean} [flatten=false]
   * @property {boolean} [wrap=true]
   * @property {PlainObject} [sandbox={}]
   * @property {boolean} [preventEval=false]
   * @property {PlainObject|GenericArray|null} [parent=null]
   * @property {string|null} [parentProperty=null]
   * @property {JSONPathCallback} [callback]
   * @property {OtherTypeCallback} [otherTypeCallback] Defaults to
   *   function which throws on encountering `@other`
   * @property {boolean} [autostart=true]
   */

  /**
   * @param {string|JSONPathOptions} opts If a string, will be treated as `expr`
   * @param {string} [expr] JSON path to evaluate
   * @param {JSON} [obj] JSON object to evaluate against
   * @param {JSONPathCallback} [callback] Passed 3 arguments: 1) desired payload
   *     per `resultType`, 2) `"value"|"property"`, 3) Full returned object with
   *     all payloads
   * @param {OtherTypeCallback} [otherTypeCallback] If `@other()` is at the end
   *   of one's query, this will be invoked with the value of the item, its
   *   path, its parent, and its parent's property name, and it should return
   *   a boolean indicating whether the supplied value belongs to the "other"
   *   type or not (or it may handle transformations and return `false`).
   * @returns {JSONPath}
   * @class
   */


  function JSONPath(opts, expr, obj, callback, otherTypeCallback) {
    // eslint-disable-next-line no-restricted-syntax
    if (!(this instanceof JSONPath)) {
      try {
        return new JSONPath(opts, expr, obj, callback, otherTypeCallback);
      } catch (e) {
        if (!e.avoidNew) {
          throw e;
        }

        return e.value;
      }
    }

    if (typeof opts === 'string') {
      otherTypeCallback = callback;
      callback = obj;
      obj = expr;
      expr = opts;
      opts = null;
    }

    var optObj = opts && _typeof(opts) === 'object';
    opts = opts || {};
    this.json = opts.json || obj;
    this.path = opts.path || expr;
    this.resultType = opts.resultType || 'value';
    this.flatten = opts.flatten || false;
    this.wrap = hasOwnProp.call(opts, 'wrap') ? opts.wrap : true;
    this.sandbox = opts.sandbox || {};
    this.preventEval = opts.preventEval || false;
    this.parent = opts.parent || null;
    this.parentProperty = opts.parentProperty || null;
    this.callback = opts.callback || callback || null;

    this.otherTypeCallback = opts.otherTypeCallback || otherTypeCallback || function () {
      throw new TypeError('You must supply an otherTypeCallback callback option ' + 'with the @other() operator.');
    };

    if (opts.autostart !== false) {
      var args = {
        path: optObj ? opts.path : expr
      };

      if (!optObj) {
        args.json = obj;
      } else if ('json' in opts) {
        args.json = opts.json;
      }

      var ret = this.evaluate(args);

      if (!ret || _typeof(ret) !== 'object') {
        throw new NewError(ret);
      }

      return ret;
    }
  } // PUBLIC METHODS


  JSONPath.prototype.evaluate = function (expr, json, callback, otherTypeCallback) {
    var that = this;
    var currParent = this.parent,
        currParentProperty = this.parentProperty;
    var flatten = this.flatten,
        wrap = this.wrap;
    this.currResultType = this.resultType;
    this.currPreventEval = this.preventEval;
    this.currSandbox = this.sandbox;
    callback = callback || this.callback;
    this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;
    json = json || this.json;
    expr = expr || this.path;

    if (expr && _typeof(expr) === 'object' && !Array.isArray(expr)) {
      if (!expr.path && expr.path !== '') {
        throw new TypeError('You must supply a "path" property when providing an object ' + 'argument to JSONPath.evaluate().');
      }

      if (!hasOwnProp.call(expr, 'json')) {
        throw new TypeError('You must supply a "json" property when providing an object ' + 'argument to JSONPath.evaluate().');
      }

      var _expr = expr;
      json = _expr.json;
      flatten = hasOwnProp.call(expr, 'flatten') ? expr.flatten : flatten;
      this.currResultType = hasOwnProp.call(expr, 'resultType') ? expr.resultType : this.currResultType;
      this.currSandbox = hasOwnProp.call(expr, 'sandbox') ? expr.sandbox : this.currSandbox;
      wrap = hasOwnProp.call(expr, 'wrap') ? expr.wrap : wrap;
      this.currPreventEval = hasOwnProp.call(expr, 'preventEval') ? expr.preventEval : this.currPreventEval;
      callback = hasOwnProp.call(expr, 'callback') ? expr.callback : callback;
      this.currOtherTypeCallback = hasOwnProp.call(expr, 'otherTypeCallback') ? expr.otherTypeCallback : this.currOtherTypeCallback;
      currParent = hasOwnProp.call(expr, 'parent') ? expr.parent : currParent;
      currParentProperty = hasOwnProp.call(expr, 'parentProperty') ? expr.parentProperty : currParentProperty;
      expr = expr.path;
    }

    currParent = currParent || null;
    currParentProperty = currParentProperty || null;

    if (Array.isArray(expr)) {
      expr = JSONPath.toPathString(expr);
    }

    if (!expr && expr !== '' || !json) {
      return undefined;
    }

    this._obj = json;
    var exprList = JSONPath.toPathArray(expr);

    if (exprList[0] === '$' && exprList.length > 1) {
      exprList.shift();
    }

    this._hasParentSelector = null;

    var result = this._trace(exprList, json, ['$'], currParent, currParentProperty, callback).filter(function (ea) {
      return ea && !ea.isParentSelector;
    });

    if (!result.length) {
      return wrap ? [] : undefined;
    }

    if (!wrap && result.length === 1 && !result[0].hasArrExpr) {
      return this._getPreferredOutput(result[0]);
    }

    return result.reduce(function (rslt, ea) {
      var valOrPath = that._getPreferredOutput(ea);

      if (flatten && Array.isArray(valOrPath)) {
        rslt = rslt.concat(valOrPath);
      } else {
        rslt.push(valOrPath);
      }

      return rslt;
    }, []);
  }; // PRIVATE METHODS


  JSONPath.prototype._getPreferredOutput = function (ea) {
    var resultType = this.currResultType;

    switch (resultType) {
      default:
        throw new TypeError('Unknown result type');

      case 'all':
        {
          var path = Array.isArray(ea.path) ? ea.path : JSONPath.toPathArray(ea.path);
          ea.pointer = JSONPath.toPointer(path);
          ea.path = typeof ea.path === 'string' ? ea.path : JSONPath.toPathString(ea.path);
          return ea;
        }

      case 'value':
      case 'parent':
      case 'parentProperty':
        return ea[resultType];

      case 'path':
        return JSONPath.toPathString(ea[resultType]);

      case 'pointer':
        return JSONPath.toPointer(ea.path);
    }
  };

  JSONPath.prototype._handleCallback = function (fullRetObj, callback, type) {
    if (callback) {
      var preferredOutput = this._getPreferredOutput(fullRetObj);

      fullRetObj.path = typeof fullRetObj.path === 'string' ? fullRetObj.path : JSONPath.toPathString(fullRetObj.path); // eslint-disable-next-line callback-return

      callback(preferredOutput, type, fullRetObj);
    }
  };
  /**
   *
   * @param {string} expr
   * @param {JSONObject} val
   * @param {string} path
   * @param {PlainObject|GenericArray} parent
   * @param {string} parentPropName
   * @param {JSONPathCallback} callback
   * @param {boolean} hasArrExpr
   * @param {boolean} literalPriority
   * @returns {ReturnObject|ReturnObject[]}
   */


  JSONPath.prototype._trace = function (expr, val, path, parent, parentPropName, callback, hasArrExpr, literalPriority) {
    // No expr to follow? return path and value as the result of
    //  this trace branch
    var retObj;
    var that = this;

    if (!expr.length) {
      retObj = {
        path: path,
        value: val,
        parent: parent,
        parentProperty: parentPropName,
        hasArrExpr: hasArrExpr
      };

      this._handleCallback(retObj, callback, 'value');

      return retObj;
    }

    var loc = expr[0],
        x = expr.slice(1); // We need to gather the return value of recursive trace calls in order to
    // do the parent sel computation.

    var ret = [];
    /**
     *
     * @param {ReturnObject|ReturnObject[]} elems
     * @returns {void}
     */

    function addRet(elems) {
      if (Array.isArray(elems)) {
        // This was causing excessive stack size in Node (with or
        //  without Babel) against our performance test:
        //  `ret.push(...elems);`
        elems.forEach(function (t) {
          ret.push(t);
        });
      } else {
        ret.push(elems);
      }
    }

    if ((typeof loc !== 'string' || literalPriority) && val && hasOwnProp.call(val, loc)) {
      // simple case--directly follow property
      addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr));
    } else if (loc === '*') {
      // all child properties
      this._walk(loc, x, val, path, parent, parentPropName, callback, function (m, l, _x, v, p, par, pr, cb) {
        addRet(that._trace(unshift(m, _x), v, p, par, pr, cb, true, true));
      });
    } else if (loc === '..') {
      // all descendent parent properties
      // Check remaining expression with val's immediate children
      addRet(this._trace(x, val, path, parent, parentPropName, callback, hasArrExpr));

      this._walk(loc, x, val, path, parent, parentPropName, callback, function (m, l, _x, v, p, par, pr, cb) {
        // We don't join m and x here because we only want parents,
        //   not scalar values
        if (_typeof(v[m]) === 'object') {
          // Keep going with recursive descent on val's
          //   object children
          addRet(that._trace(unshift(l, _x), v[m], push(p, m), v, m, cb, true));
        }
      }); // The parent sel computation is handled in the frame above using the
      // ancestor object of val

    } else if (loc === '^') {
      // This is not a final endpoint, so we do not invoke the callback here
      this._hasParentSelector = true;
      return {
        path: path.slice(0, -1),
        expr: x,
        isParentSelector: true
      };
    } else if (loc === '~') {
      // property name
      retObj = {
        path: push(path, loc),
        value: parentPropName,
        parent: parent,
        parentProperty: null
      };

      this._handleCallback(retObj, callback, 'property');

      return retObj;
    } else if (loc === '$') {
      // root only
      addRet(this._trace(x, val, path, null, null, callback, hasArrExpr));
    } else if (/^(\x2D?[0-9]*):(\x2D?[0-9]*):?([0-9]*)$/.test(loc)) {
      // [start:end:step]  Python slice syntax
      addRet(this._slice(loc, x, val, path, parent, parentPropName, callback));
    } else if (loc.indexOf('?(') === 0) {
      // [?(expr)] (filtering)
      if (this.currPreventEval) {
        throw new Error('Eval [?(expr)] prevented in JSONPath expression.');
      }

      this._walk(loc, x, val, path, parent, parentPropName, callback, function (m, l, _x, v, p, par, pr, cb) {
        if (that._eval(l.replace(/^\?\(((?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*?)\)$/, '$1'), v[m], m, p, par, pr)) {
          addRet(that._trace(unshift(m, _x), v, p, par, pr, cb, true));
        }
      });
    } else if (loc[0] === '(') {
      // [(expr)] (dynamic property/index)
      if (this.currPreventEval) {
        throw new Error('Eval [(expr)] prevented in JSONPath expression.');
      } // As this will resolve to a property name (but we don't know it
      //  yet), property and parent information is relative to the
      //  parent of the property to which this expression will resolve


      addRet(this._trace(unshift(this._eval(loc, val, path[path.length - 1], path.slice(0, -1), parent, parentPropName), x), val, path, parent, parentPropName, callback, hasArrExpr));
    } else if (loc[0] === '@') {
      // value type: @boolean(), etc.
      var addType = false;
      var valueType = loc.slice(1, -2);

      switch (valueType) {
        /* istanbul ignore next */
        default:
          throw new TypeError('Unknown value type ' + valueType);

        case 'scalar':
          if (!val || !['object', 'function'].includes(_typeof(val))) {
            addType = true;
          }

          break;

        case 'boolean':
        case 'string':
        case 'undefined':
        case 'function':
          // eslint-disable-next-line valid-typeof
          if (_typeof(val) === valueType) {
            addType = true;
          }

          break;

        case 'integer':
          if (Number.isFinite(val) && !(val % 1)) {
            addType = true;
          }

          break;

        case 'number':
          if (Number.isFinite(val)) {
            addType = true;
          }

          break;

        case 'nonFinite':
          if (typeof val === 'number' && !Number.isFinite(val)) {
            addType = true;
          }

          break;

        case 'object':
          // eslint-disable-next-line valid-typeof
          if (val && _typeof(val) === valueType) {
            addType = true;
          }

          break;

        case 'array':
          if (Array.isArray(val)) {
            addType = true;
          }

          break;

        case 'other':
          addType = this.currOtherTypeCallback(val, path, parent, parentPropName);
          break;

        case 'null':
          if (val === null) {
            addType = true;
          }

          break;
      }

      if (addType) {
        retObj = {
          path: path,
          value: val,
          parent: parent,
          parentProperty: parentPropName
        };

        this._handleCallback(retObj, callback, 'value');

        return retObj;
      } // `-escaped property

    } else if (loc[0] === '`' && val && hasOwnProp.call(val, loc.slice(1))) {
      var locProp = loc.slice(1);
      addRet(this._trace(x, val[locProp], push(path, locProp), val, locProp, callback, hasArrExpr, true));
    } else if (loc.includes(',')) {
      // [name1,name2,...]
      var parts = loc.split(',');

      var _iterator = _createForOfIteratorHelper(parts),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var part = _step.value;
          addRet(this._trace(unshift(part, x), val, path, parent, parentPropName, callback, true));
        } // simple case--directly follow property

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } else if (!literalPriority && val && hasOwnProp.call(val, loc)) {
      addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr, true));
    } // We check the resulting values for parent selections. For parent
    // selections we discard the value object and continue the trace with the
    // current val object


    if (this._hasParentSelector) {
      for (var t = 0; t < ret.length; t++) {
        var rett = ret[t];

        if (rett && rett.isParentSelector) {
          var tmp = that._trace(rett.expr, val, rett.path, parent, parentPropName, callback, hasArrExpr);

          if (Array.isArray(tmp)) {
            ret[t] = tmp[0];
            var tl = tmp.length;

            for (var tt = 1; tt < tl; tt++) {
              t++;
              ret.splice(t, 0, tmp[tt]);
            }
          } else {
            ret[t] = tmp;
          }
        }
      }
    }

    return ret;
  };

  JSONPath.prototype._walk = function (loc, expr, val, path, parent, parentPropName, callback, f) {
    if (Array.isArray(val)) {
      var n = val.length;

      for (var i = 0; i < n; i++) {
        f(i, loc, expr, val, path, parent, parentPropName, callback);
      }
    } else if (val && _typeof(val) === 'object') {
      Object.keys(val).forEach(function (m) {
        f(m, loc, expr, val, path, parent, parentPropName, callback);
      });
    }
  };

  JSONPath.prototype._slice = function (loc, expr, val, path, parent, parentPropName, callback) {
    if (!Array.isArray(val)) {
      return undefined;
    }

    var len = val.length,
        parts = loc.split(':'),
        step = parts[2] && Number.parseInt(parts[2]) || 1;
    var start = parts[0] && Number.parseInt(parts[0]) || 0,
        end = parts[1] && Number.parseInt(parts[1]) || len;
    start = start < 0 ? Math.max(0, start + len) : Math.min(len, start);
    end = end < 0 ? Math.max(0, end + len) : Math.min(len, end);
    var ret = [];

    for (var i = start; i < end; i += step) {
      var tmp = this._trace(unshift(i, expr), val, path, parent, parentPropName, callback, true); // Should only be possible to be an array here since first part of
      //   ``unshift(i, expr)` passed in above would not be empty, nor `~`,
      //     nor begin with `@` (as could return objects)
      // This was causing excessive stack size in Node (with or
      //  without Babel) against our performance test: `ret.push(...tmp);`


      tmp.forEach(function (t) {
        ret.push(t);
      });
    }

    return ret;
  };

  JSONPath.prototype._eval = function (code, _v, _vname, path, parent, parentPropName) {
    if (!this._obj || !_v) {
      return false;
    }

    if (code.includes('@parentProperty')) {
      this.currSandbox._$_parentProperty = parentPropName;
      code = code.replace(/@parentProperty/g, '_$_parentProperty');
    }

    if (code.includes('@parent')) {
      this.currSandbox._$_parent = parent;
      code = code.replace(/@parent/g, '_$_parent');
    }

    if (code.includes('@property')) {
      this.currSandbox._$_property = _vname;
      code = code.replace(/@property/g, '_$_property');
    }

    if (code.includes('@path')) {
      this.currSandbox._$_path = JSONPath.toPathString(path.concat([_vname]));
      code = code.replace(/@path/g, '_$_path');
    }

    if (code.includes('@root')) {
      this.currSandbox._$_root = this.json;
      code = code.replace(/@root/g, '_$_root');
    }

    if (code.match(/@([\t-\r \)\.\[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF])/)) {
      this.currSandbox._$_v = _v;
      code = code.replace(/@([\t-\r \)\.\[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF])/g, '_$_v$1');
    }

    try {
      return vm.runInNewContext(code, this.currSandbox);
    } catch (e) {
      // eslint-disable-next-line no-console
      console.log(e);
      throw new Error('jsonPath: ' + e.message + ': ' + code);
    }
  }; // PUBLIC CLASS PROPERTIES AND METHODS
  // Could store the cache object itself


  JSONPath.cache = {};
  /**
   * @param {string[]} pathArr Array to convert
   * @returns {string} The path string
   */

  JSONPath.toPathString = function (pathArr) {
    var x = pathArr,
        n = x.length;
    var p = '$';

    for (var i = 1; i < n; i++) {
      if (!/^(~|\^|@(?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*?\(\))$/.test(x[i])) {
        p += /^[\*0-9]+$/.test(x[i]) ? '[' + x[i] + ']' : "['" + x[i] + "']";
      }
    }

    return p;
  };
  /**
   * @param {string} pointer JSON Path
   * @returns {string} JSON Pointer
   */


  JSONPath.toPointer = function (pointer) {
    var x = pointer,
        n = x.length;
    var p = '';

    for (var i = 1; i < n; i++) {
      if (!/^(~|\^|@(?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*?\(\))$/.test(x[i])) {
        p += '/' + x[i].toString().replace(/~/g, '~0').replace(/\//g, '~1');
      }
    }

    return p;
  };
  /**
   * @param {string} expr Expression to convert
   * @returns {string[]}
   */


  JSONPath.toPathArray = function (expr) {
    var cache = JSONPath.cache;

    if (cache[expr]) {
      return cache[expr].concat();
    }

    var subx = [];
    var normalized = expr // Properties
    .replace(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\(\)/g, ';$&;') // Parenthetical evaluations (filtering and otherwise), directly
    //   within brackets or single quotes
    .replace(/['\[](\??\((?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*?\))['\]]/g, function ($0, $1) {
      return '[#' + (subx.push($1) - 1) + ']';
    }) // Escape periods and tildes within properties
    .replace(/\['((?:[\0-&\(-\\\^-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)'\]/g, function ($0, prop) {
      return "['" + prop.replace(/\./g, '%@%').replace(/~/g, '%%@@%%') + "']";
    }) // Properties operator
    .replace(/~/g, ';~;') // Split by property boundaries
    .replace(/'?\.'?(?!(?:[\0-Z\\-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*\])|\['?/g, ';') // Reinsert periods within properties
    .replace(/%@%/g, '.') // Reinsert tildes within properties
    .replace(/%%@@%%/g, '~') // Parent
    .replace(/(?:;)?(\^+)(?:;)?/g, function ($0, ups) {
      return ';' + ups.split('').join(';') + ';';
    }) // Descendents
    .replace(/;;;|;;/g, ';..;') // Remove trailing
    .replace(/;$|'?\]|'$/g, '');
    var exprList = normalized.split(';').map(function (exp) {
      var match = exp.match(/#([0-9]+)/);
      return !match || !match[1] ? exp : subx[match[1]];
    });
    cache[expr] = exprList;
    return cache[expr];
  };

  exports.JSONPath = JSONPath;

  Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ 7129:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// A linked list to keep track of recently-used-ness
const Yallist = __webpack_require__(40665)

const MAX = Symbol('max')
const LENGTH = Symbol('length')
const LENGTH_CALCULATOR = Symbol('lengthCalculator')
const ALLOW_STALE = Symbol('allowStale')
const MAX_AGE = Symbol('maxAge')
const DISPOSE = Symbol('dispose')
const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')
const LRU_LIST = Symbol('lruList')
const CACHE = Symbol('cache')
const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')

const naiveLength = () => 1

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache {
  constructor (options) {
    if (typeof options === 'number')
      options = { max: options }

    if (!options)
      options = {}

    if (options.max && (typeof options.max !== 'number' || options.max < 0))
      throw new TypeError('max must be a non-negative number')
    // Kind of weird to have a default max of Infinity, but oh well.
    const max = this[MAX] = options.max || Infinity

    const lc = options.length || naiveLength
    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc
    this[ALLOW_STALE] = options.stale || false
    if (options.maxAge && typeof options.maxAge !== 'number')
      throw new TypeError('maxAge must be a number')
    this[MAX_AGE] = options.maxAge || 0
    this[DISPOSE] = options.dispose
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false
    this.reset()
  }

  // resize the cache when the max changes.
  set max (mL) {
    if (typeof mL !== 'number' || mL < 0)
      throw new TypeError('max must be a non-negative number')

    this[MAX] = mL || Infinity
    trim(this)
  }
  get max () {
    return this[MAX]
  }

  set allowStale (allowStale) {
    this[ALLOW_STALE] = !!allowStale
  }
  get allowStale () {
    return this[ALLOW_STALE]
  }

  set maxAge (mA) {
    if (typeof mA !== 'number')
      throw new TypeError('maxAge must be a non-negative number')

    this[MAX_AGE] = mA
    trim(this)
  }
  get maxAge () {
    return this[MAX_AGE]
  }

  // resize the cache when the lengthCalculator changes.
  set lengthCalculator (lC) {
    if (typeof lC !== 'function')
      lC = naiveLength

    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(hit => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      })
    }
    trim(this)
  }
  get lengthCalculator () { return this[LENGTH_CALCULATOR] }

  get length () { return this[LENGTH] }
  get itemCount () { return this[LRU_LIST].length }

  rforEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].tail; walker !== null;) {
      const prev = walker.prev
      forEachStep(this, fn, walker, thisp)
      walker = prev
    }
  }

  forEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].head; walker !== null;) {
      const next = walker.next
      forEachStep(this, fn, walker, thisp)
      walker = next
    }
  }

  keys () {
    return this[LRU_LIST].toArray().map(k => k.key)
  }

  values () {
    return this[LRU_LIST].toArray().map(k => k.value)
  }

  reset () {
    if (this[DISPOSE] &&
        this[LRU_LIST] &&
        this[LRU_LIST].length) {
      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))
    }

    this[CACHE] = new Map() // hash of items by key
    this[LRU_LIST] = new Yallist() // list of items in order of use recency
    this[LENGTH] = 0 // length of items in the list
  }

  dump () {
    return this[LRU_LIST].map(hit =>
      isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter(h => h)
  }

  dumpLru () {
    return this[LRU_LIST]
  }

  set (key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE]

    if (maxAge && typeof maxAge !== 'number')
      throw new TypeError('maxAge must be a number')

    const now = maxAge ? Date.now() : 0
    const len = this[LENGTH_CALCULATOR](value, key)

    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key))
        return false
      }

      const node = this[CACHE].get(key)
      const item = node.value

      // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value)
      }

      item.now = now
      item.maxAge = maxAge
      item.value = value
      this[LENGTH] += len - item.length
      item.length = len
      this.get(key)
      trim(this)
      return true
    }

    const hit = new Entry(key, value, len, now, maxAge)

    // oversized objects fall out of cache automatically.
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value)

      return false
    }

    this[LENGTH] += hit.length
    this[LRU_LIST].unshift(hit)
    this[CACHE].set(key, this[LRU_LIST].head)
    trim(this)
    return true
  }

  has (key) {
    if (!this[CACHE].has(key)) return false
    const hit = this[CACHE].get(key).value
    return !isStale(this, hit)
  }

  get (key) {
    return get(this, key, true)
  }

  peek (key) {
    return get(this, key, false)
  }

  pop () {
    const node = this[LRU_LIST].tail
    if (!node)
      return null

    del(this, node)
    return node.value
  }

  del (key) {
    del(this, this[CACHE].get(key))
  }

  load (arr) {
    // reset the cache
    this.reset()

    const now = Date.now()
    // A previous serialized cache has the most recent items first
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l]
      const expiresAt = hit.e || 0
      if (expiresAt === 0)
        // the item was created without expiration in a non aged cache
        this.set(hit.k, hit.v)
      else {
        const maxAge = expiresAt - now
        // dont add already expired items
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge)
        }
      }
    }
  }

  prune () {
    this[CACHE].forEach((value, key) => get(this, key, false))
  }
}

const get = (self, key, doUse) => {
  const node = self[CACHE].get(key)
  if (node) {
    const hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE])
        return undefined
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET])
          node.value.now = Date.now()
        self[LRU_LIST].unshiftNode(node)
      }
    }
    return hit.value
  }
}

const isStale = (self, hit) => {
  if (!hit || (!hit.maxAge && !self[MAX_AGE]))
    return false

  const diff = Date.now() - hit.now
  return hit.maxAge ? diff > hit.maxAge
    : self[MAX_AGE] && (diff > self[MAX_AGE])
}

const trim = self => {
  if (self[LENGTH] > self[MAX]) {
    for (let walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      const prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

const del = (self, node) => {
  if (node) {
    const hit = node.value
    if (self[DISPOSE])
      self[DISPOSE](hit.key, hit.value)

    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
}

class Entry {
  constructor (key, value, length, now, maxAge) {
    this.key = key
    this.value = value
    this.length = length
    this.now = now
    this.maxAge = maxAge || 0
  }
}

const forEachStep = (self, fn, node, thisp) => {
  let hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!self[ALLOW_STALE])
      hit = undefined
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self)
}

module.exports = LRUCache


/***/ }),

/***/ 41077:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const proc = typeof process === 'object' && process ? process : {
  stdout: null,
  stderr: null,
}
const EE = __webpack_require__(28614)
const Stream = __webpack_require__(92413)
const Yallist = __webpack_require__(40665)
const SD = __webpack_require__(24304).StringDecoder

const EOF = Symbol('EOF')
const MAYBE_EMIT_END = Symbol('maybeEmitEnd')
const EMITTED_END = Symbol('emittedEnd')
const EMITTING_END = Symbol('emittingEnd')
const EMITTED_ERROR = Symbol('emittedError')
const CLOSED = Symbol('closed')
const READ = Symbol('read')
const FLUSH = Symbol('flush')
const FLUSHCHUNK = Symbol('flushChunk')
const ENCODING = Symbol('encoding')
const DECODER = Symbol('decoder')
const FLOWING = Symbol('flowing')
const PAUSED = Symbol('paused')
const RESUME = Symbol('resume')
const BUFFERLENGTH = Symbol('bufferLength')
const BUFFERPUSH = Symbol('bufferPush')
const BUFFERSHIFT = Symbol('bufferShift')
const OBJECTMODE = Symbol('objectMode')
const DESTROYED = Symbol('destroyed')

// TODO remove when Node v8 support drops
const doIter = global._MP_NO_ITERATOR_SYMBOLS_  !== '1'
const ASYNCITERATOR = doIter && Symbol.asyncIterator
  || Symbol('asyncIterator not implemented')
const ITERATOR = doIter && Symbol.iterator
  || Symbol('iterator not implemented')

// events that mean 'the stream is over'
// these are treated specially, and re-emitted
// if they are listened for after emitting.
const isEndish = ev =>
  ev === 'end' ||
  ev === 'finish' ||
  ev === 'prefinish'

const isArrayBuffer = b => b instanceof ArrayBuffer ||
  typeof b === 'object' &&
  b.constructor &&
  b.constructor.name === 'ArrayBuffer' &&
  b.byteLength >= 0

const isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)

module.exports = class Minipass extends Stream {
  constructor (options) {
    super()
    this[FLOWING] = false
    // whether we're explicitly paused
    this[PAUSED] = false
    this.pipes = new Yallist()
    this.buffer = new Yallist()
    this[OBJECTMODE] = options && options.objectMode || false
    if (this[OBJECTMODE])
      this[ENCODING] = null
    else
      this[ENCODING] = options && options.encoding || null
    if (this[ENCODING] === 'buffer')
      this[ENCODING] = null
    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null
    this[EOF] = false
    this[EMITTED_END] = false
    this[EMITTING_END] = false
    this[CLOSED] = false
    this[EMITTED_ERROR] = null
    this.writable = true
    this.readable = true
    this[BUFFERLENGTH] = 0
    this[DESTROYED] = false
  }

  get bufferLength () { return this[BUFFERLENGTH] }

  get encoding () { return this[ENCODING] }
  set encoding (enc) {
    if (this[OBJECTMODE])
      throw new Error('cannot set encoding in objectMode')

    if (this[ENCODING] && enc !== this[ENCODING] &&
        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
      throw new Error('cannot change encoding')

    if (this[ENCODING] !== enc) {
      this[DECODER] = enc ? new SD(enc) : null
      if (this.buffer.length)
        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))
    }

    this[ENCODING] = enc
  }

  setEncoding (enc) {
    this.encoding = enc
  }

  get objectMode () { return this[OBJECTMODE] }
  set objectMode (om) { this[OBJECTMODE] = this[OBJECTMODE] || !!om }

  write (chunk, encoding, cb) {
    if (this[EOF])
      throw new Error('write after end')

    if (this[DESTROYED]) {
      this.emit('error', Object.assign(
        new Error('Cannot call write after a stream was destroyed'),
        { code: 'ERR_STREAM_DESTROYED' }
      ))
      return true
    }

    if (typeof encoding === 'function')
      cb = encoding, encoding = 'utf8'

    if (!encoding)
      encoding = 'utf8'

    // convert array buffers and typed array views into buffers
    // at some point in the future, we may want to do the opposite!
    // leave strings and buffers as-is
    // anything else switches us into object mode
    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView(chunk))
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)
      else if (isArrayBuffer(chunk))
        chunk = Buffer.from(chunk)
      else if (typeof chunk !== 'string')
        // use the setter so we throw if we have encoding set
        this.objectMode = true
    }

    // this ensures at this point that the chunk is a buffer or string
    // don't buffer it up or send it to the decoder
    if (!this.objectMode && !chunk.length) {
      if (this[BUFFERLENGTH] !== 0)
        this.emit('readable')
      if (cb)
        cb()
      return this.flowing
    }

    // fast-path writing strings of same encoding to a stream with
    // an empty buffer, skipping the buffer/decoder dance
    if (typeof chunk === 'string' && !this[OBJECTMODE] &&
        // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
      chunk = Buffer.from(chunk, encoding)
    }

    if (Buffer.isBuffer(chunk) && this[ENCODING])
      chunk = this[DECODER].write(chunk)

    if (this.flowing) {
      // if we somehow have something in the buffer, but we think we're
      // flowing, then we need to flush all that out first, or we get
      // chunks coming in out of order.  Can't emit 'drain' here though,
      // because we're mid-write, so that'd be bad.
      if (this[BUFFERLENGTH] !== 0)
        this[FLUSH](true)
      this.emit('data', chunk)
    } else
      this[BUFFERPUSH](chunk)

    if (this[BUFFERLENGTH] !== 0)
      this.emit('readable')

    if (cb)
      cb()

    return this.flowing
  }

  read (n) {
    if (this[DESTROYED])
      return null

    try {
      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])
        return null

      if (this[OBJECTMODE])
        n = null

      if (this.buffer.length > 1 && !this[OBJECTMODE]) {
        if (this.encoding)
          this.buffer = new Yallist([
            Array.from(this.buffer).join('')
          ])
        else
          this.buffer = new Yallist([
            Buffer.concat(Array.from(this.buffer), this[BUFFERLENGTH])
          ])
      }

      return this[READ](n || null, this.buffer.head.value)
    } finally {
      this[MAYBE_EMIT_END]()
    }
  }

  [READ] (n, chunk) {
    if (n === chunk.length || n === null)
      this[BUFFERSHIFT]()
    else {
      this.buffer.head.value = chunk.slice(n)
      chunk = chunk.slice(0, n)
      this[BUFFERLENGTH] -= n
    }

    this.emit('data', chunk)

    if (!this.buffer.length && !this[EOF])
      this.emit('drain')

    return chunk
  }

  end (chunk, encoding, cb) {
    if (typeof chunk === 'function')
      cb = chunk, chunk = null
    if (typeof encoding === 'function')
      cb = encoding, encoding = 'utf8'
    if (chunk)
      this.write(chunk, encoding)
    if (cb)
      this.once('end', cb)
    this[EOF] = true
    this.writable = false

    // if we haven't written anything, then go ahead and emit,
    // even if we're not reading.
    // we'll re-emit if a new 'end' listener is added anyway.
    // This makes MP more suitable to write-only use cases.
    if (this.flowing || !this[PAUSED])
      this[MAYBE_EMIT_END]()
    return this
  }

  // don't let the internal resume be overwritten
  [RESUME] () {
    if (this[DESTROYED])
      return

    this[PAUSED] = false
    this[FLOWING] = true
    this.emit('resume')
    if (this.buffer.length)
      this[FLUSH]()
    else if (this[EOF])
      this[MAYBE_EMIT_END]()
    else
      this.emit('drain')
  }

  resume () {
    return this[RESUME]()
  }

  pause () {
    this[FLOWING] = false
    this[PAUSED] = true
  }

  get destroyed () {
    return this[DESTROYED]
  }

  get flowing () {
    return this[FLOWING]
  }

  get paused () {
    return this[PAUSED]
  }

  [BUFFERPUSH] (chunk) {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] += 1
    else
      this[BUFFERLENGTH] += chunk.length
    return this.buffer.push(chunk)
  }

  [BUFFERSHIFT] () {
    if (this.buffer.length) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] -= 1
      else
        this[BUFFERLENGTH] -= this.buffer.head.value.length
    }
    return this.buffer.shift()
  }

  [FLUSH] (noDrain) {
    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))

    if (!noDrain && !this.buffer.length && !this[EOF])
      this.emit('drain')
  }

  [FLUSHCHUNK] (chunk) {
    return chunk ? (this.emit('data', chunk), this.flowing) : false
  }

  pipe (dest, opts) {
    if (this[DESTROYED])
      return

    const ended = this[EMITTED_END]
    opts = opts || {}
    if (dest === proc.stdout || dest === proc.stderr)
      opts.end = false
    else
      opts.end = opts.end !== false

    const p = { dest: dest, opts: opts, ondrain: _ => this[RESUME]() }
    this.pipes.push(p)

    dest.on('drain', p.ondrain)
    this[RESUME]()
    // piping an ended stream ends immediately
    if (ended && p.opts.end)
      p.dest.end()
    return dest
  }

  addListener (ev, fn) {
    return this.on(ev, fn)
  }

  on (ev, fn) {
    try {
      return super.on(ev, fn)
    } finally {
      if (ev === 'data' && !this.pipes.length && !this.flowing)
        this[RESUME]()
      else if (isEndish(ev) && this[EMITTED_END]) {
        super.emit(ev)
        this.removeAllListeners(ev)
      } else if (ev === 'error' && this[EMITTED_ERROR]) {
        fn.call(this, this[EMITTED_ERROR])
      }
    }
  }

  get emittedEnd () {
    return this[EMITTED_END]
  }

  [MAYBE_EMIT_END] () {
    if (!this[EMITTING_END] &&
        !this[EMITTED_END] &&
        !this[DESTROYED] &&
        this.buffer.length === 0 &&
        this[EOF]) {
      this[EMITTING_END] = true
      this.emit('end')
      this.emit('prefinish')
      this.emit('finish')
      if (this[CLOSED])
        this.emit('close')
      this[EMITTING_END] = false
    }
  }

  emit (ev, data) {
    // error and close are only events allowed after calling destroy()
    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])
      return
    else if (ev === 'data') {
      if (!data)
        return

      if (this.pipes.length)
        this.pipes.forEach(p =>
          p.dest.write(data) === false && this.pause())
    } else if (ev === 'end') {
      // only actual end gets this treatment
      if (this[EMITTED_END] === true)
        return

      this[EMITTED_END] = true
      this.readable = false

      if (this[DECODER]) {
        data = this[DECODER].end()
        if (data) {
          this.pipes.forEach(p => p.dest.write(data))
          super.emit('data', data)
        }
      }

      this.pipes.forEach(p => {
        p.dest.removeListener('drain', p.ondrain)
        if (p.opts.end)
          p.dest.end()
      })
    } else if (ev === 'close') {
      this[CLOSED] = true
      // don't emit close before 'end' and 'finish'
      if (!this[EMITTED_END] && !this[DESTROYED])
        return
    } else if (ev === 'error') {
      this[EMITTED_ERROR] = data
    }

    // TODO: replace with a spread operator when Node v4 support drops
    const args = new Array(arguments.length)
    args[0] = ev
    args[1] = data
    if (arguments.length > 2) {
      for (let i = 2; i < arguments.length; i++) {
        args[i] = arguments[i]
      }
    }

    try {
      return super.emit.apply(this, args)
    } finally {
      if (!isEndish(ev))
        this[MAYBE_EMIT_END]()
      else
        this.removeAllListeners(ev)
    }
  }

  // const all = await stream.collect()
  collect () {
    const buf = []
    if (!this[OBJECTMODE])
      buf.dataLength = 0
    // set the promise first, in case an error is raised
    // by triggering the flow here.
    const p = this.promise()
    this.on('data', c => {
      buf.push(c)
      if (!this[OBJECTMODE])
        buf.dataLength += c.length
    })
    return p.then(() => buf)
  }

  // const data = await stream.concat()
  concat () {
    return this[OBJECTMODE]
      ? Promise.reject(new Error('cannot concat in objectMode'))
      : this.collect().then(buf =>
          this[OBJECTMODE]
            ? Promise.reject(new Error('cannot concat in objectMode'))
            : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength))
  }

  // stream.promise().then(() => done, er => emitted error)
  promise () {
    return new Promise((resolve, reject) => {
      this.on(DESTROYED, () => reject(new Error('stream destroyed')))
      this.on('error', er => reject(er))
      this.on('end', () => resolve())
    })
  }

  // for await (let chunk of stream)
  [ASYNCITERATOR] () {
    const next = () => {
      const res = this.read()
      if (res !== null)
        return Promise.resolve({ done: false, value: res })

      if (this[EOF])
        return Promise.resolve({ done: true })

      let resolve = null
      let reject = null
      const onerr = er => {
        this.removeListener('data', ondata)
        this.removeListener('end', onend)
        reject(er)
      }
      const ondata = value => {
        this.removeListener('error', onerr)
        this.removeListener('end', onend)
        this.pause()
        resolve({ value: value, done: !!this[EOF] })
      }
      const onend = () => {
        this.removeListener('error', onerr)
        this.removeListener('data', ondata)
        resolve({ done: true })
      }
      const ondestroy = () => onerr(new Error('stream destroyed'))
      return new Promise((res, rej) => {
        reject = rej
        resolve = res
        this.once(DESTROYED, ondestroy)
        this.once('error', onerr)
        this.once('end', onend)
        this.once('data', ondata)
      })
    }

    return { next }
  }

  // for (let chunk of stream)
  [ITERATOR] () {
    const next = () => {
      const value = this.read()
      const done = value === null
      return { value, done }
    }
    return { next }
  }

  destroy (er) {
    if (this[DESTROYED]) {
      if (er)
        this.emit('error', er)
      else
        this.emit(DESTROYED)
      return this
    }

    this[DESTROYED] = true

    // throw away all buffered data, it's never coming out
    this.buffer = new Yallist()
    this[BUFFERLENGTH] = 0

    if (typeof this.close === 'function' && !this[CLOSED])
      this.close()

    if (er)
      this.emit('error', er)
    else // if no error to emit, still reject pending promises
      this.emit(DESTROYED)

    return this
  }

  static isStream (s) {
    return !!s && (s instanceof Minipass || s instanceof Stream ||
      s instanceof EE && (
        typeof s.pipe === 'function' || // readable
        (typeof s.write === 'function' && typeof s.end === 'function') // writable
      ))
  }
}


/***/ }),

/***/ 6769:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Update with any zlib constants that are added or changed in the future.
// Node v6 didn't export this, so we just hard code the version and rely
// on all the other hard-coded values from zlib v4736.  When node v6
// support drops, we can just export the realZlibConstants object.
const realZlibConstants = __webpack_require__(78761).constants ||
  /* istanbul ignore next */ { ZLIB_VERNUM: 4736 }

module.exports = Object.freeze(Object.assign(Object.create(null), {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_VERSION_ERROR: -6,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  DEFLATE: 1,
  INFLATE: 2,
  GZIP: 3,
  GUNZIP: 4,
  DEFLATERAW: 5,
  INFLATERAW: 6,
  UNZIP: 7,
  BROTLI_DECODE: 8,
  BROTLI_ENCODE: 9,
  Z_MIN_WINDOWBITS: 8,
  Z_MAX_WINDOWBITS: 15,
  Z_DEFAULT_WINDOWBITS: 15,
  Z_MIN_CHUNK: 64,
  Z_MAX_CHUNK: Infinity,
  Z_DEFAULT_CHUNK: 16384,
  Z_MIN_MEMLEVEL: 1,
  Z_MAX_MEMLEVEL: 9,
  Z_DEFAULT_MEMLEVEL: 8,
  Z_MIN_LEVEL: -1,
  Z_MAX_LEVEL: 9,
  Z_DEFAULT_LEVEL: -1,
  BROTLI_OPERATION_PROCESS: 0,
  BROTLI_OPERATION_FLUSH: 1,
  BROTLI_OPERATION_FINISH: 2,
  BROTLI_OPERATION_EMIT_METADATA: 3,
  BROTLI_MODE_GENERIC: 0,
  BROTLI_MODE_TEXT: 1,
  BROTLI_MODE_FONT: 2,
  BROTLI_DEFAULT_MODE: 0,
  BROTLI_MIN_QUALITY: 0,
  BROTLI_MAX_QUALITY: 11,
  BROTLI_DEFAULT_QUALITY: 11,
  BROTLI_MIN_WINDOW_BITS: 10,
  BROTLI_MAX_WINDOW_BITS: 24,
  BROTLI_LARGE_MAX_WINDOW_BITS: 30,
  BROTLI_DEFAULT_WINDOW: 22,
  BROTLI_MIN_INPUT_BLOCK_BITS: 16,
  BROTLI_MAX_INPUT_BLOCK_BITS: 24,
  BROTLI_PARAM_MODE: 0,
  BROTLI_PARAM_QUALITY: 1,
  BROTLI_PARAM_LGWIN: 2,
  BROTLI_PARAM_LGBLOCK: 3,
  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
  BROTLI_PARAM_SIZE_HINT: 5,
  BROTLI_PARAM_LARGE_WINDOW: 6,
  BROTLI_PARAM_NPOSTFIX: 7,
  BROTLI_PARAM_NDIRECT: 8,
  BROTLI_DECODER_RESULT_ERROR: 0,
  BROTLI_DECODER_RESULT_SUCCESS: 1,
  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
  BROTLI_DECODER_NO_ERROR: 0,
  BROTLI_DECODER_SUCCESS: 1,
  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
  BROTLI_DECODER_ERROR_UNREACHABLE: -31,
}, realZlibConstants))


/***/ }),

/***/ 33486:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const assert = __webpack_require__(42357)
const Buffer = __webpack_require__(64293).Buffer
const realZlib = __webpack_require__(78761)

const constants = exports.constants = __webpack_require__(6769)
const Minipass = __webpack_require__(41077)

const OriginalBufferConcat = Buffer.concat

const _superWrite = Symbol('_superWrite')
class ZlibError extends Error {
  constructor (err) {
    super('zlib: ' + err.message)
    this.code = err.code
    this.errno = err.errno
    /* istanbul ignore if */
    if (!this.code)
      this.code = 'ZLIB_ERROR'

    this.message = 'zlib: ' + err.message
    Error.captureStackTrace(this, this.constructor)
  }

  get name () {
    return 'ZlibError'
  }
}

// the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.
const _opts = Symbol('opts')
const _flushFlag = Symbol('flushFlag')
const _finishFlushFlag = Symbol('finishFlushFlag')
const _fullFlushFlag = Symbol('fullFlushFlag')
const _handle = Symbol('handle')
const _onError = Symbol('onError')
const _sawError = Symbol('sawError')
const _level = Symbol('level')
const _strategy = Symbol('strategy')
const _ended = Symbol('ended')
const _defaultFullFlush = Symbol('_defaultFullFlush')

class ZlibBase extends Minipass {
  constructor (opts, mode) {
    if (!opts || typeof opts !== 'object')
      throw new TypeError('invalid options for ZlibBase constructor')

    super(opts)
    this[_sawError] = false
    this[_ended] = false
    this[_opts] = opts

    this[_flushFlag] = opts.flush
    this[_finishFlushFlag] = opts.finishFlush
    // this will throw if any options are invalid for the class selected
    try {
      this[_handle] = new realZlib[mode](opts)
    } catch (er) {
      // make sure that all errors get decorated properly
      throw new ZlibError(er)
    }

    this[_onError] = (err) => {
      // no sense raising multiple errors, since we abort on the first one.
      if (this[_sawError])
        return

      this[_sawError] = true

      // there is no way to cleanly recover.
      // continuing only obscures problems.
      this.close()
      this.emit('error', err)
    }

    this[_handle].on('error', er => this[_onError](new ZlibError(er)))
    this.once('end', () => this.close)
  }

  close () {
    if (this[_handle]) {
      this[_handle].close()
      this[_handle] = null
      this.emit('close')
    }
  }

  reset () {
    if (!this[_sawError]) {
      assert(this[_handle], 'zlib binding closed')
      return this[_handle].reset()
    }
  }

  flush (flushFlag) {
    if (this.ended)
      return

    if (typeof flushFlag !== 'number')
      flushFlag = this[_fullFlushFlag]
    this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }))
  }

  end (chunk, encoding, cb) {
    if (chunk)
      this.write(chunk, encoding)
    this.flush(this[_finishFlushFlag])
    this[_ended] = true
    return super.end(null, null, cb)
  }

  get ended () {
    return this[_ended]
  }

  write (chunk, encoding, cb) {
    // process the chunk using the sync process
    // then super.write() all the outputted chunks
    if (typeof encoding === 'function')
      cb = encoding, encoding = 'utf8'

    if (typeof chunk === 'string')
      chunk = Buffer.from(chunk, encoding)

    if (this[_sawError])
      return
    assert(this[_handle], 'zlib binding closed')

    // _processChunk tries to .close() the native handle after it's done, so we
    // intercept that by temporarily making it a no-op.
    const nativeHandle = this[_handle]._handle
    const originalNativeClose = nativeHandle.close
    nativeHandle.close = () => {}
    const originalClose = this[_handle].close
    this[_handle].close = () => {}
    // It also calls `Buffer.concat()` at the end, which may be convenient
    // for some, but which we are not interested in as it slows us down.
    Buffer.concat = (args) => args
    let result
    try {
      const flushFlag = typeof chunk[_flushFlag] === 'number'
        ? chunk[_flushFlag] : this[_flushFlag]
      result = this[_handle]._processChunk(chunk, flushFlag)
      // if we don't throw, reset it back how it was
      Buffer.concat = OriginalBufferConcat
    } catch (err) {
      // or if we do, put Buffer.concat() back before we emit error
      // Error events call into user code, which may call Buffer.concat()
      Buffer.concat = OriginalBufferConcat
      this[_onError](new ZlibError(err))
    } finally {
      if (this[_handle]) {
        // Core zlib resets `_handle` to null after attempting to close the
        // native handle. Our no-op handler prevented actual closure, but we
        // need to restore the `._handle` property.
        this[_handle]._handle = nativeHandle
        nativeHandle.close = originalNativeClose
        this[_handle].close = originalClose
        // `_processChunk()` adds an 'error' listener. If we don't remove it
        // after each call, these handlers start piling up.
        this[_handle].removeAllListeners('error')
        // make sure OUR error listener is still attached tho
      }
    }

    if (this[_handle])
      this[_handle].on('error', er => this[_onError](new ZlibError(er)))

    let writeReturn
    if (result) {
      if (Array.isArray(result) && result.length > 0) {
        // The first buffer is always `handle._outBuffer`, which would be
        // re-used for later invocations; so, we always have to copy that one.
        writeReturn = this[_superWrite](Buffer.from(result[0]))
        for (let i = 1; i < result.length; i++) {
          writeReturn = this[_superWrite](result[i])
        }
      } else {
        writeReturn = this[_superWrite](Buffer.from(result))
      }
    }

    if (cb)
      cb()
    return writeReturn
  }

  [_superWrite] (data) {
    return super.write(data)
  }
}

class Zlib extends ZlibBase {
  constructor (opts, mode) {
    opts = opts || {}

    opts.flush = opts.flush || constants.Z_NO_FLUSH
    opts.finishFlush = opts.finishFlush || constants.Z_FINISH
    super(opts, mode)

    this[_fullFlushFlag] = constants.Z_FULL_FLUSH
    this[_level] = opts.level
    this[_strategy] = opts.strategy
  }

  params (level, strategy) {
    if (this[_sawError])
      return

    if (!this[_handle])
      throw new Error('cannot switch params when binding is closed')

    // no way to test this without also not supporting params at all
    /* istanbul ignore if */
    if (!this[_handle].params)
      throw new Error('not supported in this implementation')

    if (this[_level] !== level || this[_strategy] !== strategy) {
      this.flush(constants.Z_SYNC_FLUSH)
      assert(this[_handle], 'zlib binding closed')
      // .params() calls .flush(), but the latter is always async in the
      // core zlib. We override .flush() temporarily to intercept that and
      // flush synchronously.
      const origFlush = this[_handle].flush
      this[_handle].flush = (flushFlag, cb) => {
        this.flush(flushFlag)
        cb()
      }
      try {
        this[_handle].params(level, strategy)
      } finally {
        this[_handle].flush = origFlush
      }
      /* istanbul ignore else */
      if (this[_handle]) {
        this[_level] = level
        this[_strategy] = strategy
      }
    }
  }
}

// minimal 2-byte header
class Deflate extends Zlib {
  constructor (opts) {
    super(opts, 'Deflate')
  }
}

class Inflate extends Zlib {
  constructor (opts) {
    super(opts, 'Inflate')
  }
}

// gzip - bigger header, same deflate compression
const _portable = Symbol('_portable')
class Gzip extends Zlib {
  constructor (opts) {
    super(opts, 'Gzip')
    this[_portable] = opts && !!opts.portable
  }

  [_superWrite] (data) {
    if (!this[_portable])
      return super[_superWrite](data)

    // we'll always get the header emitted in one first chunk
    // overwrite the OS indicator byte with 0xFF
    this[_portable] = false
    data[9] = 255
    return super[_superWrite](data)
  }
}

class Gunzip extends Zlib {
  constructor (opts) {
    super(opts, 'Gunzip')
  }
}

// raw - no header
class DeflateRaw extends Zlib {
  constructor (opts) {
    super(opts, 'DeflateRaw')
  }
}

class InflateRaw extends Zlib {
  constructor (opts) {
    super(opts, 'InflateRaw')
  }
}

// auto-detect header.
class Unzip extends Zlib {
  constructor (opts) {
    super(opts, 'Unzip')
  }
}

class Brotli extends ZlibBase {
  constructor (opts, mode) {
    opts = opts || {}

    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS
    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH

    super(opts, mode)

    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH
  }
}

class BrotliCompress extends Brotli {
  constructor (opts) {
    super(opts, 'BrotliCompress')
  }
}

class BrotliDecompress extends Brotli {
  constructor (opts) {
    super(opts, 'BrotliDecompress')
  }
}

exports.Deflate = Deflate
exports.Inflate = Inflate
exports.Gzip = Gzip
exports.Gunzip = Gunzip
exports.DeflateRaw = DeflateRaw
exports.InflateRaw = InflateRaw
exports.Unzip = Unzip
/* istanbul ignore else */
if (typeof realZlib.BrotliCompress === 'function') {
  exports.BrotliCompress = BrotliCompress
  exports.BrotliDecompress = BrotliDecompress
} else {
  exports.BrotliCompress = exports.BrotliDecompress = class {
    constructor () {
      throw new Error('Brotli is not supported in this version of Node.js')
    }
  }
}


/***/ }),

/***/ 80467:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Stream = _interopDefault(__webpack_require__(92413));
var http = _interopDefault(__webpack_require__(15876));
var Url = _interopDefault(__webpack_require__(78835));
var https = _interopDefault(__webpack_require__(57211));
var zlib = _interopDefault(__webpack_require__(78761));

// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js

// fix for "Readable" isn't a named export issue
const Readable = Stream.Readable;

const BUFFER = Symbol('buffer');
const TYPE = Symbol('type');

class Blob {
	constructor() {
		this[TYPE] = '';

		const blobParts = arguments[0];
		const options = arguments[1];

		const buffers = [];
		let size = 0;

		if (blobParts) {
			const a = blobParts;
			const length = Number(a.length);
			for (let i = 0; i < length; i++) {
				const element = a[i];
				let buffer;
				if (element instanceof Buffer) {
					buffer = element;
				} else if (ArrayBuffer.isView(element)) {
					buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
				} else if (element instanceof ArrayBuffer) {
					buffer = Buffer.from(element);
				} else if (element instanceof Blob) {
					buffer = element[BUFFER];
				} else {
					buffer = Buffer.from(typeof element === 'string' ? element : String(element));
				}
				size += buffer.length;
				buffers.push(buffer);
			}
		}

		this[BUFFER] = Buffer.concat(buffers);

		let type = options && options.type !== undefined && String(options.type).toLowerCase();
		if (type && !/[^\u0020-\u007E]/.test(type)) {
			this[TYPE] = type;
		}
	}
	get size() {
		return this[BUFFER].length;
	}
	get type() {
		return this[TYPE];
	}
	text() {
		return Promise.resolve(this[BUFFER].toString());
	}
	arrayBuffer() {
		const buf = this[BUFFER];
		const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		return Promise.resolve(ab);
	}
	stream() {
		const readable = new Readable();
		readable._read = function () {};
		readable.push(this[BUFFER]);
		readable.push(null);
		return readable;
	}
	toString() {
		return '[object Blob]';
	}
	slice() {
		const size = this.size;

		const start = arguments[0];
		const end = arguments[1];
		let relativeStart, relativeEnd;
		if (start === undefined) {
			relativeStart = 0;
		} else if (start < 0) {
			relativeStart = Math.max(size + start, 0);
		} else {
			relativeStart = Math.min(start, size);
		}
		if (end === undefined) {
			relativeEnd = size;
		} else if (end < 0) {
			relativeEnd = Math.max(size + end, 0);
		} else {
			relativeEnd = Math.min(end, size);
		}
		const span = Math.max(relativeEnd - relativeStart, 0);

		const buffer = this[BUFFER];
		const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
		const blob = new Blob([], { type: arguments[2] });
		blob[BUFFER] = slicedBuffer;
		return blob;
	}
}

Object.defineProperties(Blob.prototype, {
	size: { enumerable: true },
	type: { enumerable: true },
	slice: { enumerable: true }
});

Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
	value: 'Blob',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * fetch-error.js
 *
 * FetchError interface for operational errors
 */

/**
 * Create FetchError instance
 *
 * @param   String      message      Error message for human
 * @param   String      type         Error type for machine
 * @param   String      systemError  For Node.js system error
 * @return  FetchError
 */
function FetchError(message, type, systemError) {
  Error.call(this, message);

  this.message = message;
  this.type = type;

  // when err.type is `system`, err.code contains system error code
  if (systemError) {
    this.code = this.errno = systemError.code;
  }

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = 'FetchError';

let convert;
try {
	convert = __webpack_require__(22877).convert;
} catch (e) {}

const INTERNALS = Symbol('Body internals');

// fix an issue where "PassThrough" isn't a named export for node <10
const PassThrough = Stream.PassThrough;

/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
function Body(body) {
	var _this = this;

	var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	    _ref$size = _ref.size;

	let size = _ref$size === undefined ? 0 : _ref$size;
	var _ref$timeout = _ref.timeout;
	let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;

	if (body == null) {
		// body is undefined or null
		body = null;
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		body = Buffer.from(body.toString());
	} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		body = Buffer.from(body);
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
	} else if (body instanceof Stream) ; else {
		// none of the above
		// coerce to string then buffer
		body = Buffer.from(String(body));
	}
	this[INTERNALS] = {
		body,
		disturbed: false,
		error: null
	};
	this.size = size;
	this.timeout = timeout;

	if (body instanceof Stream) {
		body.on('error', function (err) {
			const error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
			_this[INTERNALS].error = error;
		});
	}
}

Body.prototype = {
	get body() {
		return this[INTERNALS].body;
	},

	get bodyUsed() {
		return this[INTERNALS].disturbed;
	},

	/**
  * Decode response as ArrayBuffer
  *
  * @return  Promise
  */
	arrayBuffer() {
		return consumeBody.call(this).then(function (buf) {
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		});
	},

	/**
  * Return raw response as Blob
  *
  * @return Promise
  */
	blob() {
		let ct = this.headers && this.headers.get('content-type') || '';
		return consumeBody.call(this).then(function (buf) {
			return Object.assign(
			// Prevent copying
			new Blob([], {
				type: ct.toLowerCase()
			}), {
				[BUFFER]: buf
			});
		});
	},

	/**
  * Decode response as json
  *
  * @return  Promise
  */
	json() {
		var _this2 = this;

		return consumeBody.call(this).then(function (buffer) {
			try {
				return JSON.parse(buffer.toString());
			} catch (err) {
				return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
			}
		});
	},

	/**
  * Decode response as text
  *
  * @return  Promise
  */
	text() {
		return consumeBody.call(this).then(function (buffer) {
			return buffer.toString();
		});
	},

	/**
  * Decode response as buffer (non-spec api)
  *
  * @return  Promise
  */
	buffer() {
		return consumeBody.call(this);
	},

	/**
  * Decode response as text, while automatically detecting the encoding and
  * trying to decode to UTF-8 (non-spec api)
  *
  * @return  Promise
  */
	textConverted() {
		var _this3 = this;

		return consumeBody.call(this).then(function (buffer) {
			return convertBody(buffer, _this3.headers);
		});
	}
};

// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
	body: { enumerable: true },
	bodyUsed: { enumerable: true },
	arrayBuffer: { enumerable: true },
	blob: { enumerable: true },
	json: { enumerable: true },
	text: { enumerable: true }
});

Body.mixIn = function (proto) {
	for (const name of Object.getOwnPropertyNames(Body.prototype)) {
		// istanbul ignore else: future proof
		if (!(name in proto)) {
			const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
			Object.defineProperty(proto, name, desc);
		}
	}
};

/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return  Promise
 */
function consumeBody() {
	var _this4 = this;

	if (this[INTERNALS].disturbed) {
		return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
	}

	this[INTERNALS].disturbed = true;

	if (this[INTERNALS].error) {
		return Body.Promise.reject(this[INTERNALS].error);
	}

	let body = this.body;

	// body is null
	if (body === null) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is blob
	if (isBlob(body)) {
		body = body.stream();
	}

	// body is buffer
	if (Buffer.isBuffer(body)) {
		return Body.Promise.resolve(body);
	}

	// istanbul ignore if: should never happen
	if (!(body instanceof Stream)) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is stream
	// get ready to actually consume the body
	let accum = [];
	let accumBytes = 0;
	let abort = false;

	return new Body.Promise(function (resolve, reject) {
		let resTimeout;

		// allow timeout on slow response body
		if (_this4.timeout) {
			resTimeout = setTimeout(function () {
				abort = true;
				reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
			}, _this4.timeout);
		}

		// handle stream errors
		body.on('error', function (err) {
			if (err.name === 'AbortError') {
				// if the request was aborted, reject with this Error
				abort = true;
				reject(err);
			} else {
				// other errors, such as incorrect content-encoding
				reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
			}
		});

		body.on('data', function (chunk) {
			if (abort || chunk === null) {
				return;
			}

			if (_this4.size && accumBytes + chunk.length > _this4.size) {
				abort = true;
				reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
				return;
			}

			accumBytes += chunk.length;
			accum.push(chunk);
		});

		body.on('end', function () {
			if (abort) {
				return;
			}

			clearTimeout(resTimeout);

			try {
				resolve(Buffer.concat(accum, accumBytes));
			} catch (err) {
				// handle streams that have accumulated too much data (issue #414)
				reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
			}
		});
	});
}

/**
 * Detect buffer encoding and convert to target encoding
 * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
 *
 * @param   Buffer  buffer    Incoming buffer
 * @param   String  encoding  Target encoding
 * @return  String
 */
function convertBody(buffer, headers) {
	if (typeof convert !== 'function') {
		throw new Error('The package `encoding` must be installed to use the textConverted() function');
	}

	const ct = headers.get('content-type');
	let charset = 'utf-8';
	let res, str;

	// header
	if (ct) {
		res = /charset=([^;]*)/i.exec(ct);
	}

	// no charset in content type, peek at response body for at most 1024 bytes
	str = buffer.slice(0, 1024).toString();

	// html5
	if (!res && str) {
		res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
	}

	// html4
	if (!res && str) {
		res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
		if (!res) {
			res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
			if (res) {
				res.pop(); // drop last quote
			}
		}

		if (res) {
			res = /charset=(.*)/i.exec(res.pop());
		}
	}

	// xml
	if (!res && str) {
		res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
	}

	// found charset
	if (res) {
		charset = res.pop();

		// prevent decode issues when sites use incorrect encoding
		// ref: https://hsivonen.fi/encoding-menu/
		if (charset === 'gb2312' || charset === 'gbk') {
			charset = 'gb18030';
		}
	}

	// turn raw buffers into a single utf-8 buffer
	return convert(buffer, 'UTF-8', charset).toString();
}

/**
 * Detect a URLSearchParams object
 * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
 *
 * @param   Object  obj     Object to detect by type or brand
 * @return  String
 */
function isURLSearchParams(obj) {
	// Duck-typing as a necessary condition.
	if (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {
		return false;
	}

	// Brand-checking and more duck-typing as optional condition.
	return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';
}

/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */
function isBlob(obj) {
	return typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}

/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed  instance  Response or Request instance
 * @return  Mixed
 */
function clone(instance) {
	let p1, p2;
	let body = instance.body;

	// don't allow cloning a used body
	if (instance.bodyUsed) {
		throw new Error('cannot clone body after it is used');
	}

	// check that body is a stream and not form-data object
	// note: we can't clone the form-data object without having it as a dependency
	if (body instanceof Stream && typeof body.getBoundary !== 'function') {
		// tee instance body
		p1 = new PassThrough();
		p2 = new PassThrough();
		body.pipe(p1);
		body.pipe(p2);
		// set instance body to teed body and return the other teed body
		instance[INTERNALS].body = p1;
		body = p2;
	}

	return body;
}

/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param   Mixed  instance  Any options.body input
 */
function extractContentType(body) {
	if (body === null) {
		// body is null
		return null;
	} else if (typeof body === 'string') {
		// body is string
		return 'text/plain;charset=UTF-8';
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		return 'application/x-www-form-urlencoded;charset=UTF-8';
	} else if (isBlob(body)) {
		// body is blob
		return body.type || null;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return null;
	} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		return null;
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		return null;
	} else if (typeof body.getBoundary === 'function') {
		// detect form data input from form-data module
		return `multipart/form-data;boundary=${body.getBoundary()}`;
	} else if (body instanceof Stream) {
		// body is stream
		// can't really do much about this
		return null;
	} else {
		// Body constructor defaults other things to string
		return 'text/plain;charset=UTF-8';
	}
}

/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param   Body    instance   Instance of Body
 * @return  Number?            Number of bytes, or null if not possible
 */
function getTotalBytes(instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		return 0;
	} else if (isBlob(body)) {
		return body.size;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return body.length;
	} else if (body && typeof body.getLengthSync === 'function') {
		// detect form data input from form-data module
		if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
		body.hasKnownLength && body.hasKnownLength()) {
			// 2.x
			return body.getLengthSync();
		}
		return null;
	} else {
		// body is stream
		return null;
	}
}

/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param   Body    instance   Instance of Body
 * @return  Void
 */
function writeToStream(dest, instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		dest.end();
	} else if (isBlob(body)) {
		body.stream().pipe(dest);
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		dest.write(body);
		dest.end();
	} else {
		// body is stream
		body.pipe(dest);
	}
}

// expose Promise
Body.Promise = global.Promise;

/**
 * headers.js
 *
 * Headers class offers convenient helpers
 */

const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

function validateName(name) {
	name = `${name}`;
	if (invalidTokenRegex.test(name) || name === '') {
		throw new TypeError(`${name} is not a legal HTTP header name`);
	}
}

function validateValue(value) {
	value = `${value}`;
	if (invalidHeaderCharRegex.test(value)) {
		throw new TypeError(`${value} is not a legal HTTP header value`);
	}
}

/**
 * Find the key in the map object given a header name.
 *
 * Returns undefined if not found.
 *
 * @param   String  name  Header name
 * @return  String|Undefined
 */
function find(map, name) {
	name = name.toLowerCase();
	for (const key in map) {
		if (key.toLowerCase() === name) {
			return key;
		}
	}
	return undefined;
}

const MAP = Symbol('map');
class Headers {
	/**
  * Headers class
  *
  * @param   Object  headers  Response headers
  * @return  Void
  */
	constructor() {
		let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

		this[MAP] = Object.create(null);

		if (init instanceof Headers) {
			const rawHeaders = init.raw();
			const headerNames = Object.keys(rawHeaders);

			for (const headerName of headerNames) {
				for (const value of rawHeaders[headerName]) {
					this.append(headerName, value);
				}
			}

			return;
		}

		// We don't worry about converting prop to ByteString here as append()
		// will handle it.
		if (init == null) ; else if (typeof init === 'object') {
			const method = init[Symbol.iterator];
			if (method != null) {
				if (typeof method !== 'function') {
					throw new TypeError('Header pairs must be iterable');
				}

				// sequence<sequence<ByteString>>
				// Note: per spec we have to first exhaust the lists then process them
				const pairs = [];
				for (const pair of init) {
					if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
						throw new TypeError('Each header pair must be iterable');
					}
					pairs.push(Array.from(pair));
				}

				for (const pair of pairs) {
					if (pair.length !== 2) {
						throw new TypeError('Each header pair must be a name/value tuple');
					}
					this.append(pair[0], pair[1]);
				}
			} else {
				// record<ByteString, ByteString>
				for (const key of Object.keys(init)) {
					const value = init[key];
					this.append(key, value);
				}
			}
		} else {
			throw new TypeError('Provided initializer must be an object');
		}
	}

	/**
  * Return combined header value given name
  *
  * @param   String  name  Header name
  * @return  Mixed
  */
	get(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key === undefined) {
			return null;
		}

		return this[MAP][key].join(', ');
	}

	/**
  * Iterate over all headers
  *
  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
  * @param   Boolean   thisArg   `this` context for callback function
  * @return  Void
  */
	forEach(callback) {
		let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

		let pairs = getHeaders(this);
		let i = 0;
		while (i < pairs.length) {
			var _pairs$i = pairs[i];
			const name = _pairs$i[0],
			      value = _pairs$i[1];

			callback.call(thisArg, value, name, this);
			pairs = getHeaders(this);
			i++;
		}
	}

	/**
  * Overwrite header values given name
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	set(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		this[MAP][key !== undefined ? key : name] = [value];
	}

	/**
  * Append a value onto existing header
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	append(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			this[MAP][key].push(value);
		} else {
			this[MAP][name] = [value];
		}
	}

	/**
  * Check for header name existence
  *
  * @param   String   name  Header name
  * @return  Boolean
  */
	has(name) {
		name = `${name}`;
		validateName(name);
		return find(this[MAP], name) !== undefined;
	}

	/**
  * Delete all header values given name
  *
  * @param   String  name  Header name
  * @return  Void
  */
	delete(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			delete this[MAP][key];
		}
	}

	/**
  * Return raw headers (non-spec api)
  *
  * @return  Object
  */
	raw() {
		return this[MAP];
	}

	/**
  * Get an iterator on keys.
  *
  * @return  Iterator
  */
	keys() {
		return createHeadersIterator(this, 'key');
	}

	/**
  * Get an iterator on values.
  *
  * @return  Iterator
  */
	values() {
		return createHeadersIterator(this, 'value');
	}

	/**
  * Get an iterator on entries.
  *
  * This is the default iterator of the Headers object.
  *
  * @return  Iterator
  */
	[Symbol.iterator]() {
		return createHeadersIterator(this, 'key+value');
	}
}
Headers.prototype.entries = Headers.prototype[Symbol.iterator];

Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
	value: 'Headers',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Headers.prototype, {
	get: { enumerable: true },
	forEach: { enumerable: true },
	set: { enumerable: true },
	append: { enumerable: true },
	has: { enumerable: true },
	delete: { enumerable: true },
	keys: { enumerable: true },
	values: { enumerable: true },
	entries: { enumerable: true }
});

function getHeaders(headers) {
	let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';

	const keys = Object.keys(headers[MAP]).sort();
	return keys.map(kind === 'key' ? function (k) {
		return k.toLowerCase();
	} : kind === 'value' ? function (k) {
		return headers[MAP][k].join(', ');
	} : function (k) {
		return [k.toLowerCase(), headers[MAP][k].join(', ')];
	});
}

const INTERNAL = Symbol('internal');

function createHeadersIterator(target, kind) {
	const iterator = Object.create(HeadersIteratorPrototype);
	iterator[INTERNAL] = {
		target,
		kind,
		index: 0
	};
	return iterator;
}

const HeadersIteratorPrototype = Object.setPrototypeOf({
	next() {
		// istanbul ignore if
		if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
			throw new TypeError('Value of `this` is not a HeadersIterator');
		}

		var _INTERNAL = this[INTERNAL];
		const target = _INTERNAL.target,
		      kind = _INTERNAL.kind,
		      index = _INTERNAL.index;

		const values = getHeaders(target, kind);
		const len = values.length;
		if (index >= len) {
			return {
				value: undefined,
				done: true
			};
		}

		this[INTERNAL].index = index + 1;

		return {
			value: values[index],
			done: false
		};
	}
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));

Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
	value: 'HeadersIterator',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * Export the Headers object in a form that Node.js can consume.
 *
 * @param   Headers  headers
 * @return  Object
 */
function exportNodeCompatibleHeaders(headers) {
	const obj = Object.assign({ __proto__: null }, headers[MAP]);

	// http.request() only supports string as Host header. This hack makes
	// specifying custom Host header possible.
	const hostHeaderKey = find(headers[MAP], 'Host');
	if (hostHeaderKey !== undefined) {
		obj[hostHeaderKey] = obj[hostHeaderKey][0];
	}

	return obj;
}

/**
 * Create a Headers object from an object of headers, ignoring those that do
 * not conform to HTTP grammar productions.
 *
 * @param   Object  obj  Object of headers
 * @return  Headers
 */
function createHeadersLenient(obj) {
	const headers = new Headers();
	for (const name of Object.keys(obj)) {
		if (invalidTokenRegex.test(name)) {
			continue;
		}
		if (Array.isArray(obj[name])) {
			for (const val of obj[name]) {
				if (invalidHeaderCharRegex.test(val)) {
					continue;
				}
				if (headers[MAP][name] === undefined) {
					headers[MAP][name] = [val];
				} else {
					headers[MAP][name].push(val);
				}
			}
		} else if (!invalidHeaderCharRegex.test(obj[name])) {
			headers[MAP][name] = [obj[name]];
		}
	}
	return headers;
}

const INTERNALS$1 = Symbol('Response internals');

// fix an issue where "STATUS_CODES" aren't a named export for node <10
const STATUS_CODES = http.STATUS_CODES;

/**
 * Response class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
class Response {
	constructor() {
		let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
		let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		Body.call(this, body, opts);

		const status = opts.status || 200;
		const headers = new Headers(opts.headers);

		if (body != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(body);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		this[INTERNALS$1] = {
			url: opts.url,
			status,
			statusText: opts.statusText || STATUS_CODES[status],
			headers,
			counter: opts.counter
		};
	}

	get url() {
		return this[INTERNALS$1].url || '';
	}

	get status() {
		return this[INTERNALS$1].status;
	}

	/**
  * Convenience property representing if the request ended normally
  */
	get ok() {
		return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
	}

	get redirected() {
		return this[INTERNALS$1].counter > 0;
	}

	get statusText() {
		return this[INTERNALS$1].statusText;
	}

	get headers() {
		return this[INTERNALS$1].headers;
	}

	/**
  * Clone this response
  *
  * @return  Response
  */
	clone() {
		return new Response(clone(this), {
			url: this.url,
			status: this.status,
			statusText: this.statusText,
			headers: this.headers,
			ok: this.ok,
			redirected: this.redirected
		});
	}
}

Body.mixIn(Response.prototype);

Object.defineProperties(Response.prototype, {
	url: { enumerable: true },
	status: { enumerable: true },
	ok: { enumerable: true },
	redirected: { enumerable: true },
	statusText: { enumerable: true },
	headers: { enumerable: true },
	clone: { enumerable: true }
});

Object.defineProperty(Response.prototype, Symbol.toStringTag, {
	value: 'Response',
	writable: false,
	enumerable: false,
	configurable: true
});

const INTERNALS$2 = Symbol('Request internals');

// fix an issue where "format", "parse" aren't a named export for node <10
const parse_url = Url.parse;
const format_url = Url.format;

const streamDestructionSupported = 'destroy' in Stream.Readable.prototype;

/**
 * Check if a value is an instance of Request.
 *
 * @param   Mixed   input
 * @return  Boolean
 */
function isRequest(input) {
	return typeof input === 'object' && typeof input[INTERNALS$2] === 'object';
}

function isAbortSignal(signal) {
	const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);
	return !!(proto && proto.constructor.name === 'AbortSignal');
}

/**
 * Request class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */
class Request {
	constructor(input) {
		let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		let parsedURL;

		// normalize input
		if (!isRequest(input)) {
			if (input && input.href) {
				// in order to support Node.js' Url objects; though WHATWG's URL objects
				// will fall into this branch also (since their `toString()` will return
				// `href` property anyway)
				parsedURL = parse_url(input.href);
			} else {
				// coerce input to a string before attempting to parse
				parsedURL = parse_url(`${input}`);
			}
			input = {};
		} else {
			parsedURL = parse_url(input.url);
		}

		let method = init.method || input.method || 'GET';
		method = method.toUpperCase();

		if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
			throw new TypeError('Request with GET/HEAD method cannot have body');
		}

		let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;

		Body.call(this, inputBody, {
			timeout: init.timeout || input.timeout || 0,
			size: init.size || input.size || 0
		});

		const headers = new Headers(init.headers || input.headers || {});

		if (inputBody != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(inputBody);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		let signal = isRequest(input) ? input.signal : null;
		if ('signal' in init) signal = init.signal;

		if (signal != null && !isAbortSignal(signal)) {
			throw new TypeError('Expected signal to be an instanceof AbortSignal');
		}

		this[INTERNALS$2] = {
			method,
			redirect: init.redirect || input.redirect || 'follow',
			headers,
			parsedURL,
			signal
		};

		// node-fetch-only options
		this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
		this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
		this.counter = init.counter || input.counter || 0;
		this.agent = init.agent || input.agent;
	}

	get method() {
		return this[INTERNALS$2].method;
	}

	get url() {
		return format_url(this[INTERNALS$2].parsedURL);
	}

	get headers() {
		return this[INTERNALS$2].headers;
	}

	get redirect() {
		return this[INTERNALS$2].redirect;
	}

	get signal() {
		return this[INTERNALS$2].signal;
	}

	/**
  * Clone this request
  *
  * @return  Request
  */
	clone() {
		return new Request(this);
	}
}

Body.mixIn(Request.prototype);

Object.defineProperty(Request.prototype, Symbol.toStringTag, {
	value: 'Request',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Request.prototype, {
	method: { enumerable: true },
	url: { enumerable: true },
	headers: { enumerable: true },
	redirect: { enumerable: true },
	clone: { enumerable: true },
	signal: { enumerable: true }
});

/**
 * Convert a Request to Node.js http request options.
 *
 * @param   Request  A Request instance
 * @return  Object   The options object to be passed to http.request
 */
function getNodeRequestOptions(request) {
	const parsedURL = request[INTERNALS$2].parsedURL;
	const headers = new Headers(request[INTERNALS$2].headers);

	// fetch step 1.3
	if (!headers.has('Accept')) {
		headers.set('Accept', '*/*');
	}

	// Basic fetch
	if (!parsedURL.protocol || !parsedURL.hostname) {
		throw new TypeError('Only absolute URLs are supported');
	}

	if (!/^https?:$/.test(parsedURL.protocol)) {
		throw new TypeError('Only HTTP(S) protocols are supported');
	}

	if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
		throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
	}

	// HTTP-network-or-cache fetch steps 2.4-2.7
	let contentLengthValue = null;
	if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
		contentLengthValue = '0';
	}
	if (request.body != null) {
		const totalBytes = getTotalBytes(request);
		if (typeof totalBytes === 'number') {
			contentLengthValue = String(totalBytes);
		}
	}
	if (contentLengthValue) {
		headers.set('Content-Length', contentLengthValue);
	}

	// HTTP-network-or-cache fetch step 2.11
	if (!headers.has('User-Agent')) {
		headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
	}

	// HTTP-network-or-cache fetch step 2.15
	if (request.compress && !headers.has('Accept-Encoding')) {
		headers.set('Accept-Encoding', 'gzip,deflate');
	}

	let agent = request.agent;
	if (typeof agent === 'function') {
		agent = agent(parsedURL);
	}

	if (!headers.has('Connection') && !agent) {
		headers.set('Connection', 'close');
	}

	// HTTP-network fetch step 4.2
	// chunked encoding is handled by Node.js

	return Object.assign({}, parsedURL, {
		method: request.method,
		headers: exportNodeCompatibleHeaders(headers),
		agent
	});
}

/**
 * abort-error.js
 *
 * AbortError interface for cancelled requests
 */

/**
 * Create AbortError instance
 *
 * @param   String      message      Error message for human
 * @return  AbortError
 */
function AbortError(message) {
  Error.call(this, message);

  this.type = 'aborted';
  this.message = message;

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

AbortError.prototype = Object.create(Error.prototype);
AbortError.prototype.constructor = AbortError;
AbortError.prototype.name = 'AbortError';

// fix an issue where "PassThrough", "resolve" aren't a named export for node <10
const PassThrough$1 = Stream.PassThrough;
const resolve_url = Url.resolve;

/**
 * Fetch function
 *
 * @param   Mixed    url   Absolute url or Request instance
 * @param   Object   opts  Fetch options
 * @return  Promise
 */
function fetch(url, opts) {

	// allow custom promise
	if (!fetch.Promise) {
		throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
	}

	Body.Promise = fetch.Promise;

	// wrap http.request into fetch
	return new fetch.Promise(function (resolve, reject) {
		// build request object
		const request = new Request(url, opts);
		const options = getNodeRequestOptions(request);

		const send = (options.protocol === 'https:' ? https : http).request;
		const signal = request.signal;

		let response = null;

		const abort = function abort() {
			let error = new AbortError('The user aborted a request.');
			reject(error);
			if (request.body && request.body instanceof Stream.Readable) {
				request.body.destroy(error);
			}
			if (!response || !response.body) return;
			response.body.emit('error', error);
		};

		if (signal && signal.aborted) {
			abort();
			return;
		}

		const abortAndFinalize = function abortAndFinalize() {
			abort();
			finalize();
		};

		// send request
		const req = send(options);
		let reqTimeout;

		if (signal) {
			signal.addEventListener('abort', abortAndFinalize);
		}

		function finalize() {
			req.abort();
			if (signal) signal.removeEventListener('abort', abortAndFinalize);
			clearTimeout(reqTimeout);
		}

		if (request.timeout) {
			req.once('socket', function (socket) {
				reqTimeout = setTimeout(function () {
					reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
					finalize();
				}, request.timeout);
			});
		}

		req.on('error', function (err) {
			reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
			finalize();
		});

		req.on('response', function (res) {
			clearTimeout(reqTimeout);

			const headers = createHeadersLenient(res.headers);

			// HTTP fetch step 5
			if (fetch.isRedirect(res.statusCode)) {
				// HTTP fetch step 5.2
				const location = headers.get('Location');

				// HTTP fetch step 5.3
				const locationURL = location === null ? null : resolve_url(request.url, location);

				// HTTP fetch step 5.5
				switch (request.redirect) {
					case 'error':
						reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
						finalize();
						return;
					case 'manual':
						// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
						if (locationURL !== null) {
							// handle corrupted header
							try {
								headers.set('Location', locationURL);
							} catch (err) {
								// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
								reject(err);
							}
						}
						break;
					case 'follow':
						// HTTP-redirect fetch step 2
						if (locationURL === null) {
							break;
						}

						// HTTP-redirect fetch step 5
						if (request.counter >= request.follow) {
							reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 6 (counter increment)
						// Create a new Request object.
						const requestOpts = {
							headers: new Headers(request.headers),
							follow: request.follow,
							counter: request.counter + 1,
							agent: request.agent,
							compress: request.compress,
							method: request.method,
							body: request.body,
							signal: request.signal,
							timeout: request.timeout,
							size: request.size
						};

						// HTTP-redirect fetch step 9
						if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
							reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 11
						if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
							requestOpts.method = 'GET';
							requestOpts.body = undefined;
							requestOpts.headers.delete('content-length');
						}

						// HTTP-redirect fetch step 15
						resolve(fetch(new Request(locationURL, requestOpts)));
						finalize();
						return;
				}
			}

			// prepare response
			res.once('end', function () {
				if (signal) signal.removeEventListener('abort', abortAndFinalize);
			});
			let body = res.pipe(new PassThrough$1());

			const response_options = {
				url: request.url,
				status: res.statusCode,
				statusText: res.statusMessage,
				headers: headers,
				size: request.size,
				timeout: request.timeout,
				counter: request.counter
			};

			// HTTP-network fetch step 12.1.1.3
			const codings = headers.get('Content-Encoding');

			// HTTP-network fetch step 12.1.1.4: handle content codings

			// in following scenarios we ignore compression support
			// 1. compression support is disabled
			// 2. HEAD request
			// 3. no Content-Encoding header
			// 4. no content response (204)
			// 5. content not modified response (304)
			if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// For Node v6+
			// Be less strict when decoding compressed responses, since sometimes
			// servers send slightly invalid responses that are still accepted
			// by common browsers.
			// Always using Z_SYNC_FLUSH is what cURL does.
			const zlibOptions = {
				flush: zlib.Z_SYNC_FLUSH,
				finishFlush: zlib.Z_SYNC_FLUSH
			};

			// for gzip
			if (codings == 'gzip' || codings == 'x-gzip') {
				body = body.pipe(zlib.createGunzip(zlibOptions));
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// for deflate
			if (codings == 'deflate' || codings == 'x-deflate') {
				// handle the infamous raw deflate response from old servers
				// a hack for old IIS and Apache servers
				const raw = res.pipe(new PassThrough$1());
				raw.once('data', function (chunk) {
					// see http://stackoverflow.com/questions/37519828
					if ((chunk[0] & 0x0F) === 0x08) {
						body = body.pipe(zlib.createInflate());
					} else {
						body = body.pipe(zlib.createInflateRaw());
					}
					response = new Response(body, response_options);
					resolve(response);
				});
				return;
			}

			// for br
			if (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {
				body = body.pipe(zlib.createBrotliDecompress());
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// otherwise, use response as-is
			response = new Response(body, response_options);
			resolve(response);
		});

		writeToStream(req, request);
	});
}
/**
 * Redirect code matching
 *
 * @param   Number   code  Status code
 * @return  Boolean
 */
fetch.isRedirect = function (code) {
	return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
};

// expose Promise
fetch.Promise = global.Promise;

module.exports = exports = fetch;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.default = exports;
exports.Headers = Headers;
exports.Request = Request;
exports.Response = Response;
exports.FetchError = FetchError;


/***/ }),

/***/ 33666:
/***/ ((module, exports) => {

exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var R = 0

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
var NUMERICIDENTIFIERLOOSE = R++
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')'

var MAINVERSIONLOOSE = R++
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')'

var PRERELEASEIDENTIFIERLOOSE = R++
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))'

var PRERELEASELOOSE = R++
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?'

src[FULL] = '^' + FULLPLAIN + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?'

var LOOSE = R++
src[LOOSE] = '^' + LOOSEPLAIN + '$'

var GTLT = R++
src[GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
var XRANGEIDENTIFIER = R++
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

var XRANGEPLAIN = R++
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?'

var XRANGEPLAINLOOSE = R++
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?'

var XRANGE = R++
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
var XRANGELOOSE = R++
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++
src[LONETILDE] = '(?:~>?)'

var TILDETRIM = R++
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

var TILDE = R++
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
var TILDELOOSE = R++
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++
src[LONECARET] = '(?:\\^)'

var CARETTRIM = R++
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
var caretTrimReplace = '$1^'

var CARET = R++
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
var CARETLOOSE = R++
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
var COMPARATOR = R++
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$'

var HYPHENRANGELOOSE = R++
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
var STAR = R++
src[STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[LOOSE] : re[FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1]
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY) {
    return true
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options)
        })
      })
    })
  })
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[TILDELOOSE] : re[TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[CARETLOOSE] : re[CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '')
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  var match = version.match(re[COERCE])

  if (match == null) {
    return null
  }

  return parse(match[1] +
    '.' + (match[2] || '0') +
    '.' + (match[3] || '0'))
}


/***/ }),

/***/ 32695:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = npa
module.exports.resolve = resolve
module.exports.Result = Result

let url
let HostedGit
let semver
let path_
function path () {
  if (!path_) path_ = __webpack_require__(85622)
  return path_
}
let validatePackageName
let osenv

const isWindows = process.platform === 'win32' || global.FAKE_WINDOWS
const hasSlashes = isWindows ? /\\|[/]/ : /[/]/
const isURL = /^(?:git[+])?[a-z]+:/i
const isFilename = /[.](?:tgz|tar.gz|tar)$/i

function npa (arg, where) {
  let name
  let spec
  if (typeof arg === 'object') {
    if (arg instanceof Result && (!where || where === arg.where)) {
      return arg
    } else if (arg.name && arg.rawSpec) {
      return npa.resolve(arg.name, arg.rawSpec, where || arg.where)
    } else {
      return npa(arg.raw, where || arg.where)
    }
  }
  const nameEndsAt = arg[0] === '@' ? arg.slice(1).indexOf('@') + 1 : arg.indexOf('@')
  const namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg
  if (isURL.test(arg)) {
    spec = arg
  } else if (namePart[0] !== '@' && (hasSlashes.test(namePart) || isFilename.test(namePart))) {
    spec = arg
  } else if (nameEndsAt > 0) {
    name = namePart
    spec = arg.slice(nameEndsAt + 1)
  } else {
    if (!validatePackageName) validatePackageName = __webpack_require__(64150)
    const valid = validatePackageName(arg)
    if (valid.validForOldPackages) {
      name = arg
    } else {
      spec = arg
    }
  }
  return resolve(name, spec, where, arg)
}

const isFilespec = isWindows ? /^(?:[.]|~[/]|[/\\]|[a-zA-Z]:)/ : /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/

function resolve (name, spec, where, arg) {
  const res = new Result({
    raw: arg,
    name: name,
    rawSpec: spec,
    fromArgument: arg != null
  })

  if (name) res.setName(name)

  if (spec && (isFilespec.test(spec) || /^file:/i.test(spec))) {
    return fromFile(res, where)
  } else if (spec && /^npm:/i.test(spec)) {
    return fromAlias(res, where)
  }
  if (!HostedGit) HostedGit = __webpack_require__(88869)
  const hosted = HostedGit.fromUrl(spec, {noGitPlus: true, noCommittish: true})
  if (hosted) {
    return fromHostedGit(res, hosted)
  } else if (spec && isURL.test(spec)) {
    return fromURL(res)
  } else if (spec && (hasSlashes.test(spec) || isFilename.test(spec))) {
    return fromFile(res, where)
  } else {
    return fromRegistry(res)
  }
}

function invalidPackageName (name, valid) {
  const err = new Error(`Invalid package name "${name}": ${valid.errors.join('; ')}`)
  err.code = 'EINVALIDPACKAGENAME'
  return err
}
function invalidTagName (name) {
  const err = new Error(`Invalid tag name "${name}": Tags may not have any characters that encodeURIComponent encodes.`)
  err.code = 'EINVALIDTAGNAME'
  return err
}

function Result (opts) {
  this.type = opts.type
  this.registry = opts.registry
  this.where = opts.where
  if (opts.raw == null) {
    this.raw = opts.name ? opts.name + '@' + opts.rawSpec : opts.rawSpec
  } else {
    this.raw = opts.raw
  }
  this.name = undefined
  this.escapedName = undefined
  this.scope = undefined
  this.rawSpec = opts.rawSpec == null ? '' : opts.rawSpec
  this.saveSpec = opts.saveSpec
  this.fetchSpec = opts.fetchSpec
  if (opts.name) this.setName(opts.name)
  this.gitRange = opts.gitRange
  this.gitCommittish = opts.gitCommittish
  this.hosted = opts.hosted
}

Result.prototype.setName = function (name) {
  if (!validatePackageName) validatePackageName = __webpack_require__(64150)
  const valid = validatePackageName(name)
  if (!valid.validForOldPackages) {
    throw invalidPackageName(name, valid)
  }
  this.name = name
  this.scope = name[0] === '@' ? name.slice(0, name.indexOf('/')) : undefined
  // scoped packages in couch must have slash url-encoded, e.g. @foo%2Fbar
  this.escapedName = name.replace('/', '%2f')
  return this
}

Result.prototype.toString = function () {
  const full = []
  if (this.name != null && this.name !== '') full.push(this.name)
  const spec = this.saveSpec || this.fetchSpec || this.rawSpec
  if (spec != null && spec !== '') full.push(spec)
  return full.length ? full.join('@') : this.raw
}

Result.prototype.toJSON = function () {
  const result = Object.assign({}, this)
  delete result.hosted
  return result
}

function setGitCommittish (res, committish) {
  if (committish != null && committish.length >= 7 && committish.slice(0, 7) === 'semver:') {
    res.gitRange = decodeURIComponent(committish.slice(7))
    res.gitCommittish = null
  } else {
    res.gitCommittish = committish === '' ? null : committish
  }
  return res
}

const isAbsolutePath = /^[/]|^[A-Za-z]:/

function resolvePath (where, spec) {
  if (isAbsolutePath.test(spec)) return spec
  return path().resolve(where, spec)
}

function isAbsolute (dir) {
  if (dir[0] === '/') return true
  if (/^[A-Za-z]:/.test(dir)) return true
  return false
}

function fromFile (res, where) {
  if (!where) where = process.cwd()
  res.type = isFilename.test(res.rawSpec) ? 'file' : 'directory'
  res.where = where

  const spec = res.rawSpec.replace(/\\/g, '/')
    .replace(/^file:[/]*([A-Za-z]:)/, '$1') // drive name paths on windows
    .replace(/^file:(?:[/]*([~./]))?/, '$1')
  if (/^~[/]/.test(spec)) {
    // this is needed for windows and for file:~/foo/bar
    if (!osenv) osenv = __webpack_require__(84669)
    res.fetchSpec = resolvePath(osenv.home(), spec.slice(2))
    res.saveSpec = 'file:' + spec
  } else {
    res.fetchSpec = resolvePath(where, spec)
    if (isAbsolute(spec)) {
      res.saveSpec = 'file:' + spec
    } else {
      res.saveSpec = 'file:' + path().relative(where, res.fetchSpec)
    }
  }
  return res
}

function fromHostedGit (res, hosted) {
  res.type = 'git'
  res.hosted = hosted
  res.saveSpec = hosted.toString({noGitPlus: false, noCommittish: false})
  res.fetchSpec = hosted.getDefaultRepresentation() === 'shortcut' ? null : hosted.toString()
  return setGitCommittish(res, hosted.committish)
}

function unsupportedURLType (protocol, spec) {
  const err = new Error(`Unsupported URL Type "${protocol}": ${spec}`)
  err.code = 'EUNSUPPORTEDPROTOCOL'
  return err
}

function matchGitScp (spec) {
  // git ssh specifiers are overloaded to also use scp-style git
  // specifiers, so we have to parse those out and treat them special.
  // They are NOT true URIs, so we can't hand them to `url.parse`.
  //
  // This regex looks for things that look like:
  // git+ssh://git@my.custom.git.com:username/project.git#deadbeef
  //
  // ...and various combinations. The username in the beginning is *required*.
  const matched = spec.match(/^git\+ssh:\/\/([^:#]+:[^#]+(?:\.git)?)(?:#(.*))?$/i)
  return matched && !matched[1].match(/:[0-9]+\/?.*$/i) && {
    fetchSpec: matched[1],
    gitCommittish: matched[2] == null ? null : matched[2]
  }
}

function fromURL (res) {
  if (!url) url = __webpack_require__(78835)
  const urlparse = url.parse(res.rawSpec)
  res.saveSpec = res.rawSpec
  // check the protocol, and then see if it's git or not
  switch (urlparse.protocol) {
    case 'git:':
    case 'git+http:':
    case 'git+https:':
    case 'git+rsync:':
    case 'git+ftp:':
    case 'git+file:':
    case 'git+ssh:':
      res.type = 'git'
      const match = urlparse.protocol === 'git+ssh:' && matchGitScp(res.rawSpec)
      if (match) {
        setGitCommittish(res, match.gitCommittish)
        res.fetchSpec = match.fetchSpec
      } else {
        setGitCommittish(res, urlparse.hash != null ? urlparse.hash.slice(1) : '')
        urlparse.protocol = urlparse.protocol.replace(/^git[+]/, '')
        if (urlparse.protocol === 'file:' && /^git\+file:\/\/[a-z]:/i.test(res.rawSpec)) {
          // keep the drive letter : on windows file paths
          urlparse.host += ':'
          urlparse.hostname += ':'
        }
        delete urlparse.hash
        res.fetchSpec = url.format(urlparse)
      }
      break
    case 'http:':
    case 'https:':
      res.type = 'remote'
      res.fetchSpec = res.saveSpec
      break

    default:
      throw unsupportedURLType(urlparse.protocol, res.rawSpec)
  }

  return res
}

function fromAlias (res, where) {
  const subSpec = npa(res.rawSpec.substr(4), where)
  if (subSpec.type === 'alias') {
    throw new Error('nested aliases not supported')
  }
  if (!subSpec.registry) {
    throw new Error('aliases only work for registry deps')
  }
  res.subSpec = subSpec
  res.registry = true
  res.type = 'alias'
  res.saveSpec = null
  res.fetchSpec = null
  return res
}

function fromRegistry (res) {
  res.registry = true
  const spec = res.rawSpec === '' ? 'latest' : res.rawSpec
  // no save spec for registry components as we save based on the fetched
  // version, not on the argument so this can't compute that.
  res.saveSpec = null
  res.fetchSpec = spec
  if (!semver) semver = __webpack_require__(33666)
  const version = semver.valid(spec, true)
  const range = semver.validRange(spec, true)
  if (version) {
    res.type = 'version'
  } else if (range) {
    res.type = 'range'
  } else {
    if (encodeURIComponent(spec) !== spec) {
      throw invalidTagName(spec)
    }
    res.type = 'tag'
  }
  return res
}


/***/ }),

/***/ 1223:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrappy = __webpack_require__(62940)
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),

/***/ 43406:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var os = __webpack_require__(12087);

function homedir() {
	var env = process.env;
	var home = env.HOME;
	var user = env.LOGNAME || env.USER || env.LNAME || env.USERNAME;

	if (process.platform === 'win32') {
		return env.USERPROFILE || env.HOMEDRIVE + env.HOMEPATH || home || null;
	}

	if (process.platform === 'darwin') {
		return home || (user ? '/Users/' + user : null);
	}

	if (process.platform === 'linux') {
		return home || (process.getuid() === 0 ? '/root' : (user ? '/home/' + user : null));
	}

	return home || null;
}

module.exports = typeof os.homedir === 'function' ? os.homedir : homedir;


/***/ }),

/***/ 71284:
/***/ ((module) => {

"use strict";

var isWindows = process.platform === 'win32';
var trailingSlashRe = isWindows ? /[^:]\\$/ : /.\/$/;

// https://github.com/nodejs/node/blob/3e7a14381497a3b73dda68d05b5130563cdab420/lib/os.js#L25-L43
module.exports = function () {
	var path;

	if (isWindows) {
		path = process.env.TEMP ||
			process.env.TMP ||
			(process.env.SystemRoot || process.env.windir) + '\\temp';
	} else {
		path = process.env.TMPDIR ||
			process.env.TMP ||
			process.env.TEMP ||
			'/tmp';
	}

	if (trailingSlashRe.test(path)) {
		path = path.slice(0, -1);
	}

	return path;
};


/***/ }),

/***/ 84669:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var isWindows = process.platform === 'win32'
var path = __webpack_require__(85622)
var exec = __webpack_require__(63129).exec
var osTmpdir = __webpack_require__(71284)
var osHomedir = __webpack_require__(43406)

// looking up envs is a bit costly.
// Also, sometimes we want to have a fallback
// Pass in a callback to wait for the fallback on failures
// After the first lookup, always returns the same thing.
function memo (key, lookup, fallback) {
  var fell = false
  var falling = false
  exports[key] = function (cb) {
    var val = lookup()
    if (!val && !fell && !falling && fallback) {
      fell = true
      falling = true
      exec(fallback, function (er, output, stderr) {
        falling = false
        if (er) return // oh well, we tried
        val = output.trim()
      })
    }
    exports[key] = function (cb) {
      if (cb) process.nextTick(cb.bind(null, null, val))
      return val
    }
    if (cb && !falling) process.nextTick(cb.bind(null, null, val))
    return val
  }
}

memo('user', function () {
  return ( isWindows
         ? process.env.USERDOMAIN + '\\' + process.env.USERNAME
         : process.env.USER
         )
}, 'whoami')

memo('prompt', function () {
  return isWindows ? process.env.PROMPT : process.env.PS1
})

memo('hostname', function () {
  return isWindows ? process.env.COMPUTERNAME : process.env.HOSTNAME
}, 'hostname')

memo('tmpdir', function () {
  return osTmpdir()
})

memo('home', function () {
  return osHomedir()
})

memo('path', function () {
  return (process.env.PATH ||
          process.env.Path ||
          process.env.path).split(isWindows ? ';' : ':')
})

memo('editor', function () {
  return process.env.EDITOR ||
         process.env.VISUAL ||
         (isWindows ? 'notepad.exe' : 'vi')
})

memo('shell', function () {
  return isWindows ? process.env.ComSpec || 'cmd'
         : process.env.SHELL || 'bash'
})


/***/ }),

/***/ 5980:
/***/ ((module) => {

"use strict";


var isWindows = process.platform === 'win32';

// Regex to split a windows path into into [dir, root, basename, name, ext]
var splitWindowsRe =
    /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;

var win32 = {};

function win32SplitPath(filename) {
  return splitWindowsRe.exec(filename).slice(1);
}

win32.parse = function(pathString) {
  if (typeof pathString !== 'string') {
    throw new TypeError(
        "Parameter 'pathString' must be a string, not " + typeof pathString
    );
  }
  var allParts = win32SplitPath(pathString);
  if (!allParts || allParts.length !== 5) {
    throw new TypeError("Invalid path '" + pathString + "'");
  }
  return {
    root: allParts[1],
    dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
    base: allParts[2],
    ext: allParts[4],
    name: allParts[3]
  };
};



// Split a filename into [dir, root, basename, name, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
var posix = {};


function posixSplitPath(filename) {
  return splitPathRe.exec(filename).slice(1);
}


posix.parse = function(pathString) {
  if (typeof pathString !== 'string') {
    throw new TypeError(
        "Parameter 'pathString' must be a string, not " + typeof pathString
    );
  }
  var allParts = posixSplitPath(pathString);
  if (!allParts || allParts.length !== 5) {
    throw new TypeError("Invalid path '" + pathString + "'");
  }
  
  return {
    root: allParts[1],
    dir: allParts[0].slice(0, -1),
    base: allParts[2],
    ext: allParts[4],
    name: allParts[3],
  };
};


if (isWindows)
  module.exports = win32.parse;
else /* posix */
  module.exports = posix.parse;

module.exports.posix = posix.parse;
module.exports.win32 = win32.parse;


/***/ }),

/***/ 91532:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }
  constructor (comp, options) {
    options = parseOptions(options)

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range(this.value, options).test(comp.semver)
    }

    const sameDirectionIncreasing =
      (this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '>=' || comp.operator === '>')
    const sameDirectionDecreasing =
      (this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '<=' || comp.operator === '<')
    const sameSemVer = this.semver.version === comp.semver.version
    const differentDirectionsInclusive =
      (this.operator === '>=' || this.operator === '<=') &&
      (comp.operator === '>=' || comp.operator === '<=')
    const oppositeDirectionsLessThan =
      cmp(this.semver, '<', comp.semver, options) &&
      (this.operator === '>=' || this.operator === '>') &&
        (comp.operator === '<=' || comp.operator === '<')
    const oppositeDirectionsGreaterThan =
      cmp(this.semver, '>', comp.semver, options) &&
      (this.operator === '<=' || this.operator === '<') &&
        (comp.operator === '>=' || comp.operator === '>')

    return (
      sameDirectionIncreasing ||
      sameDirectionDecreasing ||
      (sameSemVer && differentDirectionsInclusive) ||
      oppositeDirectionsLessThan ||
      oppositeDirectionsGreaterThan
    )
  }
}

module.exports = Comparator

const parseOptions = __webpack_require__(40785)
const {re, t} = __webpack_require__(9523)
const cmp = __webpack_require__(75098)
const debug = __webpack_require__(50427)
const SemVer = __webpack_require__(48088)
const Range = __webpack_require__(9828)


/***/ }),

/***/ 9828:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    options = parseOptions(options)

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.format()
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First, split based on boolean or ||
    this.raw = range
    this.set = range
      .split(/\s*\|\|\s*/)
      // map the range to a 2d array of comparators
      .map(range => this.parseRange(range.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range}`)
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      const first = this.set[0]
      this.set = this.set.filter(c => !isNullSet(c[0]))
      if (this.set.length === 0)
        this.set = [first]
      else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c]
            break
          }
        }
      }
    }

    this.format()
  }

  format () {
    this.range = this.set
      .map((comps) => {
        return comps.join(' ').trim()
      })
      .join('||')
      .trim()
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    range = range.trim()

    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts = Object.keys(this.options).join(',')
    const memoKey = `parseRange:${memoOpts}:${range}`
    const cached = cache.get(memoKey)
    if (cached)
      return cached

    const loose = this.options.loose
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range, re[t.COMPARATORTRIM])

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)

    // normalize spaces
    range = range.split(/\s+/).join(' ')

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const rangeList = range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options))
      // in loose mode, throw out any that are not valid comparators
      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)
      .map(comp => new Comparator(comp, this.options))

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    const l = rangeList.length
    const rangeMap = new Map()
    for (const comp of rangeList) {
      if (isNullSet(comp))
        return [comp]
      rangeMap.set(comp.value, comp)
    }
    if (rangeMap.size > 1 && rangeMap.has(''))
      rangeMap.delete('')

    const result = [...rangeMap.values()]
    cache.set(memoKey, result)
    return result
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}
module.exports = Range

const LRU = __webpack_require__(7129)
const cache = new LRU({ max: 1000 })

const parseOptions = __webpack_require__(40785)
const Comparator = __webpack_require__(91532)
const debug = __webpack_require__(50427)
const SemVer = __webpack_require__(48088)
const {
  re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace
} = __webpack_require__(9523)

const isNullSet = c => c.value === '<0.0.0-0'
const isAny = c => c.value === ''

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
const replaceTildes = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceTilde(comp, options)
  }).join(' ')

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
const replaceCarets = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceCaret(comp, options)
  }).join(' ')

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map((comp) => {
    return replaceXRange(comp, options)
  }).join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<')
        pr = '-0'

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp.trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return (`${from} ${to}`).trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}


/***/ }),

/***/ 48088:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(50427)
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(42293)
const { re, t } = __webpack_require__(9523)

const parseOptions = __webpack_require__(40785)
const { compareIdentifiers } = __webpack_require__(92463)
class SemVer {
  constructor (version, options) {
    options = parseOptions(options)

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier)
        this.inc('pre', identifier)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier)
        }
        this.inc('pre', identifier)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0]
            }
          } else {
            this.prerelease = [identifier, 0]
          }
        }
        break

      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.format()
    this.raw = this.version
    return this
  }
}

module.exports = SemVer


/***/ }),

/***/ 48848:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(75925)
const clean = (version, options) => {
  const s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}
module.exports = clean


/***/ }),

/***/ 75098:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const eq = __webpack_require__(91898)
const neq = __webpack_require__(6017)
const gt = __webpack_require__(84123)
const gte = __webpack_require__(15522)
const lt = __webpack_require__(80194)
const lte = __webpack_require__(77520)

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp


/***/ }),

/***/ 13466:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(48088)
const parse = __webpack_require__(75925)
const {re, t} = __webpack_require__(9523)

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  let match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next
    while ((next = re[t.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null)
    return null

  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
}
module.exports = coerce


/***/ }),

/***/ 92156:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(48088)
const compareBuild = (a, b, loose) => {
  const versionA = new SemVer(a, loose)
  const versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
module.exports = compareBuild


/***/ }),

/***/ 62804:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(44309)
const compareLoose = (a, b) => compare(a, b, true)
module.exports = compareLoose


/***/ }),

/***/ 44309:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(48088)
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare


/***/ }),

/***/ 64297:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(75925)
const eq = __webpack_require__(91898)

const diff = (version1, version2) => {
  if (eq(version1, version2)) {
    return null
  } else {
    const v1 = parse(version1)
    const v2 = parse(version2)
    const hasPre = v1.prerelease.length || v2.prerelease.length
    const prefix = hasPre ? 'pre' : ''
    const defaultResult = hasPre ? 'prerelease' : ''
    for (const key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}
module.exports = diff


/***/ }),

/***/ 91898:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(44309)
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq


/***/ }),

/***/ 84123:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(44309)
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt


/***/ }),

/***/ 15522:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(44309)
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte


/***/ }),

/***/ 30900:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(48088)

const inc = (version, release, options, identifier) => {
  if (typeof (options) === 'string') {
    identifier = options
    options = undefined
  }

  try {
    return new SemVer(version, options).inc(release, identifier).version
  } catch (er) {
    return null
  }
}
module.exports = inc


/***/ }),

/***/ 80194:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(44309)
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt


/***/ }),

/***/ 77520:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(44309)
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte


/***/ }),

/***/ 76688:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(48088)
const major = (a, loose) => new SemVer(a, loose).major
module.exports = major


/***/ }),

/***/ 38447:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(48088)
const minor = (a, loose) => new SemVer(a, loose).minor
module.exports = minor


/***/ }),

/***/ 6017:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(44309)
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq


/***/ }),

/***/ 75925:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {MAX_LENGTH} = __webpack_require__(42293)
const { re, t } = __webpack_require__(9523)
const SemVer = __webpack_require__(48088)

const parseOptions = __webpack_require__(40785)
const parse = (version, options) => {
  options = parseOptions(options)

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  const r = options.loose ? re[t.LOOSE] : re[t.FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

module.exports = parse


/***/ }),

/***/ 42866:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(48088)
const patch = (a, loose) => new SemVer(a, loose).patch
module.exports = patch


/***/ }),

/***/ 24016:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(75925)
const prerelease = (version, options) => {
  const parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}
module.exports = prerelease


/***/ }),

/***/ 76417:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(44309)
const rcompare = (a, b, loose) => compare(b, a, loose)
module.exports = rcompare


/***/ }),

/***/ 8701:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(92156)
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
module.exports = rsort


/***/ }),

/***/ 6055:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(9828)
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies


/***/ }),

/***/ 61426:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(92156)
const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
module.exports = sort


/***/ }),

/***/ 19601:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(75925)
const valid = (version, options) => {
  const v = parse(version, options)
  return v ? v.version : null
}
module.exports = valid


/***/ }),

/***/ 11383:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// just pre-load all the stuff that index.js lazily exports
const internalRe = __webpack_require__(9523)
module.exports = {
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: __webpack_require__(42293).SEMVER_SPEC_VERSION,
  SemVer: __webpack_require__(48088),
  compareIdentifiers: __webpack_require__(92463).compareIdentifiers,
  rcompareIdentifiers: __webpack_require__(92463).rcompareIdentifiers,
  parse: __webpack_require__(75925),
  valid: __webpack_require__(19601),
  clean: __webpack_require__(48848),
  inc: __webpack_require__(30900),
  diff: __webpack_require__(64297),
  major: __webpack_require__(76688),
  minor: __webpack_require__(38447),
  patch: __webpack_require__(42866),
  prerelease: __webpack_require__(24016),
  compare: __webpack_require__(44309),
  rcompare: __webpack_require__(76417),
  compareLoose: __webpack_require__(62804),
  compareBuild: __webpack_require__(92156),
  sort: __webpack_require__(61426),
  rsort: __webpack_require__(8701),
  gt: __webpack_require__(84123),
  lt: __webpack_require__(80194),
  eq: __webpack_require__(91898),
  neq: __webpack_require__(6017),
  gte: __webpack_require__(15522),
  lte: __webpack_require__(77520),
  cmp: __webpack_require__(75098),
  coerce: __webpack_require__(13466),
  Comparator: __webpack_require__(91532),
  Range: __webpack_require__(9828),
  satisfies: __webpack_require__(6055),
  toComparators: __webpack_require__(52706),
  maxSatisfying: __webpack_require__(20579),
  minSatisfying: __webpack_require__(10832),
  minVersion: __webpack_require__(34179),
  validRange: __webpack_require__(2098),
  outside: __webpack_require__(60420),
  gtr: __webpack_require__(9380),
  ltr: __webpack_require__(33323),
  intersects: __webpack_require__(27008),
  simplifyRange: __webpack_require__(75297),
  subset: __webpack_require__(7863),
}


/***/ }),

/***/ 42293:
/***/ ((module) => {

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

module.exports = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH,
  MAX_SAFE_INTEGER,
  MAX_SAFE_COMPONENT_LENGTH
}


/***/ }),

/***/ 50427:
/***/ ((module) => {

const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug


/***/ }),

/***/ 92463:
/***/ ((module) => {

const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers
}


/***/ }),

/***/ 40785:
/***/ ((module) => {

// parse out just the options we care about so we always get a consistent
// obj with keys in a consistent order.
const opts = ['includePrerelease', 'loose', 'rtl']
const parseOptions = options =>
  !options ? {}
  : typeof options !== 'object' ? { loose: true }
  : opts.filter(k => options[k]).reduce((options, k) => {
    options[k] = true
    return options
  }, {})
module.exports = parseOptions


/***/ }),

/***/ 9523:
/***/ ((module, exports, __webpack_require__) => {

const { MAX_SAFE_COMPONENT_LENGTH } = __webpack_require__(42293)
const debug = __webpack_require__(50427)
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const src = exports.src = []
const t = exports.t = {}
let R = 0

const createToken = (name, value, isGlobal) => {
  const index = R++
  debug(index, value)
  t[name] = index
  src[index] = value
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*')

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\.0\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\.0\.0-0\\s*$')


/***/ }),

/***/ 9380:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Determine if version is greater than all the versions possible in the range.
const outside = __webpack_require__(60420)
const gtr = (version, range, options) => outside(version, range, '>', options)
module.exports = gtr


/***/ }),

/***/ 27008:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(9828)
const intersects = (r1, r2, options) => {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}
module.exports = intersects


/***/ }),

/***/ 33323:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const outside = __webpack_require__(60420)
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options)
module.exports = ltr


/***/ }),

/***/ 20579:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(48088)
const Range = __webpack_require__(9828)

const maxSatisfying = (versions, range, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}
module.exports = maxSatisfying


/***/ }),

/***/ 10832:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(48088)
const Range = __webpack_require__(9828)
const minSatisfying = (versions, range, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}
module.exports = minSatisfying


/***/ }),

/***/ 34179:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(48088)
const Range = __webpack_require__(9828)
const gt = __webpack_require__(84123)

const minVersion = (range, loose) => {
  range = new Range(range, loose)

  let minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let setMin = null
    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt(compver, setMin)) {
            setMin = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    })
    if (setMin && (!minver || gt(minver, setMin)))
      minver = setMin
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}
module.exports = minVersion


/***/ }),

/***/ 60420:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(48088)
const Comparator = __webpack_require__(91532)
const {ANY} = Comparator
const Range = __webpack_require__(9828)
const satisfies = __webpack_require__(6055)
const gt = __webpack_require__(84123)
const lt = __webpack_require__(80194)
const lte = __webpack_require__(77520)
const gte = __webpack_require__(15522)

const outside = (version, range, hilo, options) => {
  version = new SemVer(version, options)
  range = new Range(range, options)

  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisfies the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let high = null
    let low = null

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

module.exports = outside


/***/ }),

/***/ 75297:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = __webpack_require__(6055)
const compare = __webpack_require__(44309)
module.exports = (versions, range, options) => {
  const set = []
  let min = null
  let prev = null
  const v = versions.sort((a, b) => compare(a, b, options))
  for (const version of v) {
    const included = satisfies(version, range, options)
    if (included) {
      prev = version
      if (!min)
        min = version
    } else {
      if (prev) {
        set.push([min, prev])
      }
      prev = null
      min = null
    }
  }
  if (min)
    set.push([min, null])

  const ranges = []
  for (const [min, max] of set) {
    if (min === max)
      ranges.push(min)
    else if (!max && min === v[0])
      ranges.push('*')
    else if (!max)
      ranges.push(`>=${min}`)
    else if (min === v[0])
      ranges.push(`<=${max}`)
    else
      ranges.push(`${min} - ${max}`)
  }
  const simplified = ranges.join(' || ')
  const original = typeof range.raw === 'string' ? range.raw : String(range)
  return simplified.length < original.length ? simplified : range
}


/***/ }),

/***/ 7863:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(9828)
const Comparator = __webpack_require__(91532)
const { ANY } = Comparator
const satisfies = __webpack_require__(6055)
const compare = __webpack_require__(44309)

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

const subset = (sub, dom, options = {}) => {
  if (sub === dom)
    return true

  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub)
        continue OUTER
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull)
      return false
  }
  return true
}

const simpleSubset = (sub, dom, options) => {
  if (sub === dom)
    return true

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY)
      return true
    else if (options.includePrerelease)
      sub = [ new Comparator('>=0.0.0-0') ]
    else
      sub = [ new Comparator('>=0.0.0') ]
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease)
      return true
    else
      dom = [ new Comparator('>=0.0.0') ]
  }

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=')
      gt = higherGT(gt, c, options)
    else if (c.operator === '<' || c.operator === '<=')
      lt = lowerLT(lt, c, options)
    else
      eqSet.add(c.semver)
  }

  if (eqSet.size > 1)
    return null

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0)
      return null
    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))
      return null
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options))
      return null

    if (lt && !satisfies(eq, String(lt), options))
      return null

    for (const c of dom) {
      if (!satisfies(eq, String(c), options))
        return false
    }

    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  let needDomLTPre = lt &&
    !options.includePrerelease &&
    lt.semver.prerelease.length ? lt.semver : false
  let needDomGTPre = gt &&
    !options.includePrerelease &&
    gt.semver.prerelease.length ? gt.semver : false
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false
  }

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false
        }
      }
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c && higher !== gt)
          return false
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))
        return false
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false
        }
      }
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c && lower !== lt)
          return false
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))
        return false
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0)
      return false
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0)
    return false

  if (lt && hasDomGT && !gt && gtltComp !== 0)
    return false

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre)
    return false

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset


/***/ }),

/***/ 52706:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(9828)

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))

module.exports = toComparators


/***/ }),

/***/ 2098:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(9828)
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}
module.exports = validRange


/***/ }),

/***/ 33988:
/***/ (function(__unused_webpack_module, exports) {

(function(window) {
    var re = {
        not_string: /[^s]/,
        number: /[diefg]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosuxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[\+\-]/
    }

    function sprintf() {
        var key = arguments[0], cache = sprintf.cache
        if (!(cache[key] && cache.hasOwnProperty(key))) {
            cache[key] = sprintf.parse(key)
        }
        return sprintf.format.call(null, cache[key], arguments)
    }

    sprintf.format = function(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = ""
        for (i = 0; i < tree_length; i++) {
            node_type = get_type(parse_tree[i])
            if (node_type === "string") {
                output[output.length] = parse_tree[i]
            }
            else if (node_type === "array") {
                match = parse_tree[i] // convenience purposes only
                if (match[2]) { // keyword argument
                    arg = argv[cursor]
                    for (k = 0; k < match[2].length; k++) {
                        if (!arg.hasOwnProperty(match[2][k])) {
                            throw new Error(sprintf("[sprintf] property '%s' does not exist", match[2][k]))
                        }
                        arg = arg[match[2][k]]
                    }
                }
                else if (match[1]) { // positional argument (explicit)
                    arg = argv[match[1]]
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++]
                }

                if (get_type(arg) == "function") {
                    arg = arg()
                }

                if (re.not_string.test(match[8]) && re.not_json.test(match[8]) && (get_type(arg) != "number" && isNaN(arg))) {
                    throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)))
                }

                if (re.number.test(match[8])) {
                    is_positive = arg >= 0
                }

                switch (match[8]) {
                    case "b":
                        arg = arg.toString(2)
                    break
                    case "c":
                        arg = String.fromCharCode(arg)
                    break
                    case "d":
                    case "i":
                        arg = parseInt(arg, 10)
                    break
                    case "j":
                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)
                    break
                    case "e":
                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential()
                    break
                    case "f":
                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)
                    break
                    case "g":
                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)
                    break
                    case "o":
                        arg = arg.toString(8)
                    break
                    case "s":
                        arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg)
                    break
                    case "u":
                        arg = arg >>> 0
                    break
                    case "x":
                        arg = arg.toString(16)
                    break
                    case "X":
                        arg = arg.toString(16).toUpperCase()
                    break
                }
                if (re.json.test(match[8])) {
                    output[output.length] = arg
                }
                else {
                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
                        sign = is_positive ? "+" : "-"
                        arg = arg.toString().replace(re.sign, "")
                    }
                    else {
                        sign = ""
                    }
                    pad_character = match[4] ? match[4] === "0" ? "0" : match[4].charAt(1) : " "
                    pad_length = match[6] - (sign + arg).length
                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : "") : ""
                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === "0" ? sign + pad + arg : pad + sign + arg)
                }
            }
        }
        return output.join("")
    }

    sprintf.cache = {}

    sprintf.parse = function(fmt) {
        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = match[0]
            }
            else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree[parse_tree.length] = "%"
            }
            else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1
                    var field_list = [], replacement_field = match[2], field_match = []
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list[field_list.length] = field_match[1]
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list[field_list.length] = field_match[1]
                            }
                            else {
                                throw new SyntaxError("[sprintf] failed to parse named argument key")
                            }
                        }
                    }
                    else {
                        throw new SyntaxError("[sprintf] failed to parse named argument key")
                    }
                    match[2] = field_list
                }
                else {
                    arg_names |= 2
                }
                if (arg_names === 3) {
                    throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported")
                }
                parse_tree[parse_tree.length] = match
            }
            else {
                throw new SyntaxError("[sprintf] unexpected placeholder")
            }
            _fmt = _fmt.substring(match[0].length)
        }
        return parse_tree
    }

    var vsprintf = function(fmt, argv, _argv) {
        _argv = (argv || []).slice(0)
        _argv.splice(0, 0, fmt)
        return sprintf.apply(null, _argv)
    }

    /**
     * helpers
     */
    function get_type(variable) {
        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()
    }

    function str_repeat(input, multiplier) {
        return Array(multiplier + 1).join(input)
    }

    /**
     * export to either browser or node.js
     */
    if (true) {
        exports.sprintf = sprintf
        exports.vsprintf = vsprintf
    }
    else {}
})(typeof window === "undefined" ? this : window);


/***/ }),

/***/ 9453:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
function parseArgsStringToArgv(value, env, file) {
    // ([^\s'"]([^\s'"]*(['"])([^\3]*?)\3)+[^\s'"]*) Matches nested quotes until the first space outside of quotes
    // [^\s'"]+ or Match if not a space ' or "
    // (['"])([^\5]*?)\5 or Match "quoted text" without quotes
    // `\3` and `\5` are a backreference to the quote style (' or ") captured
    var myRegexp = /([^\s'"]([^\s'"]*(['"])([^\3]*?)\3)+[^\s'"]*)|[^\s'"]+|(['"])([^\5]*?)\5/gi;
    var myString = value;
    var myArray = [];
    if (env) {
        myArray.push(env);
    }
    if (file) {
        myArray.push(file);
    }
    var match;
    do {
        // Each call to exec returns the next regex match as an array
        match = myRegexp.exec(myString);
        if (match !== null) {
            // Index 1 in the array is the captured group if it exists
            // Index 0 is the matched text, which we use if no captured group exists
            myArray.push(firstString(match[1], match[6], match[0]));
        }
    } while (match !== null);
    return myArray;
}
exports.default = parseArgsStringToArgv;
exports.parseArgsStringToArgv = parseArgsStringToArgv;
// Accepts any number of arguments, and returns the first one that is a string
// (even an empty string)
function firstString() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        if (typeof arg === "string") {
            return arg;
        }
    }
}


/***/ }),

/***/ 42562:
/***/ ((module) => {

"use strict";

const singleComment = Symbol('singleComment');
const multiComment = Symbol('multiComment');
const stripWithoutWhitespace = () => '';
const stripWithWhitespace = (string, start, end) => string.slice(start, end).replace(/\S/g, ' ');

const isEscaped = (jsonString, quotePosition) => {
	let index = quotePosition - 1;
	let backslashCount = 0;

	while (jsonString[index] === '\\') {
		index -= 1;
		backslashCount += 1;
	}

	return Boolean(backslashCount % 2);
};

module.exports = (jsonString, options = {}) => {
	if (typeof jsonString !== 'string') {
		throw new TypeError(`Expected argument \`jsonString\` to be a \`string\`, got \`${typeof jsonString}\``);
	}

	const strip = options.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;

	let insideString = false;
	let insideComment = false;
	let offset = 0;
	let result = '';

	for (let i = 0; i < jsonString.length; i++) {
		const currentCharacter = jsonString[i];
		const nextCharacter = jsonString[i + 1];

		if (!insideComment && currentCharacter === '"') {
			const escaped = isEscaped(jsonString, i);
			if (!escaped) {
				insideString = !insideString;
			}
		}

		if (insideString) {
			continue;
		}

		if (!insideComment && currentCharacter + nextCharacter === '//') {
			result += jsonString.slice(offset, i);
			offset = i;
			insideComment = singleComment;
			i++;
		} else if (insideComment === singleComment && currentCharacter + nextCharacter === '\r\n') {
			i++;
			insideComment = false;
			result += strip(jsonString, offset, i);
			offset = i;
			continue;
		} else if (insideComment === singleComment && currentCharacter === '\n') {
			insideComment = false;
			result += strip(jsonString, offset, i);
			offset = i;
		} else if (!insideComment && currentCharacter + nextCharacter === '/*') {
			result += jsonString.slice(offset, i);
			offset = i;
			insideComment = multiComment;
			i++;
			continue;
		} else if (insideComment === multiComment && currentCharacter + nextCharacter === '*/') {
			i++;
			insideComment = false;
			result += strip(jsonString, offset, i + 1);
			offset = i + 1;
			continue;
		}
	}

	return result + (insideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));
};


/***/ }),

/***/ 74674:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// high-level commands
exports.c = exports.create = __webpack_require__(44016)
exports.r = exports.replace = __webpack_require__(45923)
exports.t = exports.list = __webpack_require__(51525)
exports.u = exports.update = __webpack_require__(94404)
exports.x = exports.extract = __webpack_require__(75317)

// classes
exports.Pack = __webpack_require__(7900)
exports.Unpack = __webpack_require__(17628)
exports.Parse = __webpack_require__(68917)
exports.ReadEntry = __webpack_require__(38116)
exports.WriteEntry = __webpack_require__(55450)
exports.Header = __webpack_require__(66043)
exports.Pax = __webpack_require__(77996)
exports.types = __webpack_require__(24173)


/***/ }),

/***/ 44016:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// tar -c
const hlo = __webpack_require__(95274)

const Pack = __webpack_require__(7900)
const fs = __webpack_require__(35747)
const fsm = __webpack_require__(27714)
const t = __webpack_require__(51525)
const path = __webpack_require__(85622)

const c = module.exports = (opt_, files, cb) => {
  if (typeof files === 'function')
    cb = files

  if (Array.isArray(opt_))
    files = opt_, opt_ = {}

  if (!files || !Array.isArray(files) || !files.length)
    throw new TypeError('no files or directories specified')

  files = Array.from(files)

  const opt = hlo(opt_)

  if (opt.sync && typeof cb === 'function')
    throw new TypeError('callback not supported for sync tar functions')

  if (!opt.file && typeof cb === 'function')
    throw new TypeError('callback only supported with file option')

  return opt.file && opt.sync ? createFileSync(opt, files)
    : opt.file ? createFile(opt, files, cb)
    : opt.sync ? createSync(opt, files)
    : create(opt, files)
}

const createFileSync = (opt, files) => {
  const p = new Pack.Sync(opt)
  const stream = new fsm.WriteStreamSync(opt.file, {
    mode: opt.mode || 0o666
  })
  p.pipe(stream)
  addFilesSync(p, files)
}

const createFile = (opt, files, cb) => {
  const p = new Pack(opt)
  const stream = new fsm.WriteStream(opt.file, {
    mode: opt.mode || 0o666
  })
  p.pipe(stream)

  const promise = new Promise((res, rej) => {
    stream.on('error', rej)
    stream.on('close', res)
    p.on('error', rej)
  })

  addFilesAsync(p, files)

  return cb ? promise.then(cb, cb) : promise
}

const addFilesSync = (p, files) => {
  files.forEach(file => {
    if (file.charAt(0) === '@')
      t({
        file: path.resolve(p.cwd, file.substr(1)),
        sync: true,
        noResume: true,
        onentry: entry => p.add(entry)
      })
    else
      p.add(file)
  })
  p.end()
}

const addFilesAsync = (p, files) => {
  while (files.length) {
    const file = files.shift()
    if (file.charAt(0) === '@')
      return t({
        file: path.resolve(p.cwd, file.substr(1)),
        noResume: true,
        onentry: entry => p.add(entry)
      }).then(_ => addFilesAsync(p, files))
    else
      p.add(file)
  }
  p.end()
}

const createSync = (opt, files) => {
  const p = new Pack.Sync(opt)
  addFilesSync(p, files)
  return p
}

const create = (opt, files) => {
  const p = new Pack(opt)
  addFilesAsync(p, files)
  return p
}


/***/ }),

/***/ 75317:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// tar -x
const hlo = __webpack_require__(95274)
const Unpack = __webpack_require__(17628)
const fs = __webpack_require__(35747)
const fsm = __webpack_require__(27714)
const path = __webpack_require__(85622)
const stripSlash = __webpack_require__(88886)

const x = module.exports = (opt_, files, cb) => {
  if (typeof opt_ === 'function')
    cb = opt_, files = null, opt_ = {}
  else if (Array.isArray(opt_))
    files = opt_, opt_ = {}

  if (typeof files === 'function')
    cb = files, files = null

  if (!files)
    files = []
  else
    files = Array.from(files)

  const opt = hlo(opt_)

  if (opt.sync && typeof cb === 'function')
    throw new TypeError('callback not supported for sync tar functions')

  if (!opt.file && typeof cb === 'function')
    throw new TypeError('callback only supported with file option')

  if (files.length)
    filesFilter(opt, files)

  return opt.file && opt.sync ? extractFileSync(opt)
    : opt.file ? extractFile(opt, cb)
    : opt.sync ? extractSync(opt)
    : extract(opt)
}

// construct a filter that limits the file entries listed
// include child entries if a dir is included
const filesFilter = (opt, files) => {
  const map = new Map(files.map(f => [stripSlash(f), true]))
  const filter = opt.filter

  const mapHas = (file, r) => {
    const root = r || path.parse(file).root || '.'
    const ret = file === root ? false
      : map.has(file) ? map.get(file)
      : mapHas(path.dirname(file), root)

    map.set(file, ret)
    return ret
  }

  opt.filter = filter
    ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file))
    : file => mapHas(stripSlash(file))
}

const extractFileSync = opt => {
  const u = new Unpack.Sync(opt)

  const file = opt.file
  let threw = true
  let fd
  const stat = fs.statSync(file)
  // This trades a zero-byte read() syscall for a stat
  // However, it will usually result in less memory allocation
  const readSize = opt.maxReadSize || 16*1024*1024
  const stream = new fsm.ReadStreamSync(file, {
    readSize: readSize,
    size: stat.size
  })
  stream.pipe(u)
}

const extractFile = (opt, cb) => {
  const u = new Unpack(opt)
  const readSize = opt.maxReadSize || 16*1024*1024

  const file = opt.file
  const p = new Promise((resolve, reject) => {
    u.on('error', reject)
    u.on('close', resolve)

    // This trades a zero-byte read() syscall for a stat
    // However, it will usually result in less memory allocation
    fs.stat(file, (er, stat) => {
      if (er)
        reject(er)
      else {
        const stream = new fsm.ReadStream(file, {
          readSize: readSize,
          size: stat.size
        })
        stream.on('error', reject)
        stream.pipe(u)
      }
    })
  })
  return cb ? p.then(cb, cb) : p
}

const extractSync = opt => {
  return new Unpack.Sync(opt)
}

const extract = opt => {
  return new Unpack(opt)
}


/***/ }),

/***/ 91172:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Get the appropriate flag to use for creating files
// We use fmap on Windows platforms for files less than
// 512kb.  This is a fairly low limit, but avoids making
// things slower in some cases.  Since most of what this
// library is used for is extracting tarballs of many
// relatively small files in npm packages and the like,
// it can be a big boost on Windows platforms.
// Only supported in Node v12.9.0 and above.
const platform = process.env.__FAKE_PLATFORM__ || process.platform
const isWindows = platform === 'win32'
const fs = global.__FAKE_TESTING_FS__ || __webpack_require__(35747)

/* istanbul ignore next */
const { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs.constants

const fMapEnabled = isWindows && !!UV_FS_O_FILEMAP
const fMapLimit = 512 * 1024
const fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY
module.exports = !fMapEnabled ? () => 'w'
  : size => size < fMapLimit ? fMapFlag : 'w'


/***/ }),

/***/ 66043:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// parse a 512-byte header block to a data object, or vice-versa
// encode returns `true` if a pax extended header is needed, because
// the data could not be faithfully encoded in a simple header.
// (Also, check header.needPax to see if it needs a pax header.)

const types = __webpack_require__(24173)
const pathModule = __webpack_require__(85622).posix
const large = __webpack_require__(52370)

const SLURP = Symbol('slurp')
const TYPE = Symbol('type')

class Header {
  constructor (data, off, ex, gex) {
    this.cksumValid = false
    this.needPax = false
    this.nullBlock = false

    this.block = null
    this.path = null
    this.mode = null
    this.uid = null
    this.gid = null
    this.size = null
    this.mtime = null
    this.cksum = null
    this[TYPE] = '0'
    this.linkpath = null
    this.uname = null
    this.gname = null
    this.devmaj = 0
    this.devmin = 0
    this.atime = null
    this.ctime = null

    if (Buffer.isBuffer(data))
      this.decode(data, off || 0, ex, gex)
    else if (data)
      this.set(data)
  }

  decode (buf, off, ex, gex) {
    if (!off)
      off = 0

    if (!buf || !(buf.length >= off + 512))
      throw new Error('need 512 bytes for header')

    this.path = decString(buf, off, 100)
    this.mode = decNumber(buf, off + 100, 8)
    this.uid = decNumber(buf, off + 108, 8)
    this.gid = decNumber(buf, off + 116, 8)
    this.size = decNumber(buf, off + 124, 12)
    this.mtime = decDate(buf, off + 136, 12)
    this.cksum = decNumber(buf, off + 148, 12)

    // if we have extended or global extended headers, apply them now
    // See https://github.com/npm/node-tar/pull/187
    this[SLURP](ex)
    this[SLURP](gex, true)

    // old tar versions marked dirs as a file with a trailing /
    this[TYPE] = decString(buf, off + 156, 1)
    if (this[TYPE] === '')
      this[TYPE] = '0'
    if (this[TYPE] === '0' && this.path.substr(-1) === '/')
      this[TYPE] = '5'

    // tar implementations sometimes incorrectly put the stat(dir).size
    // as the size in the tarball, even though Directory entries are
    // not able to have any body at all.  In the very rare chance that
    // it actually DOES have a body, we weren't going to do anything with
    // it anyway, and it'll just be a warning about an invalid header.
    if (this[TYPE] === '5')
      this.size = 0

    this.linkpath = decString(buf, off + 157, 100)
    if (buf.slice(off + 257, off + 265).toString() === 'ustar\u000000') {
      this.uname = decString(buf, off + 265, 32)
      this.gname = decString(buf, off + 297, 32)
      this.devmaj = decNumber(buf, off + 329, 8)
      this.devmin = decNumber(buf, off + 337, 8)
      if (buf[off + 475] !== 0) {
        // definitely a prefix, definitely >130 chars.
        const prefix = decString(buf, off + 345, 155)
        this.path = prefix + '/' + this.path
      } else {
        const prefix = decString(buf, off + 345, 130)
        if (prefix)
          this.path = prefix + '/' + this.path
        this.atime = decDate(buf, off + 476, 12)
        this.ctime = decDate(buf, off + 488, 12)
      }
    }

    let sum = 8 * 0x20
    for (let i = off; i < off + 148; i++) {
      sum += buf[i]
    }
    for (let i = off + 156; i < off + 512; i++) {
      sum += buf[i]
    }
    this.cksumValid = sum === this.cksum
    if (this.cksum === null && sum === 8 * 0x20)
      this.nullBlock = true
  }

  [SLURP] (ex, global) {
    for (let k in ex) {
      // we slurp in everything except for the path attribute in
      // a global extended header, because that's weird.
      if (ex[k] !== null && ex[k] !== undefined &&
          !(global && k === 'path'))
        this[k] = ex[k]
    }
  }

  encode (buf, off) {
    if (!buf) {
      buf = this.block = Buffer.alloc(512)
      off = 0
    }

    if (!off)
      off = 0

    if (!(buf.length >= off + 512))
      throw new Error('need 512 bytes for header')

    const prefixSize = this.ctime || this.atime ? 130 : 155
    const split = splitPrefix(this.path || '', prefixSize)
    const path = split[0]
    const prefix = split[1]
    this.needPax = split[2]

    this.needPax = encString(buf, off, 100, path) || this.needPax
    this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax
    this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax
    this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax
    this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax
    this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax
    buf[off + 156] = this[TYPE].charCodeAt(0)
    this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax
    buf.write('ustar\u000000', off + 257, 8)
    this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax
    this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax
    this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax
    this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax
    this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax
    if (buf[off + 475] !== 0)
      this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax
    else {
      this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax
      this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax
      this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax
    }

    let sum = 8 * 0x20
    for (let i = off; i < off + 148; i++) {
      sum += buf[i]
    }
    for (let i = off + 156; i < off + 512; i++) {
      sum += buf[i]
    }
    this.cksum = sum
    encNumber(buf, off + 148, 8, this.cksum)
    this.cksumValid = true

    return this.needPax
  }

  set (data) {
    for (let i in data) {
      if (data[i] !== null && data[i] !== undefined)
        this[i] = data[i]
    }
  }

  get type () {
    return types.name.get(this[TYPE]) || this[TYPE]
  }

  get typeKey () {
    return this[TYPE]
  }

  set type (type) {
    if (types.code.has(type))
      this[TYPE] = types.code.get(type)
    else
      this[TYPE] = type
  }
}

const splitPrefix = (p, prefixSize) => {
  const pathSize = 100
  let pp = p
  let prefix = ''
  let ret
  const root = pathModule.parse(p).root || '.'

  if (Buffer.byteLength(pp) < pathSize)
    ret = [pp, prefix, false]
  else {
    // first set prefix to the dir, and path to the base
    prefix = pathModule.dirname(pp)
    pp = pathModule.basename(pp)

    do {
      // both fit!
      if (Buffer.byteLength(pp) <= pathSize &&
          Buffer.byteLength(prefix) <= prefixSize)
        ret = [pp, prefix, false]

      // prefix fits in prefix, but path doesn't fit in path
      else if (Buffer.byteLength(pp) > pathSize &&
          Buffer.byteLength(prefix) <= prefixSize)
        ret = [pp.substr(0, pathSize - 1), prefix, true]

      else {
        // make path take a bit from prefix
        pp = pathModule.join(pathModule.basename(prefix), pp)
        prefix = pathModule.dirname(prefix)
      }
    } while (prefix !== root && !ret)

    // at this point, found no resolution, just truncate
    if (!ret)
      ret = [p.substr(0, pathSize - 1), '', true]
  }
  return ret
}

const decString = (buf, off, size) =>
  buf.slice(off, off + size).toString('utf8').replace(/\0.*/, '')

const decDate = (buf, off, size) =>
  numToDate(decNumber(buf, off, size))

const numToDate = num => num === null ? null : new Date(num * 1000)

const decNumber = (buf, off, size) =>
  buf[off] & 0x80 ? large.parse(buf.slice(off, off + size))
    : decSmallNumber(buf, off, size)

const nanNull = value => isNaN(value) ? null : value

const decSmallNumber = (buf, off, size) =>
  nanNull(parseInt(
    buf.slice(off, off + size)
      .toString('utf8').replace(/\0.*$/, '').trim(), 8))

// the maximum encodable as a null-terminated octal, by field size
const MAXNUM = {
  12: 0o77777777777,
  8 : 0o7777777
}

const encNumber = (buf, off, size, number) =>
  number === null ? false :
  number > MAXNUM[size] || number < 0
    ? (large.encode(number, buf.slice(off, off + size)), true)
    : (encSmallNumber(buf, off, size, number), false)

const encSmallNumber = (buf, off, size, number) =>
  buf.write(octalString(number, size), off, size, 'ascii')

const octalString = (number, size) =>
  padOctal(Math.floor(number).toString(8), size)

const padOctal = (string, size) =>
  (string.length === size - 1 ? string
  : new Array(size - string.length - 1).join('0') + string + ' ') + '\0'

const encDate = (buf, off, size, date) =>
  date === null ? false :
  encNumber(buf, off, size, date.getTime() / 1000)

// enough to fill the longest string we've got
const NULLS = new Array(156).join('\0')
// pad with nulls, return true if it's longer or non-ascii
const encString = (buf, off, size, string) =>
  string === null ? false :
  (buf.write(string + NULLS, off, size, 'utf8'),
   string.length !== Buffer.byteLength(string) || string.length > size)

module.exports = Header


/***/ }),

/***/ 95274:
/***/ ((module) => {

"use strict";


// turn tar(1) style args like `C` into the more verbose things like `cwd`

const argmap = new Map([
  ['C', 'cwd'],
  ['f', 'file'],
  ['z', 'gzip'],
  ['P', 'preservePaths'],
  ['U', 'unlink'],
  ['strip-components', 'strip'],
  ['stripComponents', 'strip'],
  ['keep-newer', 'newer'],
  ['keepNewer', 'newer'],
  ['keep-newer-files', 'newer'],
  ['keepNewerFiles', 'newer'],
  ['k', 'keep'],
  ['keep-existing', 'keep'],
  ['keepExisting', 'keep'],
  ['m', 'noMtime'],
  ['no-mtime', 'noMtime'],
  ['p', 'preserveOwner'],
  ['L', 'follow'],
  ['h', 'follow']
])

const parse = module.exports = opt => opt ? Object.keys(opt).map(k => [
  argmap.has(k) ? argmap.get(k) : k, opt[k]
]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {}


/***/ }),

/***/ 52370:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Tar can encode large and negative numbers using a leading byte of
// 0xff for negative, and 0x80 for positive.

const encode = exports.encode = (num, buf) => {
  if (!Number.isSafeInteger(num))
    // The number is so large that javascript cannot represent it with integer
    // precision.
    throw Error('cannot encode number outside of javascript safe integer range')
  else if (num < 0)
    encodeNegative(num, buf)
  else
    encodePositive(num, buf)
  return buf
}

const encodePositive = (num, buf) => {
  buf[0] = 0x80

  for (var i = buf.length; i > 1; i--) {
    buf[i-1] = num & 0xff
    num = Math.floor(num / 0x100)
  }
}

const encodeNegative = (num, buf) => {
  buf[0] = 0xff
  var flipped = false
  num = num * -1
  for (var i = buf.length; i > 1; i--) {
    var byte = num & 0xff
    num = Math.floor(num / 0x100)
    if (flipped)
      buf[i-1] = onesComp(byte)
    else if (byte === 0)
      buf[i-1] = 0
    else {
      flipped = true
      buf[i-1] = twosComp(byte)
    }
  }
}

const parse = exports.parse = (buf) => {
  var post = buf[buf.length - 1]
  var pre = buf[0]
  var value;
  if (pre === 0x80)
    value = pos(buf.slice(1, buf.length))
  else if (pre === 0xff)
    value = twos(buf)
  else
    throw Error('invalid base256 encoding')

  if (!Number.isSafeInteger(value))
    // The number is so large that javascript cannot represent it with integer
    // precision.
    throw Error('parsed number outside of javascript safe integer range')

  return value
}

const twos = (buf) => {
  var len = buf.length
  var sum = 0
  var flipped = false
  for (var i = len - 1; i > -1; i--) {
    var byte = buf[i]
    var f
    if (flipped)
      f = onesComp(byte)
    else if (byte === 0)
      f = byte
    else {
      flipped = true
      f = twosComp(byte)
    }
    if (f !== 0)
      sum -= f * Math.pow(256, len - i - 1)
  }
  return sum
}

const pos = (buf) => {
  var len = buf.length
  var sum = 0
  for (var i = len - 1; i > -1; i--) {
    var byte = buf[i]
    if (byte !== 0)
      sum += byte * Math.pow(256, len - i - 1)
  }
  return sum
}

const onesComp = byte => (0xff ^ byte) & 0xff

const twosComp = byte => ((0xff ^ byte) + 1) & 0xff


/***/ }),

/***/ 51525:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// XXX: This shares a lot in common with extract.js
// maybe some DRY opportunity here?

// tar -t
const hlo = __webpack_require__(95274)
const Parser = __webpack_require__(68917)
const fs = __webpack_require__(35747)
const fsm = __webpack_require__(27714)
const path = __webpack_require__(85622)
const stripSlash = __webpack_require__(88886)

const t = module.exports = (opt_, files, cb) => {
  if (typeof opt_ === 'function')
    cb = opt_, files = null, opt_ = {}
  else if (Array.isArray(opt_))
    files = opt_, opt_ = {}

  if (typeof files === 'function')
    cb = files, files = null

  if (!files)
    files = []
  else
    files = Array.from(files)

  const opt = hlo(opt_)

  if (opt.sync && typeof cb === 'function')
    throw new TypeError('callback not supported for sync tar functions')

  if (!opt.file && typeof cb === 'function')
    throw new TypeError('callback only supported with file option')

  if (files.length)
    filesFilter(opt, files)

  if (!opt.noResume)
    onentryFunction(opt)

  return opt.file && opt.sync ? listFileSync(opt)
    : opt.file ? listFile(opt, cb)
    : list(opt)
}

const onentryFunction = opt => {
  const onentry = opt.onentry
  opt.onentry = onentry ? e => {
    onentry(e)
    e.resume()
  } : e => e.resume()
}

// construct a filter that limits the file entries listed
// include child entries if a dir is included
const filesFilter = (opt, files) => {
  const map = new Map(files.map(f => [stripSlash(f), true]))
  const filter = opt.filter

  const mapHas = (file, r) => {
    const root = r || path.parse(file).root || '.'
    const ret = file === root ? false
      : map.has(file) ? map.get(file)
      : mapHas(path.dirname(file), root)

    map.set(file, ret)
    return ret
  }

  opt.filter = filter
    ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file))
    : file => mapHas(stripSlash(file))
}

const listFileSync = opt => {
  const p = list(opt)
  const file = opt.file
  let threw = true
  let fd
  try {
    const stat = fs.statSync(file)
    const readSize = opt.maxReadSize || 16*1024*1024
    if (stat.size < readSize) {
      p.end(fs.readFileSync(file))
    } else {
      let pos = 0
      const buf = Buffer.allocUnsafe(readSize)
      fd = fs.openSync(file, 'r')
      while (pos < stat.size) {
        let bytesRead = fs.readSync(fd, buf, 0, readSize, pos)
        pos += bytesRead
        p.write(buf.slice(0, bytesRead))
      }
      p.end()
    }
    threw = false
  } finally {
    if (threw && fd)
      try { fs.closeSync(fd) } catch (er) {}
  }
}

const listFile = (opt, cb) => {
  const parse = new Parser(opt)
  const readSize = opt.maxReadSize || 16*1024*1024

  const file = opt.file
  const p = new Promise((resolve, reject) => {
    parse.on('error', reject)
    parse.on('end', resolve)

    fs.stat(file, (er, stat) => {
      if (er)
        reject(er)
      else {
        const stream = new fsm.ReadStream(file, {
          readSize: readSize,
          size: stat.size
        })
        stream.on('error', reject)
        stream.pipe(parse)
      }
    })
  })
  return cb ? p.then(cb, cb) : p
}

const list = opt => new Parser(opt)


/***/ }),

/***/ 69624:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// wrapper around mkdirp for tar's needs.

// TODO: This should probably be a class, not functionally
// passing around state in a gazillion args.

const mkdirp = __webpack_require__(47251)
const fs = __webpack_require__(35747)
const path = __webpack_require__(85622)
const chownr = __webpack_require__(59051)
const normPath = __webpack_require__(56843)

class SymlinkError extends Error {
  constructor (symlink, path) {
    super('Cannot extract through symbolic link')
    this.path = path
    this.symlink = symlink
  }

  get name () {
    return 'SylinkError'
  }
}

class CwdError extends Error {
  constructor (path, code) {
    super(code + ': Cannot cd into \'' + path + '\'')
    this.path = path
    this.code = code
  }

  get name () {
    return 'CwdError'
  }
}

const cGet = (cache, key) => cache.get(normPath(key))
const cSet = (cache, key, val) => cache.set(normPath(key), val)

const checkCwd = (dir, cb) => {
  fs.stat(dir, (er, st) => {
    if (er || !st.isDirectory())
      er = new CwdError(dir, er && er.code || 'ENOTDIR')
    cb(er)
  })
}

module.exports = (dir, opt, cb) => {
  dir = normPath(dir)

  // if there's any overlap between mask and mode,
  // then we'll need an explicit chmod
  const umask = opt.umask
  const mode = opt.mode | 0o0700
  const needChmod = (mode & umask) !== 0

  const uid = opt.uid
  const gid = opt.gid
  const doChown = typeof uid === 'number' &&
    typeof gid === 'number' &&
    ( uid !== opt.processUid || gid !== opt.processGid )

  const preserve = opt.preserve
  const unlink = opt.unlink
  const cache = opt.cache
  const cwd = normPath(opt.cwd)

  const done = (er, created) => {
    if (er)
      cb(er)
    else {
      cSet(cache, dir, true)
      if (created && doChown)
        chownr(created, uid, gid, er => done(er))
      else if (needChmod)
        fs.chmod(dir, mode, cb)
      else
        cb()
    }
  }

  if (cache && cGet(cache, dir) === true)
    return done()

  if (dir === cwd)
    return checkCwd(dir, done)

  if (preserve)
    return mkdirp(dir, mode, done)

  const sub = normPath(path.relative(cwd, dir))
  const parts = sub.split('/')
  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)
}

const mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {
  if (!parts.length)
    return cb(null, created)
  const p = parts.shift()
  const part = normPath(path.resolve(base + '/' + p))
  if (cGet(cache, part))
    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)
  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))
}

const onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {
  if (er) {
    fs.lstat(part, (statEr, st) => {
      if (statEr) {
        statEr.path = statEr.path && normPath(statEr.path)
        cb(statEr)
      } else if (st.isDirectory())
        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)
      else if (unlink)
        fs.unlink(part, er => {
          if (er)
            return cb(er)
          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))
        })
      else if (st.isSymbolicLink())
        return cb(new SymlinkError(part, part + '/' + parts.join('/')))
      else
        cb(er)
    })
  } else {
    created = created || part
    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)
  }
}

const checkCwdSync = dir => {
  let ok = false
  let code = 'ENOTDIR'
  try {
    ok = fs.statSync(dir).isDirectory()
  } catch (er) {
    code = er.code
  } finally {
    if (!ok)
      throw new CwdError(dir, code)
  }
}

module.exports.sync = (dir, opt) => {
  dir = normPath(dir)
  // if there's any overlap between mask and mode,
  // then we'll need an explicit chmod
  const umask = opt.umask
  const mode = opt.mode | 0o0700
  const needChmod = (mode & umask) !== 0

  const uid = opt.uid
  const gid = opt.gid
  const doChown = typeof uid === 'number' &&
    typeof gid === 'number' &&
    ( uid !== opt.processUid || gid !== opt.processGid )

  const preserve = opt.preserve
  const unlink = opt.unlink
  const cache = opt.cache
  const cwd = normPath(opt.cwd)

  const done = (created) => {
    cSet(cache, dir, true)
    if (created && doChown)
      chownr.sync(created, uid, gid)
    if (needChmod)
      fs.chmodSync(dir, mode)
  }

  if (cache && cGet(cache, dir) === true)
    return done()

  if (dir === cwd) {
    checkCwdSync(cwd)
    return done()
  }

  if (preserve)
    return done(mkdirp.sync(dir, mode))

  const sub = normPath(path.relative(cwd, dir))
  const parts = sub.split('/')
  let created = null
  for (let p = parts.shift(), part = cwd;
    p && (part += '/' + p);
    p = parts.shift()) {
    part = normPath(path.resolve(part))
    if (cGet(cache, part))
      continue

    try {
      fs.mkdirSync(part, mode)
      created = created || part
      cSet(cache, part, true)
    } catch (er) {
      const st = fs.lstatSync(part)
      if (st.isDirectory()) {
        cSet(cache, part, true)
        continue
      } else if (unlink) {
        fs.unlinkSync(part)
        fs.mkdirSync(part, mode)
        created = created || part
        cSet(cache, part, true)
        continue
      } else if (st.isSymbolicLink())
        return new SymlinkError(part, part + '/' + parts.join('/'))
    }
  }

  return done(created)
}


/***/ }),

/***/ 88371:
/***/ ((module) => {

"use strict";

module.exports = (mode, isDir, portable) => {
  mode &= 0o7777

  // in portable mode, use the minimum reasonable umask
  // if this system creates files with 0o664 by default
  // (as some linux distros do), then we'll write the
  // archive with 0o644 instead.  Also, don't ever create
  // a file that is not readable/writable by the owner.
  if (portable) {
    mode = (mode | 0o600) &~0o22
  }

  // if dirs are readable, then they should be listable
  if (isDir) {
    if (mode & 0o400)
      mode |= 0o100
    if (mode & 0o40)
      mode |= 0o10
    if (mode & 0o4)
      mode |= 0o1
  }
  return mode
}


/***/ }),

/***/ 56843:
/***/ ((module) => {

// on windows, either \ or / are valid directory separators.
// on unix, \ is a valid character in filenames.
// so, on windows, and only on windows, we replace all \ chars with /,
// so that we can use / as our one and only directory separator char.

const platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform
module.exports = platform !== 'win32' ? p => p
  : p => p && p.replace(/\\/g, '/')


/***/ }),

/***/ 7900:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// A readable tar stream creator
// Technically, this is a transform stream that you write paths into,
// and tar format comes out of.
// The `add()` method is like `write()` but returns this,
// and end() return `this` as well, so you can
// do `new Pack(opt).add('files').add('dir').end().pipe(output)
// You could also do something like:
// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))

class PackJob {
  constructor (path, absolute) {
    this.path = path || './'
    this.absolute = absolute
    this.entry = null
    this.stat = null
    this.readdir = null
    this.pending = false
    this.ignore = false
    this.piped = false
  }
}

const MiniPass = __webpack_require__(41077)
const zlib = __webpack_require__(33486)
const ReadEntry = __webpack_require__(38116)
const WriteEntry = __webpack_require__(55450)
const WriteEntrySync = WriteEntry.Sync
const WriteEntryTar = WriteEntry.Tar
const Yallist = __webpack_require__(40665)
const EOF = Buffer.alloc(1024)
const ONSTAT = Symbol('onStat')
const ENDED = Symbol('ended')
const QUEUE = Symbol('queue')
const CURRENT = Symbol('current')
const PROCESS = Symbol('process')
const PROCESSING = Symbol('processing')
const PROCESSJOB = Symbol('processJob')
const JOBS = Symbol('jobs')
const JOBDONE = Symbol('jobDone')
const ADDFSENTRY = Symbol('addFSEntry')
const ADDTARENTRY = Symbol('addTarEntry')
const STAT = Symbol('stat')
const READDIR = Symbol('readdir')
const ONREADDIR = Symbol('onreaddir')
const PIPE = Symbol('pipe')
const ENTRY = Symbol('entry')
const ENTRYOPT = Symbol('entryOpt')
const WRITEENTRYCLASS = Symbol('writeEntryClass')
const WRITE = Symbol('write')
const ONDRAIN = Symbol('ondrain')

const fs = __webpack_require__(35747)
const path = __webpack_require__(85622)
const warner = __webpack_require__(85899)
const normPath = __webpack_require__(56843)

const Pack = warner(class Pack extends MiniPass {
  constructor (opt) {
    super(opt)
    opt = opt || Object.create(null)
    this.opt = opt
    this.file = opt.file || ''
    this.cwd = opt.cwd || process.cwd()
    this.maxReadSize = opt.maxReadSize
    this.preservePaths = !!opt.preservePaths
    this.strict = !!opt.strict
    this.noPax = !!opt.noPax
    this.prefix = normPath(opt.prefix || '')
    this.linkCache = opt.linkCache || new Map()
    this.statCache = opt.statCache || new Map()
    this.readdirCache = opt.readdirCache || new Map()

    this[WRITEENTRYCLASS] = WriteEntry
    if (typeof opt.onwarn === 'function')
      this.on('warn', opt.onwarn)

    this.portable = !!opt.portable
    this.zip = null
    if (opt.gzip) {
      if (typeof opt.gzip !== 'object')
        opt.gzip = {}
      if (this.portable)
        opt.gzip.portable = true
      this.zip = new zlib.Gzip(opt.gzip)
      this.zip.on('data', chunk => super.write(chunk))
      this.zip.on('end', _ => super.end())
      this.zip.on('drain', _ => this[ONDRAIN]())
      this.on('resume', _ => this.zip.resume())
    } else
      this.on('drain', this[ONDRAIN])

    this.noDirRecurse = !!opt.noDirRecurse
    this.follow = !!opt.follow
    this.noMtime = !!opt.noMtime
    this.mtime = opt.mtime || null

    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true

    this[QUEUE] = new Yallist
    this[JOBS] = 0
    this.jobs = +opt.jobs || 4
    this[PROCESSING] = false
    this[ENDED] = false
  }

  [WRITE] (chunk) {
    return super.write(chunk)
  }

  add (path) {
    this.write(path)
    return this
  }

  end (path) {
    if (path)
      this.write(path)
    this[ENDED] = true
    this[PROCESS]()
    return this
  }

  write (path) {
    if (this[ENDED])
      throw new Error('write after end')

    if (path instanceof ReadEntry)
      this[ADDTARENTRY](path)
    else
      this[ADDFSENTRY](path)
    return this.flowing
  }

  [ADDTARENTRY] (p) {
    const absolute = normPath(path.resolve(this.cwd, p.path))
    // in this case, we don't have to wait for the stat
    if (!this.filter(p.path, p))
      p.resume()
    else {
      const job = new PackJob(p.path, absolute, false)
      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))
      job.entry.on('end', _ => this[JOBDONE](job))
      this[JOBS] += 1
      this[QUEUE].push(job)
    }

    this[PROCESS]()
  }

  [ADDFSENTRY] (p) {
    const absolute = normPath(path.resolve(this.cwd, p))
    this[QUEUE].push(new PackJob(p, absolute))
    this[PROCESS]()
  }

  [STAT] (job) {
    job.pending = true
    this[JOBS] += 1
    const stat = this.follow ? 'stat' : 'lstat'
    fs[stat](job.absolute, (er, stat) => {
      job.pending = false
      this[JOBS] -= 1
      if (er)
        this.emit('error', er)
      else
        this[ONSTAT](job, stat)
    })
  }

  [ONSTAT] (job, stat) {
    this.statCache.set(job.absolute, stat)
    job.stat = stat

    // now we have the stat, we can filter it.
    if (!this.filter(job.path, stat))
      job.ignore = true

    this[PROCESS]()
  }

  [READDIR] (job) {
    job.pending = true
    this[JOBS] += 1
    fs.readdir(job.absolute, (er, entries) => {
      job.pending = false
      this[JOBS] -= 1
      if (er)
        return this.emit('error', er)
      this[ONREADDIR](job, entries)
    })
  }

  [ONREADDIR] (job, entries) {
    this.readdirCache.set(job.absolute, entries)
    job.readdir = entries
    this[PROCESS]()
  }

  [PROCESS] () {
    if (this[PROCESSING])
      return

    this[PROCESSING] = true
    for (let w = this[QUEUE].head;
         w !== null && this[JOBS] < this.jobs;
         w = w.next) {
      this[PROCESSJOB](w.value)
      if (w.value.ignore) {
        const p = w.next
        this[QUEUE].removeNode(w)
        w.next = p
      }
    }

    this[PROCESSING] = false

    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {
      if (this.zip)
        this.zip.end(EOF)
      else {
        super.write(EOF)
        super.end()
      }
    }
  }

  get [CURRENT] () {
    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value
  }

  [JOBDONE] (job) {
    this[QUEUE].shift()
    this[JOBS] -= 1
    this[PROCESS]()
  }

  [PROCESSJOB] (job) {
    if (job.pending)
      return

    if (job.entry) {
      if (job === this[CURRENT] && !job.piped)
        this[PIPE](job)
      return
    }

    if (!job.stat) {
      if (this.statCache.has(job.absolute))
        this[ONSTAT](job, this.statCache.get(job.absolute))
      else
        this[STAT](job)
    }
    if (!job.stat)
      return

    // filtered out!
    if (job.ignore)
      return

    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
      if (this.readdirCache.has(job.absolute))
        this[ONREADDIR](job, this.readdirCache.get(job.absolute))
      else
        this[READDIR](job)
      if (!job.readdir)
        return
    }

    // we know it doesn't have an entry, because that got checked above
    job.entry = this[ENTRY](job)
    if (!job.entry) {
      job.ignore = true
      return
    }

    if (job === this[CURRENT] && !job.piped)
      this[PIPE](job)
  }

  [ENTRYOPT] (job) {
    return {
      onwarn: (code, msg, data) => this.warn(code, msg, data),
      noPax: this.noPax,
      cwd: this.cwd,
      absolute: job.absolute,
      preservePaths: this.preservePaths,
      maxReadSize: this.maxReadSize,
      strict: this.strict,
      portable: this.portable,
      linkCache: this.linkCache,
      statCache: this.statCache,
      noMtime: this.noMtime,
      mtime: this.mtime,
      prefix: this.prefix,
    }
  }

  [ENTRY] (job) {
    this[JOBS] += 1
    try {
      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))
        .on('end', () => this[JOBDONE](job))
        .on('error', er => this.emit('error', er))
    } catch (er) {
      this.emit('error', er)
    }
  }

  [ONDRAIN] () {
    if (this[CURRENT] && this[CURRENT].entry)
      this[CURRENT].entry.resume()
  }

  // like .pipe() but using super, because our write() is special
  [PIPE] (job) {
    job.piped = true

    if (job.readdir)
      job.readdir.forEach(entry => {
        const p = job.path
        const base = p === './' ? '' : p.replace(/\/*$/, '/')
        this[ADDFSENTRY](base + entry)
      })

    const source = job.entry
    const zip = this.zip

    if (zip)
      source.on('data', chunk => {
        if (!zip.write(chunk))
          source.pause()
      })
    else
      source.on('data', chunk => {
        if (!super.write(chunk))
          source.pause()
      })
  }

  pause () {
    if (this.zip)
      this.zip.pause()
    return super.pause()
  }
})

class PackSync extends Pack {
  constructor (opt) {
    super(opt)
    this[WRITEENTRYCLASS] = WriteEntrySync
  }

  // pause/resume are no-ops in sync streams.
  pause () {}
  resume () {}

  [STAT] (job) {
    const stat = this.follow ? 'statSync' : 'lstatSync'
    this[ONSTAT](job, fs[stat](job.absolute))
  }

  [READDIR] (job, stat) {
    this[ONREADDIR](job, fs.readdirSync(job.absolute))
  }

  // gotta get it all in this tick
  [PIPE] (job) {
    const source = job.entry
    const zip = this.zip

    if (job.readdir)
      job.readdir.forEach(entry => {
        const p = job.path
        const base = p === './' ? '' : p.replace(/\/*$/, '/')
        this[ADDFSENTRY](base + entry)
      })

    if (zip)
      source.on('data', chunk => {
        zip.write(chunk)
      })
    else
      source.on('data', chunk => {
        super[WRITE](chunk)
      })
  }
}

Pack.Sync = PackSync

module.exports = Pack


/***/ }),

/***/ 68917:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// this[BUFFER] is the remainder of a chunk if we're waiting for
// the full 512 bytes of a header to come in.  We will Buffer.concat()
// it to the next write(), which is a mem copy, but a small one.
//
// this[QUEUE] is a Yallist of entries that haven't been emitted
// yet this can only get filled up if the user keeps write()ing after
// a write() returns false, or does a write() with more than one entry
//
// We don't buffer chunks, we always parse them and either create an
// entry, or push it into the active entry.  The ReadEntry class knows
// to throw data away if .ignore=true
//
// Shift entry off the buffer when it emits 'end', and emit 'entry' for
// the next one in the list.
//
// At any time, we're pushing body chunks into the entry at WRITEENTRY,
// and waiting for 'end' on the entry at READENTRY
//
// ignored entries get .resume() called on them straight away

const warner = __webpack_require__(85899)
const path = __webpack_require__(85622)
const Header = __webpack_require__(66043)
const EE = __webpack_require__(28614)
const Yallist = __webpack_require__(40665)
const maxMetaEntrySize = 1024 * 1024
const Entry = __webpack_require__(38116)
const Pax = __webpack_require__(77996)
const zlib = __webpack_require__(33486)

const gzipHeader = Buffer.from([0x1f, 0x8b])
const STATE = Symbol('state')
const WRITEENTRY = Symbol('writeEntry')
const READENTRY = Symbol('readEntry')
const NEXTENTRY = Symbol('nextEntry')
const PROCESSENTRY = Symbol('processEntry')
const EX = Symbol('extendedHeader')
const GEX = Symbol('globalExtendedHeader')
const META = Symbol('meta')
const EMITMETA = Symbol('emitMeta')
const BUFFER = Symbol('buffer')
const QUEUE = Symbol('queue')
const ENDED = Symbol('ended')
const EMITTEDEND = Symbol('emittedEnd')
const EMIT = Symbol('emit')
const UNZIP = Symbol('unzip')
const CONSUMECHUNK = Symbol('consumeChunk')
const CONSUMECHUNKSUB = Symbol('consumeChunkSub')
const CONSUMEBODY = Symbol('consumeBody')
const CONSUMEMETA = Symbol('consumeMeta')
const CONSUMEHEADER = Symbol('consumeHeader')
const CONSUMING = Symbol('consuming')
const BUFFERCONCAT = Symbol('bufferConcat')
const MAYBEEND = Symbol('maybeEnd')
const WRITING = Symbol('writing')
const ABORTED = Symbol('aborted')
const DONE = Symbol('onDone')
const SAW_VALID_ENTRY = Symbol('sawValidEntry')
const SAW_NULL_BLOCK = Symbol('sawNullBlock')
const SAW_EOF = Symbol('sawEOF')

const noop = _ => true

module.exports = warner(class Parser extends EE {
  constructor (opt) {
    opt = opt || {}
    super(opt)

    this.file = opt.file || ''

    // set to boolean false when an entry starts.  1024 bytes of \0
    // is technically a valid tarball, albeit a boring one.
    this[SAW_VALID_ENTRY] = null

    // these BADARCHIVE errors can't be detected early. listen on DONE.
    this.on(DONE, _ => {
      if (this[STATE] === 'begin' || this[SAW_VALID_ENTRY] === false) {
        // either less than 1 block of data, or all entries were invalid.
        // Either way, probably not even a tarball.
        this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format')
      }
    })

    if (opt.ondone)
      this.on(DONE, opt.ondone)
    else
      this.on(DONE, _ => {
        this.emit('prefinish')
        this.emit('finish')
        this.emit('end')
        this.emit('close')
      })

    this.strict = !!opt.strict
    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize
    this.filter = typeof opt.filter === 'function' ? opt.filter : noop

    // have to set this so that streams are ok piping into it
    this.writable = true
    this.readable = false

    this[QUEUE] = new Yallist()
    this[BUFFER] = null
    this[READENTRY] = null
    this[WRITEENTRY] = null
    this[STATE] = 'begin'
    this[META] = ''
    this[EX] = null
    this[GEX] = null
    this[ENDED] = false
    this[UNZIP] = null
    this[ABORTED] = false
    this[SAW_NULL_BLOCK] = false
    this[SAW_EOF] = false
    if (typeof opt.onwarn === 'function')
      this.on('warn', opt.onwarn)
    if (typeof opt.onentry === 'function')
      this.on('entry', opt.onentry)
  }

  [CONSUMEHEADER] (chunk, position) {
    if (this[SAW_VALID_ENTRY] === null)
      this[SAW_VALID_ENTRY] = false
    let header
    try {
      header = new Header(chunk, position, this[EX], this[GEX])
    } catch (er) {
      return this.warn('TAR_ENTRY_INVALID', er)
    }

    if (header.nullBlock) {
      if (this[SAW_NULL_BLOCK]) {
        this[SAW_EOF] = true
        // ending an archive with no entries.  pointless, but legal.
        if (this[STATE] === 'begin')
          this[STATE] = 'header'
        this[EMIT]('eof')
      } else {
        this[SAW_NULL_BLOCK] = true
        this[EMIT]('nullBlock')
      }
    } else {
      this[SAW_NULL_BLOCK] = false
      if (!header.cksumValid)
        this.warn('TAR_ENTRY_INVALID', 'checksum failure', {header})
      else if (!header.path)
        this.warn('TAR_ENTRY_INVALID', 'path is required', {header})
      else {
        const type = header.type
        if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)
          this.warn('TAR_ENTRY_INVALID', 'linkpath required', {header})
        else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)
          this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', {header})
        else {
          const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX])

          // we do this for meta & ignored entries as well, because they
          // are still valid tar, or else we wouldn't know to ignore them
          if (!this[SAW_VALID_ENTRY]) {
            if (entry.remain) {
              // this might be the one!
              const onend = () => {
                if (!entry.invalid)
                  this[SAW_VALID_ENTRY] = true
              }
              entry.on('end', onend)
            } else {
              this[SAW_VALID_ENTRY] = true
            }
          }

          if (entry.meta) {
            if (entry.size > this.maxMetaEntrySize) {
              entry.ignore = true
              this[EMIT]('ignoredEntry', entry)
              this[STATE] = 'ignore'
              entry.resume()
            } else if (entry.size > 0) {
              this[META] = ''
              entry.on('data', c => this[META] += c)
              this[STATE] = 'meta'
            }
          } else {
            this[EX] = null
            entry.ignore = entry.ignore || !this.filter(entry.path, entry)

            if (entry.ignore) {
              // probably valid, just not something we care about
              this[EMIT]('ignoredEntry', entry)
              this[STATE] = entry.remain ? 'ignore' : 'header'
              entry.resume()
            } else {
              if (entry.remain)
                this[STATE] = 'body'
              else {
                this[STATE] = 'header'
                entry.end()
              }

              if (!this[READENTRY]) {
                this[QUEUE].push(entry)
                this[NEXTENTRY]()
              } else
                this[QUEUE].push(entry)
            }
          }
        }
      }
    }
  }

  [PROCESSENTRY] (entry) {
    let go = true

    if (!entry) {
      this[READENTRY] = null
      go = false
    } else if (Array.isArray(entry))
      this.emit.apply(this, entry)
    else {
      this[READENTRY] = entry
      this.emit('entry', entry)
      if (!entry.emittedEnd) {
        entry.on('end', _ => this[NEXTENTRY]())
        go = false
      }
    }

    return go
  }

  [NEXTENTRY] () {
    do {} while (this[PROCESSENTRY](this[QUEUE].shift()))

    if (!this[QUEUE].length) {
      // At this point, there's nothing in the queue, but we may have an
      // entry which is being consumed (readEntry).
      // If we don't, then we definitely can handle more data.
      // If we do, and either it's flowing, or it has never had any data
      // written to it, then it needs more.
      // The only other possibility is that it has returned false from a
      // write() call, so we wait for the next drain to continue.
      const re = this[READENTRY]
      const drainNow = !re || re.flowing || re.size === re.remain
      if (drainNow) {
        if (!this[WRITING])
          this.emit('drain')
      } else
        re.once('drain', _ => this.emit('drain'))
     }
  }

  [CONSUMEBODY] (chunk, position) {
    // write up to but no  more than writeEntry.blockRemain
    const entry = this[WRITEENTRY]
    const br = entry.blockRemain
    const c = (br >= chunk.length && position === 0) ? chunk
      : chunk.slice(position, position + br)

    entry.write(c)

    if (!entry.blockRemain) {
      this[STATE] = 'header'
      this[WRITEENTRY] = null
      entry.end()
    }

    return c.length
  }

  [CONSUMEMETA] (chunk, position) {
    const entry = this[WRITEENTRY]
    const ret = this[CONSUMEBODY](chunk, position)

    // if we finished, then the entry is reset
    if (!this[WRITEENTRY])
      this[EMITMETA](entry)

    return ret
  }

  [EMIT] (ev, data, extra) {
    if (!this[QUEUE].length && !this[READENTRY])
      this.emit(ev, data, extra)
    else
      this[QUEUE].push([ev, data, extra])
  }

  [EMITMETA] (entry) {
    this[EMIT]('meta', this[META])
    switch (entry.type) {
      case 'ExtendedHeader':
      case 'OldExtendedHeader':
        this[EX] = Pax.parse(this[META], this[EX], false)
        break

      case 'GlobalExtendedHeader':
        this[GEX] = Pax.parse(this[META], this[GEX], true)
        break

      case 'NextFileHasLongPath':
      case 'OldGnuLongPath':
        this[EX] = this[EX] || Object.create(null)
        this[EX].path = this[META].replace(/\0.*/, '')
        break

      case 'NextFileHasLongLinkpath':
        this[EX] = this[EX] || Object.create(null)
        this[EX].linkpath = this[META].replace(/\0.*/, '')
        break

      /* istanbul ignore next */
      default: throw new Error('unknown meta: ' + entry.type)
    }
  }

  abort (error) {
    this[ABORTED] = true
    this.emit('abort', error)
    // always throws, even in non-strict mode
    this.warn('TAR_ABORT', error, { recoverable: false })
  }

  write (chunk) {
    if (this[ABORTED])
      return

    // first write, might be gzipped
    if (this[UNZIP] === null && chunk) {
      if (this[BUFFER]) {
        chunk = Buffer.concat([this[BUFFER], chunk])
        this[BUFFER] = null
      }
      if (chunk.length < gzipHeader.length) {
        this[BUFFER] = chunk
        return true
      }
      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {
        if (chunk[i] !== gzipHeader[i])
          this[UNZIP] = false
      }
      if (this[UNZIP] === null) {
        const ended = this[ENDED]
        this[ENDED] = false
        this[UNZIP] = new zlib.Unzip()
        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))
        this[UNZIP].on('error', er => this.abort(er))
        this[UNZIP].on('end', _ => {
          this[ENDED] = true
          this[CONSUMECHUNK]()
        })
        this[WRITING] = true
        const ret = this[UNZIP][ended ? 'end' : 'write' ](chunk)
        this[WRITING] = false
        return ret
      }
    }

    this[WRITING] = true
    if (this[UNZIP])
      this[UNZIP].write(chunk)
    else
      this[CONSUMECHUNK](chunk)
    this[WRITING] = false

    // return false if there's a queue, or if the current entry isn't flowing
    const ret =
      this[QUEUE].length ? false :
      this[READENTRY] ? this[READENTRY].flowing :
      true

    // if we have no queue, then that means a clogged READENTRY
    if (!ret && !this[QUEUE].length)
      this[READENTRY].once('drain', _ => this.emit('drain'))

    return ret
  }

  [BUFFERCONCAT] (c) {
    if (c && !this[ABORTED])
      this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c
  }

  [MAYBEEND] () {
    if (this[ENDED] &&
        !this[EMITTEDEND] &&
        !this[ABORTED] &&
        !this[CONSUMING]) {
      this[EMITTEDEND] = true
      const entry = this[WRITEENTRY]
      if (entry && entry.blockRemain) {
        // truncated, likely a damaged file
        const have = this[BUFFER] ? this[BUFFER].length : 0
        this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${
          entry.blockRemain} more bytes, only ${have} available)`, {entry})
        if (this[BUFFER])
          entry.write(this[BUFFER])
        entry.end()
      }
      this[EMIT](DONE)
    }
  }

  [CONSUMECHUNK] (chunk) {
    if (this[CONSUMING])
      this[BUFFERCONCAT](chunk)
    else if (!chunk && !this[BUFFER])
      this[MAYBEEND]()
    else {
      this[CONSUMING] = true
      if (this[BUFFER]) {
        this[BUFFERCONCAT](chunk)
        const c = this[BUFFER]
        this[BUFFER] = null
        this[CONSUMECHUNKSUB](c)
      } else {
        this[CONSUMECHUNKSUB](chunk)
      }

      while (this[BUFFER] &&
          this[BUFFER].length >= 512 &&
          !this[ABORTED] &&
          !this[SAW_EOF]) {
        const c = this[BUFFER]
        this[BUFFER] = null
        this[CONSUMECHUNKSUB](c)
      }
      this[CONSUMING] = false
    }

    if (!this[BUFFER] || this[ENDED])
      this[MAYBEEND]()
  }

  [CONSUMECHUNKSUB] (chunk) {
    // we know that we are in CONSUMING mode, so anything written goes into
    // the buffer.  Advance the position and put any remainder in the buffer.
    let position = 0
    let length = chunk.length
    while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {
      switch (this[STATE]) {
        case 'begin':
        case 'header':
          this[CONSUMEHEADER](chunk, position)
          position += 512
          break

        case 'ignore':
        case 'body':
          position += this[CONSUMEBODY](chunk, position)
          break

        case 'meta':
          position += this[CONSUMEMETA](chunk, position)
          break

        /* istanbul ignore next */
        default:
          throw new Error('invalid state: ' + this[STATE])
      }
    }

    if (position < length) {
      if (this[BUFFER])
        this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]])
      else
        this[BUFFER] = chunk.slice(position)
    }
  }

  end (chunk) {
    if (!this[ABORTED]) {
      if (this[UNZIP])
        this[UNZIP].end(chunk)
      else {
        this[ENDED] = true
        this.write(chunk)
      }
    }
  }
})


/***/ }),

/***/ 99587:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// A path exclusive reservation system
// reserve([list, of, paths], fn)
// When the fn is first in line for all its paths, it
// is called with a cb that clears the reservation.
//
// Used by async unpack to avoid clobbering paths in use,
// while still allowing maximal safe parallelization.

const assert = __webpack_require__(42357)
const normPath = __webpack_require__(56843)
const stripSlashes = __webpack_require__(88886)
const { join } = __webpack_require__(85622)

const platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform
const isWindows = platform === 'win32'

module.exports = () => {
  // path => [function or Set]
  // A Set object means a directory reservation
  // A fn is a direct reservation on that path
  const queues = new Map()

  // fn => {paths:[path,...], dirs:[path, ...]}
  const reservations = new Map()

  // return a set of parent dirs for a given path
  // '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']
  const getDirs = path => {
    const dirs = path.split('/').slice(0, -1).reduce((set, path) => {
      if (set.length)
        path = normPath(join(set[set.length - 1], path))
      set.push(path || '/')
      return set
    }, [])
    return dirs
  }

  // functions currently running
  const running = new Set()

  // return the queues for each path the function cares about
  // fn => {paths, dirs}
  const getQueues = fn => {
    const res = reservations.get(fn)
    /* istanbul ignore if - unpossible */
    if (!res)
      throw new Error('function does not have any path reservations')
    return {
      paths: res.paths.map(path => queues.get(path)),
      dirs: [...res.dirs].map(path => queues.get(path)),
    }
  }

  // check if fn is first in line for all its paths, and is
  // included in the first set for all its dir queues
  const check = fn => {
    const {paths, dirs} = getQueues(fn)
    return paths.every(q => q[0] === fn) &&
      dirs.every(q => q[0] instanceof Set && q[0].has(fn))
  }

  // run the function if it's first in line and not already running
  const run = fn => {
    if (running.has(fn) || !check(fn))
      return false
    running.add(fn)
    fn(() => clear(fn))
    return true
  }

  const clear = fn => {
    if (!running.has(fn))
      return false

    const { paths, dirs } = reservations.get(fn)
    const next = new Set()

    paths.forEach(path => {
      const q = queues.get(path)
      assert.equal(q[0], fn)
      if (q.length === 1)
        queues.delete(path)
      else {
        q.shift()
        if (typeof q[0] === 'function')
          next.add(q[0])
        else
          q[0].forEach(fn => next.add(fn))
      }
    })

    dirs.forEach(dir => {
      const q = queues.get(dir)
      assert(q[0] instanceof Set)
      if (q[0].size === 1 && q.length === 1) {
        queues.delete(dir)
      } else if (q[0].size === 1) {
        q.shift()

        // must be a function or else the Set would've been reused
        next.add(q[0])
      } else
        q[0].delete(fn)
    })
    running.delete(fn)

    next.forEach(fn => run(fn))
    return true
  }

  const reserve = (paths, fn) => {
    // collide on matches across case and unicode normalization
    // On windows, thanks to the magic of 8.3 shortnames, it is fundamentally
    // impossible to determine whether two paths refer to the same thing on
    // disk, without asking the kernel for a shortname.
    // So, we just pretend that every path matches every other path here,
    // effectively removing all parallelization on windows.
    paths = isWindows ? ['win32 parallelization disabled'] : paths.map(p => {
      return stripSlashes(normPath(join(p)))
        .normalize('NFKD')
        .toLowerCase()
    })

    const dirs = new Set(
      paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b))
    )
    reservations.set(fn, {dirs, paths})
    paths.forEach(path => {
      const q = queues.get(path)
      if (!q)
        queues.set(path, [fn])
      else
        q.push(fn)
    })
    dirs.forEach(dir => {
      const q = queues.get(dir)
      if (!q)
        queues.set(dir, [new Set([fn])])
      else if (q[q.length-1] instanceof Set)
        q[q.length-1].add(fn)
      else
        q.push(new Set([fn]))
    })

    return run(fn)
  }

  return { check, reserve }
}


/***/ }),

/***/ 77996:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Header = __webpack_require__(66043)
const path = __webpack_require__(85622)

class Pax {
  constructor (obj, global) {
    this.atime = obj.atime || null
    this.charset = obj.charset || null
    this.comment = obj.comment || null
    this.ctime = obj.ctime || null
    this.gid = obj.gid || null
    this.gname = obj.gname || null
    this.linkpath = obj.linkpath || null
    this.mtime = obj.mtime || null
    this.path = obj.path || null
    this.size = obj.size || null
    this.uid = obj.uid || null
    this.uname = obj.uname || null
    this.dev = obj.dev || null
    this.ino = obj.ino || null
    this.nlink = obj.nlink || null
    this.global = global || false
  }

  encode () {
    const body = this.encodeBody()
    if (body === '')
      return null

    const bodyLen = Buffer.byteLength(body)
    // round up to 512 bytes
    // add 512 for header
    const bufLen = 512 * Math.ceil(1 + bodyLen / 512)
    const buf = Buffer.allocUnsafe(bufLen)

    // 0-fill the header section, it might not hit every field
    for (let i = 0; i < 512; i++) {
      buf[i] = 0
    }

    new Header({
      // XXX split the path
      // then the path should be PaxHeader + basename, but less than 99,
      // prepend with the dirname
      path: ('PaxHeader/' + path.basename(this.path)).slice(0, 99),
      mode: this.mode || 0o644,
      uid: this.uid || null,
      gid: this.gid || null,
      size: bodyLen,
      mtime: this.mtime || null,
      type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',
      linkpath: '',
      uname: this.uname || '',
      gname: this.gname || '',
      devmaj: 0,
      devmin: 0,
      atime: this.atime || null,
      ctime: this.ctime || null
    }).encode(buf)

    buf.write(body, 512, bodyLen, 'utf8')

    // null pad after the body
    for (let i = bodyLen + 512; i < buf.length; i++) {
      buf[i] = 0
    }

    return buf
  }

  encodeBody () {
    return (
      this.encodeField('path') +
      this.encodeField('ctime') +
      this.encodeField('atime') +
      this.encodeField('dev') +
      this.encodeField('ino') +
      this.encodeField('nlink') +
      this.encodeField('charset') +
      this.encodeField('comment') +
      this.encodeField('gid') +
      this.encodeField('gname') +
      this.encodeField('linkpath') +
      this.encodeField('mtime') +
      this.encodeField('size') +
      this.encodeField('uid') +
      this.encodeField('uname')
    )
  }

  encodeField (field) {
    if (this[field] === null || this[field] === undefined)
      return ''
    const v = this[field] instanceof Date ? this[field].getTime() / 1000
      : this[field]
    const s = ' ' +
      (field === 'dev' || field === 'ino' || field === 'nlink'
       ? 'SCHILY.' : '') +
      field + '=' + v + '\n'
    const byteLen = Buffer.byteLength(s)
    // the digits includes the length of the digits in ascii base-10
    // so if it's 9 characters, then adding 1 for the 9 makes it 10
    // which makes it 11 chars.
    let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1
    if (byteLen + digits >= Math.pow(10, digits))
      digits += 1
    const len = digits + byteLen
    return len + s
  }
}

Pax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g)

const merge = (a, b) =>
  b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a

const parseKV = string =>
  string
    .replace(/\n$/, '')
    .split('\n')
    .reduce(parseKVLine, Object.create(null))

const parseKVLine = (set, line) => {
  const n = parseInt(line, 10)

  // XXX Values with \n in them will fail this.
  // Refactor to not be a naive line-by-line parse.
  if (n !== Buffer.byteLength(line) + 1)
    return set

  line = line.substr((n + ' ').length)
  const kv = line.split('=')
  const k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, '$1')
  if (!k)
    return set

  const v = kv.join('=')
  set[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k)
    ?  new Date(v * 1000)
    : /^[0-9]+$/.test(v) ? +v
    : v
  return set
}

module.exports = Pax


/***/ }),

/***/ 38116:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const types = __webpack_require__(24173)
const MiniPass = __webpack_require__(41077)
const normPath = __webpack_require__(56843)

const SLURP = Symbol('slurp')
module.exports = class ReadEntry extends MiniPass {
  constructor (header, ex, gex) {
    super()
    // read entries always start life paused.  this is to avoid the
    // situation where Minipass's auto-ending empty streams results
    // in an entry ending before we're ready for it.
    this.pause()
    this.extended = ex
    this.globalExtended = gex
    this.header = header
    this.startBlockSize = 512 * Math.ceil(header.size / 512)
    this.blockRemain = this.startBlockSize
    this.remain = header.size
    this.type = header.type
    this.meta = false
    this.ignore = false
    switch (this.type) {
      case 'File':
      case 'OldFile':
      case 'Link':
      case 'SymbolicLink':
      case 'CharacterDevice':
      case 'BlockDevice':
      case 'Directory':
      case 'FIFO':
      case 'ContiguousFile':
      case 'GNUDumpDir':
        break

      case 'NextFileHasLongLinkpath':
      case 'NextFileHasLongPath':
      case 'OldGnuLongPath':
      case 'GlobalExtendedHeader':
      case 'ExtendedHeader':
      case 'OldExtendedHeader':
        this.meta = true
        break

      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'
      // it may be worth doing the same, but with a warning.
      default:
        this.ignore = true
    }

    this.path = normPath(header.path)
    this.mode = header.mode
    if (this.mode)
      this.mode = this.mode & 0o7777
    this.uid = header.uid
    this.gid = header.gid
    this.uname = header.uname
    this.gname = header.gname
    this.size = header.size
    this.mtime = header.mtime
    this.atime = header.atime
    this.ctime = header.ctime
    this.linkpath = normPath(header.linkpath)
    this.uname = header.uname
    this.gname = header.gname

    if (ex) this[SLURP](ex)
    if (gex) this[SLURP](gex, true)
  }

  write (data) {
    const writeLen = data.length
    if (writeLen > this.blockRemain)
      throw new Error('writing more to entry than is appropriate')

    const r = this.remain
    const br = this.blockRemain
    this.remain = Math.max(0, r - writeLen)
    this.blockRemain = Math.max(0, br - writeLen)
    if (this.ignore)
      return true

    if (r >= writeLen)
      return super.write(data)

    // r < writeLen
    return super.write(data.slice(0, r))
  }

  [SLURP] (ex, global) {
    for (let k in ex) {
      // we slurp in everything except for the path attribute in
      // a global extended header, because that's weird.
      if (ex[k] !== null && ex[k] !== undefined &&
          !(global && k === 'path'))
        this[k] = k === 'path' || k === 'linkpath' ? normPath(ex[k]) : ex[k]
    }
  }
}


/***/ }),

/***/ 45923:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// tar -r
const hlo = __webpack_require__(95274)
const Pack = __webpack_require__(7900)
const Parse = __webpack_require__(68917)
const fs = __webpack_require__(35747)
const fsm = __webpack_require__(27714)
const t = __webpack_require__(51525)
const path = __webpack_require__(85622)

// starting at the head of the file, read a Header
// If the checksum is invalid, that's our position to start writing
// If it is, jump forward by the specified size (round up to 512)
// and try again.
// Write the new Pack stream starting there.

const Header = __webpack_require__(66043)

const r = module.exports = (opt_, files, cb) => {
  const opt = hlo(opt_)

  if (!opt.file)
    throw new TypeError('file is required')

  if (opt.gzip)
    throw new TypeError('cannot append to compressed archives')

  if (!files || !Array.isArray(files) || !files.length)
    throw new TypeError('no files or directories specified')

  files = Array.from(files)

  return opt.sync ? replaceSync(opt, files)
    : replace(opt, files, cb)
}

const replaceSync = (opt, files) => {
  const p = new Pack.Sync(opt)

  let threw = true
  let fd
  let position

  try {
    try {
      fd = fs.openSync(opt.file, 'r+')
    } catch (er) {
      if (er.code === 'ENOENT')
        fd = fs.openSync(opt.file, 'w+')
      else
        throw er
    }

    const st = fs.fstatSync(fd)
    const headBuf = Buffer.alloc(512)

    POSITION: for (position = 0; position < st.size; position += 512) {
      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {
        bytes = fs.readSync(
          fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos
        )

        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)
          throw new Error('cannot append to compressed archives')

        if (!bytes)
          break POSITION
      }

      let h = new Header(headBuf)
      if (!h.cksumValid)
        break
      let entryBlockSize = 512 * Math.ceil(h.size / 512)
      if (position + entryBlockSize + 512 > st.size)
        break
      // the 512 for the header we just parsed will be added as well
      // also jump ahead all the blocks for the body
      position += entryBlockSize
      if (opt.mtimeCache)
        opt.mtimeCache.set(h.path, h.mtime)
    }
    threw = false

    streamSync(opt, p, position, fd, files)
  } finally {
    if (threw)
      try { fs.closeSync(fd) } catch (er) {}
  }
}

const streamSync = (opt, p, position, fd, files) => {
  const stream = new fsm.WriteStreamSync(opt.file, {
    fd: fd,
    start: position
  })
  p.pipe(stream)
  addFilesSync(p, files)
}

const replace = (opt, files, cb) => {
  files = Array.from(files)
  const p = new Pack(opt)

  const getPos = (fd, size, cb_) => {
    const cb = (er, pos) => {
      if (er)
        fs.close(fd, _ => cb_(er))
      else
        cb_(null, pos)
    }

    let position = 0
    if (size === 0)
      return cb(null, 0)

    let bufPos = 0
    const headBuf = Buffer.alloc(512)
    const onread = (er, bytes) => {
      if (er)
        return cb(er)
      bufPos += bytes
      if (bufPos < 512 && bytes)
        return fs.read(
          fd, headBuf, bufPos, headBuf.length - bufPos,
          position + bufPos, onread
        )

      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)
        return cb(new Error('cannot append to compressed archives'))

      // truncated header
      if (bufPos < 512)
        return cb(null, position)

      const h = new Header(headBuf)
      if (!h.cksumValid)
        return cb(null, position)

      const entryBlockSize = 512 * Math.ceil(h.size / 512)
      if (position + entryBlockSize + 512 > size)
        return cb(null, position)

      position += entryBlockSize + 512
      if (position >= size)
        return cb(null, position)

      if (opt.mtimeCache)
        opt.mtimeCache.set(h.path, h.mtime)
      bufPos = 0
      fs.read(fd, headBuf, 0, 512, position, onread)
    }
    fs.read(fd, headBuf, 0, 512, position, onread)
  }

  const promise = new Promise((resolve, reject) => {
    p.on('error', reject)
    let flag = 'r+'
    const onopen = (er, fd) => {
      if (er && er.code === 'ENOENT' && flag === 'r+') {
        flag = 'w+'
        return fs.open(opt.file, flag, onopen)
      }

      if (er)
        return reject(er)

      fs.fstat(fd, (er, st) => {
        if (er)
          return fs.close(fd, () => reject(er))

        getPos(fd, st.size, (er, position) => {
          if (er)
            return reject(er)
          const stream = new fsm.WriteStream(opt.file, {
            fd: fd,
            start: position
          })
          p.pipe(stream)
          stream.on('error', reject)
          stream.on('close', resolve)
          addFilesAsync(p, files)
        })
      })
    }
    fs.open(opt.file, flag, onopen)
  })

  return cb ? promise.then(cb, cb) : promise
}

const addFilesSync = (p, files) => {
  files.forEach(file => {
    if (file.charAt(0) === '@')
      t({
        file: path.resolve(p.cwd, file.substr(1)),
        sync: true,
        noResume: true,
        onentry: entry => p.add(entry)
      })
    else
      p.add(file)
  })
  p.end()
}

const addFilesAsync = (p, files) => {
  while (files.length) {
    const file = files.shift()
    if (file.charAt(0) === '@')
      return t({
        file: path.resolve(p.cwd, file.substr(1)),
        noResume: true,
        onentry: entry => p.add(entry)
      }).then(_ => addFilesAsync(p, files))
    else
      p.add(file)
  }
  p.end()
}


/***/ }),

/***/ 37111:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// unix absolute paths are also absolute on win32, so we use this for both
const { isAbsolute, parse } = __webpack_require__(85622).win32

// returns [root, stripped]
// Note that windows will think that //x/y/z/a has a "root" of //x/y, and in
// those cases, we want to sanitize it to x/y/z/a, not z/a, so we strip /
// explicitly if it's the first character.
// drive-specific relative paths on Windows get their root stripped off even
// though they are not absolute, so `c:../foo` becomes ['c:', '../foo']
module.exports = path => {
  let r = ''

  let parsed = parse(path)
  while (isAbsolute(path) || parsed.root) {
    // windows will think that //x/y/z has a "root" of //x/y/
    // but strip the //?/C:/ off of //?/C:/path
    const root = path.charAt(0) === '/' && path.slice(0, 4) !== '//?/' ? '/'
      : parsed.root
    path = path.substr(root.length)
    r += root
    parsed = parse(path)
  }
  return [r, path]
}


/***/ }),

/***/ 88886:
/***/ ((module) => {

// this is the only approach that was significantly faster than using
// str.replace(/\/+$/, '') for strings ending with a lot of / chars and
// containing multiple / chars.
const batchStrings = [
  '/'.repeat(1024),
  '/'.repeat(512),
  '/'.repeat(256),
  '/'.repeat(128),
  '/'.repeat(64),
  '/'.repeat(32),
  '/'.repeat(16),
  '/'.repeat(8),
  '/'.repeat(4),
  '/'.repeat(2),
  '/',
]

module.exports = str => {
  for (const s of batchStrings) {
    while (str.length >= s.length && str.slice(-1 * s.length) === s)
      str = str.slice(0, -1 * s.length)
  }
  return str
}


/***/ }),

/***/ 24173:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// map types from key to human-friendly name
exports.name = new Map([
  ['0', 'File'],
  // same as File
  ['', 'OldFile'],
  ['1', 'Link'],
  ['2', 'SymbolicLink'],
  // Devices and FIFOs aren't fully supported
  // they are parsed, but skipped when unpacking
  ['3', 'CharacterDevice'],
  ['4', 'BlockDevice'],
  ['5', 'Directory'],
  ['6', 'FIFO'],
  // same as File
  ['7', 'ContiguousFile'],
  // pax headers
  ['g', 'GlobalExtendedHeader'],
  ['x', 'ExtendedHeader'],
  // vendor-specific stuff
  // skip
  ['A', 'SolarisACL'],
  // like 5, but with data, which should be skipped
  ['D', 'GNUDumpDir'],
  // metadata only, skip
  ['I', 'Inode'],
  // data = link path of next file
  ['K', 'NextFileHasLongLinkpath'],
  // data = path of next file
  ['L', 'NextFileHasLongPath'],
  // skip
  ['M', 'ContinuationFile'],
  // like L
  ['N', 'OldGnuLongPath'],
  // skip
  ['S', 'SparseFile'],
  // skip
  ['V', 'TapeVolumeHeader'],
  // like x
  ['X', 'OldExtendedHeader']
])

// map the other direction
exports.code = new Map(Array.from(exports.name).map(kv => [kv[1], kv[0]]))


/***/ }),

/***/ 17628:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.
// but the path reservations are required to avoid race conditions where
// parallelized unpack ops may mess with one another, due to dependencies
// (like a Link depending on its target) or destructive operations (like
// clobbering an fs object to create one of a different type.)

const assert = __webpack_require__(42357)
const EE = __webpack_require__(28614).EventEmitter
const Parser = __webpack_require__(68917)
const fs = __webpack_require__(35747)
const fsm = __webpack_require__(27714)
const path = __webpack_require__(85622)
const mkdir = __webpack_require__(69624)
const mkdirSync = mkdir.sync
const wc = __webpack_require__(44808)
const pathReservations = __webpack_require__(99587)
const stripAbsolutePath = __webpack_require__(37111)
const normPath = __webpack_require__(56843)
const stripSlash = __webpack_require__(88886)

const ONENTRY = Symbol('onEntry')
const CHECKFS = Symbol('checkFs')
const CHECKFS2 = Symbol('checkFs2')
const PRUNECACHE = Symbol('pruneCache')
const ISREUSABLE = Symbol('isReusable')
const MAKEFS = Symbol('makeFs')
const FILE = Symbol('file')
const DIRECTORY = Symbol('directory')
const LINK = Symbol('link')
const SYMLINK = Symbol('symlink')
const HARDLINK = Symbol('hardlink')
const UNSUPPORTED = Symbol('unsupported')
const UNKNOWN = Symbol('unknown')
const CHECKPATH = Symbol('checkPath')
const MKDIR = Symbol('mkdir')
const ONERROR = Symbol('onError')
const PENDING = Symbol('pending')
const PEND = Symbol('pend')
const UNPEND = Symbol('unpend')
const ENDED = Symbol('ended')
const MAYBECLOSE = Symbol('maybeClose')
const SKIP = Symbol('skip')
const DOCHOWN = Symbol('doChown')
const UID = Symbol('uid')
const GID = Symbol('gid')
const CHECKED_CWD = Symbol('checkedCwd')
const crypto = __webpack_require__(33373)
const getFlag = __webpack_require__(91172)
const platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform
const isWindows = platform === 'win32'

// Unlinks on Windows are not atomic.
//
// This means that if you have a file entry, followed by another
// file entry with an identical name, and you cannot re-use the file
// (because it's a hardlink, or because unlink:true is set, or it's
// Windows, which does not have useful nlink values), then the unlink
// will be committed to the disk AFTER the new file has been written
// over the old one, deleting the new file.
//
// To work around this, on Windows systems, we rename the file and then
// delete the renamed file.  It's a sloppy kludge, but frankly, I do not
// know of a better way to do this, given windows' non-atomic unlink
// semantics.
//
// See: https://github.com/npm/node-tar/issues/183
/* istanbul ignore next */
const unlinkFile = (path, cb) => {
  if (!isWindows)
    return fs.unlink(path, cb)

  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')
  fs.rename(path, name, er => {
    if (er)
      return cb(er)
    fs.unlink(name, cb)
  })
}

/* istanbul ignore next */
const unlinkFileSync = path => {
  if (!isWindows)
    return fs.unlinkSync(path)

  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')
  fs.renameSync(path, name)
  fs.unlinkSync(name)
}

// this.gid, entry.gid, this.processUid
const uint32 = (a, b, c) =>
  a === a >>> 0 ? a
  : b === b >>> 0 ? b
  : c

// clear the cache if it's a case-insensitive unicode-squashing match.
// we can't know if the current file system is case-sensitive or supports
// unicode fully, so we check for similarity on the maximally compatible
// representation.  Err on the side of pruning, since all it's doing is
// preventing lstats, and it's not the end of the world if we get a false
// positive.
// Note that on windows, we always drop the entire cache whenever a
// symbolic link is encountered, because 8.3 filenames are impossible
// to reason about, and collisions are hazards rather than just failures.
const cacheKeyNormalize = path => stripSlash(normPath(path))
  .normalize('NFKD')
  .toLowerCase()

const pruneCache = (cache, abs) => {
  abs = cacheKeyNormalize(abs)
  for (const path of cache.keys()) {
    const pnorm = cacheKeyNormalize(path)
    if (pnorm === abs || pnorm.indexOf(abs + '/') === 0)
      cache.delete(path)
  }
}

const dropCache = cache => {
  for (const key of cache.keys())
    cache.delete(key)
}

class Unpack extends Parser {
  constructor (opt) {
    if (!opt)
      opt = {}

    opt.ondone = _ => {
      this[ENDED] = true
      this[MAYBECLOSE]()
    }

    super(opt)

    this[CHECKED_CWD] = false

    this.reservations = pathReservations()

    this.transform = typeof opt.transform === 'function' ? opt.transform : null

    this.writable = true
    this.readable = false

    this[PENDING] = 0
    this[ENDED] = false

    this.dirCache = opt.dirCache || new Map()

    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {
      // need both or neither
      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number')
        throw new TypeError('cannot set owner without number uid and gid')
      if (opt.preserveOwner)
        throw new TypeError(
          'cannot preserve owner in archive and also set owner explicitly')
      this.uid = opt.uid
      this.gid = opt.gid
      this.setOwner = true
    } else {
      this.uid = null
      this.gid = null
      this.setOwner = false
    }

    // default true for root
    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number')
      this.preserveOwner = process.getuid && process.getuid() === 0
    else
      this.preserveOwner = !!opt.preserveOwner

    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?
      process.getuid() : null
    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?
      process.getgid() : null

    // mostly just for testing, but useful in some cases.
    // Forcibly trigger a chown on every entry, no matter what
    this.forceChown = opt.forceChown === true

    // turn ><?| in filenames into 0xf000-higher encoded forms
    this.win32 = !!opt.win32 || isWindows

    // do not unpack over files that are newer than what's in the archive
    this.newer = !!opt.newer

    // do not unpack over ANY files
    this.keep = !!opt.keep

    // do not set mtime/atime of extracted entries
    this.noMtime = !!opt.noMtime

    // allow .., absolute path entries, and unpacking through symlinks
    // without this, warn and skip .., relativize absolutes, and error
    // on symlinks in extraction path
    this.preservePaths = !!opt.preservePaths

    // unlink files and links before writing. This breaks existing hard
    // links, and removes symlink directories rather than erroring
    this.unlink = !!opt.unlink

    this.cwd = normPath(path.resolve(opt.cwd || process.cwd()))
    this.strip = +opt.strip || 0
    this.processUmask = process.umask()
    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask
    // default mode for dirs created as parents
    this.dmode = opt.dmode || (0o0777 & (~this.umask))
    this.fmode = opt.fmode || (0o0666 & (~this.umask))
    this.on('entry', entry => this[ONENTRY](entry))
  }

  // a bad or damaged archive is a warning for Parser, but an error
  // when extracting.  Mark those errors as unrecoverable, because
  // the Unpack contract cannot be met.
  warn (code, msg, data = {}) {
    if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT')
      data.recoverable = false
    return super.warn(code, msg, data)
  }

  [MAYBECLOSE] () {
    if (this[ENDED] && this[PENDING] === 0) {
      this.emit('prefinish')
      this.emit('finish')
      this.emit('end')
      this.emit('close')
    }
  }

  [CHECKPATH] (entry) {
    if (this.strip) {
      const parts = normPath(entry.path).split('/')
      if (parts.length < this.strip)
        return false
      entry.path = parts.slice(this.strip).join('/')

      if (entry.type === 'Link') {
        const linkparts = normPath(entry.linkpath).split('/')
        if (linkparts.length >= this.strip)
          entry.linkpath = linkparts.slice(this.strip).join('/')
        else
          return false
      }
    }

    if (!this.preservePaths) {
      const p = normPath(entry.path)
      const parts = p.split('/')
      if (parts.includes('..') || isWindows && /^[a-z]:\.\.$/i.test(parts[0])) {
        this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {
          entry,
          path: p,
        })
        return false
      }

      // strip off the root
      const [root, stripped] = stripAbsolutePath(p)
      if (root) {
        entry.path = stripped
        this.warn('TAR_ENTRY_INFO', `stripping ${root} from absolute path`, {
          entry,
          path: p,
        })
      }
    }

    if (path.isAbsolute(entry.path))
      entry.absolute = normPath(path.resolve(entry.path))
    else
      entry.absolute = normPath(path.resolve(this.cwd, entry.path))

    // if we somehow ended up with a path that escapes the cwd, and we are
    // not in preservePaths mode, then something is fishy!  This should have
    // been prevented above, so ignore this for coverage.
    /* istanbul ignore if - defense in depth */
    if (!this.preservePaths &&
        entry.absolute.indexOf(this.cwd + '/') !== 0 &&
        entry.absolute !== this.cwd) {
      this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {
        entry,
        path: normPath(entry.path),
        resolvedPath: entry.absolute,
        cwd: this.cwd,
      })
      return false
    }

    // an archive can set properties on the extraction directory, but it
    // may not replace the cwd with a different kind of thing entirely.
    if (entry.absolute === this.cwd &&
        entry.type !== 'Directory' &&
        entry.type !== 'GNUDumpDir')
      return false

    // only encode : chars that aren't drive letter indicators
    if (this.win32) {
      const { root: aRoot } = path.win32.parse(entry.absolute)
      entry.absolute = aRoot + wc.encode(entry.absolute.substr(aRoot.length))
      const { root: pRoot } = path.win32.parse(entry.path)
      entry.path = pRoot + wc.encode(entry.path.substr(pRoot.length))
    }

    return true
  }

  [ONENTRY] (entry) {
    if (!this[CHECKPATH](entry))
      return entry.resume()

    assert.equal(typeof entry.absolute, 'string')

    switch (entry.type) {
      case 'Directory':
      case 'GNUDumpDir':
        if (entry.mode)
          entry.mode = entry.mode | 0o700

      case 'File':
      case 'OldFile':
      case 'ContiguousFile':
      case 'Link':
      case 'SymbolicLink':
        return this[CHECKFS](entry)

      case 'CharacterDevice':
      case 'BlockDevice':
      case 'FIFO':
        return this[UNSUPPORTED](entry)
    }
  }

  [ONERROR] (er, entry) {
    // Cwd has to exist, or else nothing works. That's serious.
    // Other errors are warnings, which raise the error in strict
    // mode, but otherwise continue on.
    if (er.name === 'CwdError')
      this.emit('error', er)
    else {
      this.warn('TAR_ENTRY_ERROR', er, {entry})
      this[UNPEND]()
      entry.resume()
    }
  }

  [MKDIR] (dir, mode, cb) {
    mkdir(normPath(dir), {
      uid: this.uid,
      gid: this.gid,
      processUid: this.processUid,
      processGid: this.processGid,
      umask: this.processUmask,
      preserve: this.preservePaths,
      unlink: this.unlink,
      cache: this.dirCache,
      cwd: this.cwd,
      mode: mode
    }, cb)
  }

  [DOCHOWN] (entry) {
    // in preserve owner mode, chown if the entry doesn't match process
    // in set owner mode, chown if setting doesn't match process
    return this.forceChown ||
      this.preserveOwner &&
      ( typeof entry.uid === 'number' && entry.uid !== this.processUid ||
        typeof entry.gid === 'number' && entry.gid !== this.processGid )
      ||
      ( typeof this.uid === 'number' && this.uid !== this.processUid ||
        typeof this.gid === 'number' && this.gid !== this.processGid )
  }

  [UID] (entry) {
    return uint32(this.uid, entry.uid, this.processUid)
  }

  [GID] (entry) {
    return uint32(this.gid, entry.gid, this.processGid)
  }

  [FILE] (entry, fullyDone) {
    const mode = entry.mode & 0o7777 || this.fmode
    const stream = new fsm.WriteStream(entry.absolute, {
      flags: getFlag(entry.size),
      mode: mode,
      autoClose: false
    })
    stream.on('error', er => {
      if (stream.fd)
        fs.close(stream.fd, () => {})

      // flush all the data out so that we aren't left hanging
      // if the error wasn't actually fatal.  otherwise the parse
      // is blocked, and we never proceed.
      stream.write = () => true
      this[ONERROR](er, entry)
      fullyDone()
    })

    let actions = 1
    const done = er => {
      if (er) {
        /* istanbul ignore else - we should always have a fd by now */
        if (stream.fd)
          fs.close(stream.fd, () => {})

        this[ONERROR](er, entry)
        fullyDone()
        return
      }

      if (--actions === 0) {
        fs.close(stream.fd, er => {
          if (er)
            this[ONERROR](er, entry)
          else
            this[UNPEND]()
          fullyDone()
        })
      }
    }

    stream.on('finish', _ => {
      // if futimes fails, try utimes
      // if utimes fails, fail with the original error
      // same for fchown/chown
      const abs = entry.absolute
      const fd = stream.fd

      if (entry.mtime && !this.noMtime) {
        actions++
        const atime = entry.atime || new Date()
        const mtime = entry.mtime
        fs.futimes(fd, atime, mtime, er =>
          er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))
          : done())
      }

      if (this[DOCHOWN](entry)) {
        actions++
        const uid = this[UID](entry)
        const gid = this[GID](entry)
        fs.fchown(fd, uid, gid, er =>
          er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))
          : done())
      }

      done()
    })

    const tx = this.transform ? this.transform(entry) || entry : entry
    if (tx !== entry) {
      tx.on('error', er => {
        this[ONERROR](er, entry)
        fullyDone()
      })
      entry.pipe(tx)
    }
    tx.pipe(stream)
  }

  [DIRECTORY] (entry, fullyDone) {
    const mode = entry.mode & 0o7777 || this.dmode
    this[MKDIR](entry.absolute, mode, er => {
      if (er) {
        this[ONERROR](er, entry)
        fullyDone()
        return
      }

      let actions = 1
      const done = _ => {
        if (--actions === 0) {
          fullyDone()
          this[UNPEND]()
          entry.resume()
        }
      }

      if (entry.mtime && !this.noMtime) {
        actions++
        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)
      }

      if (this[DOCHOWN](entry)) {
        actions++
        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)
      }

      done()
    })
  }

  [UNSUPPORTED] (entry) {
    entry.unsupported = true
    this.warn('TAR_ENTRY_UNSUPPORTED',
      `unsupported entry type: ${entry.type}`, {entry})
    entry.resume()
  }

  [SYMLINK] (entry, done) {
    this[LINK](entry, entry.linkpath, 'symlink', done)
  }

  [HARDLINK] (entry, done) {
    const linkpath = normPath(path.resolve(this.cwd, entry.linkpath))
    this[LINK](entry, linkpath, 'link', done)
  }

  [PEND] () {
    this[PENDING]++
  }

  [UNPEND] () {
    this[PENDING]--
    this[MAYBECLOSE]()
  }

  [SKIP] (entry) {
    this[UNPEND]()
    entry.resume()
  }

  // Check if we can reuse an existing filesystem entry safely and
  // overwrite it, rather than unlinking and recreating
  // Windows doesn't report a useful nlink, so we just never reuse entries
  [ISREUSABLE] (entry, st) {
    return entry.type === 'File' &&
      !this.unlink &&
      st.isFile() &&
      st.nlink <= 1 &&
      !isWindows
  }

  // check if a thing is there, and if so, try to clobber it
  [CHECKFS] (entry) {
    this[PEND]()
    const paths = [entry.path]
    if (entry.linkpath)
      paths.push(entry.linkpath)
    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done))
  }

  [PRUNECACHE] (entry) {
    // if we are not creating a directory, and the path is in the dirCache,
    // then that means we are about to delete the directory we created
    // previously, and it is no longer going to be a directory, and neither
    // is any of its children.
    // If a symbolic link is encountered, all bets are off.  There is no
    // reasonable way to sanitize the cache in such a way we will be able to
    // avoid having filesystem collisions.  If this happens with a non-symlink
    // entry, it'll just fail to unpack, but a symlink to a directory, using an
    // 8.3 shortname or certain unicode attacks, can evade detection and lead
    // to arbitrary writes to anywhere on the system.
    if (entry.type === 'SymbolicLink')
      dropCache(this.dirCache)
    else if (entry.type !== 'Directory')
      pruneCache(this.dirCache, entry.absolute)
  }

  [CHECKFS2] (entry, fullyDone) {
    this[PRUNECACHE](entry)

    const done = er => {
      this[PRUNECACHE](entry)
      fullyDone(er)
    }

    const checkCwd = () => {
      this[MKDIR](this.cwd, this.dmode, er => {
        if (er) {
          this[ONERROR](er, entry)
          done()
          return
        }
        this[CHECKED_CWD] = true
        start()
      })
    }

    const start = () => {
      if (entry.absolute !== this.cwd) {
        const parent = normPath(path.dirname(entry.absolute))
        if (parent !== this.cwd) {
          return this[MKDIR](parent, this.dmode, er => {
            if (er) {
              this[ONERROR](er, entry)
              done()
              return
            }
            afterMakeParent()
          })
        }
      }
      afterMakeParent()
    }

    const afterMakeParent = () => {
      fs.lstat(entry.absolute, (lstatEr, st) => {
        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
          this[SKIP](entry)
          done()
          return
        }
        if (lstatEr || this[ISREUSABLE](entry, st))
          return this[MAKEFS](null, entry, done)

        if (st.isDirectory()) {
          if (entry.type === 'Directory') {
            const needChmod = !this.noChmod &&
              entry.mode &&
              (st.mode & 0o7777) !== entry.mode
            const afterChmod = er => this[MAKEFS](er, entry, done)
            if (!needChmod)
              return afterChmod()
            return fs.chmod(entry.absolute, entry.mode, afterChmod)
          }
          // Not a dir entry, have to remove it.
          // NB: the only way to end up with an entry that is the cwd
          // itself, in such a way that == does not detect, is a
          // tricky windows absolute path with UNC or 8.3 parts (and
          // preservePaths:true, or else it will have been stripped).
          // In that case, the user has opted out of path protections
          // explicitly, so if they blow away the cwd, c'est la vie.
          if (entry.absolute !== this.cwd) {
            return fs.rmdir(entry.absolute, er =>
              this[MAKEFS](er, entry, done))
          }
        }

        // not a dir, and not reusable
        // don't remove if the cwd, we want that error
        if (entry.absolute === this.cwd)
          return this[MAKEFS](null, entry, done)

        unlinkFile(entry.absolute, er =>
          this[MAKEFS](er, entry, done))
      })
    }

    if (this[CHECKED_CWD])
      start()
    else
      checkCwd()
  }

  [MAKEFS] (er, entry, done) {
    if (er) {
      this[ONERROR](er, entry)
      done()
      return
    }

    switch (entry.type) {
      case 'File':
      case 'OldFile':
      case 'ContiguousFile':
        return this[FILE](entry, done)

      case 'Link':
        return this[HARDLINK](entry, done)

      case 'SymbolicLink':
        return this[SYMLINK](entry, done)

      case 'Directory':
      case 'GNUDumpDir':
        return this[DIRECTORY](entry, done)
    }
  }

  [LINK] (entry, linkpath, link, done) {
    // XXX: get the type ('symlink' or 'junction') for windows
    fs[link](linkpath, entry.absolute, er => {
      if (er)
        this[ONERROR](er, entry)
      else {
        this[UNPEND]()
        entry.resume()
      }
      done()
    })
  }
}

const callSync = fn => {
  try {
    return [null, fn()]
  } catch (er) {
    return [er, null]
  }
}
class UnpackSync extends Unpack {
  [MAKEFS] (er, entry) {
    return super[MAKEFS](er, entry, () => {})
  }

  [CHECKFS] (entry) {
    this[PRUNECACHE](entry)

    if (!this[CHECKED_CWD]) {
      const er = this[MKDIR](this.cwd, this.dmode)
      if (er)
        return this[ONERROR](er, entry)
      this[CHECKED_CWD] = true
    }

    // don't bother to make the parent if the current entry is the cwd,
    // we've already checked it.
    if (entry.absolute !== this.cwd) {
      const parent = normPath(path.dirname(entry.absolute))
      if (parent !== this.cwd) {
        const mkParent = this[MKDIR](parent, this.dmode)
        if (mkParent)
          return this[ONERROR](mkParent, entry)
      }
    }

    const [lstatEr, st] = callSync(() => fs.lstatSync(entry.absolute))
    if (st && (this.keep || this.newer && st.mtime > entry.mtime))
      return this[SKIP](entry)

    if (lstatEr || this[ISREUSABLE](entry, st))
      return this[MAKEFS](null, entry)

    if (st.isDirectory()) {
      if (entry.type === 'Directory') {
        const needChmod = !this.noChmod &&
          entry.mode &&
          (st.mode & 0o7777) !== entry.mode
        const [er] = needChmod ? callSync(() => {
          fs.chmodSync(entry.absolute, entry.mode)
        }) : []
        return this[MAKEFS](er, entry)
      }
      // not a dir entry, have to remove it
      const [er] = callSync(() => fs.rmdirSync(entry.absolute))
      this[MAKEFS](er, entry)
    }

    // not a dir, and not reusable.
    // don't remove if it's the cwd, since we want that error.
    const [er] = entry.absolute === this.cwd ? []
      : callSync(() => unlinkFileSync(entry.absolute))
    this[MAKEFS](er, entry)
  }

  [FILE] (entry, done) {
    const mode = entry.mode & 0o7777 || this.fmode

    const oner = er => {
      let closeError
      try {
        fs.closeSync(fd)
      } catch (e) {
        closeError = e
      }
      if (er || closeError)
        this[ONERROR](er || closeError, entry)
      done()
    }

    let stream
    let fd
    try {
      fd = fs.openSync(entry.absolute, getFlag(entry.size), mode)
    } catch (er) {
      return oner(er)
    }
    const tx = this.transform ? this.transform(entry) || entry : entry
    if (tx !== entry) {
      tx.on('error', er => this[ONERROR](er, entry))
      entry.pipe(tx)
    }

    tx.on('data', chunk => {
      try {
        fs.writeSync(fd, chunk, 0, chunk.length)
      } catch (er) {
        oner(er)
      }
    })

    tx.on('end', _ => {
      let er = null
      // try both, falling futimes back to utimes
      // if either fails, handle the first error
      if (entry.mtime && !this.noMtime) {
        const atime = entry.atime || new Date()
        const mtime = entry.mtime
        try {
          fs.futimesSync(fd, atime, mtime)
        } catch (futimeser) {
          try {
            fs.utimesSync(entry.absolute, atime, mtime)
          } catch (utimeser) {
            er = futimeser
          }
        }
      }

      if (this[DOCHOWN](entry)) {
        const uid = this[UID](entry)
        const gid = this[GID](entry)

        try {
          fs.fchownSync(fd, uid, gid)
        } catch (fchowner) {
          try {
            fs.chownSync(entry.absolute, uid, gid)
          } catch (chowner) {
            er = er || fchowner
          }
        }
      }

      oner(er)
    })
  }

  [DIRECTORY] (entry, done) {
    const mode = entry.mode & 0o7777 || this.dmode
    const er = this[MKDIR](entry.absolute, mode)
    if (er) {
      this[ONERROR](er, entry)
      done()
      return
    }
    if (entry.mtime && !this.noMtime) {
      try {
        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)
      } catch (er) {}
    }
    if (this[DOCHOWN](entry)) {
      try {
        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))
      } catch (er) {}
    }
    done()
    entry.resume()
  }

  [MKDIR] (dir, mode) {
    try {
      return mkdir.sync(normPath(dir), {
        uid: this.uid,
        gid: this.gid,
        processUid: this.processUid,
        processGid: this.processGid,
        umask: this.processUmask,
        preserve: this.preservePaths,
        unlink: this.unlink,
        cache: this.dirCache,
        cwd: this.cwd,
        mode: mode
      })
    } catch (er) {
      return er
    }
  }

  [LINK] (entry, linkpath, link, done) {
    try {
      fs[link + 'Sync'](linkpath, entry.absolute)
      done()
      entry.resume()
    } catch (er) {
      return this[ONERROR](er, entry)
    }
  }
}

Unpack.Sync = UnpackSync
module.exports = Unpack


/***/ }),

/***/ 94404:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// tar -u

const hlo = __webpack_require__(95274)
const r = __webpack_require__(45923)
// just call tar.r with the filter and mtimeCache

const u = module.exports = (opt_, files, cb) => {
  const opt = hlo(opt_)

  if (!opt.file)
    throw new TypeError('file is required')

  if (opt.gzip)
    throw new TypeError('cannot append to compressed archives')

  if (!files || !Array.isArray(files) || !files.length)
    throw new TypeError('no files or directories specified')

  files = Array.from(files)

  mtimeFilter(opt)
  return r(opt, files, cb)
}

const mtimeFilter = opt => {
  const filter = opt.filter

  if (!opt.mtimeCache)
    opt.mtimeCache = new Map()

  opt.filter = filter ? (path, stat) =>
    filter(path, stat) && !(opt.mtimeCache.get(path) > stat.mtime)
    : (path, stat) => !(opt.mtimeCache.get(path) > stat.mtime)
}


/***/ }),

/***/ 85899:
/***/ ((module) => {

"use strict";

module.exports = Base => class extends Base {
  warn (code, message, data = {}) {
    if (this.file)
      data.file = this.file
    if (this.cwd)
      data.cwd = this.cwd
    data.code = message instanceof Error && message.code || code
    data.tarCode = code
    if (!this.strict && data.recoverable !== false) {
      if (message instanceof Error) {
        data = Object.assign(message, data)
        message = message.message
      }
      this.emit('warn', data.tarCode, message, data)
    } else if (message instanceof Error) {
      this.emit('error', Object.assign(message, data))
    } else
      this.emit('error', Object.assign(new Error(`${code}: ${message}`), data))
  }
}


/***/ }),

/***/ 44808:
/***/ ((module) => {

"use strict";


// When writing files on Windows, translate the characters to their
// 0xf000 higher-encoded versions.

const raw = [
  '|',
  '<',
  '>',
  '?',
  ':'
]

const win = raw.map(char =>
  String.fromCharCode(0xf000 + char.charCodeAt(0)))

const toWin = new Map(raw.map((char, i) => [char, win[i]]))
const toRaw = new Map(win.map((char, i) => [char, raw[i]]))

module.exports = {
  encode: s => raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s),
  decode: s => win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s)
}


/***/ }),

/***/ 55450:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const MiniPass = __webpack_require__(41077)
const Pax = __webpack_require__(77996)
const Header = __webpack_require__(66043)
const ReadEntry = __webpack_require__(38116)
const fs = __webpack_require__(35747)
const path = __webpack_require__(85622)
const normPath = __webpack_require__(56843)
const stripSlash = __webpack_require__(88886)

const prefixPath = (path, prefix) => {
  if (!prefix)
    return path
  path = normPath(path).replace(/^\.(\/|$)/, '')
  return stripSlash(prefix) + '/' + path
}

const maxReadSize = 16 * 1024 * 1024
const PROCESS = Symbol('process')
const FILE = Symbol('file')
const DIRECTORY = Symbol('directory')
const SYMLINK = Symbol('symlink')
const HARDLINK = Symbol('hardlink')
const HEADER = Symbol('header')
const READ = Symbol('read')
const LSTAT = Symbol('lstat')
const ONLSTAT = Symbol('onlstat')
const ONREAD = Symbol('onread')
const ONREADLINK = Symbol('onreadlink')
const OPENFILE = Symbol('openfile')
const ONOPENFILE = Symbol('onopenfile')
const CLOSE = Symbol('close')
const MODE = Symbol('mode')
const AWAITDRAIN = Symbol('awaitDrain')
const ONDRAIN = Symbol('ondrain')
const PREFIX = Symbol('prefix')
const HAD_ERROR = Symbol('hadError')
const warner = __webpack_require__(85899)
const winchars = __webpack_require__(44808)
const stripAbsolutePath = __webpack_require__(37111)

const modeFix = __webpack_require__(88371)

const WriteEntry = warner(class WriteEntry extends MiniPass {
  constructor (p, opt) {
    opt = opt || {}
    super(opt)
    if (typeof p !== 'string')
      throw new TypeError('path is required')
    this.path = normPath(p)
    // suppress atime, ctime, uid, gid, uname, gname
    this.portable = !!opt.portable
    // until node has builtin pwnam functions, this'll have to do
    this.myuid = process.getuid && process.getuid() || 0
    this.myuser = process.env.USER || ''
    this.maxReadSize = opt.maxReadSize || maxReadSize
    this.linkCache = opt.linkCache || new Map()
    this.statCache = opt.statCache || new Map()
    this.preservePaths = !!opt.preservePaths
    this.cwd = normPath(opt.cwd || process.cwd())
    this.strict = !!opt.strict
    this.noPax = !!opt.noPax
    this.noMtime = !!opt.noMtime
    this.mtime = opt.mtime || null
    this.prefix = opt.prefix ? normPath(opt.prefix) : null

    this.fd = null
    this.blockLen = null
    this.blockRemain = null
    this.buf = null
    this.offset = null
    this.length = null
    this.pos = null
    this.remain = null

    if (typeof opt.onwarn === 'function')
      this.on('warn', opt.onwarn)

    let pathWarn = false
    if (!this.preservePaths) {
      const [root, stripped] = stripAbsolutePath(this.path)
      if (root) {
        this.path = stripped
        pathWarn = root
      }
    }

    this.win32 = !!opt.win32 || process.platform === 'win32'
    if (this.win32) {
      // force the \ to / normalization, since we might not *actually*
      // be on windows, but want \ to be considered a path separator.
      this.path = winchars.decode(this.path.replace(/\\/g, '/'))
      p = p.replace(/\\/g, '/')
    }

    this.absolute = normPath(opt.absolute || path.resolve(this.cwd, p))

    if (this.path === '')
      this.path = './'

    if (pathWarn) {
      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {
        entry: this,
        path: pathWarn + this.path,
      })
    }

    if (this.statCache.has(this.absolute))
      this[ONLSTAT](this.statCache.get(this.absolute))
    else
      this[LSTAT]()
  }

  emit (ev, ...data) {
    if (ev === 'error')
      this[HAD_ERROR] = true
    return super.emit(ev, ...data)
  }

  [LSTAT] () {
    fs.lstat(this.absolute, (er, stat) => {
      if (er)
        return this.emit('error', er)
      this[ONLSTAT](stat)
    })
  }

  [ONLSTAT] (stat) {
    this.statCache.set(this.absolute, stat)
    this.stat = stat
    if (!stat.isFile())
      stat.size = 0
    this.type = getType(stat)
    this.emit('stat', stat)
    this[PROCESS]()
  }

  [PROCESS] () {
    switch (this.type) {
      case 'File': return this[FILE]()
      case 'Directory': return this[DIRECTORY]()
      case 'SymbolicLink': return this[SYMLINK]()
      // unsupported types are ignored.
      default: return this.end()
    }
  }

  [MODE] (mode) {
    return modeFix(mode, this.type === 'Directory', this.portable)
  }

  [PREFIX] (path) {
    return prefixPath(path, this.prefix)
  }

  [HEADER] () {
    if (this.type === 'Directory' && this.portable)
      this.noMtime = true

    this.header = new Header({
      path: this[PREFIX](this.path),
      // only apply the prefix to hard links.
      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)
      : this.linkpath,
      // only the permissions and setuid/setgid/sticky bitflags
      // not the higher-order bits that specify file type
      mode: this[MODE](this.stat.mode),
      uid: this.portable ? null : this.stat.uid,
      gid: this.portable ? null : this.stat.gid,
      size: this.stat.size,
      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
      type: this.type,
      uname: this.portable ? null :
        this.stat.uid === this.myuid ? this.myuser : '',
      atime: this.portable ? null : this.stat.atime,
      ctime: this.portable ? null : this.stat.ctime
    })

    if (this.header.encode() && !this.noPax) {
      super.write(new Pax({
        atime: this.portable ? null : this.header.atime,
        ctime: this.portable ? null : this.header.ctime,
        gid: this.portable ? null : this.header.gid,
        mtime: this.noMtime ? null : this.mtime || this.header.mtime,
        path: this[PREFIX](this.path),
        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)
        : this.linkpath,
        size: this.header.size,
        uid: this.portable ? null : this.header.uid,
        uname: this.portable ? null : this.header.uname,
        dev: this.portable ? null : this.stat.dev,
        ino: this.portable ? null : this.stat.ino,
        nlink: this.portable ? null : this.stat.nlink
      }).encode())
    }
    super.write(this.header.block)
  }

  [DIRECTORY] () {
    if (this.path.substr(-1) !== '/')
      this.path += '/'
    this.stat.size = 0
    this[HEADER]()
    this.end()
  }

  [SYMLINK] () {
    fs.readlink(this.absolute, (er, linkpath) => {
      if (er)
        return this.emit('error', er)
      this[ONREADLINK](linkpath)
    })
  }

  [ONREADLINK] (linkpath) {
    this.linkpath = normPath(linkpath)
    this[HEADER]()
    this.end()
  }

  [HARDLINK] (linkpath) {
    this.type = 'Link'
    this.linkpath = normPath(path.relative(this.cwd, linkpath))
    this.stat.size = 0
    this[HEADER]()
    this.end()
  }

  [FILE] () {
    if (this.stat.nlink > 1) {
      const linkKey = this.stat.dev + ':' + this.stat.ino
      if (this.linkCache.has(linkKey)) {
        const linkpath = this.linkCache.get(linkKey)
        if (linkpath.indexOf(this.cwd) === 0)
          return this[HARDLINK](linkpath)
      }
      this.linkCache.set(linkKey, this.absolute)
    }

    this[HEADER]()
    if (this.stat.size === 0)
      return this.end()

    this[OPENFILE]()
  }

  [OPENFILE] () {
    fs.open(this.absolute, 'r', (er, fd) => {
      if (er)
        return this.emit('error', er)
      this[ONOPENFILE](fd)
    })
  }

  [ONOPENFILE] (fd) {
    this.fd = fd
    if (this[HAD_ERROR])
      return this[CLOSE]()

    this.blockLen = 512 * Math.ceil(this.stat.size / 512)
    this.blockRemain = this.blockLen
    const bufLen = Math.min(this.blockLen, this.maxReadSize)
    this.buf = Buffer.allocUnsafe(bufLen)
    this.offset = 0
    this.pos = 0
    this.remain = this.stat.size
    this.length = this.buf.length
    this[READ]()
  }

  [READ] () {
    const { fd, buf, offset, length, pos } = this
    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {
      if (er) {
        // ignoring the error from close(2) is a bad practice, but at
        // this point we already have an error, don't need another one
        return this[CLOSE](() => this.emit('error', er))
      }
      this[ONREAD](bytesRead)
    })
  }

  [CLOSE] (cb) {
    fs.close(this.fd, cb)
  }

  [ONREAD] (bytesRead) {
    if (bytesRead <= 0 && this.remain > 0) {
      const er = new Error('encountered unexpected EOF')
      er.path = this.absolute
      er.syscall = 'read'
      er.code = 'EOF'
      return this[CLOSE](() => this.emit('error', er))
    }

    if (bytesRead > this.remain) {
      const er = new Error('did not encounter expected EOF')
      er.path = this.absolute
      er.syscall = 'read'
      er.code = 'EOF'
      return this[CLOSE](() => this.emit('error', er))
    }

    // null out the rest of the buffer, if we could fit the block padding
    // at the end of this loop, we've incremented bytesRead and this.remain
    // to be incremented up to the blockRemain level, as if we had expected
    // to get a null-padded file, and read it until the end.  then we will
    // decrement both remain and blockRemain by bytesRead, and know that we
    // reached the expected EOF, without any null buffer to append.
    if (bytesRead === this.remain) {
      for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {
        this.buf[i + this.offset] = 0
        bytesRead++
        this.remain++
      }
    }

    const writeBuf = this.offset === 0 && bytesRead === this.buf.length ?
      this.buf : this.buf.slice(this.offset, this.offset + bytesRead)

    const flushed = this.write(writeBuf)
    if (!flushed)
      this[AWAITDRAIN](() => this[ONDRAIN]())
    else
      this[ONDRAIN]()
  }

  [AWAITDRAIN] (cb) {
    this.once('drain', cb)
  }

  write (writeBuf) {
    if (this.blockRemain < writeBuf.length) {
      const er = new Error('writing more data than expected')
      er.path = this.absolute
      return this.emit('error', er)
    }
    this.remain -= writeBuf.length
    this.blockRemain -= writeBuf.length
    this.pos += writeBuf.length
    this.offset += writeBuf.length
    return super.write(writeBuf)
  }

  [ONDRAIN] () {
    if (!this.remain) {
      if (this.blockRemain)
        super.write(Buffer.alloc(this.blockRemain))
      return this[CLOSE](er => er ? this.emit('error', er) : this.end())
    }

    if (this.offset >= this.length) {
      // if we only have a smaller bit left to read, alloc a smaller buffer
      // otherwise, keep it the same length it was before.
      this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length))
      this.offset = 0
    }
    this.length = this.buf.length - this.offset
    this[READ]()
  }
})

class WriteEntrySync extends WriteEntry {
  constructor (path, opt) {
    super(path, opt)
  }

  [LSTAT] () {
    this[ONLSTAT](fs.lstatSync(this.absolute))
  }

  [SYMLINK] () {
    this[ONREADLINK](fs.readlinkSync(this.absolute))
  }

  [OPENFILE] () {
    this[ONOPENFILE](fs.openSync(this.absolute, 'r'))
  }

  [READ] () {
    let threw = true
    try {
      const { fd, buf, offset, length, pos } = this
      const bytesRead = fs.readSync(fd, buf, offset, length, pos)
      this[ONREAD](bytesRead)
      threw = false
    } finally {
      // ignoring the error from close(2) is a bad practice, but at
      // this point we already have an error, don't need another one
      if (threw) {
        try {
          this[CLOSE](() => {})
        } catch (er) {}
      }
    }
  }

  [AWAITDRAIN] (cb) {
    cb()
  }

  [CLOSE] (cb) {
    fs.closeSync(this.fd)
    cb()
  }
}

const WriteEntryTar = warner(class WriteEntryTar extends MiniPass {
  constructor (readEntry, opt) {
    opt = opt || {}
    super(opt)
    this.preservePaths = !!opt.preservePaths
    this.portable = !!opt.portable
    this.strict = !!opt.strict
    this.noPax = !!opt.noPax
    this.noMtime = !!opt.noMtime

    this.readEntry = readEntry
    this.type = readEntry.type
    if (this.type === 'Directory' && this.portable)
      this.noMtime = true

    this.prefix = opt.prefix || null

    this.path = normPath(readEntry.path)
    this.mode = this[MODE](readEntry.mode)
    this.uid = this.portable ? null : readEntry.uid
    this.gid = this.portable ? null : readEntry.gid
    this.uname = this.portable ? null : readEntry.uname
    this.gname = this.portable ? null : readEntry.gname
    this.size = readEntry.size
    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime
    this.atime = this.portable ? null : readEntry.atime
    this.ctime = this.portable ? null : readEntry.ctime
    this.linkpath = normPath(readEntry.linkpath)

    if (typeof opt.onwarn === 'function')
      this.on('warn', opt.onwarn)

    let pathWarn = false
    if (!this.preservePaths) {
      const [root, stripped] = stripAbsolutePath(this.path)
      if (root) {
        this.path = stripped
        pathWarn = root
      }
    }

    this.remain = readEntry.size
    this.blockRemain = readEntry.startBlockSize

    this.header = new Header({
      path: this[PREFIX](this.path),
      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)
      : this.linkpath,
      // only the permissions and setuid/setgid/sticky bitflags
      // not the higher-order bits that specify file type
      mode: this.mode,
      uid: this.portable ? null : this.uid,
      gid: this.portable ? null : this.gid,
      size: this.size,
      mtime: this.noMtime ? null : this.mtime,
      type: this.type,
      uname: this.portable ? null : this.uname,
      atime: this.portable ? null : this.atime,
      ctime: this.portable ? null : this.ctime
    })

    if (pathWarn) {
      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {
        entry: this,
        path: pathWarn + this.path,
      })
    }

    if (this.header.encode() && !this.noPax)
      super.write(new Pax({
        atime: this.portable ? null : this.atime,
        ctime: this.portable ? null : this.ctime,
        gid: this.portable ? null : this.gid,
        mtime: this.noMtime ? null : this.mtime,
        path: this[PREFIX](this.path),
        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)
        : this.linkpath,
        size: this.size,
        uid: this.portable ? null : this.uid,
        uname: this.portable ? null : this.uname,
        dev: this.portable ? null : this.readEntry.dev,
        ino: this.portable ? null : this.readEntry.ino,
        nlink: this.portable ? null : this.readEntry.nlink
      }).encode())

    super.write(this.header.block)
    readEntry.pipe(this)
  }

  [PREFIX] (path) {
    return prefixPath(path, this.prefix)
  }

  [MODE] (mode) {
    return modeFix(mode, this.type === 'Directory', this.portable)
  }

  write (data) {
    const writeLen = data.length
    if (writeLen > this.blockRemain)
      throw new Error('writing more to entry than is appropriate')
    this.blockRemain -= writeLen
    return super.write(data)
  }

  end () {
    if (this.blockRemain)
      super.write(Buffer.alloc(this.blockRemain))
    return super.end()
  }
})

WriteEntry.Sync = WriteEntrySync
WriteEntry.Tar = WriteEntryTar

const getType = stat =>
  stat.isFile() ? 'File'
  : stat.isDirectory() ? 'Directory'
  : stat.isSymbolicLink() ? 'SymbolicLink'
  : 'Unsupported'

module.exports = WriteEntry


/***/ }),

/***/ 47251:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var path = __webpack_require__(85622);
var fs = __webpack_require__(35747);
var _0777 = parseInt('0777', 8);

module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

function mkdirP (p, opts, f, made) {
    if (typeof opts === 'function') {
        f = opts;
        opts = {};
    }
    else if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777
    }
    if (!made) made = null;
    
    var cb = f || function () {};
    p = path.resolve(p);
    
    xfs.mkdir(p, mode, function (er) {
        if (!er) {
            made = made || p;
            return cb(null, made);
        }
        switch (er.code) {
            case 'ENOENT':
                if (path.dirname(p) === p) return cb(er);
                mkdirP(path.dirname(p), opts, function (er, made) {
                    if (er) cb(er, made);
                    else mkdirP(p, opts, cb, made);
                });
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                xfs.stat(p, function (er2, stat) {
                    // if the stat fails, then that's super weird.
                    // let the original error be the failure reason.
                    if (er2 || !stat.isDirectory()) cb(er, made)
                    else cb(null, made);
                });
                break;
        }
    });
}

mkdirP.sync = function sync (p, opts, made) {
    if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777
    }
    if (!made) made = null;

    p = path.resolve(p);

    try {
        xfs.mkdirSync(p, mode);
        made = made || p;
    }
    catch (err0) {
        switch (err0.code) {
            case 'ENOENT' :
                made = sync(path.dirname(p), opts, made);
                sync(p, opts, made);
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                var stat;
                try {
                    stat = xfs.statSync(p);
                }
                catch (err1) {
                    throw err0;
                }
                if (!stat.isDirectory()) throw err0;
                break;
        }
    }

    return made;
};


/***/ }),

/***/ 4534:
/***/ (function(__unused_webpack_module, exports) {

/****
 * The MIT License
 *
 * Copyright (c) 2015 Marco Ziccardi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 ****/
(function (global, factory) {
  if (typeof define === 'function' && define.amd) {
    define('timsort', ['exports'], factory);
  } else if (true) {
    factory(exports);
  } else { var mod; }
})(this, function (exports) {
  'use strict';

  exports.__esModule = true;
  exports.sort = sort;

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }

  var DEFAULT_MIN_MERGE = 32;

  var DEFAULT_MIN_GALLOPING = 7;

  var DEFAULT_TMP_STORAGE_LENGTH = 256;

  var POWERS_OF_TEN = [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];

  function log10(x) {
    if (x < 1e5) {
      if (x < 1e2) {
        return x < 1e1 ? 0 : 1;
      }

      if (x < 1e4) {
        return x < 1e3 ? 2 : 3;
      }

      return 4;
    }

    if (x < 1e7) {
      return x < 1e6 ? 5 : 6;
    }

    if (x < 1e9) {
      return x < 1e8 ? 7 : 8;
    }

    return 9;
  }

  function alphabeticalCompare(a, b) {
    if (a === b) {
      return 0;
    }

    if (~ ~a === a && ~ ~b === b) {
      if (a === 0 || b === 0) {
        return a < b ? -1 : 1;
      }

      if (a < 0 || b < 0) {
        if (b >= 0) {
          return -1;
        }

        if (a >= 0) {
          return 1;
        }

        a = -a;
        b = -b;
      }

      var al = log10(a);
      var bl = log10(b);

      var t = 0;

      if (al < bl) {
        a *= POWERS_OF_TEN[bl - al - 1];
        b /= 10;
        t = -1;
      } else if (al > bl) {
        b *= POWERS_OF_TEN[al - bl - 1];
        a /= 10;
        t = 1;
      }

      if (a === b) {
        return t;
      }

      return a < b ? -1 : 1;
    }

    var aStr = String(a);
    var bStr = String(b);

    if (aStr === bStr) {
      return 0;
    }

    return aStr < bStr ? -1 : 1;
  }

  function minRunLength(n) {
    var r = 0;

    while (n >= DEFAULT_MIN_MERGE) {
      r |= n & 1;
      n >>= 1;
    }

    return n + r;
  }

  function makeAscendingRun(array, lo, hi, compare) {
    var runHi = lo + 1;

    if (runHi === hi) {
      return 1;
    }

    if (compare(array[runHi++], array[lo]) < 0) {
      while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
        runHi++;
      }

      reverseRun(array, lo, runHi);
    } else {
      while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
        runHi++;
      }
    }

    return runHi - lo;
  }

  function reverseRun(array, lo, hi) {
    hi--;

    while (lo < hi) {
      var t = array[lo];
      array[lo++] = array[hi];
      array[hi--] = t;
    }
  }

  function binaryInsertionSort(array, lo, hi, start, compare) {
    if (start === lo) {
      start++;
    }

    for (; start < hi; start++) {
      var pivot = array[start];

      var left = lo;
      var right = start;

      while (left < right) {
        var mid = left + right >>> 1;

        if (compare(pivot, array[mid]) < 0) {
          right = mid;
        } else {
          left = mid + 1;
        }
      }

      var n = start - left;

      switch (n) {
        case 3:
          array[left + 3] = array[left + 2];

        case 2:
          array[left + 2] = array[left + 1];

        case 1:
          array[left + 1] = array[left];
          break;
        default:
          while (n > 0) {
            array[left + n] = array[left + n - 1];
            n--;
          }
      }

      array[left] = pivot;
    }
  }

  function gallopLeft(value, array, start, length, hint, compare) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;

    if (compare(value, array[start + hint]) > 0) {
      maxOffset = length - hint;

      while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;

        if (offset <= 0) {
          offset = maxOffset;
        }
      }

      if (offset > maxOffset) {
        offset = maxOffset;
      }

      lastOffset += hint;
      offset += hint;
    } else {
      maxOffset = hint + 1;
      while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;

        if (offset <= 0) {
          offset = maxOffset;
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset;
      }

      var tmp = lastOffset;
      lastOffset = hint - offset;
      offset = hint - tmp;
    }

    lastOffset++;
    while (lastOffset < offset) {
      var m = lastOffset + (offset - lastOffset >>> 1);

      if (compare(value, array[start + m]) > 0) {
        lastOffset = m + 1;
      } else {
        offset = m;
      }
    }
    return offset;
  }

  function gallopRight(value, array, start, length, hint, compare) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;

    if (compare(value, array[start + hint]) < 0) {
      maxOffset = hint + 1;

      while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;

        if (offset <= 0) {
          offset = maxOffset;
        }
      }

      if (offset > maxOffset) {
        offset = maxOffset;
      }

      var tmp = lastOffset;
      lastOffset = hint - offset;
      offset = hint - tmp;
    } else {
      maxOffset = length - hint;

      while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;

        if (offset <= 0) {
          offset = maxOffset;
        }
      }

      if (offset > maxOffset) {
        offset = maxOffset;
      }

      lastOffset += hint;
      offset += hint;
    }

    lastOffset++;

    while (lastOffset < offset) {
      var m = lastOffset + (offset - lastOffset >>> 1);

      if (compare(value, array[start + m]) < 0) {
        offset = m;
      } else {
        lastOffset = m + 1;
      }
    }

    return offset;
  }

  var TimSort = (function () {
    function TimSort(array, compare) {
      _classCallCheck(this, TimSort);

      this.array = null;
      this.compare = null;
      this.minGallop = DEFAULT_MIN_GALLOPING;
      this.length = 0;
      this.tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
      this.stackLength = 0;
      this.runStart = null;
      this.runLength = null;
      this.stackSize = 0;

      this.array = array;
      this.compare = compare;

      this.length = array.length;

      if (this.length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
        this.tmpStorageLength = this.length >>> 1;
      }

      this.tmp = new Array(this.tmpStorageLength);

      this.stackLength = this.length < 120 ? 5 : this.length < 1542 ? 10 : this.length < 119151 ? 19 : 40;

      this.runStart = new Array(this.stackLength);
      this.runLength = new Array(this.stackLength);
    }

    TimSort.prototype.pushRun = function pushRun(runStart, runLength) {
      this.runStart[this.stackSize] = runStart;
      this.runLength[this.stackSize] = runLength;
      this.stackSize += 1;
    };

    TimSort.prototype.mergeRuns = function mergeRuns() {
      while (this.stackSize > 1) {
        var n = this.stackSize - 2;

        if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) {

          if (this.runLength[n - 1] < this.runLength[n + 1]) {
            n--;
          }
        } else if (this.runLength[n] > this.runLength[n + 1]) {
          break;
        }
        this.mergeAt(n);
      }
    };

    TimSort.prototype.forceMergeRuns = function forceMergeRuns() {
      while (this.stackSize > 1) {
        var n = this.stackSize - 2;

        if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {
          n--;
        }

        this.mergeAt(n);
      }
    };

    TimSort.prototype.mergeAt = function mergeAt(i) {
      var compare = this.compare;
      var array = this.array;

      var start1 = this.runStart[i];
      var length1 = this.runLength[i];
      var start2 = this.runStart[i + 1];
      var length2 = this.runLength[i + 1];

      this.runLength[i] = length1 + length2;

      if (i === this.stackSize - 3) {
        this.runStart[i + 1] = this.runStart[i + 2];
        this.runLength[i + 1] = this.runLength[i + 2];
      }

      this.stackSize--;

      var k = gallopRight(array[start2], array, start1, length1, 0, compare);
      start1 += k;
      length1 -= k;

      if (length1 === 0) {
        return;
      }

      length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);

      if (length2 === 0) {
        return;
      }

      if (length1 <= length2) {
        this.mergeLow(start1, length1, start2, length2);
      } else {
        this.mergeHigh(start1, length1, start2, length2);
      }
    };

    TimSort.prototype.mergeLow = function mergeLow(start1, length1, start2, length2) {

      var compare = this.compare;
      var array = this.array;
      var tmp = this.tmp;
      var i = 0;

      for (i = 0; i < length1; i++) {
        tmp[i] = array[start1 + i];
      }

      var cursor1 = 0;
      var cursor2 = start2;
      var dest = start1;

      array[dest++] = array[cursor2++];

      if (--length2 === 0) {
        for (i = 0; i < length1; i++) {
          array[dest + i] = tmp[cursor1 + i];
        }
        return;
      }

      if (length1 === 1) {
        for (i = 0; i < length2; i++) {
          array[dest + i] = array[cursor2 + i];
        }
        array[dest + length2] = tmp[cursor1];
        return;
      }

      var minGallop = this.minGallop;

      while (true) {
        var count1 = 0;
        var count2 = 0;
        var exit = false;

        do {
          if (compare(array[cursor2], tmp[cursor1]) < 0) {
            array[dest++] = array[cursor2++];
            count2++;
            count1 = 0;

            if (--length2 === 0) {
              exit = true;
              break;
            }
          } else {
            array[dest++] = tmp[cursor1++];
            count1++;
            count2 = 0;
            if (--length1 === 1) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count2) < minGallop);

        if (exit) {
          break;
        }

        do {
          count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);

          if (count1 !== 0) {
            for (i = 0; i < count1; i++) {
              array[dest + i] = tmp[cursor1 + i];
            }

            dest += count1;
            cursor1 += count1;
            length1 -= count1;
            if (length1 <= 1) {
              exit = true;
              break;
            }
          }

          array[dest++] = array[cursor2++];

          if (--length2 === 0) {
            exit = true;
            break;
          }

          count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);

          if (count2 !== 0) {
            for (i = 0; i < count2; i++) {
              array[dest + i] = array[cursor2 + i];
            }

            dest += count2;
            cursor2 += count2;
            length2 -= count2;

            if (length2 === 0) {
              exit = true;
              break;
            }
          }
          array[dest++] = tmp[cursor1++];

          if (--length1 === 1) {
            exit = true;
            break;
          }

          minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

        if (exit) {
          break;
        }

        if (minGallop < 0) {
          minGallop = 0;
        }

        minGallop += 2;
      }

      this.minGallop = minGallop;

      if (minGallop < 1) {
        this.minGallop = 1;
      }

      if (length1 === 1) {
        for (i = 0; i < length2; i++) {
          array[dest + i] = array[cursor2 + i];
        }
        array[dest + length2] = tmp[cursor1];
      } else if (length1 === 0) {
        throw new Error('mergeLow preconditions were not respected');
      } else {
        for (i = 0; i < length1; i++) {
          array[dest + i] = tmp[cursor1 + i];
        }
      }
    };

    TimSort.prototype.mergeHigh = function mergeHigh(start1, length1, start2, length2) {
      var compare = this.compare;
      var array = this.array;
      var tmp = this.tmp;
      var i = 0;

      for (i = 0; i < length2; i++) {
        tmp[i] = array[start2 + i];
      }

      var cursor1 = start1 + length1 - 1;
      var cursor2 = length2 - 1;
      var dest = start2 + length2 - 1;
      var customCursor = 0;
      var customDest = 0;

      array[dest--] = array[cursor1--];

      if (--length1 === 0) {
        customCursor = dest - (length2 - 1);

        for (i = 0; i < length2; i++) {
          array[customCursor + i] = tmp[i];
        }

        return;
      }

      if (length2 === 1) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;

        for (i = length1 - 1; i >= 0; i--) {
          array[customDest + i] = array[customCursor + i];
        }

        array[dest] = tmp[cursor2];
        return;
      }

      var minGallop = this.minGallop;

      while (true) {
        var count1 = 0;
        var count2 = 0;
        var exit = false;

        do {
          if (compare(tmp[cursor2], array[cursor1]) < 0) {
            array[dest--] = array[cursor1--];
            count1++;
            count2 = 0;
            if (--length1 === 0) {
              exit = true;
              break;
            }
          } else {
            array[dest--] = tmp[cursor2--];
            count2++;
            count1 = 0;
            if (--length2 === 1) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count2) < minGallop);

        if (exit) {
          break;
        }

        do {
          count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);

          if (count1 !== 0) {
            dest -= count1;
            cursor1 -= count1;
            length1 -= count1;
            customDest = dest + 1;
            customCursor = cursor1 + 1;

            for (i = count1 - 1; i >= 0; i--) {
              array[customDest + i] = array[customCursor + i];
            }

            if (length1 === 0) {
              exit = true;
              break;
            }
          }

          array[dest--] = tmp[cursor2--];

          if (--length2 === 1) {
            exit = true;
            break;
          }

          count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);

          if (count2 !== 0) {
            dest -= count2;
            cursor2 -= count2;
            length2 -= count2;
            customDest = dest + 1;
            customCursor = cursor2 + 1;

            for (i = 0; i < count2; i++) {
              array[customDest + i] = tmp[customCursor + i];
            }

            if (length2 <= 1) {
              exit = true;
              break;
            }
          }

          array[dest--] = array[cursor1--];

          if (--length1 === 0) {
            exit = true;
            break;
          }

          minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

        if (exit) {
          break;
        }

        if (minGallop < 0) {
          minGallop = 0;
        }

        minGallop += 2;
      }

      this.minGallop = minGallop;

      if (minGallop < 1) {
        this.minGallop = 1;
      }

      if (length2 === 1) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;

        for (i = length1 - 1; i >= 0; i--) {
          array[customDest + i] = array[customCursor + i];
        }

        array[dest] = tmp[cursor2];
      } else if (length2 === 0) {
        throw new Error('mergeHigh preconditions were not respected');
      } else {
        customCursor = dest - (length2 - 1);
        for (i = 0; i < length2; i++) {
          array[customCursor + i] = tmp[i];
        }
      }
    };

    return TimSort;
  })();

  function sort(array, compare, lo, hi) {
    if (!Array.isArray(array)) {
      throw new TypeError('Can only sort arrays');
    }

    if (!compare) {
      compare = alphabeticalCompare;
    } else if (typeof compare !== 'function') {
      hi = lo;
      lo = compare;
      compare = alphabeticalCompare;
    }

    if (!lo) {
      lo = 0;
    }
    if (!hi) {
      hi = array.length;
    }

    var remaining = hi - lo;

    if (remaining < 2) {
      return;
    }

    var runLength = 0;

    if (remaining < DEFAULT_MIN_MERGE) {
      runLength = makeAscendingRun(array, lo, hi, compare);
      binaryInsertionSort(array, lo, hi, lo + runLength, compare);
      return;
    }

    var ts = new TimSort(array, compare);

    var minRun = minRunLength(remaining);

    do {
      runLength = makeAscendingRun(array, lo, hi, compare);
      if (runLength < minRun) {
        var force = remaining;
        if (force > minRun) {
          force = minRun;
        }

        binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
        runLength = force;
      }

      ts.pushRun(lo, runLength);
      ts.mergeRuns();

      remaining -= runLength;
      lo += runLength;
    } while (remaining !== 0);

    ts.forceMergeRuns();
  }
});


/***/ }),

/***/ 46655:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(4534);

/***/ }),

/***/ 76979:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { readdir: _readdir, readdirSync } = __webpack_require__(35747)
const { platform } = __webpack_require__(12087)
const { isAbsolute, normalize } = __webpack_require__(85622)
const { promisify: pify } = __webpack_require__(31669)

const readdir = pify(_readdir)
const isWindows = platform() === 'win32'
const delimiter = isWindows ? '\\' : '/'

module.exports = {
  trueCasePath: _trueCasePath({ sync: false }),
  trueCasePathSync: _trueCasePath({ sync: true })
}

function getRelevantFilePathSegments(filePath) {
  return filePath.split(delimiter).filter((s) => s !== '')
}

function escapeString(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

function matchCaseInsensitive(fileOrDirectory, directoryContents, filePath) {
  const caseInsensitiveRegex = new RegExp(
    `^${escapeString(fileOrDirectory)}$`,
    'i'
  )
  for (const file of directoryContents) {
    if (caseInsensitiveRegex.test(file)) return file
  }
  throw new Error(
    `[true-case-path]: Called with ${filePath}, but no matching file exists`
  )
}

function _trueCasePath({ sync }) {
  return (filePath, basePath) => {
    if (basePath) {
      if (!isAbsolute(basePath)) {
        throw new Error(
          `[true-case-path]: basePath argument must be absolute. Received "${basePath}"`
        )
      }
      basePath = normalize(basePath)
    }
    filePath = normalize(filePath)
    const segments = getRelevantFilePathSegments(filePath)
    if (isAbsolute(filePath)) {
      if (basePath) {
        throw new Error(
          '[true-case-path]: filePath must be relative when used with basePath'
        )
      }
      basePath = isWindows
        ? segments.shift().toUpperCase() // drive letter
        : ''
    } else if (!basePath) {
      basePath = process.cwd()
    }
    return sync
      ? iterateSync(basePath, filePath, segments)
      : iterateAsync(basePath, filePath, segments)
  }
}

function iterateSync(basePath, filePath, segments) {
  return segments.reduce(
    (realPath, fileOrDirectory) =>
      realPath +
      delimiter +
      matchCaseInsensitive(
        fileOrDirectory,
        readdirSync(realPath + delimiter),
        filePath
      ),
    basePath
  )
}

async function iterateAsync(basePath, filePath, segments) {
  return await segments.reduce(
    async (realPathPromise, fileOrDirectory) =>
      (await realPathPromise) +
      delimiter +
      matchCaseInsensitive(
        fileOrDirectory,
        await readdir((await realPathPromise) + delimiter),
        filePath
      ),
    basePath
  )
}


/***/ }),

/***/ 74294:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(54219);


/***/ }),

/***/ 54219:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var net = __webpack_require__(11631);
var tls = __webpack_require__(4016);
var http = __webpack_require__(15876);
var https = __webpack_require__(57211);
var events = __webpack_require__(28614);
var assert = __webpack_require__(42357);
var util = __webpack_require__(31669);


exports.httpOverHttp = httpOverHttp;
exports.httpsOverHttp = httpsOverHttp;
exports.httpOverHttps = httpOverHttps;
exports.httpsOverHttps = httpsOverHttps;


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  return agent;
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  return agent;
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}


function TunnelingAgent(options) {
  var self = this;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];

  self.on('free', function onFree(socket, host, port, localAddress) {
    var options = toOptions(host, port, localAddress);
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i];
      if (pending.host === options.host && pending.port === options.port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return;
      }
    }
    socket.destroy();
    self.removeSocket(socket);
  });
}
util.inherits(TunnelingAgent, events.EventEmitter);

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
  var self = this;
  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push(options);
    return;
  }

  // If we are under maxSockets create a new one.
  self.createSocket(options, function(socket) {
    socket.on('free', onFree);
    socket.on('close', onCloseOrRemove);
    socket.on('agentRemove', onCloseOrRemove);
    req.onSocket(socket);

    function onFree() {
      self.emit('free', socket, options);
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket);
      socket.removeListener('free', onFree);
      socket.removeListener('close', onCloseOrRemove);
      socket.removeListener('agentRemove', onCloseOrRemove);
    }
  });
};

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this;
  var placeholder = {};
  self.sockets.push(placeholder);

  var connectOptions = mergeOptions({}, self.proxyOptions, {
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false,
    headers: {
      host: options.host + ':' + options.port
    }
  });
  if (options.localAddress) {
    connectOptions.localAddress = options.localAddress;
  }
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64');
  }

  debug('making CONNECT request');
  var connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false; // for v0.6
  connectReq.once('response', onResponse); // for v0.6
  connectReq.once('upgrade', onUpgrade);   // for v0.6
  connectReq.once('connect', onConnect);   // for v0.7 or later
  connectReq.once('error', onError);
  connectReq.end();

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true;
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head);
    });
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    if (res.statusCode !== 200) {
      debug('tunneling socket could not be established, statusCode=%d',
        res.statusCode);
      socket.destroy();
      var error = new Error('tunneling socket could not be established, ' +
        'statusCode=' + res.statusCode);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    if (head.length > 0) {
      debug('got illegal response body from proxy');
      socket.destroy();
      var error = new Error('got illegal response body from proxy');
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    debug('tunneling connection has established');
    self.sockets[self.sockets.indexOf(placeholder)] = socket;
    return cb(socket);
  }

  function onError(cause) {
    connectReq.removeAllListeners();

    debug('tunneling socket could not be established, cause=%s\n',
          cause.message, cause.stack);
    var error = new Error('tunneling socket could not be established, ' +
                          'cause=' + cause.message);
    error.code = 'ECONNRESET';
    options.request.emit('error', error);
    self.removeSocket(placeholder);
  }
};

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) {
    return;
  }
  this.sockets.splice(pos, 1);

  var pending = this.requests.shift();
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket);
    });
  }
};

function createSecureSocket(options, cb) {
  var self = this;
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    var hostHeader = options.request.getHeader('host');
    var tlsOptions = mergeOptions({}, self.options, {
      socket: socket,
      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
    });

    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, tlsOptions);
    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}


function toOptions(host, port, localAddress) {
  if (typeof host === 'string') { // since v0.10
    return {
      host: host,
      port: port,
      localAddress: localAddress
    };
  }
  return host; // for v0.11 or later
}

function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides);
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j];
        if (overrides[k] !== undefined) {
          target[k] = overrides[k];
        }
      }
    }
  }
  return target;
}


var debug;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0];
    } else {
      args.unshift('TUNNEL:');
    }
    console.error.apply(console, args);
  }
} else {
  debug = function() {};
}
exports.debug = debug; // for test


/***/ }),

/***/ 45030:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }

  if (typeof process === "object" && "version" in process) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }

  return "<environment undetectable>";
}

exports.getUserAgent = getUserAgent;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 9046:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.E = function (fn) {
  return Object.defineProperty(function () {
    if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
    else {
      return new Promise((resolve, reject) => {
        arguments[arguments.length] = (err, res) => {
          if (err) return reject(err)
          resolve(res)
        }
        arguments.length++
        fn.apply(this, arguments)
      })
    }
  }, 'name', { value: fn.name })
}

exports.p = function (fn) {
  return Object.defineProperty(function () {
    const cb = arguments[arguments.length - 1]
    if (typeof cb !== 'function') return fn.apply(this, arguments)
    else fn.apply(this, arguments).then(r => cb(null, r), cb)
  }, 'name', { value: fn.name })
}


/***/ }),

/***/ 64150:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var scopedPackagePattern = new RegExp('^(?:@([^/]+?)[/])?([^/]+?)$')
var builtins = __webpack_require__(92008)
var blacklist = [
  'node_modules',
  'favicon.ico'
]

var validate = module.exports = function (name) {
  var warnings = []
  var errors = []

  if (name === null) {
    errors.push('name cannot be null')
    return done(warnings, errors)
  }

  if (name === undefined) {
    errors.push('name cannot be undefined')
    return done(warnings, errors)
  }

  if (typeof name !== 'string') {
    errors.push('name must be a string')
    return done(warnings, errors)
  }

  if (!name.length) {
    errors.push('name length must be greater than zero')
  }

  if (name.match(/^\./)) {
    errors.push('name cannot start with a period')
  }

  if (name.match(/^_/)) {
    errors.push('name cannot start with an underscore')
  }

  if (name.trim() !== name) {
    errors.push('name cannot contain leading or trailing spaces')
  }

  // No funny business
  blacklist.forEach(function (blacklistedName) {
    if (name.toLowerCase() === blacklistedName) {
      errors.push(blacklistedName + ' is a blacklisted name')
    }
  })

  // Generate warnings for stuff that used to be allowed

  // core module names like http, events, util, etc
  builtins.forEach(function (builtin) {
    if (name.toLowerCase() === builtin) {
      warnings.push(builtin + ' is a core module name')
    }
  })

  // really-long-package-names-------------------------------such--length-----many---wow
  // the thisisareallyreallylongpackagenameitshouldpublishdowenowhavealimittothelengthofpackagenames-poch.
  if (name.length > 214) {
    warnings.push('name can no longer contain more than 214 characters')
  }

  // mIxeD CaSe nAMEs
  if (name.toLowerCase() !== name) {
    warnings.push('name can no longer contain capital letters')
  }

  if (/[~'!()*]/.test(name.split('/').slice(-1)[0])) {
    warnings.push('name can no longer contain special characters ("~\'!()*")')
  }

  if (encodeURIComponent(name) !== name) {
    // Maybe it's a scoped package name, like @user/package
    var nameMatch = name.match(scopedPackagePattern)
    if (nameMatch) {
      var user = nameMatch[1]
      var pkg = nameMatch[2]
      if (encodeURIComponent(user) === user && encodeURIComponent(pkg) === pkg) {
        return done(warnings, errors)
      }
    }

    errors.push('name can only contain URL-friendly characters')
  }

  return done(warnings, errors)
}

validate.scopedPackagePattern = scopedPackagePattern

var done = function (warnings, errors) {
  var result = {
    validForNewPackages: errors.length === 0 && warnings.length === 0,
    validForOldPackages: errors.length === 0,
    warnings: warnings,
    errors: errors
  }
  if (!result.warnings.length) delete result.warnings
  if (!result.errors.length) delete result.errors
  return result
}


/***/ }),

/***/ 321:
/***/ ((module) => {

var wordwrap = module.exports = function (start, stop, params) {
    if (typeof start === 'object') {
        params = start;
        start = params.start;
        stop = params.stop;
    }
    
    if (typeof stop === 'object') {
        params = stop;
        start = start || params.start;
        stop = undefined;
    }
    
    if (!stop) {
        stop = start;
        start = 0;
    }
    
    if (!params) params = {};
    var mode = params.mode || 'soft';
    var re = mode === 'hard' ? /\b/ : /(\S+\s+)/;
    
    return function (text) {
        var chunks = text.toString()
            .split(re)
            .reduce(function (acc, x) {
                if (mode === 'hard') {
                    for (var i = 0; i < x.length; i += stop - start) {
                        acc.push(x.slice(i, i + stop - start));
                    }
                }
                else acc.push(x)
                return acc;
            }, [])
        ;
        
        return chunks.reduce(function (lines, rawChunk) {
            if (rawChunk === '') return lines;
            
            var chunk = rawChunk.replace(/\t/g, '    ');
            
            var i = lines.length - 1;
            if (lines[i].length + chunk.length > stop) {
                lines[i] = lines[i].replace(/\s+$/, '');
                
                chunk.split(/\n/).forEach(function (c) {
                    lines.push(
                        new Array(start + 1).join(' ')
                        + c.replace(/^\s+/, '')
                    );
                });
            }
            else if (chunk.match(/\n/)) {
                var xs = chunk.split(/\n/);
                lines[i] += xs.shift();
                xs.forEach(function (c) {
                    lines.push(
                        new Array(start + 1).join(' ')
                        + c.replace(/^\s+/, '')
                    );
                });
            }
            else {
                lines[i] += chunk;
            }
            
            return lines;
        }, [ new Array(start + 1).join(' ') ]).join('\n');
    };
};

wordwrap.soft = wordwrap;

wordwrap.hard = function (start, stop) {
    return wordwrap(start, stop, { mode : 'hard' });
};


/***/ }),

/***/ 62940:
/***/ ((module) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),

/***/ 4091:
/***/ ((module) => {

"use strict";

module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value
    }
  }
}


/***/ }),

/***/ 40665:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null

  return next
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1
  }
  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next
  }

  var ret = []
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value)
    walker = this.removeNode(walker)
  }
  if (walker === null) {
    walker = this.tail
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev
  }

  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i])
  }
  return ret;
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function insert (self, node, value) {
  var inserted = node === self.head ?
    new Node(value, null, node, self) :
    new Node(value, node, node.next, self)

  if (inserted.next === null) {
    self.tail = inserted
  }
  if (inserted.prev === null) {
    self.head = inserted
  }

  self.length++

  return inserted
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}

try {
  // add if support for Symbol.iterator is present
  __webpack_require__(4091)(Yallist)
} catch (er) {}


/***/ }),

/***/ 59997:
/***/ ((module) => {

!function(e){if(true)module.exports=e();else {}}(function(){return function e(t,r,i){function n(a,s){if(!r[a]){if(!t[a]){var u= true&&require;if(!s&&u)return u(a,!0);if(o)return o(a,!0);var l=new Error("Cannot find module '"+a+"'");throw l.code="MODULE_NOT_FOUND",l}var f=r[a]={exports:{}};t[a][0].call(f.exports,function(e){var r=t[a][1][e];return n(r||e)},f,f.exports,e,t,r,i)}return r[a].exports}for(var o= true&&require,a=0;a<i.length;a++)n(i[a]);return n}({1:[function(e,t,r){(function(e){function r(e,t){return null==e?void 0:e[t]}function i(e){var t=!1;if(null!=e&&"function"!=typeof e.toString)try{t=!!(e+"")}catch(e){}return t}function n(e){var t=-1,r=e?e.length:0;for(this.clear();++t<r;){var i=e[t];this.set(i[0],i[1])}}function o(e){var t=-1,r=e?e.length:0;for(this.clear();++t<r;){var i=e[t];this.set(i[0],i[1])}}function a(e){var t=-1,r=e?e.length:0;for(this.clear();++t<r;){var i=e[t];this.set(i[0],i[1])}}function s(e,t){for(var r=e.length;r--;)if(E(e[r][0],t))return r;return-1}function u(e,t){for(var r=0,i=(t=h(t,e)?[t]:d(t)).length;null!=e&&r<i;)e=e[y(t[r++])];return r&&r==i?e:void 0}function l(e){return!(!O(e)||_(e))&&(b(e)||i(e)?H:U).test(g(e))}function f(e){if("string"==typeof e)return e;if(A(e))return re?re.call(e):"";var t=e+"";return"0"==t&&1/e==-M?"-0":t}function d(e){return ne(e)?e:ie(e)}function c(e,t){var r=e.__data__;return m(t)?r["string"==typeof t?"string":"hash"]:r.map}function p(e,t){var i=r(e,t);return l(i)?i:void 0}function h(e,t){if(ne(e))return!1;var r=typeof e;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=e&&!A(e))||(j.test(e)||!$.test(e)||null!=t&&e in Object(t))}function m(e){var t=typeof e;return"string"==t||"number"==t||"symbol"==t||"boolean"==t?"__proto__"!==e:null===e}function _(e){return!!V&&V in e}function y(e){if("string"==typeof e||A(e))return e;var t=e+"";return"0"==t&&1/e==-M?"-0":t}function g(e){if(null!=e){try{return Z.call(e)}catch(e){}try{return e+""}catch(e){}}return""}function v(e,t){if("function"!=typeof e||t&&"function"!=typeof t)throw new TypeError(R);var r=function(){var i=arguments,n=t?t.apply(this,i):i[0],o=r.cache;if(o.has(n))return o.get(n);var a=e.apply(this,i);return r.cache=o.set(n,a),a};return r.cache=new(v.Cache||a),r}function E(e,t){return e===t||e!==e&&t!==t}function b(e){var t=O(e)?X.call(e):"";return t==I||t==T}function O(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}function S(e){return!!e&&"object"==typeof e}function A(e){return"symbol"==typeof e||S(e)&&X.call(e)==D}function P(e){return null==e?"":f(e)}var R="Expected a function",x="__lodash_hash_undefined__",M=1/0,I="[object Function]",T="[object GeneratorFunction]",D="[object Symbol]",$=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,j=/^\w*$/,w=/^\./,F=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,C=/[\\^$.*+?()[\]{}|]/g,N=/\\(\\)?/g,U=/^\[object .+?Constructor\]$/,L="object"==typeof e&&e&&e.Object===Object&&e,k="object"==typeof self&&self&&self.Object===Object&&self,Y=L||k||Function("return this")(),W=Array.prototype,K=Function.prototype,B=Object.prototype,q=Y["__core-js_shared__"],V=function(){var e=/[^.]+$/.exec(q&&q.keys&&q.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}(),Z=K.toString,z=B.hasOwnProperty,X=B.toString,H=RegExp("^"+Z.call(z).replace(C,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),J=Y.Symbol,G=W.splice,Q=p(Y,"Map"),ee=p(Object,"create"),te=J?J.prototype:void 0,re=te?te.toString:void 0;n.prototype.clear=function(){this.__data__=ee?ee(null):{}},n.prototype.delete=function(e){return this.has(e)&&delete this.__data__[e]},n.prototype.get=function(e){var t=this.__data__;if(ee){var r=t[e];return r===x?void 0:r}return z.call(t,e)?t[e]:void 0},n.prototype.has=function(e){var t=this.__data__;return ee?void 0!==t[e]:z.call(t,e)},n.prototype.set=function(e,t){return this.__data__[e]=ee&&void 0===t?x:t,this},o.prototype.clear=function(){this.__data__=[]},o.prototype.delete=function(e){var t=this.__data__,r=s(t,e);return!(r<0||(r==t.length-1?t.pop():G.call(t,r,1),0))},o.prototype.get=function(e){var t=this.__data__,r=s(t,e);return r<0?void 0:t[r][1]},o.prototype.has=function(e){return s(this.__data__,e)>-1},o.prototype.set=function(e,t){var r=this.__data__,i=s(r,e);return i<0?r.push([e,t]):r[i][1]=t,this},a.prototype.clear=function(){this.__data__={hash:new n,map:new(Q||o),string:new n}},a.prototype.delete=function(e){return c(this,e).delete(e)},a.prototype.get=function(e){return c(this,e).get(e)},a.prototype.has=function(e){return c(this,e).has(e)},a.prototype.set=function(e,t){return c(this,e).set(e,t),this};var ie=v(function(e){e=P(e);var t=[];return w.test(e)&&t.push(""),e.replace(F,function(e,r,i,n){t.push(i?n.replace(N,"$1"):r||e)}),t});v.Cache=a;var ne=Array.isArray;t.exports=function(e,t,r){var i=null==e?void 0:u(e,t);return void 0===i?r:i}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],2:[function(e,t,r){(function(e){function i(e,t){for(var r=-1,i=null==e?0:e.length,n=0,o=[];++r<i;){var a=e[r];t(a,r,e)&&(o[n++]=a)}return o}function n(e,t){for(var r=-1,i=t.length,n=e.length;++r<i;)e[n+r]=t[r];return e}function o(e,t){for(var r=-1,i=null==e?0:e.length;++r<i;)if(t(e[r],r,e))return!0;return!1}function a(e,t){for(var r=-1,i=Array(e);++r<e;)i[r]=t(r);return i}function s(e,t){return e.has(t)}function u(e,t){return null==e?void 0:e[t]}function l(e){var t=-1,r=Array(e.size);return e.forEach(function(e,i){r[++t]=[i,e]}),r}function f(e){var t=-1,r=Array(e.size);return e.forEach(function(e){r[++t]=e}),r}function d(e){var t=-1,r=null==e?0:e.length;for(this.clear();++t<r;){var i=e[t];this.set(i[0],i[1])}}function c(e){var t=-1,r=null==e?0:e.length;for(this.clear();++t<r;){var i=e[t];this.set(i[0],i[1])}}function p(e){var t=-1,r=null==e?0:e.length;for(this.clear();++t<r;){var i=e[t];this.set(i[0],i[1])}}function h(e){var t=-1,r=null==e?0:e.length;for(this.__data__=new p;++t<r;)this.add(e[t])}function m(e){var t=this.__data__=new c(e);this.size=t.size}function _(e,t){var r=lt(e),i=!r&&ut(e),n=!r&&!i&&ft(e),o=!r&&!i&&!n&&dt(e),s=r||i||n||o,u=s?a(e.length,String):[],l=u.length;for(var f in e)!t&&!we.call(e,f)||s&&("length"==f||n&&("offset"==f||"parent"==f)||o&&("buffer"==f||"byteLength"==f||"byteOffset"==f)||$(f,l))||u.push(f);return u}function y(e,t){for(var r=e.length;r--;)if(U(e[r][0],t))return r;return-1}function g(e,t,r){var i=t(e);return lt(e)?i:n(i,r(e))}function v(e){return null==e?void 0===e?pe:ae:Ke&&Ke in Object(e)?D(e):C(e)}function E(e){return K(e)&&v(e)==H}function b(e,t,r,i,n){return e===t||(null==e||null==t||!K(e)&&!K(t)?e!==e&&t!==t:O(e,t,r,i,b,n))}function O(e,t,r,i,n,o){var a=lt(e),s=lt(t),u=a?J:st(e),l=s?J:st(t),f=(u=u==H?se:u)==se,d=(l=l==H?se:l)==se,c=u==l;if(c&&ft(e)){if(!ft(t))return!1;a=!0,f=!1}if(c&&!f)return o||(o=new m),a||dt(e)?P(e,t,r,i,n,o):R(e,t,u,r,i,n,o);if(!(r&Z)){var p=f&&we.call(e,"__wrapped__"),h=d&&we.call(t,"__wrapped__");if(p||h){var _=p?e.value():e,y=h?t.value():t;return o||(o=new m),n(_,y,r,i,o)}}return!!c&&(o||(o=new m),x(e,t,r,i,n,o))}function S(e){return!(!W(e)||w(e))&&(k(e)?Ne:ye).test(N(e))}function A(e){if(!F(e))return Ve(e);var t=[];for(var r in Object(e))we.call(e,r)&&"constructor"!=r&&t.push(r);return t}function P(e,t,r,i,n,a){var u=r&Z,l=e.length,f=t.length;if(l!=f&&!(u&&f>l))return!1;var d=a.get(e);if(d&&a.get(t))return d==t;var c=-1,p=!0,m=r&z?new h:void 0;for(a.set(e,t),a.set(t,e);++c<l;){var _=e[c],y=t[c];if(i)var g=u?i(y,_,c,t,e,a):i(_,y,c,e,t,a);if(void 0!==g){if(g)continue;p=!1;break}if(m){if(!o(t,function(e,t){if(!s(m,t)&&(_===e||n(_,e,r,i,a)))return m.push(t)})){p=!1;break}}else if(_!==y&&!n(_,y,r,i,a)){p=!1;break}}return a.delete(e),a.delete(t),p}function R(e,t,r,i,n,o,a){switch(r){case me:if(e.byteLength!=t.byteLength||e.byteOffset!=t.byteOffset)return!1;e=e.buffer,t=t.buffer;case he:return!(e.byteLength!=t.byteLength||!o(new ke(e),new ke(t)));case Q:case ee:case oe:return U(+e,+t);case te:return e.name==t.name&&e.message==t.message;case le:case de:return e==t+"";case ne:var s=l;case fe:var u=i&Z;if(s||(s=f),e.size!=t.size&&!u)return!1;var d=a.get(e);if(d)return d==t;i|=z,a.set(e,t);var c=P(s(e),s(t),i,n,o,a);return a.delete(e),c;case ce:if(ot)return ot.call(e)==ot.call(t)}return!1}function x(e,t,r,i,n,o){var a=r&Z,s=M(e),u=s.length;if(u!=M(t).length&&!a)return!1;for(var l=u;l--;){var f=s[l];if(!(a?f in t:we.call(t,f)))return!1}var d=o.get(e);if(d&&o.get(t))return d==t;var c=!0;o.set(e,t),o.set(t,e);for(var p=a;++l<u;){var h=e[f=s[l]],m=t[f];if(i)var _=a?i(m,h,f,t,e,o):i(h,m,f,e,t,o);if(!(void 0===_?h===m||n(h,m,r,i,o):_)){c=!1;break}p||(p="constructor"==f)}if(c&&!p){var y=e.constructor,g=t.constructor;y!=g&&"constructor"in e&&"constructor"in t&&!("function"==typeof y&&y instanceof y&&"function"==typeof g&&g instanceof g)&&(c=!1)}return o.delete(e),o.delete(t),c}function M(e){return g(e,B,at)}function I(e,t){var r=e.__data__;return j(t)?r["string"==typeof t?"string":"hash"]:r.map}function T(e,t){var r=u(e,t);return S(r)?r:void 0}function D(e){var t=we.call(e,Ke),r=e[Ke];try{e[Ke]=void 0;var i=!0}catch(e){}var n=Ce.call(e);return i&&(t?e[Ke]=r:delete e[Ke]),n}function $(e,t){return!!(t=null==t?X:t)&&("number"==typeof e||ge.test(e))&&e>-1&&e%1==0&&e<t}function j(e){var t=typeof e;return"string"==t||"number"==t||"symbol"==t||"boolean"==t?"__proto__"!==e:null===e}function w(e){return!!Fe&&Fe in e}function F(e){var t=e&&e.constructor;return e===("function"==typeof t&&t.prototype||De)}function C(e){return Ce.call(e)}function N(e){if(null!=e){try{return je.call(e)}catch(e){}try{return e+""}catch(e){}}return""}function U(e,t){return e===t||e!==e&&t!==t}function L(e){return null!=e&&Y(e.length)&&!k(e)}function k(e){if(!W(e))return!1;var t=v(e);return t==re||t==ie||t==G||t==ue}function Y(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=X}function W(e){var t=typeof e;return null!=e&&("object"==t||"function"==t)}function K(e){return null!=e&&"object"==typeof e}function B(e){return L(e)?_(e):A(e)}var q=200,V="__lodash_hash_undefined__",Z=1,z=2,X=9007199254740991,H="[object Arguments]",J="[object Array]",G="[object AsyncFunction]",Q="[object Boolean]",ee="[object Date]",te="[object Error]",re="[object Function]",ie="[object GeneratorFunction]",ne="[object Map]",oe="[object Number]",ae="[object Null]",se="[object Object]",ue="[object Proxy]",le="[object RegExp]",fe="[object Set]",de="[object String]",ce="[object Symbol]",pe="[object Undefined]",he="[object ArrayBuffer]",me="[object DataView]",_e=/[\\^$.*+?()[\]{}|]/g,ye=/^\[object .+?Constructor\]$/,ge=/^(?:0|[1-9]\d*)$/,ve={};ve["[object Float32Array]"]=ve["[object Float64Array]"]=ve["[object Int8Array]"]=ve["[object Int16Array]"]=ve["[object Int32Array]"]=ve["[object Uint8Array]"]=ve["[object Uint8ClampedArray]"]=ve["[object Uint16Array]"]=ve["[object Uint32Array]"]=!0,ve[H]=ve[J]=ve[he]=ve[Q]=ve[me]=ve[ee]=ve[te]=ve[re]=ve[ne]=ve[oe]=ve[se]=ve[le]=ve[fe]=ve[de]=ve["[object WeakMap]"]=!1;var Ee="object"==typeof e&&e&&e.Object===Object&&e,be="object"==typeof self&&self&&self.Object===Object&&self,Oe=Ee||be||Function("return this")(),Se="object"==typeof r&&r&&!r.nodeType&&r,Ae=Se&&"object"==typeof t&&t&&!t.nodeType&&t,Pe=Ae&&Ae.exports===Se,Re=Pe&&Ee.process,xe=function(){try{return Re&&Re.binding&&Re.binding("util")}catch(e){}}(),Me=xe&&xe.isTypedArray,Ie=Array.prototype,Te=Function.prototype,De=Object.prototype,$e=Oe["__core-js_shared__"],je=Te.toString,we=De.hasOwnProperty,Fe=function(){var e=/[^.]+$/.exec($e&&$e.keys&&$e.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}(),Ce=De.toString,Ne=RegExp("^"+je.call(we).replace(_e,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Ue=Pe?Oe.Buffer:void 0,Le=Oe.Symbol,ke=Oe.Uint8Array,Ye=De.propertyIsEnumerable,We=Ie.splice,Ke=Le?Le.toStringTag:void 0,Be=Object.getOwnPropertySymbols,qe=Ue?Ue.isBuffer:void 0,Ve=function(e,t){return function(r){return e(t(r))}}(Object.keys,Object),Ze=T(Oe,"DataView"),ze=T(Oe,"Map"),Xe=T(Oe,"Promise"),He=T(Oe,"Set"),Je=T(Oe,"WeakMap"),Ge=T(Object,"create"),Qe=N(Ze),et=N(ze),tt=N(Xe),rt=N(He),it=N(Je),nt=Le?Le.prototype:void 0,ot=nt?nt.valueOf:void 0;d.prototype.clear=function(){this.__data__=Ge?Ge(null):{},this.size=0},d.prototype.delete=function(e){var t=this.has(e)&&delete this.__data__[e];return this.size-=t?1:0,t},d.prototype.get=function(e){var t=this.__data__;if(Ge){var r=t[e];return r===V?void 0:r}return we.call(t,e)?t[e]:void 0},d.prototype.has=function(e){var t=this.__data__;return Ge?void 0!==t[e]:we.call(t,e)},d.prototype.set=function(e,t){var r=this.__data__;return this.size+=this.has(e)?0:1,r[e]=Ge&&void 0===t?V:t,this},c.prototype.clear=function(){this.__data__=[],this.size=0},c.prototype.delete=function(e){var t=this.__data__,r=y(t,e);return!(r<0||(r==t.length-1?t.pop():We.call(t,r,1),--this.size,0))},c.prototype.get=function(e){var t=this.__data__,r=y(t,e);return r<0?void 0:t[r][1]},c.prototype.has=function(e){return y(this.__data__,e)>-1},c.prototype.set=function(e,t){var r=this.__data__,i=y(r,e);return i<0?(++this.size,r.push([e,t])):r[i][1]=t,this},p.prototype.clear=function(){this.size=0,this.__data__={hash:new d,map:new(ze||c),string:new d}},p.prototype.delete=function(e){var t=I(this,e).delete(e);return this.size-=t?1:0,t},p.prototype.get=function(e){return I(this,e).get(e)},p.prototype.has=function(e){return I(this,e).has(e)},p.prototype.set=function(e,t){var r=I(this,e),i=r.size;return r.set(e,t),this.size+=r.size==i?0:1,this},h.prototype.add=h.prototype.push=function(e){return this.__data__.set(e,V),this},h.prototype.has=function(e){return this.__data__.has(e)},m.prototype.clear=function(){this.__data__=new c,this.size=0},m.prototype.delete=function(e){var t=this.__data__,r=t.delete(e);return this.size=t.size,r},m.prototype.get=function(e){return this.__data__.get(e)},m.prototype.has=function(e){return this.__data__.has(e)},m.prototype.set=function(e,t){var r=this.__data__;if(r instanceof c){var i=r.__data__;if(!ze||i.length<q-1)return i.push([e,t]),this.size=++r.size,this;r=this.__data__=new p(i)}return r.set(e,t),this.size=r.size,this};var at=Be?function(e){return null==e?[]:(e=Object(e),i(Be(e),function(t){return Ye.call(e,t)}))}:function(){return[]},st=v;(Ze&&st(new Ze(new ArrayBuffer(1)))!=me||ze&&st(new ze)!=ne||Xe&&"[object Promise]"!=st(Xe.resolve())||He&&st(new He)!=fe||Je&&"[object WeakMap]"!=st(new Je))&&(st=function(e){var t=v(e),r=t==se?e.constructor:void 0,i=r?N(r):"";if(i)switch(i){case Qe:return me;case et:return ne;case tt:return"[object Promise]";case rt:return fe;case it:return"[object WeakMap]"}return t});var ut=E(function(){return arguments}())?E:function(e){return K(e)&&we.call(e,"callee")&&!Ye.call(e,"callee")},lt=Array.isArray,ft=qe||function(){return!1},dt=Me?function(e){return function(t){return e(t)}}(Me):function(e){return K(e)&&Y(e.length)&&!!ve[v(e)]};t.exports=function(e,t){return b(e,t)}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],3:[function(e,t,r){function i(){throw new Error("setTimeout has not been defined")}function n(){throw new Error("clearTimeout has not been defined")}function o(e){if(d===setTimeout)return setTimeout(e,0);if((d===i||!d)&&setTimeout)return d=setTimeout,setTimeout(e,0);try{return d(e,0)}catch(t){try{return d.call(null,e,0)}catch(t){return d.call(this,e,0)}}}function a(e){if(c===clearTimeout)return clearTimeout(e);if((c===n||!c)&&clearTimeout)return c=clearTimeout,clearTimeout(e);try{return c(e)}catch(t){try{return c.call(null,e)}catch(t){return c.call(this,e)}}}function s(){_&&h&&(_=!1,h.length?m=h.concat(m):y=-1,m.length&&u())}function u(){if(!_){var e=o(s);_=!0;for(var t=m.length;t;){for(h=m,m=[];++y<t;)h&&h[y].run();y=-1,t=m.length}h=null,_=!1,a(e)}}function l(e,t){this.fun=e,this.array=t}function f(){}var d,c,p=t.exports={};!function(){try{d="function"==typeof setTimeout?setTimeout:i}catch(e){d=i}try{c="function"==typeof clearTimeout?clearTimeout:n}catch(e){c=n}}();var h,m=[],_=!1,y=-1;p.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];m.push(new l(e,t)),1!==m.length||_||o(u)},l.prototype.run=function(){this.fun.apply(null,this.array)},p.title="browser",p.browser=!0,p.env={},p.argv=[],p.version="",p.versions={},p.on=f,p.addListener=f,p.once=f,p.off=f,p.removeListener=f,p.removeAllListeners=f,p.emit=f,p.prependListener=f,p.prependOnceListener=f,p.listeners=function(e){return[]},p.binding=function(e){throw new Error("process.binding is not supported")},p.cwd=function(){return"/"},p.chdir=function(e){throw new Error("process.chdir is not supported")},p.umask=function(){return 0}},{}],4:[function(e,t,r){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(r,"__esModule",{value:!0});var n=i(e("./lib/toDate")),o=i(e("./lib/toFloat")),a=i(e("./lib/toInt")),s=i(e("./lib/toBoolean")),u=i(e("./lib/equals")),l=i(e("./lib/contains")),f=i(e("./lib/matches")),d=i(e("./lib/isEmail")),c=i(e("./lib/isURL")),p=i(e("./lib/isMACAddress")),h=i(e("./lib/isIP")),m=i(e("./lib/isFQDN")),_=i(e("./lib/isBoolean")),y=i(e("./lib/isAlpha")),g=i(e("./lib/isAlphanumeric")),v=i(e("./lib/isNumeric")),E=i(e("./lib/isLowercase")),b=i(e("./lib/isUppercase")),O=i(e("./lib/isAscii")),S=i(e("./lib/isFullWidth")),A=i(e("./lib/isHalfWidth")),P=i(e("./lib/isVariableWidth")),R=i(e("./lib/isMultibyte")),x=i(e("./lib/isSurrogatePair")),M=i(e("./lib/isInt")),I=i(e("./lib/isFloat")),T=i(e("./lib/isDecimal")),D=i(e("./lib/isHexadecimal")),$=i(e("./lib/isDivisibleBy")),j=i(e("./lib/isHexColor")),w=i(e("./lib/isISRC")),F=i(e("./lib/isMD5")),C=i(e("./lib/isHash")),N=i(e("./lib/isJSON")),U=i(e("./lib/isEmpty")),L=i(e("./lib/isLength")),k=i(e("./lib/isByteLength")),Y=i(e("./lib/isUUID")),W=i(e("./lib/isMongoId")),K=i(e("./lib/isAfter")),B=i(e("./lib/isBefore")),q=i(e("./lib/isIn")),V=i(e("./lib/isCreditCard")),Z=i(e("./lib/isISIN")),z=i(e("./lib/isISBN")),X=i(e("./lib/isISSN")),H=i(e("./lib/isMobilePhone")),J=i(e("./lib/isCurrency")),G=i(e("./lib/isISO8601")),Q=i(e("./lib/isBase64")),ee=i(e("./lib/isDataURI")),te=i(e("./lib/isLatLong")),re=i(e("./lib/isPostalCode")),ie=i(e("./lib/ltrim")),ne=i(e("./lib/rtrim")),oe=i(e("./lib/trim")),ae=i(e("./lib/escape")),se=i(e("./lib/unescape")),ue=i(e("./lib/stripLow")),le=i(e("./lib/whitelist")),fe=i(e("./lib/blacklist")),de=i(e("./lib/isWhitelisted")),ce=i(e("./lib/normalizeEmail")),pe=i(e("./lib/util/toString")),he={version:"8.2.0",toDate:n.default,toFloat:o.default,toInt:a.default,toBoolean:s.default,equals:u.default,contains:l.default,matches:f.default,isEmail:d.default,isURL:c.default,isMACAddress:p.default,isIP:h.default,isFQDN:m.default,isBoolean:_.default,isAlpha:y.default,isAlphanumeric:g.default,isNumeric:v.default,isLowercase:E.default,isUppercase:b.default,isAscii:O.default,isFullWidth:S.default,isHalfWidth:A.default,isVariableWidth:P.default,isMultibyte:R.default,isSurrogatePair:x.default,isInt:M.default,isFloat:I.default,isDecimal:T.default,isHexadecimal:D.default,isDivisibleBy:$.default,isHexColor:j.default,isISRC:w.default,isMD5:F.default,isHash:C.default,isJSON:N.default,isEmpty:U.default,isLength:L.default,isByteLength:k.default,isUUID:Y.default,isMongoId:W.default,isAfter:K.default,isBefore:B.default,isIn:q.default,isCreditCard:V.default,isISIN:Z.default,isISBN:z.default,isISSN:X.default,isMobilePhone:H.default,isPostalCode:re.default,isCurrency:J.default,isISO8601:G.default,isBase64:Q.default,isDataURI:ee.default,isLatLong:te.default,ltrim:ie.default,rtrim:ne.default,trim:oe.default,escape:ae.default,unescape:se.default,stripLow:ue.default,whitelist:le.default,blacklist:fe.default,isWhitelisted:de.default,normalizeEmail:ce.default,toString:pe.default};r.default=he,t.exports=r.default},{"./lib/blacklist":6,"./lib/contains":7,"./lib/equals":8,"./lib/escape":9,"./lib/isAfter":10,"./lib/isAlpha":11,"./lib/isAlphanumeric":12,"./lib/isAscii":13,"./lib/isBase64":14,"./lib/isBefore":15,"./lib/isBoolean":16,"./lib/isByteLength":17,"./lib/isCreditCard":18,"./lib/isCurrency":19,"./lib/isDataURI":20,"./lib/isDecimal":21,"./lib/isDivisibleBy":22,"./lib/isEmail":23,"./lib/isEmpty":24,"./lib/isFQDN":25,"./lib/isFloat":26,"./lib/isFullWidth":27,"./lib/isHalfWidth":28,"./lib/isHash":29,"./lib/isHexColor":30,"./lib/isHexadecimal":31,"./lib/isIP":32,"./lib/isISBN":33,"./lib/isISIN":34,"./lib/isISO8601":35,"./lib/isISRC":36,"./lib/isISSN":37,"./lib/isIn":38,"./lib/isInt":39,"./lib/isJSON":40,"./lib/isLatLong":41,"./lib/isLength":42,"./lib/isLowercase":43,"./lib/isMACAddress":44,"./lib/isMD5":45,"./lib/isMobilePhone":46,"./lib/isMongoId":47,"./lib/isMultibyte":48,"./lib/isNumeric":49,"./lib/isPostalCode":50,"./lib/isSurrogatePair":51,"./lib/isURL":52,"./lib/isUUID":53,"./lib/isUppercase":54,"./lib/isVariableWidth":55,"./lib/isWhitelisted":56,"./lib/ltrim":57,"./lib/matches":58,"./lib/normalizeEmail":59,"./lib/rtrim":60,"./lib/stripLow":61,"./lib/toBoolean":62,"./lib/toDate":63,"./lib/toFloat":64,"./lib/toInt":65,"./lib/trim":66,"./lib/unescape":67,"./lib/util/toString":70,"./lib/whitelist":71}],5:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});for(var i,n=r.alpha={"en-US":/^[A-Z]+$/i,"cs-CZ":/^[A-Z]+$/i,"da-DK":/^[A-Z]+$/i,"de-DE":/^[A-Z]+$/i,"es-ES":/^[A-Z]+$/i,"fr-FR":/^[A-Z]+$/i,"it-IT":/^[A-Z]+$/i,"nb-NO":/^[A-Z]+$/i,"nl-NL":/^[A-Z]+$/i,"nn-NO":/^[A-Z]+$/i,"hu-HU":/^[A-Z]+$/i,"pl-PL":/^[A-Z]+$/i,"pt-PT":/^[A-Z]+$/i,"ru-RU":/^[-]+$/i,"sr-RS@latin":/^[A-Z]+$/i,"sr-RS":/^[-]+$/i,"sv-SE":/^[A-Z]+$/i,"tr-TR":/^[A-Z]+$/i,"uk-UA":/^[-I]+$/i,ar:/^[]+$/},o=r.alphanumeric={"en-US":/^[0-9A-Z]+$/i,"cs-CZ":/^[0-9A-Z]+$/i,"da-DK":/^[0-9A-Z]+$/i,"de-DE":/^[0-9A-Z]+$/i,"es-ES":/^[0-9A-Z]+$/i,"fr-FR":/^[0-9A-Z]+$/i,"it-IT":/^[0-9A-Z]+$/i,"hu-HU":/^[0-9A-Z]+$/i,"nb-NO":/^[0-9A-Z]+$/i,"nl-NL":/^[0-9A-Z]+$/i,"nn-NO":/^[0-9A-Z]+$/i,"pl-PL":/^[0-9A-Z]+$/i,"pt-PT":/^[0-9A-Z]+$/i,"ru-RU":/^[0-9-]+$/i,"sr-RS@latin":/^[0-9A-Z]+$/i,"sr-RS":/^[0-9-]+$/i,"sv-SE":/^[0-9A-Z]+$/i,"tr-TR":/^[0-9A-Z]+$/i,"uk-UA":/^[0-9-I]+$/i,ar:/^[0-9]+$/},a=r.englishLocales=["AU","GB","HK","IN","NZ","ZA","ZM"],s=0;s<a.length;s++)n[i="en-"+a[s]]=n["en-US"],o[i]=o["en-US"];n["pt-BR"]=n["pt-PT"],o["pt-BR"]=o["pt-PT"];for(var u,l=r.arabicLocales=["AE","BH","DZ","EG","IQ","JO","KW","LB","LY","MA","QM","QA","SA","SD","SY","TN","YE"],f=0;f<l.length;f++)n[u="ar-"+l[f]]=n.ar,o[u]=o.ar},{}],6:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t){return(0,i.default)(e),e.replace(new RegExp("["+t+"]+","g"),"")};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString"));t.exports=r.default},{"./util/assertString":68}],7:[function(e,t,r){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t){return(0,n.default)(e),e.indexOf((0,o.default)(t))>=0};var n=i(e("./util/assertString")),o=i(e("./util/toString"));t.exports=r.default},{"./util/assertString":68,"./util/toString":70}],8:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t){return(0,i.default)(e),e===t};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString"));t.exports=r.default},{"./util/assertString":68}],9:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,i.default)(e),e.replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/\//g,"&#x2F;").replace(/\\/g,"&#x5C;").replace(/`/g,"&#96;")};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString"));t.exports=r.default},{"./util/assertString":68}],10:[function(e,t,r){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:String(new Date);(0,n.default)(e);var r=(0,o.default)(t),i=(0,o.default)(e);return!!(i&&r&&i>r)};var n=i(e("./util/assertString")),o=i(e("./toDate"));t.exports=r.default},{"./toDate":63,"./util/assertString":68}],11:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"en-US";if((0,i.default)(e),t in n.alpha)return n.alpha[t].test(e);throw new Error("Invalid locale '"+t+"'")};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=e("./alpha");t.exports=r.default},{"./alpha":5,"./util/assertString":68}],12:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"en-US";if((0,i.default)(e),t in n.alphanumeric)return n.alphanumeric[t].test(e);throw new Error("Invalid locale '"+t+"'")};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=e("./alpha");t.exports=r.default},{"./alpha":5,"./util/assertString":68}],13:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,i.default)(e),n.test(e)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=/^[\x00-\x7F]+$/;t.exports=r.default},{"./util/assertString":68}],14:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){(0,i.default)(e);var t=e.length;if(!t||t%4!=0||n.test(e))return!1;var r=e.indexOf("=");return-1===r||r===t-1||r===t-2&&"="===e[t-1]};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=/[^A-Z0-9+\/=]/i;t.exports=r.default},{"./util/assertString":68}],15:[function(e,t,r){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:String(new Date);(0,n.default)(e);var r=(0,o.default)(t),i=(0,o.default)(e);return!!(i&&r&&i<r)};var n=i(e("./util/assertString")),o=i(e("./toDate"));t.exports=r.default},{"./toDate":63,"./util/assertString":68}],16:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,i.default)(e),["true","false","1","0"].indexOf(e)>=0};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString"));t.exports=r.default},{"./util/assertString":68}],17:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};r.default=function(e,t){(0,n.default)(e);var r=void 0,o=void 0;"object"===(void 0===t?"undefined":i(t))?(r=t.min||0,o=t.max):(r=arguments[1],o=arguments[2]);var a=encodeURI(e).split(/%..|./).length-1;return a>=r&&(void 0===o||a<=o)};var n=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString"));t.exports=r.default},{"./util/assertString":68}],18:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){(0,i.default)(e);var t=e.replace(/[- ]+/g,"");if(!n.test(t))return!1;for(var r=0,o=void 0,a=void 0,s=void 0,u=t.length-1;u>=0;u--)o=t.substring(u,u+1),a=parseInt(o,10),r+=s&&(a*=2)>=10?a%10+1:a,s=!s;return!(r%10!=0||!t)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=/^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|62[0-9]{14})$/;t.exports=r.default},{"./util/assertString":68}],19:[function(e,t,r){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}function n(e){var t="\\d{"+e.digits_after_decimal[0]+"}";e.digits_after_decimal.forEach(function(e,r){0!==r&&(t=t+"|\\d{"+e+"}")});var r="(\\"+e.symbol.replace(/\./g,"\\.")+")"+(e.require_symbol?"":"?"),i="("+["0","[1-9]\\d*","[1-9]\\d{0,2}(\\"+e.thousands_separator+"\\d{3})*"].join("|")+")?",n="(\\"+e.decimal_separator+"("+t+"))"+(e.require_decimal?"":"?"),o=i+(e.allow_decimal||e.require_decimal?n:"");return e.allow_negatives&&!e.parens_for_negatives&&(e.negative_sign_after_digits?o+="-?":e.negative_sign_before_digits&&(o="-?"+o)),e.allow_negative_sign_placeholder?o="( (?!\\-))?"+o:e.allow_space_after_symbol?o=" ?"+o:e.allow_space_after_digits&&(o+="( (?!$))?"),e.symbol_after_digits?o+=r:o=r+o,e.allow_negatives&&(e.parens_for_negatives?o="(\\("+o+"\\)|"+o+")":e.negative_sign_before_digits||e.negative_sign_after_digits||(o="-?"+o)),new RegExp("^(?!-? )(?=.*\\d)"+o+"$")}Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t){return(0,a.default)(e),t=(0,o.default)(t,s),n(t).test(e)};var o=i(e("./util/merge")),a=i(e("./util/assertString")),s={symbol:"$",require_symbol:!1,allow_space_after_symbol:!1,symbol_after_digits:!1,allow_negatives:!0,parens_for_negatives:!1,negative_sign_before_digits:!1,negative_sign_after_digits:!1,allow_negative_sign_placeholder:!1,thousands_separator:",",decimal_separator:".",allow_decimal:!0,require_decimal:!1,digits_after_decimal:[2],allow_space_after_digits:!1};t.exports=r.default},{"./util/assertString":68,"./util/merge":69}],20:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,i.default)(e),n.test(e)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=/^\s*data:([a-z]+\/[a-z0-9\-\+]+(;[a-z\-]+=[a-z0-9\-]+)?)?(;base64)?,[a-z0-9!\$&',\(\)\*\+,;=\-\._~:@\/\?%\s]*\s*$/i;t.exports=r.default},{"./util/assertString":68}],21:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,i.default)(e),""!==e&&n.test(e)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=/^[-+]?([0-9]+|\.[0-9]+|[0-9]+\.[0-9]+)$/;t.exports=r.default},{"./util/assertString":68}],22:[function(e,t,r){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t){return(0,n.default)(e),(0,o.default)(e)%parseInt(t,10)==0};var n=i(e("./util/assertString")),o=i(e("./toFloat"));t.exports=r.default},{"./toFloat":64,"./util/assertString":68}],23:[function(e,t,r){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t){if((0,n.default)(e),(t=(0,o.default)(t,u)).require_display_name||t.allow_display_name){var r=e.match(l);if(r)e=r[1];else if(t.require_display_name)return!1}var i=e.split("@"),h=i.pop(),m=i.join("@"),_=h.toLowerCase();if("gmail.com"!==_&&"googlemail.com"!==_||(m=m.replace(/\./g,"").toLowerCase()),!(0,a.default)(m,{max:64})||!(0,a.default)(h,{max:254}))return!1;if(!(0,s.default)(h,{require_tld:t.require_tld}))return!1;if('"'===m[0])return m=m.slice(1,m.length-1),t.allow_utf8_local_part?p.test(m):d.test(m);for(var y=t.allow_utf8_local_part?c:f,g=m.split("."),v=0;v<g.length;v++)if(!y.test(g[v]))return!1;return!0};var n=i(e("./util/assertString")),o=i(e("./util/merge")),a=i(e("./isByteLength")),s=i(e("./isFQDN")),u={allow_display_name:!1,require_display_name:!1,allow_utf8_local_part:!0,require_tld:!0},l=/^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\,\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i,f=/^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i,d=/^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i,c=/^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i,p=/^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;t.exports=r.default},{"./isByteLength":17,"./isFQDN":25,"./util/assertString":68,"./util/merge":69}],24:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,i.default)(e),0===e.length};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString"));t.exports=r.default},{"./util/assertString":68}],25:[function(e,t,r){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t){(0,n.default)(e),(t=(0,o.default)(t,a)).allow_trailing_dot&&"."===e[e.length-1]&&(e=e.substring(0,e.length-1));var r=e.split(".");if(t.require_tld){var i=r.pop();if(!r.length||!/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(i))return!1;if(/[\s\u2002-\u200B\u202F\u205F\u3000\uFEFF\uDB40\uDC20]/.test(i))return!1}for(var s,u=0;u<r.length;u++){if(s=r[u],t.allow_underscores&&(s=s.replace(/_/g,"")),!/^[a-z\u00a1-\uffff0-9-]+$/i.test(s))return!1;if(/[\uff01-\uff5e]/.test(s))return!1;if("-"===s[0]||"-"===s[s.length-1])return!1}return!0};var n=i(e("./util/assertString")),o=i(e("./util/merge")),a={require_tld:!0,allow_underscores:!1,allow_trailing_dot:!1};t.exports=r.default},{"./util/assertString":68,"./util/merge":69}],26:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t){return(0,i.default)(e),t=t||{},""!==e&&"."!==e&&n.test(e)&&(!t.hasOwnProperty("min")||e>=t.min)&&(!t.hasOwnProperty("max")||e<=t.max)&&(!t.hasOwnProperty("lt")||e<t.lt)&&(!t.hasOwnProperty("gt")||e>t.gt)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=/^(?:[-+])?(?:[0-9]+)?(?:\.[0-9]*)?(?:[eE][\+\-]?(?:[0-9]+))?$/;t.exports=r.default},{"./util/assertString":68}],27:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.fullWidth=void 0,r.default=function(e){return(0,i.default)(e),n.test(e)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=r.fullWidth=/[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/},{"./util/assertString":68}],28:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.halfWidth=void 0,r.default=function(e){return(0,i.default)(e),n.test(e)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=r.halfWidth=/[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/},{"./util/assertString":68}],29:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t){return(0,i.default)(e),new RegExp("^[a-f0-9]{"+n[t]+"}$").test(e)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n={md5:32,md4:32,sha1:40,sha256:64,sha384:96,sha512:128,ripemd128:32,ripemd160:40,tiger128:32,tiger160:40,tiger192:48,crc32:8,crc32b:8};t.exports=r.default},{"./util/assertString":68}],30:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,i.default)(e),n.test(e)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i;t.exports=r.default},{"./util/assertString":68}],31:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,i.default)(e),n.test(e)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=/^[0-9A-F]+$/i;t.exports=r.default},{"./util/assertString":68}],32:[function(e,t,r){"use strict";function i(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";if((0,n.default)(e),!(t=String(t)))return i(e,4)||i(e,6);if("4"===t)return!!o.test(e)&&e.split(".").sort(function(e,t){return e-t})[3]<=255;if("6"===t){var r=e.split(":"),s=!1,u=i(r[r.length-1],4),l=u?7:8;if(r.length>l)return!1;if("::"===e)return!0;"::"===e.substr(0,2)?(r.shift(),r.shift(),s=!0):"::"===e.substr(e.length-2)&&(r.pop(),r.pop(),s=!0);for(var f=0;f<r.length;++f)if(""===r[f]&&f>0&&f<r.length-1){if(s)return!1;s=!0}else if(u&&f===r.length-1);else if(!a.test(r[f]))return!1;return s?r.length>=1:r.length===l}return!1}Object.defineProperty(r,"__esModule",{value:!0}),r.default=i;var n=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),o=/^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/,a=/^[0-9A-F]{1,4}$/i;t.exports=r.default},{"./util/assertString":68}],33:[function(e,t,r){"use strict";function i(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";if((0,n.default)(e),!(t=String(t)))return i(e,10)||i(e,13);var r=e.replace(/[\s-]+/g,""),u=0,l=void 0;if("10"===t){if(!o.test(r))return!1;for(l=0;l<9;l++)u+=(l+1)*r.charAt(l);if("X"===r.charAt(9)?u+=100:u+=10*r.charAt(9),u%11==0)return!!r}else if("13"===t){if(!a.test(r))return!1;for(l=0;l<12;l++)u+=s[l%2]*r.charAt(l);if(r.charAt(12)-(10-u%10)%10==0)return!!r}return!1}Object.defineProperty(r,"__esModule",{value:!0}),r.default=i;var n=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),o=/^(?:[0-9]{9}X|[0-9]{10})$/,a=/^(?:[0-9]{13})$/,s=[1,3];t.exports=r.default},{"./util/assertString":68}],34:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){if((0,i.default)(e),!n.test(e))return!1;for(var t=e.replace(/[A-Z]/g,function(e){return parseInt(e,36)}),r=0,o=void 0,a=void 0,s=!0,u=t.length-2;u>=0;u--)o=t.substring(u,u+1),a=parseInt(o,10),r+=s&&(a*=2)>=10?a+1:a,s=!s;return parseInt(e.substr(e.length-1),10)===(1e4-r)%10};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=/^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;t.exports=r.default},{"./util/assertString":68}],35:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,i.default)(e),n.test(e)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=/^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;t.exports=r.default},{"./util/assertString":68}],36:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,i.default)(e),n.test(e)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=/^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;t.exports=r.default},{"./util/assertString":68}],37:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};(0,i.default)(e);var r=n;if(r=t.require_hyphen?r.replace("?",""):r,!(r=t.case_sensitive?new RegExp(r):new RegExp(r,"i")).test(e))return!1;var o=e.replace("-",""),a=8,s=0,u=!0,l=!1,f=void 0;try{for(var d,c=o[Symbol.iterator]();!(u=(d=c.next()).done);u=!0){var p=d.value;s+=("X"===p.toUpperCase()?10:+p)*a,--a}}catch(e){l=!0,f=e}finally{try{!u&&c.return&&c.return()}finally{if(l)throw f}}return s%11==0};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n="^\\d{4}-?\\d{3}[\\dX]$";t.exports=r.default},{"./util/assertString":68}],38:[function(e,t,r){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(r,"__esModule",{value:!0});var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};r.default=function(e,t){(0,o.default)(e);var r=void 0;if("[object Array]"===Object.prototype.toString.call(t)){var i=[];for(r in t)({}).hasOwnProperty.call(t,r)&&(i[r]=(0,a.default)(t[r]));return i.indexOf(e)>=0}return"object"===(void 0===t?"undefined":n(t))?t.hasOwnProperty(e):!(!t||"function"!=typeof t.indexOf)&&t.indexOf(e)>=0};var o=i(e("./util/assertString")),a=i(e("./util/toString"));t.exports=r.default},{"./util/assertString":68,"./util/toString":70}],39:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t){(0,i.default)(e);var r=(t=t||{}).hasOwnProperty("allow_leading_zeroes")&&!t.allow_leading_zeroes?n:o,a=!t.hasOwnProperty("min")||e>=t.min,s=!t.hasOwnProperty("max")||e<=t.max,u=!t.hasOwnProperty("lt")||e<t.lt,l=!t.hasOwnProperty("gt")||e>t.gt;return r.test(e)&&a&&s&&u&&l};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=/^(?:[-+]?(?:0|[1-9][0-9]*))$/,o=/^[-+]?[0-9]+$/;t.exports=r.default},{"./util/assertString":68}],40:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};r.default=function(e){(0,n.default)(e);try{var t=JSON.parse(e);return!!t&&"object"===(void 0===t?"undefined":i(t))}catch(e){}return!1};var n=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString"));t.exports=r.default},{"./util/assertString":68}],41:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){if((0,i.default)(e),!e.includes(","))return!1;var t=e.split(",");return n.test(t[0])&&o.test(t[1])};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=/^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/,o=/^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/;t.exports=r.default},{"./util/assertString":68}],42:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};r.default=function(e,t){(0,n.default)(e);var r=void 0,o=void 0;"object"===(void 0===t?"undefined":i(t))?(r=t.min||0,o=t.max):(r=arguments[1],o=arguments[2]);var a=e.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g)||[],s=e.length-a.length;return s>=r&&(void 0===o||s<=o)};var n=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString"));t.exports=r.default},{"./util/assertString":68}],43:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,i.default)(e),e===e.toLowerCase()};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString"));t.exports=r.default},{"./util/assertString":68}],44:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,i.default)(e),n.test(e)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=/^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$/;t.exports=r.default},{"./util/assertString":68}],45:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,i.default)(e),n.test(e)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=/^[a-f0-9]{32}$/;t.exports=r.default},{"./util/assertString":68}],46:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t){if((0,i.default)(e),t in n)return n[t].test(e);if("any"===t){for(var r in n)if(n.hasOwnProperty(r)&&n[r].test(e))return!0;return!1}throw new Error("Invalid locale '"+t+"'")};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n={"ar-AE":/^((\+?971)|0)?5[024568]\d{7}$/,"ar-DZ":/^(\+?213|0)(5|6|7)\d{8}$/,"ar-EG":/^((\+?20)|0)?1[012]\d{8}$/,"ar-JO":/^(\+?962|0)?7[789]\d{7}$/,"ar-SY":/^(!?(\+?963)|0)?9\d{8}$/,"ar-SA":/^(!?(\+?966)|0)?5\d{8}$/,"en-US":/^(\+?1)?[2-9]\d{2}[2-9](?!11)\d{6}$/,"cs-CZ":/^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,"sk-SK":/^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,"de-DE":/^(\+?49[ \.\-])?([\(]{1}[0-9]{1,6}[\)])?([0-9 \.\-\/]{3,20})((x|ext|extension)[ ]?[0-9]{1,4})?$/,"da-DK":/^(\+?45)?(\d{8})$/,"el-GR":/^(\+?30)?(69\d{8})$/,"en-AU":/^(\+?61|0)4\d{8}$/,"en-GB":/^(\+?44|0)7\d{9}$/,"en-HK":/^(\+?852\-?)?[569]\d{3}\-?\d{4}$/,"en-IN":/^(\+?91|0)?[789]\d{9}$/,"en-KE":/^(\+?254|0)?[7]\d{8}$/,"en-NG":/^(\+?234|0)?[789]\d{9}$/,"en-NZ":/^(\+?64|0)2\d{7,9}$/,"en-UG":/^(\+?256|0)?[7]\d{8}$/,"en-RW":/^(\+?250|0)?[7]\d{8}$/,"en-TZ":/^(\+?255|0)?[67]\d{8}$/,"en-ZA":/^(\+?27|0)\d{9}$/,"en-ZM":/^(\+?26)?09[567]\d{7}$/,"es-ES":/^(\+?34)?(6\d{1}|7[1234])\d{7}$/,"fi-FI":/^(\+?358|0)\s?(4(0|1|2|4|5|6)?|50)\s?(\d\s?){4,8}\d$/,"fa-IR":/^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,"fr-FR":/^(\+?33|0)[67]\d{8}$/,"he-IL":/^(\+972|0)([23489]|5[0248]|77)[1-9]\d{6}/,"hu-HU":/^(\+?36)(20|30|70)\d{7}$/,"lt-LT":/^(\+370|8)\d{8}$/,"id-ID":/^(\+?62|0[1-9])[\s|\d]+$/,"it-IT":/^(\+?39)?\s?3\d{2} ?\d{6,7}$/,"ko-KR":/^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,"ja-JP":/^(\+?81|0)\d{1,4}[ \-]?\d{1,4}[ \-]?\d{4}$/,"ms-MY":/^(\+?6?01){1}(([145]{1}(\-|\s)?\d{7,8})|([236789]{1}(\s|\-)?\d{7}))$/,"nb-NO":/^(\+?47)?[49]\d{7}$/,"nl-BE":/^(\+?32|0)4?\d{8}$/,"nn-NO":/^(\+?47)?[49]\d{7}$/,"pl-PL":/^(\+?48)? ?[5-8]\d ?\d{3} ?\d{2} ?\d{2}$/,"pt-BR":/^(\+?55|0)\-?[1-9]{2}\-?[2-9]{1}\d{3,4}\-?\d{4}$/,"pt-PT":/^(\+?351)?9[1236]\d{7}$/,"ro-RO":/^(\+?4?0)\s?7\d{2}(\/|\s|\.|\-)?\d{3}(\s|\.|\-)?\d{3}$/,"en-PK":/^((\+92)|(0092))-{0,1}\d{3}-{0,1}\d{7}$|^\d{11}$|^\d{4}-\d{7}$/,"ru-RU":/^(\+?7|8)?9\d{9}$/,"sr-RS":/^(\+3816|06)[- \d]{5,9}$/,"tr-TR":/^(\+?90|0)?5\d{9}$/,"vi-VN":/^(\+?84|0)?((1(2([0-9])|6([2-9])|88|99))|(9((?!5)[0-9])))([0-9]{7})$/,"zh-CN":/^(\+?0?86\-?)?1[345789]\d{9}$/,"zh-TW":/^(\+?886\-?|0)?9\d{8}$/};n["en-CA"]=n["en-US"],n["fr-BE"]=n["nl-BE"],n["zh-HK"]=n["en-HK"],t.exports=r.default},{"./util/assertString":68}],47:[function(e,t,r){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,n.default)(e),(0,o.default)(e)&&24===e.length};var n=i(e("./util/assertString")),o=i(e("./isHexadecimal"));t.exports=r.default},{"./isHexadecimal":31,"./util/assertString":68}],48:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,i.default)(e),n.test(e)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=/[^\x00-\x7F]/;t.exports=r.default},{"./util/assertString":68}],49:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,i.default)(e),n.test(e)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=/^[-+]?[0-9]+$/;t.exports=r.default},{"./util/assertString":68}],50:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.locales=void 0,r.default=function(e,t){if((0,i.default)(e),t in s)return s[t].test(e);if("any"===t){for(var r in s)if(s.hasOwnProperty(r)&&s[r].test(e))return!0;return!1}throw new Error("Invalid locale '"+t+"'")};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=/^\d{4}$/,o=/^\d{5}$/,a=/^\d{6}$/,s={AT:n,AU:a,BE:n,CA:/^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,CH:n,CZ:/^\d{3}\s?\d{2}$/,DE:o,DK:n,DZ:o,ES:o,FI:o,FR:/^\d{2}\s?\d{3}$/,GB:/^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,GR:/^\d{3}\s?\d{2}$/,IL:o,IN:a,IS:/^\d{3}$/,IT:o,JP:/^\d{3}\-\d{4}$/,KE:o,LI:/^(948[5-9]|949[0-7])$/,MX:o,NL:/^\d{4}\s?[a-z]{2}$/i,NO:n,PL:/^\d{2}\-\d{3}$/,PT:/^\d{4}(\-\d{3})?$/,RO:a,RU:a,SA:o,SE:/^\d{3}\s?\d{2}$/,TW:/^\d{3}(\d{2})?$/,US:/^\d{5}(-\d{4})?$/,ZA:n,ZM:o};r.locales=Object.keys(s)},{"./util/assertString":68}],51:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,i.default)(e),n.test(e)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=/[\uD800-\uDBFF][\uDC00-\uDFFF]/;t.exports=r.default},{"./util/assertString":68}],52:[function(e,t,r){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}function n(e){return"[object RegExp]"===Object.prototype.toString.call(e)}function o(e,t){for(var r=0;r<t.length;r++){var i=t[r];if(e===i||n(i)&&i.test(e))return!0}return!1}Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t){if((0,a.default)(e),!e||e.length>=2083||/[\s<>]/.test(e))return!1;if(0===e.indexOf("mailto:"))return!1;t=(0,l.default)(t,f);var r=void 0,i=void 0,n=void 0,c=void 0,p=void 0,h=void 0,m=void 0,_=void 0;if(m=e.split("#"),e=m.shift(),m=e.split("?"),e=m.shift(),(m=e.split("://")).length>1){if(r=m.shift(),t.require_valid_protocol&&-1===t.protocols.indexOf(r))return!1}else{if(t.require_protocol)return!1;t.allow_protocol_relative_urls&&"//"===e.substr(0,2)&&(m[0]=e.substr(2))}if(""===(e=m.join("://")))return!1;if(m=e.split("/"),""===(e=m.shift())&&!t.require_host)return!0;if((m=e.split("@")).length>1&&(i=m.shift()).indexOf(":")>=0&&i.split(":").length>2)return!1;h=null,_=null;var y=(c=m.join("@")).match(d);return y?(n="",_=y[1],h=y[2]||null):(n=(m=c.split(":")).shift(),m.length&&(h=m.join(":"))),!(null!==h&&(p=parseInt(h,10),!/^[0-9]+$/.test(h)||p<=0||p>65535)||!((0,u.default)(n)||(0,s.default)(n,t)||_&&(0,u.default)(_,6))||(n=n||_,t.host_whitelist&&!o(n,t.host_whitelist)||t.host_blacklist&&o(n,t.host_blacklist)))};var a=i(e("./util/assertString")),s=i(e("./isFQDN")),u=i(e("./isIP")),l=i(e("./util/merge")),f={protocols:["http","https","ftp"],require_tld:!0,require_protocol:!1,require_host:!0,require_valid_protocol:!0,allow_underscores:!1,allow_trailing_dot:!1,allow_protocol_relative_urls:!1},d=/^\[([^\]]+)\](?::([0-9]+))?$/;t.exports=r.default},{"./isFQDN":25,"./isIP":32,"./util/assertString":68,"./util/merge":69}],53:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"all";(0,i.default)(e);var r=n[t];return r&&r.test(e)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n={3:/^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,4:/^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,5:/^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,all:/^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i};t.exports=r.default},{"./util/assertString":68}],54:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,i.default)(e),e===e.toUpperCase()};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString"));t.exports=r.default},{"./util/assertString":68}],55:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,i.default)(e),n.fullWidth.test(e)&&o.halfWidth.test(e)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString")),n=e("./isFullWidth"),o=e("./isHalfWidth");t.exports=r.default},{"./isFullWidth":27,"./isHalfWidth":28,"./util/assertString":68}],56:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t){(0,i.default)(e);for(var r=e.length-1;r>=0;r--)if(-1===t.indexOf(e[r]))return!1;return!0};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString"));t.exports=r.default},{"./util/assertString":68}],57:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t){(0,i.default)(e);var r=t?new RegExp("^["+t+"]+","g"):/^\s+/g;return e.replace(r,"")};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString"));t.exports=r.default},{"./util/assertString":68}],58:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t,r){return(0,i.default)(e),"[object RegExp]"!==Object.prototype.toString.call(t)&&(t=new RegExp(t,r)),t.test(e)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString"));t.exports=r.default},{"./util/assertString":68}],59:[function(e,t,r){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t){if(t=(0,o.default)(t,a),!(0,n.default)(e))return!1;var r=e.split("@"),i=r.pop(),f=[r.join("@"),i];if(f[1]=f[1].toLowerCase(),"gmail.com"===f[1]||"googlemail.com"===f[1]){if(t.gmail_remove_subaddress&&(f[0]=f[0].split("+")[0]),t.gmail_remove_dots&&(f[0]=f[0].replace(/\./g,"")),!f[0].length)return!1;(t.all_lowercase||t.gmail_lowercase)&&(f[0]=f[0].toLowerCase()),f[1]=t.gmail_convert_googlemaildotcom?"gmail.com":f[1]}else if(~s.indexOf(f[1])){if(t.icloud_remove_subaddress&&(f[0]=f[0].split("+")[0]),!f[0].length)return!1;(t.all_lowercase||t.icloud_lowercase)&&(f[0]=f[0].toLowerCase())}else if(~u.indexOf(f[1])){if(t.outlookdotcom_remove_subaddress&&(f[0]=f[0].split("+")[0]),!f[0].length)return!1;(t.all_lowercase||t.outlookdotcom_lowercase)&&(f[0]=f[0].toLowerCase())}else if(~l.indexOf(f[1])){if(t.yahoo_remove_subaddress){var d=f[0].split("-");f[0]=d.length>1?d.slice(0,-1).join("-"):d[0]}if(!f[0].length)return!1;(t.all_lowercase||t.yahoo_lowercase)&&(f[0]=f[0].toLowerCase())}else t.all_lowercase&&(f[0]=f[0].toLowerCase());return f.join("@")};var n=i(e("./isEmail")),o=i(e("./util/merge")),a={all_lowercase:!0,gmail_lowercase:!0,gmail_remove_dots:!0,gmail_remove_subaddress:!0,gmail_convert_googlemaildotcom:!0,outlookdotcom_lowercase:!0,outlookdotcom_remove_subaddress:!0,yahoo_lowercase:!0,yahoo_remove_subaddress:!0,icloud_lowercase:!0,icloud_remove_subaddress:!0},s=["icloud.com","me.com"],u=["hotmail.at","hotmail.be","hotmail.ca","hotmail.cl","hotmail.co.il","hotmail.co.nz","hotmail.co.th","hotmail.co.uk","hotmail.com","hotmail.com.ar","hotmail.com.au","hotmail.com.br","hotmail.com.gr","hotmail.com.mx","hotmail.com.pe","hotmail.com.tr","hotmail.com.vn","hotmail.cz","hotmail.de","hotmail.dk","hotmail.es","hotmail.fr","hotmail.hu","hotmail.id","hotmail.ie","hotmail.in","hotmail.it","hotmail.jp","hotmail.kr","hotmail.lv","hotmail.my","hotmail.ph","hotmail.pt","hotmail.sa","hotmail.sg","hotmail.sk","live.be","live.co.uk","live.com","live.com.ar","live.com.mx","live.de","live.es","live.eu","live.fr","live.it","live.nl","msn.com","outlook.at","outlook.be","outlook.cl","outlook.co.il","outlook.co.nz","outlook.co.th","outlook.com","outlook.com.ar","outlook.com.au","outlook.com.br","outlook.com.gr","outlook.com.pe","outlook.com.tr","outlook.com.vn","outlook.cz","outlook.de","outlook.dk","outlook.es","outlook.fr","outlook.hu","outlook.id","outlook.ie","outlook.in","outlook.it","outlook.jp","outlook.kr","outlook.lv","outlook.my","outlook.ph","outlook.pt","outlook.sa","outlook.sg","outlook.sk","passport.com"],l=["rocketmail.com","yahoo.ca","yahoo.co.uk","yahoo.com","yahoo.de","yahoo.fr","yahoo.in","yahoo.it","ymail.com"];t.exports=r.default},{"./isEmail":23,"./util/merge":69}],60:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t){(0,i.default)(e);for(var r=t?new RegExp("["+t+"]"):/\s/,n=e.length-1;n>=0&&r.test(e[n]);)n--;return n<e.length?e.substr(0,n+1):e};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString"));t.exports=r.default},{"./util/assertString":68}],61:[function(e,t,r){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t){(0,n.default)(e);var r=t?"\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F":"\\x00-\\x1F\\x7F";return(0,o.default)(e,r)};var n=i(e("./util/assertString")),o=i(e("./blacklist"));t.exports=r.default},{"./blacklist":6,"./util/assertString":68}],62:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t){return(0,i.default)(e),t?"1"===e||"true"===e:"0"!==e&&"false"!==e&&""!==e};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString"));t.exports=r.default},{"./util/assertString":68}],63:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,i.default)(e),e=Date.parse(e),isNaN(e)?null:new Date(e)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString"));t.exports=r.default},{"./util/assertString":68}],64:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,i.default)(e),parseFloat(e)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString"));t.exports=r.default},{"./util/assertString":68}],65:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t){return(0,i.default)(e),parseInt(e,t||10)};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString"));t.exports=r.default},{"./util/assertString":68}],66:[function(e,t,r){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t){return(0,n.default)((0,o.default)(e,t),t)};var n=i(e("./rtrim")),o=i(e("./ltrim"));t.exports=r.default},{"./ltrim":57,"./rtrim":60}],67:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){return(0,i.default)(e),e.replace(/&amp;/g,"&").replace(/&quot;/g,'"').replace(/&#x27;/g,"'").replace(/&lt;/g,"<").replace(/&gt;/g,">").replace(/&#x2F;/g,"/").replace(/&#x5C;/g,"\\").replace(/&#96;/g,"`")};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString"));t.exports=r.default},{"./util/assertString":68}],68:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e){if(!("string"==typeof e||e instanceof String))throw new TypeError("This library (validator.js) validates strings only")},t.exports=r.default},{}],69:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments[1];for(var r in t)void 0===e[r]&&(e[r]=t[r]);return e},t.exports=r.default},{}],70:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};r.default=function(e){return"object"===(void 0===e?"undefined":i(e))&&null!==e?e="function"==typeof e.toString?e.toString():"[object Object]":(null===e||void 0===e||isNaN(e)&&!e.length)&&(e=""),String(e)},t.exports=r.default},{}],71:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.default=function(e,t){return(0,i.default)(e),e.replace(new RegExp("[^"+t+"]+","g"),"")};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("./util/assertString"));t.exports=r.default},{"./util/assertString":68}],72:[function(e,t,r){"use strict";t.exports={INVALID_TYPE:"Expected type {0} but found type {1}",INVALID_FORMAT:"Object didn't pass validation for format {0}: {1}",ENUM_MISMATCH:"No enum match for: {0}",ANY_OF_MISSING:"Data does not match any schemas from 'anyOf'",ONE_OF_MISSING:"Data does not match any schemas from 'oneOf'",ONE_OF_MULTIPLE:"Data is valid against more than one schema from 'oneOf'",NOT_PASSED:"Data matches schema from 'not'",ARRAY_LENGTH_SHORT:"Array is too short ({0}), minimum {1}",ARRAY_LENGTH_LONG:"Array is too long ({0}), maximum {1}",ARRAY_UNIQUE:"Array items are not unique (indexes {0} and {1})",ARRAY_ADDITIONAL_ITEMS:"Additional items not allowed",MULTIPLE_OF:"Value {0} is not a multiple of {1}",MINIMUM:"Value {0} is less than minimum {1}",MINIMUM_EXCLUSIVE:"Value {0} is equal or less than exclusive minimum {1}",MAXIMUM:"Value {0} is greater than maximum {1}",MAXIMUM_EXCLUSIVE:"Value {0} is equal or greater than exclusive maximum {1}",OBJECT_PROPERTIES_MINIMUM:"Too few properties defined ({0}), minimum {1}",OBJECT_PROPERTIES_MAXIMUM:"Too many properties defined ({0}), maximum {1}",OBJECT_MISSING_REQUIRED_PROPERTY:"Missing required property: {0}",OBJECT_ADDITIONAL_PROPERTIES:"Additional properties not allowed: {0}",OBJECT_DEPENDENCY_KEY:"Dependency failed - key must exist: {0} (due to key: {1})",MIN_LENGTH:"String is too short ({0} chars), minimum {1}",MAX_LENGTH:"String is too long ({0} chars), maximum {1}",PATTERN:"String does not match pattern {0}: {1}",KEYWORD_TYPE_EXPECTED:"Keyword '{0}' is expected to be of type '{1}'",KEYWORD_UNDEFINED_STRICT:"Keyword '{0}' must be defined in strict mode",KEYWORD_UNEXPECTED:"Keyword '{0}' is not expected to appear in the schema",KEYWORD_MUST_BE:"Keyword '{0}' must be {1}",KEYWORD_DEPENDENCY:"Keyword '{0}' requires keyword '{1}'",KEYWORD_PATTERN:"Keyword '{0}' is not a valid RegExp pattern: {1}",KEYWORD_VALUE_TYPE:"Each element of keyword '{0}' array must be a '{1}'",UNKNOWN_FORMAT:"There is no validation function for format '{0}'",CUSTOM_MODE_FORCE_PROPERTIES:"{0} must define at least one property if present",REF_UNRESOLVED:"Reference has not been resolved during compilation: {0}",UNRESOLVABLE_REFERENCE:"Reference could not be resolved: {0}",SCHEMA_NOT_REACHABLE:"Validator was not able to read schema with uri: {0}",SCHEMA_TYPE_EXPECTED:"Schema is expected to be of type 'object'",SCHEMA_NOT_AN_OBJECT:"Schema is not an object: {0}",ASYNC_TIMEOUT:"{0} asynchronous task(s) have timed out after {1} ms",PARENT_SCHEMA_VALIDATION_FAILED:"Schema failed to validate against its parent schema, see inner errors for details.",REMOTE_NOT_VALID:"Remote reference didn't compile successfully: {0}"}},{}],73:[function(e,t,r){var i=e("validator"),n={date:function(e){if("string"!=typeof e)return!0;var t=/^([0-9]{4})-([0-9]{2})-([0-9]{2})$/.exec(e);return null!==t&&!(t[2]<"01"||t[2]>"12"||t[3]<"01"||t[3]>"31")},"date-time":function(e){if("string"!=typeof e)return!0;var t=e.toLowerCase().split("t");if(!n.date(t[0]))return!1;var r=/^([0-9]{2}):([0-9]{2}):([0-9]{2})(.[0-9]+)?(z|([+-][0-9]{2}:[0-9]{2}))$/.exec(t[1]);return null!==r&&!(r[1]>"23"||r[2]>"59"||r[3]>"59")},email:function(e){return"string"!=typeof e||i.isEmail(e,{require_tld:!0})},hostname:function(e){if("string"!=typeof e)return!0;var t=/^[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?(\.[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?)*$/.test(e);if(t){if(e.length>255)return!1;for(var r=e.split("."),i=0;i<r.length;i++)if(r[i].length>63)return!1}return t},"host-name":function(e){return n.hostname.call(this,e)},ipv4:function(e){return"string"!=typeof e||i.isIP(e,4)},ipv6:function(e){return"string"!=typeof e||i.isIP(e,6)},regex:function(e){try{return RegExp(e),!0}catch(e){return!1}},uri:function(e){return this.options.strictUris?n["strict-uri"].apply(this,arguments):"string"!=typeof e||RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?").test(e)},"strict-uri":function(e){return"string"!=typeof e||i.isURL(e)}};t.exports=n},{validator:4}],74:[function(e,t,r){"use strict";var i=e("./FormatValidators"),n=e("./Report"),o=e("./Utils"),a={multipleOf:function(e,t,r){"number"==typeof r&&"integer"!==o.whatIs(r/t.multipleOf)&&e.addError("MULTIPLE_OF",[r,t.multipleOf],null,t.description)},maximum:function(e,t,r){"number"==typeof r&&(!0!==t.exclusiveMaximum?r>t.maximum&&e.addError("MAXIMUM",[r,t.maximum],null,t.description):r>=t.maximum&&e.addError("MAXIMUM_EXCLUSIVE",[r,t.maximum],null,t.description))},exclusiveMaximum:function(){},minimum:function(e,t,r){"number"==typeof r&&(!0!==t.exclusiveMinimum?r<t.minimum&&e.addError("MINIMUM",[r,t.minimum],null,t.description):r<=t.minimum&&e.addError("MINIMUM_EXCLUSIVE",[r,t.minimum],null,t.description))},exclusiveMinimum:function(){},maxLength:function(e,t,r){"string"==typeof r&&o.ucs2decode(r).length>t.maxLength&&e.addError("MAX_LENGTH",[r.length,t.maxLength],null,t.description)},minLength:function(e,t,r){"string"==typeof r&&o.ucs2decode(r).length<t.minLength&&e.addError("MIN_LENGTH",[r.length,t.minLength],null,t.description)},pattern:function(e,t,r){"string"==typeof r&&!1===RegExp(t.pattern).test(r)&&e.addError("PATTERN",[t.pattern,r],null,t.description)},additionalItems:function(e,t,r){Array.isArray(r)&&!1===t.additionalItems&&Array.isArray(t.items)&&r.length>t.items.length&&e.addError("ARRAY_ADDITIONAL_ITEMS",null,null,t.description)},items:function(){},maxItems:function(e,t,r){Array.isArray(r)&&r.length>t.maxItems&&e.addError("ARRAY_LENGTH_LONG",[r.length,t.maxItems],null,t.description)},minItems:function(e,t,r){Array.isArray(r)&&r.length<t.minItems&&e.addError("ARRAY_LENGTH_SHORT",[r.length,t.minItems],null,t.description)},uniqueItems:function(e,t,r){if(Array.isArray(r)&&!0===t.uniqueItems){var i=[];!1===o.isUniqueArray(r,i)&&e.addError("ARRAY_UNIQUE",i,null,t.description)}},maxProperties:function(e,t,r){if("object"===o.whatIs(r)){var i=Object.keys(r).length;i>t.maxProperties&&e.addError("OBJECT_PROPERTIES_MAXIMUM",[i,t.maxProperties],null,t.description)}},minProperties:function(e,t,r){if("object"===o.whatIs(r)){var i=Object.keys(r).length;i<t.minProperties&&e.addError("OBJECT_PROPERTIES_MINIMUM",[i,t.minProperties],null,t.description)}},required:function(e,t,r){if("object"===o.whatIs(r))for(var i=t.required.length;i--;){var n=t.required[i];void 0===r[n]&&e.addError("OBJECT_MISSING_REQUIRED_PROPERTY",[n],null,t.description)}},additionalProperties:function(e,t,r){if(void 0===t.properties&&void 0===t.patternProperties)return a.properties.call(this,e,t,r)},patternProperties:function(e,t,r){if(void 0===t.properties)return a.properties.call(this,e,t,r)},properties:function(e,t,r){if("object"===o.whatIs(r)){var i=void 0!==t.properties?t.properties:{},n=void 0!==t.patternProperties?t.patternProperties:{};if(!1===t.additionalProperties){var a=Object.keys(r),s=Object.keys(i),u=Object.keys(n);a=o.difference(a,s);for(var l=u.length;l--;)for(var f=RegExp(u[l]),d=a.length;d--;)!0===f.test(a[d])&&a.splice(d,1);if(a.length>0){var c=this.options.assumeAdditional.length;if(c)for(;c--;){var p=a.indexOf(this.options.assumeAdditional[c]);-1!==p&&a.splice(p,1)}a.length>0&&e.addError("OBJECT_ADDITIONAL_PROPERTIES",[a],null,t.description)}}}},dependencies:function(e,t,i){if("object"===o.whatIs(i))for(var n=Object.keys(t.dependencies),a=n.length;a--;){var s=n[a];if(i[s]){var u=t.dependencies[s];if("object"===o.whatIs(u))r.validate.call(this,e,u,i);else for(var l=u.length;l--;){var f=u[l];void 0===i[f]&&e.addError("OBJECT_DEPENDENCY_KEY",[f,s],null,t.description)}}}},enum:function(e,t,r){for(var i=!1,n=t.enum.length;n--;)if(o.areEqual(r,t.enum[n])){i=!0;break}!1===i&&e.addError("ENUM_MISMATCH",[r],null,t.description)},allOf:function(e,t,i){for(var n=t.allOf.length;n--;){var o=r.validate.call(this,e,t.allOf[n],i);if(this.options.breakOnFirstError&&!1===o)break}},anyOf:function(e,t,i){for(var o=[],a=!1,s=t.anyOf.length;s--&&!1===a;){var u=new n(e);o.push(u),a=r.validate.call(this,u,t.anyOf[s],i)}!1===a&&e.addError("ANY_OF_MISSING",void 0,o,t.description)},oneOf:function(e,t,i){for(var o=0,a=[],s=t.oneOf.length;s--;){var u=new n(e,{maxErrors:1});a.push(u),!0===r.validate.call(this,u,t.oneOf[s],i)&&o++}0===o?e.addError("ONE_OF_MISSING",void 0,a,t.description):o>1&&e.addError("ONE_OF_MULTIPLE",null,null,t.description)},not:function(e,t,i){var o=new n(e);!0===r.validate.call(this,o,t.not,i)&&e.addError("NOT_PASSED",null,null,t.description)},definitions:function(){},format:function(e,t,r){var n=i[t.format];"function"==typeof n?2===n.length?e.addAsyncTask(n,[r],function(i){!0!==i&&e.addError("INVALID_FORMAT",[t.format,r],null,t.description)}):!0!==n.call(this,r)&&e.addError("INVALID_FORMAT",[t.format,r],null,t.description):!0!==this.options.ignoreUnknownFormats&&e.addError("UNKNOWN_FORMAT",[t.format],null,t.description)}},s=function(e,t,i){var n=i.length;if(Array.isArray(t.items))for(;n--;)n<t.items.length?(e.path.push(n.toString()),r.validate.call(this,e,t.items[n],i[n]),e.path.pop()):"object"==typeof t.additionalItems&&(e.path.push(n.toString()),r.validate.call(this,e,t.additionalItems,i[n]),e.path.pop());else if("object"==typeof t.items)for(;n--;)e.path.push(n.toString()),r.validate.call(this,e,t.items,i[n]),e.path.pop()},u=function(e,t,i){var n=t.additionalProperties;!0!==n&&void 0!==n||(n={});for(var o=t.properties?Object.keys(t.properties):[],a=t.patternProperties?Object.keys(t.patternProperties):[],s=Object.keys(i),u=s.length;u--;){var l=s[u],f=i[l],d=[];-1!==o.indexOf(l)&&d.push(t.properties[l]);for(var c=a.length;c--;){var p=a[c];!0===RegExp(p).test(l)&&d.push(t.patternProperties[p])}for(0===d.length&&!1!==n&&d.push(n),c=d.length;c--;)e.path.push(l),r.validate.call(this,e,d[c],f),e.path.pop()}};r.validate=function(e,t,r){e.commonErrorMessage="JSON_OBJECT_VALIDATION_FAILED";var i=o.whatIs(t);if("object"!==i)return e.addError("SCHEMA_NOT_AN_OBJECT",[i],null,t.description),!1;var n=Object.keys(t);if(0===n.length)return!0;var l=!1;if(e.rootSchema||(e.rootSchema=t,l=!0),void 0!==t.$ref){for(var f=99;t.$ref&&f>0;){if(!t.__$refResolved){e.addError("REF_UNRESOLVED",[t.$ref],null,t.description);break}if(t.__$refResolved===t)break;t=t.__$refResolved,n=Object.keys(t),f--}if(0===f)throw new Error("Circular dependency by $ref references!")}var d=o.whatIs(r);if(t.type)if("string"==typeof t.type){if(d!==t.type&&("integer"!==d||"number"!==t.type)&&(e.addError("INVALID_TYPE",[t.type,d],null,t.description),this.options.breakOnFirstError))return!1}else if(-1===t.type.indexOf(d)&&("integer"!==d||-1===t.type.indexOf("number"))&&(e.addError("INVALID_TYPE",[t.type,d],null,t.description),this.options.breakOnFirstError))return!1;for(var c=n.length;c--&&!(a[n[c]]&&(a[n[c]].call(this,e,t,r),e.errors.length&&this.options.breakOnFirstError)););return 0!==e.errors.length&&!1!==this.options.breakOnFirstError||("array"===d?s.call(this,e,t,r):"object"===d&&u.call(this,e,t,r)),"function"==typeof this.options.customValidator&&this.options.customValidator(e,t,r),l&&(e.rootSchema=void 0),0===e.errors.length}},{"./FormatValidators":73,"./Report":76,"./Utils":80}],75:[function(e,t,r){"function"!=typeof Number.isFinite&&(Number.isFinite=function(e){return"number"==typeof e&&(e===e&&e!==1/0&&e!==-1/0)})},{}],76:[function(e,t,r){(function(r){"use strict";function i(e,t){this.parentReport=e instanceof i?e:void 0,this.options=e instanceof i?e.options:e||{},this.reportOptions=t||{},this.errors=[],this.path=[],this.asyncTasks=[]}var n=e("lodash.get"),o=e("./Errors"),a=e("./Utils");i.prototype.isValid=function(){if(this.asyncTasks.length>0)throw new Error("Async tasks pending, can't answer isValid");return 0===this.errors.length},i.prototype.addAsyncTask=function(e,t,r){this.asyncTasks.push([e,t,r])},i.prototype.processAsyncTasks=function(e,t){function i(){r.nextTick(function(){var e=0===u.errors.length,r=e?void 0:u.errors;t(r,e)})}var n=e||2e3,o=this.asyncTasks.length,a=o,s=!1,u=this;if(0===o||this.errors.length>0)i();else{for(;a--;){var l=this.asyncTasks[a];l[0].apply(null,l[1].concat(function(e){return function(t){s||(e(t),0==--o&&i())}}(l[2])))}setTimeout(function(){o>0&&(s=!0,u.addError("ASYNC_TIMEOUT",[o,n]),t(u.errors,!1))},n)}},i.prototype.getPath=function(e){var t=[];return this.parentReport&&(t=t.concat(this.parentReport.path)),t=t.concat(this.path),!0!==e&&(t="#/"+t.map(function(e){return a.isAbsoluteUri(e)?"uri("+e+")":e.replace(/\~/g,"~0").replace(/\//g,"~1")}).join("/")),t},i.prototype.getSchemaId=function(){if(!this.rootSchema)return null;var e=[];for(this.parentReport&&(e=e.concat(this.parentReport.path)),e=e.concat(this.path);e.length>0;){var t=n(this.rootSchema,e);if(t&&t.id)return t.id;e.pop()}return this.rootSchema.id},i.prototype.hasError=function(e,t){for(var r=this.errors.length;r--;)if(this.errors[r].code===e){for(var i=!0,n=this.errors[r].params.length;n--;)this.errors[r].params[n]!==t[n]&&(i=!1);if(i)return i}return!1},i.prototype.addError=function(e,t,r,i){if(!e)throw new Error("No errorCode passed into addError()");this.addCustomError(e,o[e],t,r,i)},i.prototype.addCustomError=function(e,t,r,i,n){if(!(this.errors.length>=this.reportOptions.maxErrors)){if(!t)throw new Error("No errorMessage known for code "+e);for(var o=(r=r||[]).length;o--;){var s=a.whatIs(r[o]),u="object"===s||"null"===s?JSON.stringify(r[o]):r[o];t=t.replace("{"+o+"}",u)}var l={code:e,params:r,message:t,path:this.getPath(this.options.reportPathAsArray),schemaId:this.getSchemaId()};if(n&&(l.description=n),null!=i){for(Array.isArray(i)||(i=[i]),l.inner=[],o=i.length;o--;)for(var f=i[o],d=f.errors.length;d--;)l.inner.push(f.errors[d]);0===l.inner.length&&(l.inner=void 0)}this.errors.push(l)}},t.exports=i}).call(this,e("_process"))},{"./Errors":72,"./Utils":80,_process:3,"lodash.get":1}],77:[function(e,t,r){"use strict";function i(e){return decodeURIComponent(e).replace(/~[0-1]/g,function(e){return"~1"===e?"/":"~"})}function n(e){var t=e.indexOf("#");return-1===t?e:e.slice(0,t)}function o(e){var t=e.indexOf("#");return-1===t?void 0:e.slice(t+1)}function a(e,t){if("object"==typeof e&&null!==e){if(!t)return e;if(e.id&&(e.id===t||"#"===e.id[0]&&e.id.substring(1)===t))return e;var r,i;if(Array.isArray(e)){for(r=e.length;r--;)if(i=a(e[r],t))return i}else{var n=Object.keys(e);for(r=n.length;r--;){var o=n[r];if(0!==o.indexOf("__$")&&(i=a(e[o],t)))return i}}}}var s=e("lodash.isequal"),u=e("./Report"),l=e("./SchemaCompilation"),f=e("./SchemaValidation"),d=e("./Utils");r.cacheSchemaByUri=function(e,t){var r=n(e);r&&(this.cache[r]=t)},r.removeFromCacheByUri=function(e){var t=n(e);t&&delete this.cache[t]},r.checkCacheForUri=function(e){var t=n(e);return!!t&&null!=this.cache[t]},r.getSchema=function(e,t){return"object"==typeof t&&(t=r.getSchemaByReference.call(this,e,t)),"string"==typeof t&&(t=r.getSchemaByUri.call(this,e,t)),t},r.getSchemaByReference=function(e,t){for(var r=this.referenceCache.length;r--;)if(s(this.referenceCache[r][0],t))return this.referenceCache[r][1];var i=d.cloneDeep(t);return this.referenceCache.push([t,i]),i},r.getSchemaByUri=function(e,t,r){var s=n(t),d=o(t),c=s?this.cache[s]:r;if(c&&s&&c!==r){e.path.push(s);var p=new u(e);l.compileSchema.call(this,p,c)&&f.validateSchema.call(this,p,c);var h=p.isValid();if(h||e.addError("REMOTE_NOT_VALID",[t],p),e.path.pop(),!h)return}if(c&&d)for(var m=d.split("/"),_=0,y=m.length;c&&_<y;_++){var g=i(m[_]);c=0===_?a(c,g):c[g]}return c},r.getRemotePath=n},{"./Report":76,"./SchemaCompilation":78,"./SchemaValidation":79,"./Utils":80,"lodash.isequal":2}],78:[function(e,t,r){"use strict";function i(e,t){if(u.isAbsoluteUri(t))return t;var r,i=e.join(""),n=u.isAbsoluteUri(i),o=u.isRelativeUri(i),a=u.isRelativeUri(t);n&&a?(r=i.match(/\/[^\/]*$/))&&(i=i.slice(0,r.index+1)):o&&a?i="":(r=i.match(/[^#/]+$/))&&(i=i.slice(0,r.index));var s=i+t;return s=s.replace(/##/,"#")}function n(e,t,r,o){if(t=t||[],r=r||[],o=o||[],"object"!=typeof e||null===e)return t;"string"==typeof e.id&&r.push(e.id),"string"==typeof e.$ref&&void 0===e.__$refResolved&&t.push({ref:i(r,e.$ref),key:"$ref",obj:e,path:o.slice(0)}),"string"==typeof e.$schema&&void 0===e.__$schemaResolved&&t.push({ref:i(r,e.$schema),key:"$schema",obj:e,path:o.slice(0)});var a;if(Array.isArray(e))for(a=e.length;a--;)o.push(a.toString()),n(e[a],t,r,o),o.pop();else{var s=Object.keys(e);for(a=s.length;a--;)0!==s[a].indexOf("__$")&&(o.push(s[a]),n(e[s[a]],t,r,o),o.pop())}return"string"==typeof e.id&&r.pop(),t}function o(e,t){for(var r=e.length;r--;)if(e[r].id===t)return e[r];return null}var a=e("./Report"),s=e("./SchemaCache"),u=e("./Utils"),l=function(e,t){for(var i=t.length,n=0;i--;){var o=new a(e);r.compileSchema.call(this,o,t[i])&&n++,e.errors=e.errors.concat(o.errors)}return n},f=function(e,t){var r,i=0;do{for(var n=e.errors.length;n--;)"UNRESOLVABLE_REFERENCE"===e.errors[n].code&&e.errors.splice(n,1);for(r=i,i=l.call(this,e,t),n=t.length;n--;){var a=t[n];if(a.__$missingReferences){for(var s=a.__$missingReferences.length;s--;){var u=a.__$missingReferences[s],f=o(t,u.ref);f&&(u.obj["__"+u.key+"Resolved"]=f,a.__$missingReferences.splice(s,1))}0===a.__$missingReferences.length&&delete a.__$missingReferences}}}while(i!==t.length&&i!==r);return e.isValid()};r.compileSchema=function(e,t){if(e.commonErrorMessage="SCHEMA_COMPILATION_FAILED","string"==typeof t){var i=s.getSchemaByUri.call(this,e,t);if(!i)return e.addError("SCHEMA_NOT_REACHABLE",[t]),!1;t=i}if(Array.isArray(t))return f.call(this,e,t);if(t.__$compiled&&t.id&&!1===s.checkCacheForUri.call(this,t.id)&&(t.__$compiled=void 0),t.__$compiled)return!0;t.id&&"string"==typeof t.id&&s.cacheSchemaByUri.call(this,t.id,t);var o=!1;e.rootSchema||(e.rootSchema=t,o=!0);var l=e.isValid();delete t.__$missingReferences;for(var d=n.call(this,t),c=d.length;c--;){var p=d[c],h=s.getSchemaByUri.call(this,e,p.ref,t);if(!h){var m=this.getSchemaReader();if(m){var _=m(p.ref);if(_){_.id=p.ref;var y=new a(e);r.compileSchema.call(this,y,_)?h=s.getSchemaByUri.call(this,e,p.ref,t):e.errors=e.errors.concat(y.errors)}}}if(!h){var g=e.hasError("REMOTE_NOT_VALID",[p.ref]),v=u.isAbsoluteUri(p.ref),E=!1,b=!0===this.options.ignoreUnresolvableReferences;v&&(E=s.checkCacheForUri.call(this,p.ref)),g||b&&v||E||(Array.prototype.push.apply(e.path,p.path),e.addError("UNRESOLVABLE_REFERENCE",[p.ref]),e.path=e.path.slice(0,-p.path.length),l&&(t.__$missingReferences=t.__$missingReferences||[],t.__$missingReferences.push(p)))}p.obj["__"+p.key+"Resolved"]=h}var O=e.isValid();return O?t.__$compiled=!0:t.id&&"string"==typeof t.id&&s.removeFromCacheByUri.call(this,t.id),o&&(e.rootSchema=void 0),O}},{"./Report":76,"./SchemaCache":77,"./Utils":80}],79:[function(e,t,r){"use strict";var i=e("./FormatValidators"),n=e("./JsonValidation"),o=e("./Report"),a=e("./Utils"),s={$ref:function(e,t){"string"!=typeof t.$ref&&e.addError("KEYWORD_TYPE_EXPECTED",["$ref","string"])},$schema:function(e,t){"string"!=typeof t.$schema&&e.addError("KEYWORD_TYPE_EXPECTED",["$schema","string"])},multipleOf:function(e,t){"number"!=typeof t.multipleOf?e.addError("KEYWORD_TYPE_EXPECTED",["multipleOf","number"]):t.multipleOf<=0&&e.addError("KEYWORD_MUST_BE",["multipleOf","strictly greater than 0"])},maximum:function(e,t){"number"!=typeof t.maximum&&e.addError("KEYWORD_TYPE_EXPECTED",["maximum","number"])},exclusiveMaximum:function(e,t){"boolean"!=typeof t.exclusiveMaximum?e.addError("KEYWORD_TYPE_EXPECTED",["exclusiveMaximum","boolean"]):void 0===t.maximum&&e.addError("KEYWORD_DEPENDENCY",["exclusiveMaximum","maximum"])},minimum:function(e,t){"number"!=typeof t.minimum&&e.addError("KEYWORD_TYPE_EXPECTED",["minimum","number"])},exclusiveMinimum:function(e,t){"boolean"!=typeof t.exclusiveMinimum?e.addError("KEYWORD_TYPE_EXPECTED",["exclusiveMinimum","boolean"]):void 0===t.minimum&&e.addError("KEYWORD_DEPENDENCY",["exclusiveMinimum","minimum"])},maxLength:function(e,t){"integer"!==a.whatIs(t.maxLength)?e.addError("KEYWORD_TYPE_EXPECTED",["maxLength","integer"]):t.maxLength<0&&e.addError("KEYWORD_MUST_BE",["maxLength","greater than, or equal to 0"])},minLength:function(e,t){"integer"!==a.whatIs(t.minLength)?e.addError("KEYWORD_TYPE_EXPECTED",["minLength","integer"]):t.minLength<0&&e.addError("KEYWORD_MUST_BE",["minLength","greater than, or equal to 0"])},pattern:function(e,t){if("string"!=typeof t.pattern)e.addError("KEYWORD_TYPE_EXPECTED",["pattern","string"]);else try{RegExp(t.pattern)}catch(r){e.addError("KEYWORD_PATTERN",["pattern",t.pattern])}},additionalItems:function(e,t){var i=a.whatIs(t.additionalItems);"boolean"!==i&&"object"!==i?e.addError("KEYWORD_TYPE_EXPECTED",["additionalItems",["boolean","object"]]):"object"===i&&(e.path.push("additionalItems"),r.validateSchema.call(this,e,t.additionalItems),e.path.pop())},items:function(e,t){var i=a.whatIs(t.items);if("object"===i)e.path.push("items"),r.validateSchema.call(this,e,t.items),e.path.pop();else if("array"===i)for(var n=t.items.length;n--;)e.path.push("items"),e.path.push(n.toString()),r.validateSchema.call(this,e,t.items[n]),e.path.pop(),e.path.pop();else e.addError("KEYWORD_TYPE_EXPECTED",["items",["array","object"]]);!0===this.options.forceAdditional&&void 0===t.additionalItems&&Array.isArray(t.items)&&e.addError("KEYWORD_UNDEFINED_STRICT",["additionalItems"]),this.options.assumeAdditional&&void 0===t.additionalItems&&Array.isArray(t.items)&&(t.additionalItems=!1)},maxItems:function(e,t){"number"!=typeof t.maxItems?e.addError("KEYWORD_TYPE_EXPECTED",["maxItems","integer"]):t.maxItems<0&&e.addError("KEYWORD_MUST_BE",["maxItems","greater than, or equal to 0"])},minItems:function(e,t){"integer"!==a.whatIs(t.minItems)?e.addError("KEYWORD_TYPE_EXPECTED",["minItems","integer"]):t.minItems<0&&e.addError("KEYWORD_MUST_BE",["minItems","greater than, or equal to 0"])},uniqueItems:function(e,t){"boolean"!=typeof t.uniqueItems&&e.addError("KEYWORD_TYPE_EXPECTED",["uniqueItems","boolean"])},maxProperties:function(e,t){"integer"!==a.whatIs(t.maxProperties)?e.addError("KEYWORD_TYPE_EXPECTED",["maxProperties","integer"]):t.maxProperties<0&&e.addError("KEYWORD_MUST_BE",["maxProperties","greater than, or equal to 0"])},minProperties:function(e,t){"integer"!==a.whatIs(t.minProperties)?e.addError("KEYWORD_TYPE_EXPECTED",["minProperties","integer"]):t.minProperties<0&&e.addError("KEYWORD_MUST_BE",["minProperties","greater than, or equal to 0"])},required:function(e,t){if("array"!==a.whatIs(t.required))e.addError("KEYWORD_TYPE_EXPECTED",["required","array"]);else if(0===t.required.length)e.addError("KEYWORD_MUST_BE",["required","an array with at least one element"]);else{for(var r=t.required.length;r--;)"string"!=typeof t.required[r]&&e.addError("KEYWORD_VALUE_TYPE",["required","string"]);!1===a.isUniqueArray(t.required)&&e.addError("KEYWORD_MUST_BE",["required","an array with unique items"])}},additionalProperties:function(e,t){var i=a.whatIs(t.additionalProperties);"boolean"!==i&&"object"!==i?e.addError("KEYWORD_TYPE_EXPECTED",["additionalProperties",["boolean","object"]]):"object"===i&&(e.path.push("additionalProperties"),r.validateSchema.call(this,e,t.additionalProperties),e.path.pop())},properties:function(e,t){if("object"===a.whatIs(t.properties)){for(var i=Object.keys(t.properties),n=i.length;n--;){var o=i[n],s=t.properties[o];e.path.push("properties"),e.path.push(o),r.validateSchema.call(this,e,s),e.path.pop(),e.path.pop()}!0===this.options.forceAdditional&&void 0===t.additionalProperties&&e.addError("KEYWORD_UNDEFINED_STRICT",["additionalProperties"]),this.options.assumeAdditional&&void 0===t.additionalProperties&&(t.additionalProperties=!1),!0===this.options.forceProperties&&0===i.length&&e.addError("CUSTOM_MODE_FORCE_PROPERTIES",["properties"])}else e.addError("KEYWORD_TYPE_EXPECTED",["properties","object"])},patternProperties:function(e,t){if("object"===a.whatIs(t.patternProperties)){for(var i=Object.keys(t.patternProperties),n=i.length;n--;){var o=i[n],s=t.patternProperties[o];try{RegExp(o)}catch(t){e.addError("KEYWORD_PATTERN",["patternProperties",o])}e.path.push("patternProperties"),e.path.push(o.toString()),r.validateSchema.call(this,e,s),e.path.pop(),e.path.pop()}!0===this.options.forceProperties&&0===i.length&&e.addError("CUSTOM_MODE_FORCE_PROPERTIES",["patternProperties"])}else e.addError("KEYWORD_TYPE_EXPECTED",["patternProperties","object"])},dependencies:function(e,t){if("object"!==a.whatIs(t.dependencies))e.addError("KEYWORD_TYPE_EXPECTED",["dependencies","object"]);else for(var i=Object.keys(t.dependencies),n=i.length;n--;){var o=i[n],s=t.dependencies[o],u=a.whatIs(s);if("object"===u)e.path.push("dependencies"),e.path.push(o),r.validateSchema.call(this,e,s),e.path.pop(),e.path.pop();else if("array"===u){var l=s.length;for(0===l&&e.addError("KEYWORD_MUST_BE",["dependencies","not empty array"]);l--;)"string"!=typeof s[l]&&e.addError("KEYWORD_VALUE_TYPE",["dependensices","string"]);!1===a.isUniqueArray(s)&&e.addError("KEYWORD_MUST_BE",["dependencies","an array with unique items"])}else e.addError("KEYWORD_VALUE_TYPE",["dependencies","object or array"])}},enum:function(e,t){!1===Array.isArray(t.enum)?e.addError("KEYWORD_TYPE_EXPECTED",["enum","array"]):0===t.enum.length?e.addError("KEYWORD_MUST_BE",["enum","an array with at least one element"]):!1===a.isUniqueArray(t.enum)&&e.addError("KEYWORD_MUST_BE",["enum","an array with unique elements"])},type:function(e,t){var r=["array","boolean","integer","number","null","object","string"],i=r.join(","),n=Array.isArray(t.type);if(n){for(var o=t.type.length;o--;)-1===r.indexOf(t.type[o])&&e.addError("KEYWORD_TYPE_EXPECTED",["type",i]);!1===a.isUniqueArray(t.type)&&e.addError("KEYWORD_MUST_BE",["type","an object with unique properties"])}else"string"==typeof t.type?-1===r.indexOf(t.type)&&e.addError("KEYWORD_TYPE_EXPECTED",["type",i]):e.addError("KEYWORD_TYPE_EXPECTED",["type",["string","array"]]);!0===this.options.noEmptyStrings&&("string"===t.type||n&&-1!==t.type.indexOf("string"))&&void 0===t.minLength&&void 0===t.enum&&void 0===t.format&&(t.minLength=1),!0===this.options.noEmptyArrays&&("array"===t.type||n&&-1!==t.type.indexOf("array"))&&void 0===t.minItems&&(t.minItems=1),!0===this.options.forceProperties&&("object"===t.type||n&&-1!==t.type.indexOf("object"))&&void 0===t.properties&&void 0===t.patternProperties&&e.addError("KEYWORD_UNDEFINED_STRICT",["properties"]),!0===this.options.forceItems&&("array"===t.type||n&&-1!==t.type.indexOf("array"))&&void 0===t.items&&e.addError("KEYWORD_UNDEFINED_STRICT",["items"]),!0===this.options.forceMinItems&&("array"===t.type||n&&-1!==t.type.indexOf("array"))&&void 0===t.minItems&&e.addError("KEYWORD_UNDEFINED_STRICT",["minItems"]),!0===this.options.forceMaxItems&&("array"===t.type||n&&-1!==t.type.indexOf("array"))&&void 0===t.maxItems&&e.addError("KEYWORD_UNDEFINED_STRICT",["maxItems"]),!0===this.options.forceMinLength&&("string"===t.type||n&&-1!==t.type.indexOf("string"))&&void 0===t.minLength&&void 0===t.format&&void 0===t.enum&&void 0===t.pattern&&e.addError("KEYWORD_UNDEFINED_STRICT",["minLength"]),!0===this.options.forceMaxLength&&("string"===t.type||n&&-1!==t.type.indexOf("string"))&&void 0===t.maxLength&&void 0===t.format&&void 0===t.enum&&void 0===t.pattern&&e.addError("KEYWORD_UNDEFINED_STRICT",["maxLength"])},allOf:function(e,t){if(!1===Array.isArray(t.allOf))e.addError("KEYWORD_TYPE_EXPECTED",["allOf","array"]);else if(0===t.allOf.length)e.addError("KEYWORD_MUST_BE",["allOf","an array with at least one element"]);else for(var i=t.allOf.length;i--;)e.path.push("allOf"),e.path.push(i.toString()),r.validateSchema.call(this,e,t.allOf[i]),e.path.pop(),e.path.pop()},anyOf:function(e,t){if(!1===Array.isArray(t.anyOf))e.addError("KEYWORD_TYPE_EXPECTED",["anyOf","array"]);else if(0===t.anyOf.length)e.addError("KEYWORD_MUST_BE",["anyOf","an array with at least one element"]);else for(var i=t.anyOf.length;i--;)e.path.push("anyOf"),e.path.push(i.toString()),r.validateSchema.call(this,e,t.anyOf[i]),e.path.pop(),e.path.pop()},oneOf:function(e,t){if(!1===Array.isArray(t.oneOf))e.addError("KEYWORD_TYPE_EXPECTED",["oneOf","array"]);else if(0===t.oneOf.length)e.addError("KEYWORD_MUST_BE",["oneOf","an array with at least one element"]);else for(var i=t.oneOf.length;i--;)e.path.push("oneOf"),e.path.push(i.toString()),r.validateSchema.call(this,e,t.oneOf[i]),e.path.pop(),e.path.pop()},not:function(e,t){"object"!==a.whatIs(t.not)?e.addError("KEYWORD_TYPE_EXPECTED",["not","object"]):(e.path.push("not"),r.validateSchema.call(this,e,t.not),e.path.pop())},definitions:function(e,t){if("object"!==a.whatIs(t.definitions))e.addError("KEYWORD_TYPE_EXPECTED",["definitions","object"]);else for(var i=Object.keys(t.definitions),n=i.length;n--;){var o=i[n],s=t.definitions[o];e.path.push("definitions"),e.path.push(o),r.validateSchema.call(this,e,s),e.path.pop(),e.path.pop()}},format:function(e,t){"string"!=typeof t.format?e.addError("KEYWORD_TYPE_EXPECTED",["format","string"]):void 0===i[t.format]&&!0!==this.options.ignoreUnknownFormats&&e.addError("UNKNOWN_FORMAT",[t.format])},id:function(e,t){"string"!=typeof t.id&&e.addError("KEYWORD_TYPE_EXPECTED",["id","string"])},title:function(e,t){"string"!=typeof t.title&&e.addError("KEYWORD_TYPE_EXPECTED",["title","string"])},description:function(e,t){"string"!=typeof t.description&&e.addError("KEYWORD_TYPE_EXPECTED",["description","string"])},default:function(){}},u=function(e,t){for(var i=t.length;i--;)r.validateSchema.call(this,e,t[i]);return e.isValid()};r.validateSchema=function(e,t){if(e.commonErrorMessage="SCHEMA_VALIDATION_FAILED",Array.isArray(t))return u.call(this,e,t);if(t.__$validated)return!0;var r=t.$schema&&t.id!==t.$schema;if(r)if(t.__$schemaResolved&&t.__$schemaResolved!==t){var i=new o(e);!1===n.validate.call(this,i,t.__$schemaResolved,t)&&e.addError("PARENT_SCHEMA_VALIDATION_FAILED",null,i)}else!0!==this.options.ignoreUnresolvableReferences&&e.addError("REF_UNRESOLVED",[t.$schema]);if(!0===this.options.noTypeless){if(void 0!==t.type){var l=[];Array.isArray(t.anyOf)&&(l=l.concat(t.anyOf)),Array.isArray(t.oneOf)&&(l=l.concat(t.oneOf)),Array.isArray(t.allOf)&&(l=l.concat(t.allOf)),l.forEach(function(e){e.type||(e.type=t.type)})}void 0===t.enum&&void 0===t.type&&void 0===t.anyOf&&void 0===t.oneOf&&void 0===t.not&&void 0===t.$ref&&e.addError("KEYWORD_UNDEFINED_STRICT",["type"])}for(var f=Object.keys(t),d=f.length;d--;){var c=f[d];0!==c.indexOf("__")&&(void 0!==s[c]?s[c].call(this,e,t):r||!0===this.options.noExtraKeywords&&e.addError("KEYWORD_UNEXPECTED",[c]))}if(!0===this.options.pedanticCheck){if(t.enum){var p=a.clone(t);for(delete p.enum,delete p.default,e.path.push("enum"),d=t.enum.length;d--;)e.path.push(d.toString()),n.validate.call(this,e,p,t.enum[d]),e.path.pop();e.path.pop()}t.default&&(e.path.push("default"),n.validate.call(this,e,t,t.default),e.path.pop())}var h=e.isValid();return h&&(t.__$validated=!0),h}},{"./FormatValidators":73,"./JsonValidation":74,"./Report":76,"./Utils":80}],80:[function(e,t,r){"use strict";r.isAbsoluteUri=function(e){return/^https?:\/\//.test(e)},r.isRelativeUri=function(e){return/.+#/.test(e)},r.whatIs=function(e){var t=typeof e;return"object"===t?null===e?"null":Array.isArray(e)?"array":"object":"number"===t?Number.isFinite(e)?e%1==0?"integer":"number":Number.isNaN(e)?"not-a-number":"unknown-number":t},r.areEqual=function e(t,i){if(t===i)return!0;var n,o;if(Array.isArray(t)&&Array.isArray(i)){if(t.length!==i.length)return!1;for(o=t.length,n=0;n<o;n++)if(!e(t[n],i[n]))return!1;return!0}if("object"===r.whatIs(t)&&"object"===r.whatIs(i)){var a=Object.keys(t);if(!e(a,Object.keys(i)))return!1;for(o=a.length,n=0;n<o;n++)if(!e(t[a[n]],i[a[n]]))return!1;return!0}return!1},r.isUniqueArray=function(e,t){var i,n,o=e.length;for(i=0;i<o;i++)for(n=i+1;n<o;n++)if(r.areEqual(e[i],e[n]))return t&&t.push(i,n),!1;return!0},r.difference=function(e,t){for(var r=[],i=e.length;i--;)-1===t.indexOf(e[i])&&r.push(e[i]);return r},r.clone=function(e){if(void 0!==e){if("object"!=typeof e||null===e)return e;var t,r;if(Array.isArray(e))for(t=[],r=e.length;r--;)t[r]=e[r];else{t={};var i=Object.keys(e);for(r=i.length;r--;){var n=i[r];t[n]=e[n]}}return t}},r.cloneDeep=function(e){function t(e){if("object"!=typeof e||null===e)return e;var n,o,a;if(-1!==(a=r.indexOf(e)))return i[a];if(r.push(e),Array.isArray(e))for(n=[],i.push(n),o=e.length;o--;)n[o]=t(e[o]);else{n={},i.push(n);var s=Object.keys(e);for(o=s.length;o--;){var u=s[o];n[u]=t(e[u])}}return n}var r=[],i=[];return t(e)},r.ucs2decode=function(e){for(var t,r,i=[],n=0,o=e.length;n<o;)(t=e.charCodeAt(n++))>=55296&&t<=56319&&n<o?56320==(64512&(r=e.charCodeAt(n++)))?i.push(((1023&t)<<10)+(1023&r)+65536):(i.push(t),n--):i.push(t);return i}},{}],81:[function(e,t,r){(function(r){"use strict";function i(e){if(this.cache={},this.referenceCache=[],this.setRemoteReference("http://json-schema.org/draft-04/schema",c),this.setRemoteReference("http://json-schema.org/draft-04/hyper-schema",p),"object"==typeof e){for(var t,r=Object.keys(e),i=r.length;i--;)if(t=r[i],void 0===h[t])throw new Error("Unexpected option passed to constructor: "+t);for(i=(r=Object.keys(h)).length;i--;)void 0===e[t=r[i]]&&(e[t]=d.clone(h[t]));this.options=e}else this.options=d.clone(h);!0===this.options.strictMode&&(this.options.forceAdditional=!0,this.options.forceItems=!0,this.options.forceMaxLength=!0,this.options.forceProperties=!0,this.options.noExtraKeywords=!0,this.options.noTypeless=!0,this.options.noEmptyStrings=!0,this.options.noEmptyArrays=!0)}e("./Polyfills");var n=e("lodash.get"),o=e("./Report"),a=e("./FormatValidators"),s=e("./JsonValidation"),u=e("./SchemaCache"),l=e("./SchemaCompilation"),f=e("./SchemaValidation"),d=e("./Utils"),c=e("./schemas/schema.json"),p=e("./schemas/hyper-schema.json"),h={asyncTimeout:2e3,forceAdditional:!1,assumeAdditional:!1,forceItems:!1,forceMinItems:!1,forceMaxItems:!1,forceMinLength:!1,forceMaxLength:!1,forceProperties:!1,ignoreUnresolvableReferences:!1,noExtraKeywords:!1,noTypeless:!1,noEmptyStrings:!1,noEmptyArrays:!1,strictUris:!1,strictMode:!1,reportPathAsArray:!1,breakOnFirstError:!0,pedanticCheck:!1,ignoreUnknownFormats:!1,customValidator:null};i.prototype.compileSchema=function(e){var t=new o(this.options);return e=u.getSchema.call(this,t,e),l.compileSchema.call(this,t,e),this.lastReport=t,t.isValid()},i.prototype.validateSchema=function(e){if(Array.isArray(e)&&0===e.length)throw new Error(".validateSchema was called with an empty array");var t=new o(this.options);return e=u.getSchema.call(this,t,e),l.compileSchema.call(this,t,e)&&f.validateSchema.call(this,t,e),this.lastReport=t,t.isValid()},i.prototype.validate=function(e,t,i,a){"function"===d.whatIs(i)&&(a=i,i={}),i||(i={});var c=d.whatIs(t);if("string"!==c&&"object"!==c){var p=new Error("Invalid .validate call - schema must be an string or object but "+c+" was passed!");if(a)return void r.nextTick(function(){a(p,!1)});throw p}var h=!1,m=new o(this.options);if("string"==typeof t){var _=t;if(!(t=u.getSchema.call(this,m,_)))throw new Error("Schema with id '"+_+"' wasn't found in the validator cache!")}else t=u.getSchema.call(this,m,t);var y=!1;h||(y=l.compileSchema.call(this,m,t)),y||(this.lastReport=m,h=!0);var g=!1;if(h||(g=f.validateSchema.call(this,m,t)),g||(this.lastReport=m,h=!0),i.schemaPath&&(m.rootSchema=t,!(t=n(t,i.schemaPath))))throw new Error("Schema path '"+i.schemaPath+"' wasn't found in the schema!");if(h||s.validate.call(this,m,t,e),!a){if(m.asyncTasks.length>0)throw new Error("This validation has async tasks and cannot be done in sync mode, please provide callback argument.");return this.lastReport=m,m.isValid()}m.processAsyncTasks(this.options.asyncTimeout,a)},i.prototype.getLastError=function(){if(0===this.lastReport.errors.length)return null;var e=new Error;return e.name="z-schema validation error",e.message=this.lastReport.commonErrorMessage,e.details=this.lastReport.errors,e},i.prototype.getLastErrors=function(){return this.lastReport&&this.lastReport.errors.length>0?this.lastReport.errors:void 0},i.prototype.getMissingReferences=function(e){for(var t=[],r=(e=e||this.lastReport.errors).length;r--;){var i=e[r];if("UNRESOLVABLE_REFERENCE"===i.code){var n=i.params[0];-1===t.indexOf(n)&&t.push(n)}i.inner&&(t=t.concat(this.getMissingReferences(i.inner)))}return t},i.prototype.getMissingRemoteReferences=function(){for(var e=this.getMissingReferences(),t=[],r=e.length;r--;){var i=u.getRemotePath(e[r]);i&&-1===t.indexOf(i)&&t.push(i)}return t},i.prototype.setRemoteReference=function(e,t){t="string"==typeof t?JSON.parse(t):d.cloneDeep(t),u.cacheSchemaByUri.call(this,e,t)},i.prototype.getResolvedSchema=function(e){var t=new o(this.options);e=u.getSchema.call(this,t,e),e=d.cloneDeep(e);var r=[],i=function(e){var t,n=d.whatIs(e);if(("object"===n||"array"===n)&&!e.___$visited){if(e.___$visited=!0,r.push(e),e.$ref&&e.__$refResolved){var o=e.__$refResolved,a=e;delete e.$ref,delete e.__$refResolved;for(t in o)o.hasOwnProperty(t)&&(a[t]=o[t])}for(t in e)e.hasOwnProperty(t)&&(0===t.indexOf("__$")?delete e[t]:i(e[t]))}};if(i(e),r.forEach(function(e){delete e.___$visited}),this.lastReport=t,t.isValid())return e;throw this.getLastError()},i.prototype.setSchemaReader=function(e){return i.setSchemaReader(e)},i.prototype.getSchemaReader=function(){return i.schemaReader},i.setSchemaReader=function(e){i.schemaReader=e},i.registerFormat=function(e,t){a[e]=t},i.unregisterFormat=function(e){delete a[e]},i.getRegisteredFormats=function(){return Object.keys(a)},i.getDefaultOptions=function(){return d.cloneDeep(h)},t.exports=i}).call(this,e("_process"))},{"./FormatValidators":73,"./JsonValidation":74,"./Polyfills":75,"./Report":76,"./SchemaCache":77,"./SchemaCompilation":78,"./SchemaValidation":79,"./Utils":80,"./schemas/hyper-schema.json":82,"./schemas/schema.json":83,_process:3,"lodash.get":1}],82:[function(e,t,r){t.exports={$schema:"http://json-schema.org/draft-04/hyper-schema#",id:"http://json-schema.org/draft-04/hyper-schema#",title:"JSON Hyper-Schema",allOf:[{$ref:"http://json-schema.org/draft-04/schema#"}],properties:{additionalItems:{anyOf:[{type:"boolean"},{$ref:"#"}]},additionalProperties:{anyOf:[{type:"boolean"},{$ref:"#"}]},dependencies:{additionalProperties:{anyOf:[{$ref:"#"},{type:"array"}]}},items:{anyOf:[{$ref:"#"},{$ref:"#/definitions/schemaArray"}]},definitions:{additionalProperties:{$ref:"#"}},patternProperties:{additionalProperties:{$ref:"#"}},properties:{additionalProperties:{$ref:"#"}},allOf:{$ref:"#/definitions/schemaArray"},anyOf:{$ref:"#/definitions/schemaArray"},oneOf:{$ref:"#/definitions/schemaArray"},not:{$ref:"#"},links:{type:"array",items:{$ref:"#/definitions/linkDescription"}},fragmentResolution:{type:"string"},media:{type:"object",properties:{type:{description:"A media type, as described in RFC 2046",type:"string"},binaryEncoding:{description:"A content encoding scheme, as described in RFC 2045",type:"string"}}},pathStart:{description:"Instances' URIs must start with this value for this schema to apply to them",type:"string",format:"uri"}},definitions:{schemaArray:{type:"array",items:{$ref:"#"}},linkDescription:{title:"Link Description Object",type:"object",required:["href","rel"],properties:{href:{description:"a URI template, as defined by RFC 6570, with the addition of the $, ( and ) characters for pre-processing",type:"string"},rel:{description:"relation to the target resource of the link",type:"string"},title:{description:"a title for the link",type:"string"},targetSchema:{description:"JSON Schema describing the link target",$ref:"#"},mediaType:{description:"media type (as defined by RFC 2046) describing the link target",type:"string"},method:{description:'method for requesting the target of the link (e.g. for HTTP this might be "GET" or "DELETE")',type:"string"},encType:{description:"The media type in which to submit data along with the request",type:"string",default:"application/json"},schema:{description:"Schema describing the data to submit along with the request",$ref:"#"}}}}}},{}],83:[function(e,t,r){t.exports={id:"http://json-schema.org/draft-04/schema#",$schema:"http://json-schema.org/draft-04/schema#",description:"Core schema meta-schema",definitions:{schemaArray:{type:"array",minItems:1,items:{$ref:"#"}},positiveInteger:{type:"integer",minimum:0},positiveIntegerDefault0:{allOf:[{$ref:"#/definitions/positiveInteger"},{default:0}]},simpleTypes:{enum:["array","boolean","integer","null","number","object","string"]},stringArray:{type:"array",items:{type:"string"},minItems:1,uniqueItems:!0}},type:"object",properties:{id:{type:"string",format:"uri"},$schema:{type:"string",format:"uri"},title:{type:"string"},description:{type:"string"},default:{},multipleOf:{type:"number",minimum:0,exclusiveMinimum:!0},maximum:{type:"number"},exclusiveMaximum:{type:"boolean",default:!1},minimum:{type:"number"},exclusiveMinimum:{type:"boolean",default:!1},maxLength:{$ref:"#/definitions/positiveInteger"},minLength:{$ref:"#/definitions/positiveIntegerDefault0"},pattern:{type:"string",format:"regex"},additionalItems:{anyOf:[{type:"boolean"},{$ref:"#"}],default:{}},items:{anyOf:[{$ref:"#"},{$ref:"#/definitions/schemaArray"}],default:{}},maxItems:{$ref:"#/definitions/positiveInteger"},minItems:{$ref:"#/definitions/positiveIntegerDefault0"},uniqueItems:{type:"boolean",default:!1},maxProperties:{$ref:"#/definitions/positiveInteger"},minProperties:{$ref:"#/definitions/positiveIntegerDefault0"},required:{$ref:"#/definitions/stringArray"},additionalProperties:{anyOf:[{type:"boolean"},{$ref:"#"}],default:{}},definitions:{type:"object",additionalProperties:{$ref:"#"},default:{}},properties:{type:"object",additionalProperties:{$ref:"#"},default:{}},patternProperties:{type:"object",additionalProperties:{$ref:"#"},default:{}},dependencies:{type:"object",additionalProperties:{anyOf:[{$ref:"#"},{$ref:"#/definitions/stringArray"}]}},enum:{type:"array",minItems:1,uniqueItems:!0},type:{anyOf:[{$ref:"#/definitions/simpleTypes"},{type:"array",items:{$ref:"#/definitions/simpleTypes"},minItems:1,uniqueItems:!0}]},format:{type:"string"},allOf:{$ref:"#/definitions/schemaArray"},anyOf:{$ref:"#/definitions/schemaArray"},oneOf:{$ref:"#/definitions/schemaArray"},not:{$ref:"#"}},dependencies:{exclusiveMaximum:["maximum"],exclusiveMinimum:["minimum"]},default:{}}},{}]},{},[72,73,74,75,76,77,78,79,80,81])(81)});
//# sourceMappingURL=ZSchema-browser-min.js.map

/***/ }),

/***/ 70978:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isChangeInPath = exports.getTagSha = exports.isMainBranch = exports.getPullRequestNumber = void 0;
const github_1 = __webpack_require__(95438);
const child_process_1 = __webpack_require__(63129);
const getPullRequestNumber = () => {
    var _a;
    return ((_a = github_1.context.payload.pull_request) === null || _a === void 0 ? void 0 : _a.number) || 0;
};
exports.getPullRequestNumber = getPullRequestNumber;
const isMainBranch = () => {
    return github_1.context.ref === 'refs/heads/main';
};
exports.isMainBranch = isMainBranch;
const getTagSha = (tagName) => {
    return child_process_1.spawnSync('git', ['rev-list', '-n', '1', tagName]).stdout.toString().trim();
};
exports.getTagSha = getTagSha;
const isChangeInPath = (commitSha, path) => {
    return child_process_1.spawnSync('git', ['diff', '--quiet', commitSha, '--', path]).status ? true : false;
};
exports.isChangeInPath = isChangeInPath;


/***/ }),

/***/ 70399:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const rush_lib_1 = __webpack_require__(57088);
const node_core_library_1 = __webpack_require__(67607);
const core_1 = __webpack_require__(42186);
const utils_1 = __webpack_require__(71314);
const run = () => __awaiter(void 0, void 0, void 0, function* () {
    var e_1, _a;
    try {
        const environment = core_1.getInput('environment');
        const tagForDeployment = utils_1.getTagForDeployment(environment);
        core_1.info('Using bundle analyzer');
        const rushConfiguration = rush_lib_1.RushConfiguration.loadFromDefaultLocation({
            startingFolder: process.cwd(),
        });
        const terminalProvider = new node_core_library_1.ConsoleTerminalProvider();
        const terminal = new node_core_library_1.Terminal(terminalProvider);
        const projectChangeAnalyzer = new rush_lib_1.ProjectChangeAnalyzer(rushConfiguration);
        const changedProjects = yield projectChangeAnalyzer.getChangedProjectsAsync({
            targetBranchName: rushConfiguration.repositoryDefaultBranch,
            terminal,
        });
        const projectMap = new Map();
        try {
            for (var changedProjects_1 = __asyncValues(changedProjects), changedProjects_1_1; changedProjects_1_1 = yield changedProjects_1.next(), !changedProjects_1_1.done;) {
                const changedProject = changedProjects_1_1.value;
                for (const consumer of changedProject.consumingProjects) {
                    projectMap.set(consumer.packageName, {
                        packageName: consumer.packageName,
                        projectFolder: consumer.projectFolder,
                        reviewCategory: consumer.reviewCategory,
                        shouldPublish: consumer.shouldPublish,
                    });
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (changedProjects_1_1 && !changedProjects_1_1.done && (_a = changedProjects_1.return)) yield _a.call(changedProjects_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        const result = projectMap.values();
        core_1.setOutput('changedProjects', result);
        core_1.setOutput('tag', tagForDeployment);
    }
    catch (e) {
        core_1.setFailed(e.message);
    }
});
run();


/***/ }),

/***/ 71314:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readJson = exports.getAllPackages = exports.getChangedPackages = exports.getLastDeployedRef = exports.getTagForDeployment = void 0;
const fs_1 = __importDefault(__webpack_require__(35747));
const github_1 = __webpack_require__(70978);
const core_1 = __webpack_require__(42186);
const getTagForDeployment = (environment) => {
    const pullRequestNumber = github_1.getPullRequestNumber();
    if (pullRequestNumber) {
        return `preview-${pullRequestNumber}`;
    }
    if (github_1.isMainBranch()) {
        return environment;
    }
    throw new Error('This action only supports push event on main branch or pull request events');
};
exports.getTagForDeployment = getTagForDeployment;
const getLastDeployedRef = (environment, tagName) => {
    core_1.debug(`Looking for last deployed ref - "${tagName}"`);
    const tagSha = github_1.getTagSha(tagName);
    if (tagSha) {
        return tagSha;
    }
    core_1.debug(`Tag was not found, deploy based on environment - "${environment}" `);
    return github_1.getTagSha(environment);
};
exports.getLastDeployedRef = getLastDeployedRef;
const getChangedPackages = (lastDeployedRef, rushPackages) => {
    return rushPackages.reduce((changes, _package) => {
        if (github_1.isChangeInPath(lastDeployedRef, _package.projectFolder)) {
            updatePackageCategories(_package, changes);
        }
        return changes;
    }, []);
};
exports.getChangedPackages = getChangedPackages;
const getAllPackages = (rushPackages) => {
    return rushPackages.reduce((changes, _package) => {
        updatePackageCategories(_package, changes);
        return changes;
    }, []);
};
exports.getAllPackages = getAllPackages;
const readJson = (jsonPath) => {
    return JSON.parse(fs_1.default
        .readFileSync(jsonPath, 'utf-8')
        .replace(/\\"|"(?:\\"|[^"])*"|(\/\/.*|\/\*[\s\S]*?\*\/)/g, (jsonKeyOrValue, comment) => comment ? '' : jsonKeyOrValue));
};
exports.readJson = readJson;
const updatePackageCategories = (project, output) => {
    output.push(project);
};


/***/ }),

/***/ 53223:
/***/ ((module) => {

module.exports = eval("require")("./pnpmfileSettings.json");


/***/ }),

/***/ 22877:
/***/ ((module) => {

module.exports = eval("require")("encoding");


/***/ }),

/***/ 92008:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse("[\"assert\",\"buffer\",\"child_process\",\"cluster\",\"console\",\"constants\",\"crypto\",\"dgram\",\"dns\",\"domain\",\"events\",\"fs\",\"http\",\"https\",\"module\",\"net\",\"os\",\"path\",\"process\",\"punycode\",\"querystring\",\"readline\",\"repl\",\"stream\",\"string_decoder\",\"timers\",\"tls\",\"tty\",\"url\",\"util\",\"v8\",\"vm\",\"zlib\"]");

/***/ }),

/***/ 42357:
/***/ ((module) => {

"use strict";
module.exports = require("assert");;

/***/ }),

/***/ 64293:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");;

/***/ }),

/***/ 63129:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");;

/***/ }),

/***/ 27619:
/***/ ((module) => {

"use strict";
module.exports = require("constants");;

/***/ }),

/***/ 33373:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");;

/***/ }),

/***/ 28614:
/***/ ((module) => {

"use strict";
module.exports = require("events");;

/***/ }),

/***/ 35747:
/***/ ((module) => {

"use strict";
module.exports = require("fs");;

/***/ }),

/***/ 15876:
/***/ ((module) => {

"use strict";
module.exports = require("http");;

/***/ }),

/***/ 57211:
/***/ ((module) => {

"use strict";
module.exports = require("https");;

/***/ }),

/***/ 32282:
/***/ ((module) => {

"use strict";
module.exports = require("module");;

/***/ }),

/***/ 11631:
/***/ ((module) => {

"use strict";
module.exports = require("net");;

/***/ }),

/***/ 12087:
/***/ ((module) => {

"use strict";
module.exports = require("os");;

/***/ }),

/***/ 85622:
/***/ ((module) => {

"use strict";
module.exports = require("path");;

/***/ }),

/***/ 61765:
/***/ ((module) => {

"use strict";
module.exports = require("process");;

/***/ }),

/***/ 51058:
/***/ ((module) => {

"use strict";
module.exports = require("readline");;

/***/ }),

/***/ 92413:
/***/ ((module) => {

"use strict";
module.exports = require("stream");;

/***/ }),

/***/ 24304:
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");;

/***/ }),

/***/ 4016:
/***/ ((module) => {

"use strict";
module.exports = require("tls");;

/***/ }),

/***/ 78835:
/***/ ((module) => {

"use strict";
module.exports = require("url");;

/***/ }),

/***/ 31669:
/***/ ((module) => {

"use strict";
module.exports = require("util");;

/***/ }),

/***/ 92184:
/***/ ((module) => {

"use strict";
module.exports = require("vm");;

/***/ }),

/***/ 78761:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	__webpack_require__.ab = __dirname + "/";/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(70399);
/******/ })()
;